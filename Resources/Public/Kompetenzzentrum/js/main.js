(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
        ;(function () {
            'use strict';

            window.$ = window.jQuery = require('jquery');
            require('./widgets/jcf');
            require('./widgets/jcf.select');
            require('./widgets/jcf.radio');
            require('./widgets/jcf.checkbox');
            require('./widgets/jcf.file');
            require('./widgets/jcf.textarea');
            require('./widgets/jcf.scrollable');
            require('./widgets/collapse');
            require('./libs/sticky.js');
            require('./libs/imagefill.js');
            require('./libs/imagesloaded.js');
            require('./utils/debounce.js');
            require('./utils/throttle.js');
            // require('gsap');
            require ('./vendors/sticky-kit');
            require('./vendors/owl.carousel.js');
            require('./vendors/owl.autoplay.js');
            var viewport = require('./utils/viewport');
            var smartBlocks = require('./utils/smart_blocks');
            var detect = require('./utils/detect');
            var translate = require('./utils/translate');
            var Slider = require('./widgets/slider');
            var validate = require('./widgets/validate');
            var throttle = require('./widgets/throttle');
            var ajaxApi = require('./widgets/ajax-api');
            //var menu = require('./widgets/menu');
            var verticalMenu = require('./widgets/vertical-menu');
            var topMenu = require('./widgets/top-menu');
            var searchbox = require('./widgets/searchbox');
            var searchFilters = require('./widgets/search-filters');
            var relatedBox = require('./widgets/related_search_box');
            var objectFit = require('./libs/object_fit.js');
            var equalWidth = require('./widgets/equal_width');
            var publicationScroll = require('./widgets/publication-scroll');
            var Home = require('./widgets/home');
            var StackBlur = require("./vendors/stackblur");

            function Site() {
                var self = this;

                viewport.enable();
                smartBlocks.enable();

                viewport.onChange.connect(function() {
                    // Put there code to be executed when viewport is changed
                });

                jQuery(window).on('rkw-ajax-api-content-changed', this.onAjaxContentChanged.bind(this));
                jQuery(window).on('rkw-ajax-api-push-state', this.onAjaxApiPushState.bind(this));

                this.parseContent(document.body);

                jQuery(window).on('popstate', (function() {
                    if (window.history.state) {
                        var json = jQuery.parseJSON(window.history.state);

                        jQuery('#' + json.parent).empty().append(json.data);
                        self.parseContent(jQuery('#' + json.parent)[0]);
                    }
                }));

                try {
                    Typekit.load({
                                     async: true,
                                     active: function() { setTimeout("jQuery(window).trigger('font-reload'); jQuery('.top-menu').addClass('top-menu--font-reload-show');", 500); },
                                     inactive: function() { jQuery('.top-menu').addClass('top-menu--font-reload-show');}
                                 });
                }
                catch(e) {
                    jQuery('.top-menu').addClass('top-menu--font-reload-show');
                }

            }

            Site.prototype.parseContent = function(root) {
                function find(selector) {
                    return jQuery(root).is(selector) ? jQuery(root) : jQuery(root).find('*').filter(selector);
                }

                var self = this;

                /* Forms */
                find('select:not(.no-jcf)').each(function() {
                    jcf.replace(jQuery(this), 'Select', {
                        wrapNative: false
                    });
                });
                find('input:checkbox:not(.no-jcf)').each(function() {
                    jcf.replace(jQuery(this), 'Checkbox', {'wrapNative': true});
                });
                find('input:radio:not(.no-jcf)').each(function() {
                    if (jQuery(this).closest('.filter').length === 0)
                        jcf.replace(jQuery(this), 'Radio', {'wrapNative': true});
                });
                find('input[type="file"]:not(.no-jcf)').each(function() {
                    if (jQuery(this).closest('.filter').length === 0)
                        jcf.replace(jQuery(this), 'File', {
                            'wrapNative': false
                        });
                });
                find('form.validate').validate();

                /* Slider */
                find('.slider').each(function() {
                    new Slider(jQuery(this), {
                        'mode': Slider.MODE_CAROUSEL,
                        'arrows': false
                    });
                });

                /* Accordion */
                jQuery('.accordion-trigger').click(function (event) {
                    event.preventDefault();
                    var accordion = jQuery(this).parent('.accordion__item');
                    var content = jQuery(this).next('.accordion-cnt');
                    content.stop(true).slideToggle();

                    if (accordion.hasClass('accordion__item--open'))
                        accordion.removeClass('accordion__item--open')
                    else {
                        var openAccordion = jQuery('.accordion__item--open');
                        openAccordion.removeClass('accordion__item--open');
                        openAccordion.find('.accordion-cnt').stop(true).slideUp()
                        accordion.addClass('accordion__item--open')
                    }
                });

                /* Collapsed text */
                jQuery('.collapsed-text').collapse();


                // remove attribs since they are breaking the zooming
                jQuery('.box figure img').each(function() {
                    jQuery(this).removeAttr('width').removeAttr('height');
                });

                jQuery('.box .box-content figure').each(function() {

                    // we do this via css object-fit now!
                    /*
            jQuery(this).find('img').load(function(){
                jQuery(this).parent().parent().imagefill();
            }).each(function(){
                if(this.complete) {
                    jQuery(this).trigger('load');
                }
            });
            */

                    /*
            jQuery(this).find('img').one("load", function() {
                jQuery(this).parent().parent().imagefill();

            }).each(function() {
                if(jQuery(this).complete) {
                    jQuery(this).load();
                    console.log(jQuery(this).attr('src'));
                }
            });*/

                });

                find('.ajax, .ajax-feedback, .ajax .ajax-override, .ajax .ajax-send, .ajax .ajax-override-submit, .ajax input, .ajax textarea, .ajax select').ajaxApi();

                /* -------------------- */

                /* Put own scripts here */

                find('.toggle-project').click(function(event) {
                    event.preventDefault();

                    var link = jQuery(this);
                    var tabName = link.data('toggle');
                    var toggledContent = jQuery('[data-tab="' + tabName + '"]');
                    var bodyClasses = document.body.classList;
                    var arrayBodyClasses = Array.prototype.slice.call(bodyClasses);
                    var publicationDetails = jQuery('.publication-details--chapter');

                    if (!jQuery('body').find('.publication-details').hasClass('publication-details--chapter') && toggledContent.css('display') === 'none' && window.scrollY < 250) {
                        window.scrollTo(0, window.scrollY + 200);
                    }

                    if (publicationDetails.hasClass('is_stuck')) {
                        toggledContent.css('top', publicationDetails.offset().top - publicationDetails.height() + 32);
                    } else {
                        toggledContent.css('top', 'initial');
                    }

                    if (jQuery('body').find('.project-details').length === 0) {
                        var contentDetails = document.getElementsByClassName('publication-details');
                        var contentTable = jQuery('body').find('.publications-contents-table');
                        var height = $(window).height() - contentDetails[0].getBoundingClientRect().top - contentDetails[0].offsetHeight - 50;

                        contentTable.height(height);

                        var position = window.pageYOffset;

                        jQuery('html').toggleClass('no-scroll');

                        if (arrayBodyClasses.indexOf('ipad') !== -1 || arrayBodyClasses.indexOf('iphone') !== -1) {
                            if (jQuery('html').hasClass('no-scroll')) {
                                jQuery('.page-wrap').addClass('fixed');
                                jQuery('.page-wrap').css('top', -position);
                            } else {
                                position = -parseInt(jQuery('.page-wrap').css('top'));
                                jQuery('.page-wrap').removeClass('fixed');
                                jQuery('.page-wrap').removeAttr('style');
                                window.scrollTo(0, position);
                            }
                        }
                    }

                    link.find('>span').toggleClass('icon-arrow-right').toggleClass('icon-arrow-down');
                    toggledContent.slideToggle();
                });

                find('.pre-queries-item').click(function (event) {
                    event.preventDefault();
                    jQuery('.searchbox .search').val(jQuery(this).data('query'));
                    if (jQuery(this).data('filter-id')) {
                        jQuery('#' + jQuery(this).data('filter-id')).click();
                    }
                    var form = jQuery('.searchbox').closest('form');
                    form.submit();
                });

                find('.contact-info .phone').click(function(event) {
                    event.preventDefault();

                    var phone = jQuery(this);
                    var mail = phone.parent().next();

                    phone.parent().toggleClass('show');
                    phone.toggleClass('text-hide');
                });

                find('.top-menu').topMenu();

                find('.main-menu').verticalMenu();

                find('.publication-details--chapter').publicationScroll();

                // find('.article-menu').articleMenu();

                // find('.content-menu:not(.sticky)').contentMenu();

                find('.submenu-container').each(function() {
                    var element = jQuery(this);
                    var scrollableContainer = element.find('>*');
                    var additionalHeight = 0;

                    if (element.closest('.content-menu.sticky').length) {
                        additionalHeight = element.closest('.content-menu.sticky').outerHeight();
                    }

                    setTimeout(function() {
                        setMaxHeight();
                        element.show();
                        scrollableContainer.css('max-height', element.height());
                        jcf.replace(scrollableContainer, 'Scrollable', {
                            alwaysPreventMouseWheel: true
                        });
                        element.hide();
                    }, 250);

                    jQuery(document).on('submenuUpdated', updateScroll);
                    jQuery(window).resize(jQuery.debounce(250, function() {
                        setMaxHeight();
                        updateScroll();
                    }));
                    element.on('updateScroll', function() {
                        setMaxHeight();
                        updateScroll();
                    });

                    function setMaxHeight() {
                        var windowHeight = viewport.height();
                        var headerHeight = jQuery('header').outerHeight();
                        var elementHeight = windowHeight - headerHeight - additionalHeight;

                        if (element.attr('data-max-height') !== undefined) {
                            elementHeight = parseInt(element.attr('data-max-height'));
                        }

                        element.show();
                        element.css('max-height', elementHeight);
                        element.hide();
                    }

                    function updateScroll() {
                        element.css('opacity', 0).show();
                        scrollableContainer.parent().css({
                                                             width: '',
                                                             height: '',
                                                             'max-height': ''
                                                         });
                        scrollableContainer.css({
                                                    width: '',
                                                    height: '',
                                                    'max-height': ''
                                                });
                        scrollableContainer.css('max-height', element.height());
                        jcf.refresh(scrollableContainer);
                        element.hide().css('opacity', '');
                    }
                });

                find('.searchbox .search').searchbox();
                find('.search-filter').searchFilters();

                find('.next-page[href]').each(function() {
                    var link = jQuery(this);
                    var boxesContainer = link.parent().parent();
                    boxesContainer.find('.box-loading').remove();

                    if (link.hasClass('autoload'))
                        jQuery(window).scroll(checkBottom);

                    link.click(function() {
                        if (!jQuery(this).hasClass('disabled')) {

                            link.removeAttr('href').addClass('disabled');
                            boxesContainer.append('<div class="box-loading"/>');
                            jQuery(window).scrollTop(jQuery(window).scrollTop() - 2);
                        }
                    });

                    function checkBottom() {
                        if (jQuery(window).scrollTop() + jQuery(window).height() >= jQuery(document).height() - 100) {
                            if (!link.hasClass('disabled')) {
                                link.click();
                            }
                        }
                    }
                });

                // delete disabled more box if this is the only entry in the box list
                find('div.box-wrapper .box.disabled:first-child').parent().remove();
                find('div .box.publication.disabled:first-child').parent().remove();

                // scroll to first TYPO3-message (if there is one)
                if (find('.typo3-messages').first().length > 0){

                    jQuery(document).ready(function() {
                        var messageDiv = find('.typo3-messages').first();
                        var offset = messageDiv.offset().top;
                        jQuery('html, body').animate({'scrollTop': offset - 100}, 1000);
                    });
                }

                find('.publications-contents-table__close-icon').on('click', function(e){
                    e.preventDefault();
                    var link = jQuery('body').find('.toggle-project > span');
                    var toggledContent = jQuery('body').find('.toggled-content');
                    var bodyClasses = document.body.classList;
                    var arrayBodyClasses = Array.prototype.slice.call(bodyClasses);
                    var position = window.pageYOffset;

                    link.removeClass('icon-arrow-down').addClass('icon-arrow-right');
                    toggledContent.slideUp();
                    jQuery('html').removeClass('no-scroll');

                    if (arrayBodyClasses.indexOf('ipad') !== -1) {
                        jQuery('.page-wrap').removeClass('fixed');
                        jQuery('.page-wrap').removeAttr('style');
                        window.scrollTop = position;
                    }

                });

                find('.related').relatedSearchBox();

                find('.message-box').each(function() {
                    var box = jQuery(this);
                    var boxHeight = box.height();
                    var parent = jQuery(box.data('for'));

                    if (parent.css('position') !== 'absolute') {
                        parent.css('position', 'relative');
                    }

                    box.css({
                                position: 'absolute',
                                top: -(boxHeight + 10),
                                left: 0
                            });
                });

                find('.boxes-experts').each(function() {
                    var lastLetter = '';
                    var grid = jQuery(this);
                    var boxes = grid.find('.box.expert');

                    jQuery('body').click(function(event) {
                        var target = event.target;
                        var contactsBox = boxes.find('.contact-info-box');
                        var contactsOpener = boxes.find('.contact-box-toggle');

                        if (!jQuery(target).hasClass('contact-box-toggle') && !jQuery(target).hasClass('contact-info-box') && jQuery(target).closest('.contact-info-box').length === 0) {
                            contactsBox.slideUp();
                            contactsOpener.removeClass('active');
                        }
                    });

                    boxes.each(function() {
                        var box = jQuery(this);
                        var letter = box.find('.letter').text();
                        var contactButton = box.find('.contact-box-toggle');
                        var contactBox = box.find('.contact-info-box');

                        setTimeout(updateContactBox, 250);
                        jQuery(window).resize(jQuery.debounce(250, updateContactBox));

                        if (lastLetter !== letter) {
                            box.addClass('show-letter');
                        }
                        lastLetter = letter;

                        contactButton.click(function(event) {
                            event.preventDefault();

                            jQuery(this).toggleClass('active');
                            contactBox.slideToggle();
                        });

                        function updateContactBox() {
                            contactBox.show().css('bottom', 0);
                            var headerOffset = box.find('header').offset().top;
                            var headerPadding = parseInt(box.find('header').css('padding-top'));
                            var contactOffset = contactBox.offset().top;
                            var contactHeight = contactBox.height();

                            contactBox.css('bottom', contactOffset - headerOffset + contactHeight + headerPadding + 13).hide();
                            contactButton.removeClass('active');
                        }
                    });
                });

                find('.homebox').Home();

                find('.map').each(function() {
                    var map = jQuery(this);
                    var regions = map.find('.map__region');
                    var badge = jQuery('.map__mouseover');

                    var date = new Date();
                    var hour = date.getHours();

                    if (hour >= 20 || hour <= 7) {
                        map.addClass('map--night');
                        jQuery('.regions-mobile').addClass('regions-mobile--night');
                    }

                    if (detect.touch) {
                        regions.on('touchstart', showBadge);
                    } else {
                        regions.on('mouseenter', showBadge);
                        regions.on('mouseleave', hideBadge);
                    }

                    function showBadge() {
                        var region = jQuery(this);
                        badge.show();
                        badge.css({left: region.data('position-x'), top: region.data('position-y')})
                        badge.html('<span>' + region.data('text') + '</span>');
                    }
                    function hideBadge(event) {
                        badge.hide();
                    }

                    map.find('a').on('touchend, click', function(e) {
                        e.preventDefault();
                        var url = $(this).attr('href');
                        window.location = url;
                    });
                });

                find('[data-scroll-to]').each(function() {
                    var anchor = $(this);
                    var target = $(anchor.data('scroll-to'));

                    anchor.click(function(event) {
                        event.preventDefault();
                        if (target.length > 0) {
                            jQuery('body, html').stop().animate({scrollTop: target.offset().top}, 200, 'swing');
                        }
                    });
                });

                /* -------------------- */
                find('[data-equal-width-group]').each(equalWidth.handler);

                if ((/*@cc_on!@*/false || !!document.documentMode) || (!(/*@cc_on!@*/false || !!document.documentMode) && !!window.StyleMedia)){
                    find('.publications-article__picture').each(function(){
                        var picture = jQuery(this);
                        var image = picture.find('.publications-article__image');
                        var canvas = picture.find('.publications-article__canvas');
                        canvas.show();
                        jQuery(image).removeClass('publications-article__image--hidden');
                        StackBlur.image('image', 'canvas', 16, false);
                        jQuery(image).addClass('publications-article__image--hidden');
                    });
                }

                equalWidth.updateAll();
                smartBlocks.updateTree(root);
            };


            // Call it like this:
            // jQuery(document).trigger('rkw-ajax-api-push-state', [jQuery(document).find('.search-result-section'), 'http://www.google.de', 'Title']);
            Site.prototype.pushState = function(root, url, title) {
                function find(selector) {
                    return jQuery(root).is(selector) ? jQuery(root) : jQuery(root).find('*').filter(selector);
                }

                var self = this;
                /*
        var form = find('form.ajax');
        var stateUrl = form.attr('action');
        var stateData = form.serializeArray();
        var stateTitle = form.attr('title') ? form.attr('title') : 'Search';
        */

                // clone data
                var stateRoot = jQuery(root).clone();

                // remove loading-indicator and deactivate more-links in this clone
                stateRoot.find('.box-loading').remove();
                stateRoot.find('.next-page[href]').each(function() {
                    var link = jQuery(this);
                    if (link.hasClass('autoload'))
                        link.removeAttr('href').addClass('disabled');
                });

                var stateUrl = url;
                var stateTitle = title ? title : 'RKW Kompetenzzentrum';
                var stateObj = JSON.stringify({
                                                  'parent': stateRoot.attr('id'),
                                                  'data': stateRoot.html()
                                              });

                // history.pushState(stateObj, stateTitle, stateUrl + '&' + jQuery.param(stateData));
                history.pushState(stateObj, stateTitle, stateUrl);

            };

            Site.prototype.onAjaxContentChanged = function(event, content) {
                this.parseContent(content);
            };

            Site.prototype.onAjaxApiPushState = function(event, content, url, title) {
                this.pushState(content, url, title);
            };

            new Site();


        }());

    },{"./libs/imagefill.js":3,"./libs/imagesloaded.js":4,"./libs/object_fit.js":5,"./libs/sticky.js":6,"./utils/debounce.js":7,"./utils/detect":8,"./utils/smart_blocks":13,"./utils/throttle.js":14,"./utils/translate":15,"./utils/viewport":16,"./vendors/owl.autoplay.js":17,"./vendors/owl.carousel.js":18,"./vendors/stackblur":19,"./vendors/sticky-kit":20,"./widgets/ajax-api":21,"./widgets/collapse":22,"./widgets/equal_width":23,"./widgets/home":24,"./widgets/jcf":27,"./widgets/jcf.checkbox":25,"./widgets/jcf.file":26,"./widgets/jcf.radio":28,"./widgets/jcf.scrollable":29,"./widgets/jcf.select":30,"./widgets/jcf.textarea":31,"./widgets/publication-scroll":32,"./widgets/related_search_box":33,"./widgets/search-filters":34,"./widgets/searchbox":35,"./widgets/slider":36,"./widgets/throttle":37,"./widgets/top-menu":38,"./widgets/validate":39,"./widgets/vertical-menu":40,"jquery":2}],2:[function(require,module,exports){
        /*!
 * jQuery JavaScript Library v2.2.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-05-20T17:23Z
 */

        (function( global, factory ) {

            if ( typeof module === "object" && typeof module.exports === "object" ) {
                // For CommonJS and CommonJS-like environments where a proper `window`
                // is present, execute the factory and get jQuery.
                // For environments that do not have a `window` with a `document`
                // (such as Node.js), expose a factory as module.exports.
                // This accentuates the need for the creation of a real `window`.
                // e.g. var jQuery = require("jquery")(window);
                // See ticket #14549 for more info.
                module.exports = global.document ?
                    factory( global, true ) :
                    function( w ) {
                        if ( !w.document ) {
                            throw new Error( "jQuery requires a window with a document" );
                        }
                        return factory( w );
                    };
            } else {
                factory( global );
            }

// Pass this if window is not defined yet
        }(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//"use strict";
            var arr = [];

            var document = window.document;

            var slice = arr.slice;

            var concat = arr.concat;

            var push = arr.push;

            var indexOf = arr.indexOf;

            var class2type = {};

            var toString = class2type.toString;

            var hasOwn = class2type.hasOwnProperty;

            var support = {};



            var
                version = "2.2.4",

                // Define a local copy of jQuery
                jQuery = function( selector, context ) {

                    // The jQuery object is actually just the init constructor 'enhanced'
                    // Need init if jQuery is called (just allow error to be thrown if not included)
                    return new jQuery.fn.init( selector, context );
                },

                // Support: Android<4.1
                // Make sure we trim BOM and NBSP
                rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

                // Matches dashed string for camelizing
                rmsPrefix = /^-ms-/,
                rdashAlpha = /-([\da-z])/gi,

                // Used by jQuery.camelCase as callback to replace()
                fcamelCase = function( all, letter ) {
                    return letter.toUpperCase();
                };

            jQuery.fn = jQuery.prototype = {

                // The current version of jQuery being used
                jquery: version,

                constructor: jQuery,

                // Start with an empty selector
                selector: "",

                // The default length of a jQuery object is 0
                length: 0,

                toArray: function() {
                    return slice.call( this );
                },

                // Get the Nth element in the matched element set OR
                // Get the whole matched element set as a clean array
                get: function( num ) {
                    return num != null ?

                        // Return just the one element from the set
                        ( num < 0 ? this[ num + this.length ] : this[ num ] ) :

                        // Return all the elements in a clean array
                        slice.call( this );
                },

                // Take an array of elements and push it onto the stack
                // (returning the new matched element set)
                pushStack: function( elems ) {

                    // Build a new jQuery matched element set
                    var ret = jQuery.merge( this.constructor(), elems );

                    // Add the old object onto the stack (as a reference)
                    ret.prevObject = this;
                    ret.context = this.context;

                    // Return the newly-formed element set
                    return ret;
                },

                // Execute a callback for every element in the matched set.
                each: function( callback ) {
                    return jQuery.each( this, callback );
                },

                map: function( callback ) {
                    return this.pushStack( jQuery.map( this, function( elem, i ) {
                        return callback.call( elem, i, elem );
                    } ) );
                },

                slice: function() {
                    return this.pushStack( slice.apply( this, arguments ) );
                },

                first: function() {
                    return this.eq( 0 );
                },

                last: function() {
                    return this.eq( -1 );
                },

                eq: function( i ) {
                    var len = this.length,
                        j = +i + ( i < 0 ? len : 0 );
                    return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
                },

                end: function() {
                    return this.prevObject || this.constructor();
                },

                // For internal use only.
                // Behaves like an Array's method, not like a jQuery method.
                push: push,
                sort: arr.sort,
                splice: arr.splice
            };

            jQuery.extend = jQuery.fn.extend = function() {
                var options, name, src, copy, copyIsArray, clone,
                    target = arguments[ 0 ] || {},
                    i = 1,
                    length = arguments.length,
                    deep = false;

                // Handle a deep copy situation
                if ( typeof target === "boolean" ) {
                    deep = target;

                    // Skip the boolean and the target
                    target = arguments[ i ] || {};
                    i++;
                }

                // Handle case when target is a string or something (possible in deep copy)
                if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
                    target = {};
                }

                // Extend jQuery itself if only one argument is passed
                if ( i === length ) {
                    target = this;
                    i--;
                }

                for ( ; i < length; i++ ) {

                    // Only deal with non-null/undefined values
                    if ( ( options = arguments[ i ] ) != null ) {

                        // Extend the base object
                        for ( name in options ) {
                            src = target[ name ];
                            copy = options[ name ];

                            // Prevent never-ending loop
                            if ( target === copy ) {
                                continue;
                            }

                            // Recurse if we're merging plain objects or arrays
                            if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
                                                   ( copyIsArray = jQuery.isArray( copy ) ) ) ) {

                                if ( copyIsArray ) {
                                    copyIsArray = false;
                                    clone = src && jQuery.isArray( src ) ? src : [];

                                } else {
                                    clone = src && jQuery.isPlainObject( src ) ? src : {};
                                }

                                // Never move original objects, clone them
                                target[ name ] = jQuery.extend( deep, clone, copy );

                                // Don't bring in undefined values
                            } else if ( copy !== undefined ) {
                                target[ name ] = copy;
                            }
                        }
                    }
                }

                // Return the modified object
                return target;
            };

            jQuery.extend( {

                               // Unique for each copy of jQuery on the page
                               expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

                               // Assume jQuery is ready without the ready module
                               isReady: true,

                               error: function( msg ) {
                                   throw new Error( msg );
                               },

                               noop: function() {},

                               isFunction: function( obj ) {
                                   return jQuery.type( obj ) === "function";
                               },

                               isArray: Array.isArray,

                               isWindow: function( obj ) {
                                   return obj != null && obj === obj.window;
                               },

                               isNumeric: function( obj ) {

                                   // parseFloat NaNs numeric-cast false positives (null|true|false|"")
                                   // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
                                   // subtraction forces infinities to NaN
                                   // adding 1 corrects loss of precision from parseFloat (#15100)
                                   var realStringObj = obj && obj.toString();
                                   return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
                               },

                               isPlainObject: function( obj ) {
                                   var key;

                                   // Not plain objects:
                                   // - Any object or value whose internal [[Class]] property is not "[object Object]"
                                   // - DOM nodes
                                   // - window
                                   if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
                                       return false;
                                   }

                                   // Not own constructor property must be Object
                                   if ( obj.constructor &&
                                        !hasOwn.call( obj, "constructor" ) &&
                                        !hasOwn.call( obj.constructor.prototype || {}, "isPrototypeOf" ) ) {
                                       return false;
                                   }

                                   // Own properties are enumerated firstly, so to speed up,
                                   // if last one is own, then all properties are own
                                   for ( key in obj ) {}

                                   return key === undefined || hasOwn.call( obj, key );
                               },

                               isEmptyObject: function( obj ) {
                                   var name;
                                   for ( name in obj ) {
                                       return false;
                                   }
                                   return true;
                               },

                               type: function( obj ) {
                                   if ( obj == null ) {
                                       return obj + "";
                                   }

                                   // Support: Android<4.0, iOS<6 (functionish RegExp)
                                   return typeof obj === "object" || typeof obj === "function" ?
                                       class2type[ toString.call( obj ) ] || "object" :
                                       typeof obj;
                               },

                               // Evaluates a script in a global context
                               globalEval: function( code ) {
                                   var script,
                                       indirect = eval;

                                   code = jQuery.trim( code );

                                   if ( code ) {

                                       // If the code includes a valid, prologue position
                                       // strict mode pragma, execute code by injecting a
                                       // script tag into the document.
                                       if ( code.indexOf( "use strict" ) === 1 ) {
                                           script = document.createElement( "script" );
                                           script.text = code;
                                           document.head.appendChild( script ).parentNode.removeChild( script );
                                       } else {

                                           // Otherwise, avoid the DOM node creation, insertion
                                           // and removal by using an indirect global eval

                                           indirect( code );
                                       }
                                   }
                               },

                               // Convert dashed to camelCase; used by the css and data modules
                               // Support: IE9-11+
                               // Microsoft forgot to hump their vendor prefix (#9572)
                               camelCase: function( string ) {
                                   return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
                               },

                               nodeName: function( elem, name ) {
                                   return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
                               },

                               each: function( obj, callback ) {
                                   var length, i = 0;

                                   if ( isArrayLike( obj ) ) {
                                       length = obj.length;
                                       for ( ; i < length; i++ ) {
                                           if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
                                               break;
                                           }
                                       }
                                   } else {
                                       for ( i in obj ) {
                                           if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
                                               break;
                                           }
                                       }
                                   }

                                   return obj;
                               },

                               // Support: Android<4.1
                               trim: function( text ) {
                                   return text == null ?
                                       "" :
                                       ( text + "" ).replace( rtrim, "" );
                               },

                               // results is for internal usage only
                               makeArray: function( arr, results ) {
                                   var ret = results || [];

                                   if ( arr != null ) {
                                       if ( isArrayLike( Object( arr ) ) ) {
                                           jQuery.merge( ret,
                                                         typeof arr === "string" ?
                                                             [ arr ] : arr
                                           );
                                       } else {
                                           push.call( ret, arr );
                                       }
                                   }

                                   return ret;
                               },

                               inArray: function( elem, arr, i ) {
                                   return arr == null ? -1 : indexOf.call( arr, elem, i );
                               },

                               merge: function( first, second ) {
                                   var len = +second.length,
                                       j = 0,
                                       i = first.length;

                                   for ( ; j < len; j++ ) {
                                       first[ i++ ] = second[ j ];
                                   }

                                   first.length = i;

                                   return first;
                               },

                               grep: function( elems, callback, invert ) {
                                   var callbackInverse,
                                       matches = [],
                                       i = 0,
                                       length = elems.length,
                                       callbackExpect = !invert;

                                   // Go through the array, only saving the items
                                   // that pass the validator function
                                   for ( ; i < length; i++ ) {
                                       callbackInverse = !callback( elems[ i ], i );
                                       if ( callbackInverse !== callbackExpect ) {
                                           matches.push( elems[ i ] );
                                       }
                                   }

                                   return matches;
                               },

                               // arg is for internal usage only
                               map: function( elems, callback, arg ) {
                                   var length, value,
                                       i = 0,
                                       ret = [];

                                   // Go through the array, translating each of the items to their new values
                                   if ( isArrayLike( elems ) ) {
                                       length = elems.length;
                                       for ( ; i < length; i++ ) {
                                           value = callback( elems[ i ], i, arg );

                                           if ( value != null ) {
                                               ret.push( value );
                                           }
                                       }

                                       // Go through every key on the object,
                                   } else {
                                       for ( i in elems ) {
                                           value = callback( elems[ i ], i, arg );

                                           if ( value != null ) {
                                               ret.push( value );
                                           }
                                       }
                                   }

                                   // Flatten any nested arrays
                                   return concat.apply( [], ret );
                               },

                               // A global GUID counter for objects
                               guid: 1,

                               // Bind a function to a context, optionally partially applying any
                               // arguments.
                               proxy: function( fn, context ) {
                                   var tmp, args, proxy;

                                   if ( typeof context === "string" ) {
                                       tmp = fn[ context ];
                                       context = fn;
                                       fn = tmp;
                                   }

                                   // Quick check to determine if target is callable, in the spec
                                   // this throws a TypeError, but we will just return undefined.
                                   if ( !jQuery.isFunction( fn ) ) {
                                       return undefined;
                                   }

                                   // Simulated bind
                                   args = slice.call( arguments, 2 );
                                   proxy = function() {
                                       return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
                                   };

                                   // Set the guid of unique handler to the same of original handler, so it can be removed
                                   proxy.guid = fn.guid = fn.guid || jQuery.guid++;

                                   return proxy;
                               },

                               now: Date.now,

                               // jQuery.support is not used in Core but other projects attach their
                               // properties to it so it needs to exist.
                               support: support
                           } );

// JSHint would error on this code due to the Symbol not being defined in ES5.
// Defining this global in .jshintrc would create a danger of using the global
// unguarded in another place, it seems safer to just disable JSHint for these
// three lines.
            /* jshint ignore: start */
            if ( typeof Symbol === "function" ) {
                jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
            }
            /* jshint ignore: end */

// Populate the class2type map
            jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
                         function( i, name ) {
                             class2type[ "[object " + name + "]" ] = name.toLowerCase();
                         } );

            function isArrayLike( obj ) {

                // Support: iOS 8.2 (not reproducible in simulator)
                // `in` check used to prevent JIT error (gh-2145)
                // hasOwn isn't used here due to false negatives
                // regarding Nodelist length in IE
                var length = !!obj && "length" in obj && obj.length,
                    type = jQuery.type( obj );

                if ( type === "function" || jQuery.isWindow( obj ) ) {
                    return false;
                }

                return type === "array" || length === 0 ||
                       typeof length === "number" && length > 0 && ( length - 1 ) in obj;
            }
            var Sizzle =
                /*!
 * Sizzle CSS Selector Engine v2.2.1
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-10-17
 */
                (function( window ) {

                    var i,
                        support,
                        Expr,
                        getText,
                        isXML,
                        tokenize,
                        compile,
                        select,
                        outermostContext,
                        sortInput,
                        hasDuplicate,

                        // Local document vars
                        setDocument,
                        document,
                        docElem,
                        documentIsHTML,
                        rbuggyQSA,
                        rbuggyMatches,
                        matches,
                        contains,

                        // Instance-specific data
                        expando = "sizzle" + 1 * new Date(),
                        preferredDoc = window.document,
                        dirruns = 0,
                        done = 0,
                        classCache = createCache(),
                        tokenCache = createCache(),
                        compilerCache = createCache(),
                        sortOrder = function( a, b ) {
                            if ( a === b ) {
                                hasDuplicate = true;
                            }
                            return 0;
                        },

                        // General-purpose constants
                        MAX_NEGATIVE = 1 << 31,

                        // Instance methods
                        hasOwn = ({}).hasOwnProperty,
                        arr = [],
                        pop = arr.pop,
                        push_native = arr.push,
                        push = arr.push,
                        slice = arr.slice,
                        // Use a stripped-down indexOf as it's faster than native
                        // http://jsperf.com/thor-indexof-vs-for/5
                        indexOf = function( list, elem ) {
                            var i = 0,
                                len = list.length;
                            for ( ; i < len; i++ ) {
                                if ( list[i] === elem ) {
                                    return i;
                                }
                            }
                            return -1;
                        },

                        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

                        // Regular expressions

                        // http://www.w3.org/TR/css3-selectors/#whitespace
                        whitespace = "[\\x20\\t\\r\\n\\f]",

                        // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
                        identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

                        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
                        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
                                     // Operator (capture 2)
                                     "*([*^$|!~]?=)" + whitespace +
                                     // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
                                     "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
                                     "*\\]",

                        pseudos = ":(" + identifier + ")(?:\\((" +
                                  // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                                  // 1. quoted (capture 3; capture 4 or capture 5)
                                  "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
                                  // 2. simple (capture 6)
                                  "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
                                  // 3. anything else (capture 2)
                                  ".*" +
                                  ")\\)|)",

                        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                        rwhitespace = new RegExp( whitespace + "+", "g" ),
                        rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

                        rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
                        rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

                        rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

                        rpseudo = new RegExp( pseudos ),
                        ridentifier = new RegExp( "^" + identifier + "$" ),

                        matchExpr = {
                            "ID": new RegExp( "^#(" + identifier + ")" ),
                            "CLASS": new RegExp( "^\\.(" + identifier + ")" ),
                            "TAG": new RegExp( "^(" + identifier + "|[*])" ),
                            "ATTR": new RegExp( "^" + attributes ),
                            "PSEUDO": new RegExp( "^" + pseudos ),
                            "CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
                                                 "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
                                                 "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
                            "bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
                            // For use in libraries implementing .is()
                            // We use this for POS matching in `select`
                            "needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                                                        whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
                        },

                        rinputs = /^(?:input|select|textarea|button)$/i,
                        rheader = /^h\d$/i,

                        rnative = /^[^{]+\{\s*\[native \w/,

                        // Easily-parseable/retrievable ID or TAG or CLASS selectors
                        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

                        rsibling = /[+~]/,
                        rescape = /'|\\/g,

                        // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                        runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
                        funescape = function( _, escaped, escapedWhitespace ) {
                            var high = "0x" + escaped - 0x10000;
                            // NaN means non-codepoint
                            // Support: Firefox<24
                            // Workaround erroneous numeric interpretation of +"0x"
                            return high !== high || escapedWhitespace ?
                                escaped :
                                high < 0 ?
                                    // BMP codepoint
                                    String.fromCharCode( high + 0x10000 ) :
                                    // Supplemental Plane codepoint (surrogate pair)
                                    String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
                        },

                        // Used for iframes
                        // See setDocument()
                        // Removing the function wrapper causes a "Permission Denied"
                        // error in IE
                        unloadHandler = function() {
                            setDocument();
                        };

// Optimize for push.apply( _, NodeList )
                    try {
                        push.apply(
                            (arr = slice.call( preferredDoc.childNodes )),
                            preferredDoc.childNodes
                        );
                        // Support: Android<4.0
                        // Detect silently failing push.apply
                        arr[ preferredDoc.childNodes.length ].nodeType;
                    } catch ( e ) {
                        push = { apply: arr.length ?

                                // Leverage slice if possible
                                function( target, els ) {
                                    push_native.apply( target, slice.call(els) );
                                } :

                                // Support: IE<9
                                // Otherwise append directly
                                function( target, els ) {
                                    var j = target.length,
                                        i = 0;
                                    // Can't trust NodeList.length
                                    while ( (target[j++] = els[i++]) ) {}
                                    target.length = j - 1;
                                }
                        };
                    }

                    function Sizzle( selector, context, results, seed ) {
                        var m, i, elem, nid, nidselect, match, groups, newSelector,
                            newContext = context && context.ownerDocument,

                            // nodeType defaults to 9, since context defaults to document
                            nodeType = context ? context.nodeType : 9;

                        results = results || [];

                        // Return early from calls with invalid selector or context
                        if ( typeof selector !== "string" || !selector ||
                             nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

                            return results;
                        }

                        // Try to shortcut find operations (as opposed to filters) in HTML documents
                        if ( !seed ) {

                            if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
                                setDocument( context );
                            }
                            context = context || document;

                            if ( documentIsHTML ) {

                                // If the selector is sufficiently simple, try using a "get*By*" DOM method
                                // (excepting DocumentFragment context, where the methods don't exist)
                                if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

                                    // ID selector
                                    if ( (m = match[1]) ) {

                                        // Document context
                                        if ( nodeType === 9 ) {
                                            if ( (elem = context.getElementById( m )) ) {

                                                // Support: IE, Opera, Webkit
                                                // TODO: identify versions
                                                // getElementById can match elements by name instead of ID
                                                if ( elem.id === m ) {
                                                    results.push( elem );
                                                    return results;
                                                }
                                            } else {
                                                return results;
                                            }

                                            // Element context
                                        } else {

                                            // Support: IE, Opera, Webkit
                                            // TODO: identify versions
                                            // getElementById can match elements by name instead of ID
                                            if ( newContext && (elem = newContext.getElementById( m )) &&
                                                 contains( context, elem ) &&
                                                 elem.id === m ) {

                                                results.push( elem );
                                                return results;
                                            }
                                        }

                                        // Type selector
                                    } else if ( match[2] ) {
                                        push.apply( results, context.getElementsByTagName( selector ) );
                                        return results;

                                        // Class selector
                                    } else if ( (m = match[3]) && support.getElementsByClassName &&
                                                context.getElementsByClassName ) {

                                        push.apply( results, context.getElementsByClassName( m ) );
                                        return results;
                                    }
                                }

                                // Take advantage of querySelectorAll
                                if ( support.qsa &&
                                     !compilerCache[ selector + " " ] &&
                                     (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

                                    if ( nodeType !== 1 ) {
                                        newContext = context;
                                        newSelector = selector;

                                        // qSA looks outside Element context, which is not what we want
                                        // Thanks to Andrew Dupont for this workaround technique
                                        // Support: IE <=8
                                        // Exclude object elements
                                    } else if ( context.nodeName.toLowerCase() !== "object" ) {

                                        // Capture the context ID, setting it first if necessary
                                        if ( (nid = context.getAttribute( "id" )) ) {
                                            nid = nid.replace( rescape, "\\$&" );
                                        } else {
                                            context.setAttribute( "id", (nid = expando) );
                                        }

                                        // Prefix every selector in the list
                                        groups = tokenize( selector );
                                        i = groups.length;
                                        nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
                                        while ( i-- ) {
                                            groups[i] = nidselect + " " + toSelector( groups[i] );
                                        }
                                        newSelector = groups.join( "," );

                                        // Expand context for sibling selectors
                                        newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
                                                     context;
                                    }

                                    if ( newSelector ) {
                                        try {
                                            push.apply( results,
                                                        newContext.querySelectorAll( newSelector )
                                            );
                                            return results;
                                        } catch ( qsaError ) {
                                        } finally {
                                            if ( nid === expando ) {
                                                context.removeAttribute( "id" );
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        // All others
                        return select( selector.replace( rtrim, "$1" ), context, results, seed );
                    }

                    /**
                     * Create key-value caches of limited size
                     * @returns {function(string, object)} Returns the Object data after storing it on itself with
                     *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
                     *	deleting the oldest entry
                     */
                    function createCache() {
                        var keys = [];

                        function cache( key, value ) {
                            // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                            if ( keys.push( key + " " ) > Expr.cacheLength ) {
                                // Only keep the most recent entries
                                delete cache[ keys.shift() ];
                            }
                            return (cache[ key + " " ] = value);
                        }
                        return cache;
                    }

                    /**
                     * Mark a function for special use by Sizzle
                     * @param {Function} fn The function to mark
                     */
                    function markFunction( fn ) {
                        fn[ expando ] = true;
                        return fn;
                    }

                    /**
                     * Support testing using an element
                     * @param {Function} fn Passed the created div and expects a boolean result
                     */
                    function assert( fn ) {
                        var div = document.createElement("div");

                        try {
                            return !!fn( div );
                        } catch (e) {
                            return false;
                        } finally {
                            // Remove from its parent by default
                            if ( div.parentNode ) {
                                div.parentNode.removeChild( div );
                            }
                            // release memory in IE
                            div = null;
                        }
                    }

                    /**
                     * Adds the same handler for all of the specified attrs
                     * @param {String} attrs Pipe-separated list of attributes
                     * @param {Function} handler The method that will be applied
                     */
                    function addHandle( attrs, handler ) {
                        var arr = attrs.split("|"),
                            i = arr.length;

                        while ( i-- ) {
                            Expr.attrHandle[ arr[i] ] = handler;
                        }
                    }

                    /**
                     * Checks document order of two siblings
                     * @param {Element} a
                     * @param {Element} b
                     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
                     */
                    function siblingCheck( a, b ) {
                        var cur = b && a,
                            diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
                                   ( ~b.sourceIndex || MAX_NEGATIVE ) -
                                   ( ~a.sourceIndex || MAX_NEGATIVE );

                        // Use IE sourceIndex if available on both nodes
                        if ( diff ) {
                            return diff;
                        }

                        // Check if b follows a
                        if ( cur ) {
                            while ( (cur = cur.nextSibling) ) {
                                if ( cur === b ) {
                                    return -1;
                                }
                            }
                        }

                        return a ? 1 : -1;
                    }

                    /**
                     * Returns a function to use in pseudos for input types
                     * @param {String} type
                     */
                    function createInputPseudo( type ) {
                        return function( elem ) {
                            var name = elem.nodeName.toLowerCase();
                            return name === "input" && elem.type === type;
                        };
                    }

                    /**
                     * Returns a function to use in pseudos for buttons
                     * @param {String} type
                     */
                    function createButtonPseudo( type ) {
                        return function( elem ) {
                            var name = elem.nodeName.toLowerCase();
                            return (name === "input" || name === "button") && elem.type === type;
                        };
                    }

                    /**
                     * Returns a function to use in pseudos for positionals
                     * @param {Function} fn
                     */
                    function createPositionalPseudo( fn ) {
                        return markFunction(function( argument ) {
                            argument = +argument;
                            return markFunction(function( seed, matches ) {
                                var j,
                                    matchIndexes = fn( [], seed.length, argument ),
                                    i = matchIndexes.length;

                                // Match elements found at the specified indexes
                                while ( i-- ) {
                                    if ( seed[ (j = matchIndexes[i]) ] ) {
                                        seed[j] = !(matches[j] = seed[j]);
                                    }
                                }
                            });
                        });
                    }

                    /**
                     * Checks a node for validity as a Sizzle context
                     * @param {Element|Object=} context
                     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
                     */
                    function testContext( context ) {
                        return context && typeof context.getElementsByTagName !== "undefined" && context;
                    }

// Expose support vars for convenience
                    support = Sizzle.support = {};

                    /**
                     * Detects XML nodes
                     * @param {Element|Object} elem An element or a document
                     * @returns {Boolean} True iff elem is a non-HTML XML node
                     */
                    isXML = Sizzle.isXML = function( elem ) {
                        // documentElement is verified for cases where it doesn't yet exist
                        // (such as loading iframes in IE - #4833)
                        var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                        return documentElement ? documentElement.nodeName !== "HTML" : false;
                    };

                    /**
                     * Sets document-related variables once based on the current document
                     * @param {Element|Object} [doc] An element or document object to use to set the document
                     * @returns {Object} Returns the current document
                     */
                    setDocument = Sizzle.setDocument = function( node ) {
                        var hasCompare, parent,
                            doc = node ? node.ownerDocument || node : preferredDoc;

                        // Return early if doc is invalid or already selected
                        if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
                            return document;
                        }

                        // Update global variables
                        document = doc;
                        docElem = document.documentElement;
                        documentIsHTML = !isXML( document );

                        // Support: IE 9-11, Edge
                        // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
                        if ( (parent = document.defaultView) && parent.top !== parent ) {
                            // Support: IE 11
                            if ( parent.addEventListener ) {
                                parent.addEventListener( "unload", unloadHandler, false );

                                // Support: IE 9 - 10 only
                            } else if ( parent.attachEvent ) {
                                parent.attachEvent( "onunload", unloadHandler );
                            }
                        }

                        /* Attributes
	---------------------------------------------------------------------- */

                        // Support: IE<8
                        // Verify that getAttribute really returns attributes and not properties
                        // (excepting IE8 booleans)
                        support.attributes = assert(function( div ) {
                            div.className = "i";
                            return !div.getAttribute("className");
                        });

                        /* getElement(s)By*
	---------------------------------------------------------------------- */

                        // Check if getElementsByTagName("*") returns only elements
                        support.getElementsByTagName = assert(function( div ) {
                            div.appendChild( document.createComment("") );
                            return !div.getElementsByTagName("*").length;
                        });

                        // Support: IE<9
                        support.getElementsByClassName = rnative.test( document.getElementsByClassName );

                        // Support: IE<10
                        // Check if getElementById returns elements by name
                        // The broken getElementById methods don't pick up programatically-set names,
                        // so use a roundabout getElementsByName test
                        support.getById = assert(function( div ) {
                            docElem.appendChild( div ).id = expando;
                            return !document.getElementsByName || !document.getElementsByName( expando ).length;
                        });

                        // ID find and filter
                        if ( support.getById ) {
                            Expr.find["ID"] = function( id, context ) {
                                if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
                                    var m = context.getElementById( id );
                                    return m ? [ m ] : [];
                                }
                            };
                            Expr.filter["ID"] = function( id ) {
                                var attrId = id.replace( runescape, funescape );
                                return function( elem ) {
                                    return elem.getAttribute("id") === attrId;
                                };
                            };
                        } else {
                            // Support: IE6/7
                            // getElementById is not reliable as a find shortcut
                            delete Expr.find["ID"];

                            Expr.filter["ID"] =  function( id ) {
                                var attrId = id.replace( runescape, funescape );
                                return function( elem ) {
                                    var node = typeof elem.getAttributeNode !== "undefined" &&
                                               elem.getAttributeNode("id");
                                    return node && node.value === attrId;
                                };
                            };
                        }

                        // Tag
                        Expr.find["TAG"] = support.getElementsByTagName ?
                            function( tag, context ) {
                                if ( typeof context.getElementsByTagName !== "undefined" ) {
                                    return context.getElementsByTagName( tag );

                                    // DocumentFragment nodes don't have gEBTN
                                } else if ( support.qsa ) {
                                    return context.querySelectorAll( tag );
                                }
                            } :

                            function( tag, context ) {
                                var elem,
                                    tmp = [],
                                    i = 0,
                                    // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                                    results = context.getElementsByTagName( tag );

                                // Filter out possible comments
                                if ( tag === "*" ) {
                                    while ( (elem = results[i++]) ) {
                                        if ( elem.nodeType === 1 ) {
                                            tmp.push( elem );
                                        }
                                    }

                                    return tmp;
                                }
                                return results;
                            };

                        // Class
                        Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
                            if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
                                return context.getElementsByClassName( className );
                            }
                        };

                        /* QSA/matchesSelector
	---------------------------------------------------------------------- */

                        // QSA and matchesSelector support

                        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                        rbuggyMatches = [];

                        // qSa(:focus) reports false when true (Chrome 21)
                        // We allow this because of a bug in IE8/9 that throws an error
                        // whenever `document.activeElement` is accessed on an iframe
                        // So, we allow :focus to pass through QSA all the time to avoid the IE error
                        // See http://bugs.jquery.com/ticket/13378
                        rbuggyQSA = [];

                        if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
                            // Build QSA regex
                            // Regex strategy adopted from Diego Perini
                            assert(function( div ) {
                                // Select is set to empty string on purpose
                                // This is to test IE's treatment of not explicitly
                                // setting a boolean content attribute,
                                // since its presence should be enough
                                // http://bugs.jquery.com/ticket/12359
                                docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
                                                                       "<select id='" + expando + "-\r\\' msallowcapture=''>" +
                                                                       "<option selected=''></option></select>";

                                // Support: IE8, Opera 11-12.16
                                // Nothing should be selected when empty strings follow ^= or $= or *=
                                // The test attribute must be unknown in Opera but "safe" for WinRT
                                // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                                if ( div.querySelectorAll("[msallowcapture^='']").length ) {
                                    rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
                                }

                                // Support: IE8
                                // Boolean attributes and "value" are not treated correctly
                                if ( !div.querySelectorAll("[selected]").length ) {
                                    rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
                                }

                                // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
                                if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
                                    rbuggyQSA.push("~=");
                                }

                                // Webkit/Opera - :checked should return selected option elements
                                // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                                // IE8 throws error here and will not see later tests
                                if ( !div.querySelectorAll(":checked").length ) {
                                    rbuggyQSA.push(":checked");
                                }

                                // Support: Safari 8+, iOS 8+
                                // https://bugs.webkit.org/show_bug.cgi?id=136851
                                // In-page `selector#id sibing-combinator selector` fails
                                if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
                                    rbuggyQSA.push(".#.+[+~]");
                                }
                            });

                            assert(function( div ) {
                                // Support: Windows 8 Native Apps
                                // The type and name attributes are restricted during .innerHTML assignment
                                var input = document.createElement("input");
                                input.setAttribute( "type", "hidden" );
                                div.appendChild( input ).setAttribute( "name", "D" );

                                // Support: IE8
                                // Enforce case-sensitivity of name attribute
                                if ( div.querySelectorAll("[name=d]").length ) {
                                    rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
                                }

                                // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                                // IE8 throws error here and will not see later tests
                                if ( !div.querySelectorAll(":enabled").length ) {
                                    rbuggyQSA.push( ":enabled", ":disabled" );
                                }

                                // Opera 10-11 does not throw on post-comma invalid pseudos
                                div.querySelectorAll("*,:x");
                                rbuggyQSA.push(",.*:");
                            });
                        }

                        if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
                                                                                 docElem.webkitMatchesSelector ||
                                                                                 docElem.mozMatchesSelector ||
                                                                                 docElem.oMatchesSelector ||
                                                                                 docElem.msMatchesSelector) )) ) {

                            assert(function( div ) {
                                // Check to see if it's possible to do matchesSelector
                                // on a disconnected node (IE 9)
                                support.disconnectedMatch = matches.call( div, "div" );

                                // This should fail with an exception
                                // Gecko does not error, returns false instead
                                matches.call( div, "[s!='']:x" );
                                rbuggyMatches.push( "!=", pseudos );
                            });
                        }

                        rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
                        rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

                        /* Contains
	---------------------------------------------------------------------- */
                        hasCompare = rnative.test( docElem.compareDocumentPosition );

                        // Element contains another
                        // Purposefully self-exclusive
                        // As in, an element does not contain itself
                        contains = hasCompare || rnative.test( docElem.contains ) ?
                            function( a, b ) {
                                var adown = a.nodeType === 9 ? a.documentElement : a,
                                    bup = b && b.parentNode;
                                return a === bup || !!( bup && bup.nodeType === 1 && (
                                    adown.contains ?
                                        adown.contains( bup ) :
                                                        a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
                                ));
                            } :
                            function( a, b ) {
                                if ( b ) {
                                    while ( (b = b.parentNode) ) {
                                        if ( b === a ) {
                                            return true;
                                        }
                                    }
                                }
                                return false;
                            };

                        /* Sorting
	---------------------------------------------------------------------- */

                        // Document order sorting
                        sortOrder = hasCompare ?
                            function( a, b ) {

                                // Flag for duplicate removal
                                if ( a === b ) {
                                    hasDuplicate = true;
                                    return 0;
                                }

                                // Sort on method existence if only one input has compareDocumentPosition
                                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                                if ( compare ) {
                                    return compare;
                                }

                                // Calculate position if both inputs belong to the same document
                                compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
                                    a.compareDocumentPosition( b ) :

                                    // Otherwise we know they are disconnected
                                    1;

                                // Disconnected nodes
                                if ( compare & 1 ||
                                     (!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

                                    // Choose the first element that is related to our preferred document
                                    if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
                                        return -1;
                                    }
                                    if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
                                        return 1;
                                    }

                                    // Maintain original order
                                    return sortInput ?
                                        ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
                                        0;
                                }

                                return compare & 4 ? -1 : 1;
                            } :
                            function( a, b ) {
                                // Exit early if the nodes are identical
                                if ( a === b ) {
                                    hasDuplicate = true;
                                    return 0;
                                }

                                var cur,
                                    i = 0,
                                    aup = a.parentNode,
                                    bup = b.parentNode,
                                    ap = [ a ],
                                    bp = [ b ];

                                // Parentless nodes are either documents or disconnected
                                if ( !aup || !bup ) {
                                    return a === document ? -1 :
                                        b === document ? 1 :
                                            aup ? -1 :
                                                bup ? 1 :
                                                    sortInput ?
                                                        ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
                                                        0;

                                    // If the nodes are siblings, we can do a quick check
                                } else if ( aup === bup ) {
                                    return siblingCheck( a, b );
                                }

                                // Otherwise we need full lists of their ancestors for comparison
                                cur = a;
                                while ( (cur = cur.parentNode) ) {
                                    ap.unshift( cur );
                                }
                                cur = b;
                                while ( (cur = cur.parentNode) ) {
                                    bp.unshift( cur );
                                }

                                // Walk down the tree looking for a discrepancy
                                while ( ap[i] === bp[i] ) {
                                    i++;
                                }

                                return i ?
                                    // Do a sibling check if the nodes have a common ancestor
                                    siblingCheck( ap[i], bp[i] ) :

                                    // Otherwise nodes in our document sort first
                                    ap[i] === preferredDoc ? -1 :
                                        bp[i] === preferredDoc ? 1 :
                                            0;
                            };

                        return document;
                    };

                    Sizzle.matches = function( expr, elements ) {
                        return Sizzle( expr, null, null, elements );
                    };

                    Sizzle.matchesSelector = function( elem, expr ) {
                        // Set document vars if needed
                        if ( ( elem.ownerDocument || elem ) !== document ) {
                            setDocument( elem );
                        }

                        // Make sure that attribute selectors are quoted
                        expr = expr.replace( rattributeQuotes, "='$1']" );

                        if ( support.matchesSelector && documentIsHTML &&
                             !compilerCache[ expr + " " ] &&
                             ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
                             ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

                            try {
                                var ret = matches.call( elem, expr );

                                // IE 9's matchesSelector returns false on disconnected nodes
                                if ( ret || support.disconnectedMatch ||
                                     // As well, disconnected nodes are said to be in a document
                                     // fragment in IE 9
                                     elem.document && elem.document.nodeType !== 11 ) {
                                    return ret;
                                }
                            } catch (e) {}
                        }

                        return Sizzle( expr, document, null, [ elem ] ).length > 0;
                    };

                    Sizzle.contains = function( context, elem ) {
                        // Set document vars if needed
                        if ( ( context.ownerDocument || context ) !== document ) {
                            setDocument( context );
                        }
                        return contains( context, elem );
                    };

                    Sizzle.attr = function( elem, name ) {
                        // Set document vars if needed
                        if ( ( elem.ownerDocument || elem ) !== document ) {
                            setDocument( elem );
                        }

                        var fn = Expr.attrHandle[ name.toLowerCase() ],
                            // Don't get fooled by Object.prototype properties (jQuery #13807)
                            val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
                                fn( elem, name, !documentIsHTML ) :
                                undefined;

                        return val !== undefined ?
                            val :
                            support.attributes || !documentIsHTML ?
                                elem.getAttribute( name ) :
                                (val = elem.getAttributeNode(name)) && val.specified ?
                                    val.value :
                                    null;
                    };

                    Sizzle.error = function( msg ) {
                        throw new Error( "Syntax error, unrecognized expression: " + msg );
                    };

                    /**
                     * Document sorting and removing duplicates
                     * @param {ArrayLike} results
                     */
                    Sizzle.uniqueSort = function( results ) {
                        var elem,
                            duplicates = [],
                            j = 0,
                            i = 0;

                        // Unless we *know* we can detect duplicates, assume their presence
                        hasDuplicate = !support.detectDuplicates;
                        sortInput = !support.sortStable && results.slice( 0 );
                        results.sort( sortOrder );

                        if ( hasDuplicate ) {
                            while ( (elem = results[i++]) ) {
                                if ( elem === results[ i ] ) {
                                    j = duplicates.push( i );
                                }
                            }
                            while ( j-- ) {
                                results.splice( duplicates[ j ], 1 );
                            }
                        }

                        // Clear input after sorting to release objects
                        // See https://github.com/jquery/sizzle/pull/225
                        sortInput = null;

                        return results;
                    };

                    /**
                     * Utility function for retrieving the text value of an array of DOM nodes
                     * @param {Array|Element} elem
                     */
                    getText = Sizzle.getText = function( elem ) {
                        var node,
                            ret = "",
                            i = 0,
                            nodeType = elem.nodeType;

                        if ( !nodeType ) {
                            // If no nodeType, this is expected to be an array
                            while ( (node = elem[i++]) ) {
                                // Do not traverse comment nodes
                                ret += getText( node );
                            }
                        } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
                            // Use textContent for elements
                            // innerText usage removed for consistency of new lines (jQuery #11153)
                            if ( typeof elem.textContent === "string" ) {
                                return elem.textContent;
                            } else {
                                // Traverse its children
                                for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                                    ret += getText( elem );
                                }
                            }
                        } else if ( nodeType === 3 || nodeType === 4 ) {
                            return elem.nodeValue;
                        }
                        // Do not include comment or processing instruction nodes

                        return ret;
                    };

                    Expr = Sizzle.selectors = {

                        // Can be adjusted by the user
                        cacheLength: 50,

                        createPseudo: markFunction,

                        match: matchExpr,

                        attrHandle: {},

                        find: {},

                        relative: {
                            ">": { dir: "parentNode", first: true },
                            " ": { dir: "parentNode" },
                            "+": { dir: "previousSibling", first: true },
                            "~": { dir: "previousSibling" }
                        },

                        preFilter: {
                            "ATTR": function( match ) {
                                match[1] = match[1].replace( runescape, funescape );

                                // Move the given value to match[3] whether quoted or unquoted
                                match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

                                if ( match[2] === "~=" ) {
                                    match[3] = " " + match[3] + " ";
                                }

                                return match.slice( 0, 4 );
                            },

                            "CHILD": function( match ) {
                                /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
                                match[1] = match[1].toLowerCase();

                                if ( match[1].slice( 0, 3 ) === "nth" ) {
                                    // nth-* requires argument
                                    if ( !match[3] ) {
                                        Sizzle.error( match[0] );
                                    }

                                    // numeric x and y parameters for Expr.filter.CHILD
                                    // remember that false/true cast respectively to 0/1
                                    match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
                                    match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

                                    // other types prohibit arguments
                                } else if ( match[3] ) {
                                    Sizzle.error( match[0] );
                                }

                                return match;
                            },

                            "PSEUDO": function( match ) {
                                var excess,
                                    unquoted = !match[6] && match[2];

                                if ( matchExpr["CHILD"].test( match[0] ) ) {
                                    return null;
                                }

                                // Accept quoted arguments as-is
                                if ( match[3] ) {
                                    match[2] = match[4] || match[5] || "";

                                    // Strip excess characters from unquoted arguments
                                } else if ( unquoted && rpseudo.test( unquoted ) &&
                                            // Get excess from tokenize (recursively)
                                            (excess = tokenize( unquoted, true )) &&
                                            // advance to the next closing parenthesis
                                            (excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

                                    // excess is a negative index
                                    match[0] = match[0].slice( 0, excess );
                                    match[2] = unquoted.slice( 0, excess );
                                }

                                // Return only captures needed by the pseudo filter method (type and argument)
                                return match.slice( 0, 3 );
                            }
                        },

                        filter: {

                            "TAG": function( nodeNameSelector ) {
                                var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
                                return nodeNameSelector === "*" ?
                                    function() { return true; } :
                                    function( elem ) {
                                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                                    };
                            },

                            "CLASS": function( className ) {
                                var pattern = classCache[ className + " " ];

                                return pattern ||
                                       (pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
                                       classCache( className, function( elem ) {
                                           return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
                                       });
                            },

                            "ATTR": function( name, operator, check ) {
                                return function( elem ) {
                                    var result = Sizzle.attr( elem, name );

                                    if ( result == null ) {
                                        return operator === "!=";
                                    }
                                    if ( !operator ) {
                                        return true;
                                    }

                                    result += "";

                                    return operator === "=" ? result === check :
                                        operator === "!=" ? result !== check :
                                            operator === "^=" ? check && result.indexOf( check ) === 0 :
                                                operator === "*=" ? check && result.indexOf( check ) > -1 :
                                                    operator === "$=" ? check && result.slice( -check.length ) === check :
                                                        operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
                                                            operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
                                                                false;
                                };
                            },

                            "CHILD": function( type, what, argument, first, last ) {
                                var simple = type.slice( 0, 3 ) !== "nth",
                                    forward = type.slice( -4 ) !== "last",
                                    ofType = what === "of-type";

                                return first === 1 && last === 0 ?

                                    // Shortcut for :nth-*(n)
                                    function( elem ) {
                                        return !!elem.parentNode;
                                    } :

                                    function( elem, context, xml ) {
                                        var cache, uniqueCache, outerCache, node, nodeIndex, start,
                                            dir = simple !== forward ? "nextSibling" : "previousSibling",
                                            parent = elem.parentNode,
                                            name = ofType && elem.nodeName.toLowerCase(),
                                            useCache = !xml && !ofType,
                                            diff = false;

                                        if ( parent ) {

                                            // :(first|last|only)-(child|of-type)
                                            if ( simple ) {
                                                while ( dir ) {
                                                    node = elem;
                                                    while ( (node = node[ dir ]) ) {
                                                        if ( ofType ?
                                                            node.nodeName.toLowerCase() === name :
                                                            node.nodeType === 1 ) {

                                                            return false;
                                                        }
                                                    }
                                                    // Reverse direction for :only-* (if we haven't yet done so)
                                                    start = dir = type === "only" && !start && "nextSibling";
                                                }
                                                return true;
                                            }

                                            start = [ forward ? parent.firstChild : parent.lastChild ];

                                            // non-xml :nth-child(...) stores cache data on `parent`
                                            if ( forward && useCache ) {

                                                // Seek `elem` from a previously-cached index

                                                // ...in a gzip-friendly way
                                                node = parent;
                                                outerCache = node[ expando ] || (node[ expando ] = {});

                                                // Support: IE <9 only
                                                // Defend against cloned attroperties (jQuery gh-1709)
                                                uniqueCache = outerCache[ node.uniqueID ] ||
                                                              (outerCache[ node.uniqueID ] = {});

                                                cache = uniqueCache[ type ] || [];
                                                nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
                                                diff = nodeIndex && cache[ 2 ];
                                                node = nodeIndex && parent.childNodes[ nodeIndex ];

                                                while ( (node = ++nodeIndex && node && node[ dir ] ||

                                                                // Fallback to seeking `elem` from the start
                                                                (diff = nodeIndex = 0) || start.pop()) ) {

                                                    // When found, cache indexes on `parent` and break
                                                    if ( node.nodeType === 1 && ++diff && node === elem ) {
                                                        uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
                                                        break;
                                                    }
                                                }

                                            } else {
                                                // Use previously-cached element index if available
                                                if ( useCache ) {
                                                    // ...in a gzip-friendly way
                                                    node = elem;
                                                    outerCache = node[ expando ] || (node[ expando ] = {});

                                                    // Support: IE <9 only
                                                    // Defend against cloned attroperties (jQuery gh-1709)
                                                    uniqueCache = outerCache[ node.uniqueID ] ||
                                                                  (outerCache[ node.uniqueID ] = {});

                                                    cache = uniqueCache[ type ] || [];
                                                    nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
                                                    diff = nodeIndex;
                                                }

                                                // xml :nth-child(...)
                                                // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                                if ( diff === false ) {
                                                    // Use the same loop as above to seek `elem` from the start
                                                    while ( (node = ++nodeIndex && node && node[ dir ] ||
                                                                    (diff = nodeIndex = 0) || start.pop()) ) {

                                                        if ( ( ofType ?
                                                            node.nodeName.toLowerCase() === name :
                                                            node.nodeType === 1 ) &&
                                                             ++diff ) {

                                                            // Cache the index of each encountered element
                                                            if ( useCache ) {
                                                                outerCache = node[ expando ] || (node[ expando ] = {});

                                                                // Support: IE <9 only
                                                                // Defend against cloned attroperties (jQuery gh-1709)
                                                                uniqueCache = outerCache[ node.uniqueID ] ||
                                                                              (outerCache[ node.uniqueID ] = {});

                                                                uniqueCache[ type ] = [ dirruns, diff ];
                                                            }

                                                            if ( node === elem ) {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                            }

                                            // Incorporate the offset, then check against cycle size
                                            diff -= last;
                                            return diff === first || ( diff % first === 0 && diff / first >= 0 );
                                        }
                                    };
                            },

                            "PSEUDO": function( pseudo, argument ) {
                                // pseudo-class names are case-insensitive
                                // http://www.w3.org/TR/selectors/#pseudo-classes
                                // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                                // Remember that setFilters inherits from pseudos
                                var args,
                                    fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
                                         Sizzle.error( "unsupported pseudo: " + pseudo );

                                // The user may use createPseudo to indicate that
                                // arguments are needed to create the filter function
                                // just as Sizzle does
                                if ( fn[ expando ] ) {
                                    return fn( argument );
                                }

                                // But maintain support for old signatures
                                if ( fn.length > 1 ) {
                                    args = [ pseudo, pseudo, "", argument ];
                                    return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
                                        markFunction(function( seed, matches ) {
                                            var idx,
                                                matched = fn( seed, argument ),
                                                i = matched.length;
                                            while ( i-- ) {
                                                idx = indexOf( seed, matched[i] );
                                                seed[ idx ] = !( matches[ idx ] = matched[i] );
                                            }
                                        }) :
                                        function( elem ) {
                                            return fn( elem, 0, args );
                                        };
                                }

                                return fn;
                            }
                        },

                        pseudos: {
                            // Potentially complex pseudos
                            "not": markFunction(function( selector ) {
                                // Trim the selector passed to compile
                                // to avoid treating leading and trailing
                                // spaces as combinators
                                var input = [],
                                    results = [],
                                    matcher = compile( selector.replace( rtrim, "$1" ) );

                                return matcher[ expando ] ?
                                    markFunction(function( seed, matches, context, xml ) {
                                        var elem,
                                            unmatched = matcher( seed, null, xml, [] ),
                                            i = seed.length;

                                        // Match elements unmatched by `matcher`
                                        while ( i-- ) {
                                            if ( (elem = unmatched[i]) ) {
                                                seed[i] = !(matches[i] = elem);
                                            }
                                        }
                                    }) :
                                    function( elem, context, xml ) {
                                        input[0] = elem;
                                        matcher( input, null, xml, results );
                                        // Don't keep the element (issue #299)
                                        input[0] = null;
                                        return !results.pop();
                                    };
                            }),

                            "has": markFunction(function( selector ) {
                                return function( elem ) {
                                    return Sizzle( selector, elem ).length > 0;
                                };
                            }),

                            "contains": markFunction(function( text ) {
                                text = text.replace( runescape, funescape );
                                return function( elem ) {
                                    return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
                                };
                            }),

                            // "Whether an element is represented by a :lang() selector
                            // is based solely on the element's language value
                            // being equal to the identifier C,
                            // or beginning with the identifier C immediately followed by "-".
                            // The matching of C against the element's language value is performed case-insensitively.
                            // The identifier C does not have to be a valid language name."
                            // http://www.w3.org/TR/selectors/#lang-pseudo
                            "lang": markFunction( function( lang ) {
                                // lang value must be a valid identifier
                                if ( !ridentifier.test(lang || "") ) {
                                    Sizzle.error( "unsupported lang: " + lang );
                                }
                                lang = lang.replace( runescape, funescape ).toLowerCase();
                                return function( elem ) {
                                    var elemLang;
                                    do {
                                        if ( (elemLang = documentIsHTML ?
                                            elem.lang :
                                            elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

                                            elemLang = elemLang.toLowerCase();
                                            return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
                                        }
                                    } while ( (elem = elem.parentNode) && elem.nodeType === 1 );
                                    return false;
                                };
                            }),

                            // Miscellaneous
                            "target": function( elem ) {
                                var hash = window.location && window.location.hash;
                                return hash && hash.slice( 1 ) === elem.id;
                            },

                            "root": function( elem ) {
                                return elem === docElem;
                            },

                            "focus": function( elem ) {
                                return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                            },

                            // Boolean properties
                            "enabled": function( elem ) {
                                return elem.disabled === false;
                            },

                            "disabled": function( elem ) {
                                return elem.disabled === true;
                            },

                            "checked": function( elem ) {
                                // In CSS3, :checked should return both checked and selected elements
                                // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                                var nodeName = elem.nodeName.toLowerCase();
                                return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
                            },

                            "selected": function( elem ) {
                                // Accessing this property makes selected-by-default
                                // options in Safari work properly
                                if ( elem.parentNode ) {
                                    elem.parentNode.selectedIndex;
                                }

                                return elem.selected === true;
                            },

                            // Contents
                            "empty": function( elem ) {
                                // http://www.w3.org/TR/selectors/#empty-pseudo
                                // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                                //   but not by others (comment: 8; processing instruction: 7; etc.)
                                // nodeType < 6 works because attributes (2) do not appear as children
                                for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                                    if ( elem.nodeType < 6 ) {
                                        return false;
                                    }
                                }
                                return true;
                            },

                            "parent": function( elem ) {
                                return !Expr.pseudos["empty"]( elem );
                            },

                            // Element/input types
                            "header": function( elem ) {
                                return rheader.test( elem.nodeName );
                            },

                            "input": function( elem ) {
                                return rinputs.test( elem.nodeName );
                            },

                            "button": function( elem ) {
                                var name = elem.nodeName.toLowerCase();
                                return name === "input" && elem.type === "button" || name === "button";
                            },

                            "text": function( elem ) {
                                var attr;
                                return elem.nodeName.toLowerCase() === "input" &&
                                       elem.type === "text" &&

                                       // Support: IE<8
                                       // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                                       ( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
                            },

                            // Position-in-collection
                            "first": createPositionalPseudo(function() {
                                return [ 0 ];
                            }),

                            "last": createPositionalPseudo(function( matchIndexes, length ) {
                                return [ length - 1 ];
                            }),

                            "eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
                                return [ argument < 0 ? argument + length : argument ];
                            }),

                            "even": createPositionalPseudo(function( matchIndexes, length ) {
                                var i = 0;
                                for ( ; i < length; i += 2 ) {
                                    matchIndexes.push( i );
                                }
                                return matchIndexes;
                            }),

                            "odd": createPositionalPseudo(function( matchIndexes, length ) {
                                var i = 1;
                                for ( ; i < length; i += 2 ) {
                                    matchIndexes.push( i );
                                }
                                return matchIndexes;
                            }),

                            "lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
                                var i = argument < 0 ? argument + length : argument;
                                for ( ; --i >= 0; ) {
                                    matchIndexes.push( i );
                                }
                                return matchIndexes;
                            }),

                            "gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
                                var i = argument < 0 ? argument + length : argument;
                                for ( ; ++i < length; ) {
                                    matchIndexes.push( i );
                                }
                                return matchIndexes;
                            })
                        }
                    };

                    Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
                    for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
                        Expr.pseudos[ i ] = createInputPseudo( i );
                    }
                    for ( i in { submit: true, reset: true } ) {
                        Expr.pseudos[ i ] = createButtonPseudo( i );
                    }

// Easy API for creating new setFilters
                    function setFilters() {}
                    setFilters.prototype = Expr.filters = Expr.pseudos;
                    Expr.setFilters = new setFilters();

                    tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
                        var matched, match, tokens, type,
                            soFar, groups, preFilters,
                            cached = tokenCache[ selector + " " ];

                        if ( cached ) {
                            return parseOnly ? 0 : cached.slice( 0 );
                        }

                        soFar = selector;
                        groups = [];
                        preFilters = Expr.preFilter;

                        while ( soFar ) {

                            // Comma and first run
                            if ( !matched || (match = rcomma.exec( soFar )) ) {
                                if ( match ) {
                                    // Don't consume trailing commas as valid
                                    soFar = soFar.slice( match[0].length ) || soFar;
                                }
                                groups.push( (tokens = []) );
                            }

                            matched = false;

                            // Combinators
                            if ( (match = rcombinators.exec( soFar )) ) {
                                matched = match.shift();
                                tokens.push({
                                                value: matched,
                                                // Cast descendant combinators to space
                                                type: match[0].replace( rtrim, " " )
                                            });
                                soFar = soFar.slice( matched.length );
                            }

                            // Filters
                            for ( type in Expr.filter ) {
                                if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
                                                                                   (match = preFilters[ type ]( match ))) ) {
                                    matched = match.shift();
                                    tokens.push({
                                                    value: matched,
                                                    type: type,
                                                    matches: match
                                                });
                                    soFar = soFar.slice( matched.length );
                                }
                            }

                            if ( !matched ) {
                                break;
                            }
                        }

                        // Return the length of the invalid excess
                        // if we're just parsing
                        // Otherwise, throw an error or return tokens
                        return parseOnly ?
                            soFar.length :
                            soFar ?
                                Sizzle.error( selector ) :
                                // Cache the tokens
                                tokenCache( selector, groups ).slice( 0 );
                    };

                    function toSelector( tokens ) {
                        var i = 0,
                            len = tokens.length,
                            selector = "";
                        for ( ; i < len; i++ ) {
                            selector += tokens[i].value;
                        }
                        return selector;
                    }

                    function addCombinator( matcher, combinator, base ) {
                        var dir = combinator.dir,
                            checkNonElements = base && dir === "parentNode",
                            doneName = done++;

                        return combinator.first ?
                            // Check against closest ancestor/preceding element
                            function( elem, context, xml ) {
                                while ( (elem = elem[ dir ]) ) {
                                    if ( elem.nodeType === 1 || checkNonElements ) {
                                        return matcher( elem, context, xml );
                                    }
                                }
                            } :

                            // Check against all ancestor/preceding elements
                            function( elem, context, xml ) {
                                var oldCache, uniqueCache, outerCache,
                                    newCache = [ dirruns, doneName ];

                                // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                                if ( xml ) {
                                    while ( (elem = elem[ dir ]) ) {
                                        if ( elem.nodeType === 1 || checkNonElements ) {
                                            if ( matcher( elem, context, xml ) ) {
                                                return true;
                                            }
                                        }
                                    }
                                } else {
                                    while ( (elem = elem[ dir ]) ) {
                                        if ( elem.nodeType === 1 || checkNonElements ) {
                                            outerCache = elem[ expando ] || (elem[ expando ] = {});

                                            // Support: IE <9 only
                                            // Defend against cloned attroperties (jQuery gh-1709)
                                            uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

                                            if ( (oldCache = uniqueCache[ dir ]) &&
                                                 oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

                                                // Assign to newCache so results back-propagate to previous elements
                                                return (newCache[ 2 ] = oldCache[ 2 ]);
                                            } else {
                                                // Reuse newcache so results back-propagate to previous elements
                                                uniqueCache[ dir ] = newCache;

                                                // A match means we're done; a fail means we have to keep checking
                                                if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
                                                    return true;
                                                }
                                            }
                                        }
                                    }
                                }
                            };
                    }

                    function elementMatcher( matchers ) {
                        return matchers.length > 1 ?
                            function( elem, context, xml ) {
                                var i = matchers.length;
                                while ( i-- ) {
                                    if ( !matchers[i]( elem, context, xml ) ) {
                                        return false;
                                    }
                                }
                                return true;
                            } :
                            matchers[0];
                    }

                    function multipleContexts( selector, contexts, results ) {
                        var i = 0,
                            len = contexts.length;
                        for ( ; i < len; i++ ) {
                            Sizzle( selector, contexts[i], results );
                        }
                        return results;
                    }

                    function condense( unmatched, map, filter, context, xml ) {
                        var elem,
                            newUnmatched = [],
                            i = 0,
                            len = unmatched.length,
                            mapped = map != null;

                        for ( ; i < len; i++ ) {
                            if ( (elem = unmatched[i]) ) {
                                if ( !filter || filter( elem, context, xml ) ) {
                                    newUnmatched.push( elem );
                                    if ( mapped ) {
                                        map.push( i );
                                    }
                                }
                            }
                        }

                        return newUnmatched;
                    }

                    function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
                        if ( postFilter && !postFilter[ expando ] ) {
                            postFilter = setMatcher( postFilter );
                        }
                        if ( postFinder && !postFinder[ expando ] ) {
                            postFinder = setMatcher( postFinder, postSelector );
                        }
                        return markFunction(function( seed, results, context, xml ) {
                            var temp, i, elem,
                                preMap = [],
                                postMap = [],
                                preexisting = results.length,

                                // Get initial elements from seed or context
                                elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

                                // Prefilter to get matcher input, preserving a map for seed-results synchronization
                                matcherIn = preFilter && ( seed || !selector ) ?
                                    condense( elems, preMap, preFilter, context, xml ) :
                                    elems,

                                matcherOut = matcher ?
                                    // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                                    postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

                                        // ...intermediate processing is necessary
                                        [] :

                                        // ...otherwise use results directly
                                        results :
                                    matcherIn;

                            // Find primary matches
                            if ( matcher ) {
                                matcher( matcherIn, matcherOut, context, xml );
                            }

                            // Apply postFilter
                            if ( postFilter ) {
                                temp = condense( matcherOut, postMap );
                                postFilter( temp, [], context, xml );

                                // Un-match failing elements by moving them back to matcherIn
                                i = temp.length;
                                while ( i-- ) {
                                    if ( (elem = temp[i]) ) {
                                        matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
                                    }
                                }
                            }

                            if ( seed ) {
                                if ( postFinder || preFilter ) {
                                    if ( postFinder ) {
                                        // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                        temp = [];
                                        i = matcherOut.length;
                                        while ( i-- ) {
                                            if ( (elem = matcherOut[i]) ) {
                                                // Restore matcherIn since elem is not yet a final match
                                                temp.push( (matcherIn[i] = elem) );
                                            }
                                        }
                                        postFinder( null, (matcherOut = []), temp, xml );
                                    }

                                    // Move matched elements from seed to results to keep them synchronized
                                    i = matcherOut.length;
                                    while ( i-- ) {
                                        if ( (elem = matcherOut[i]) &&
                                             (temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

                                            seed[temp] = !(results[temp] = elem);
                                        }
                                    }
                                }

                                // Add elements to results, through postFinder if defined
                            } else {
                                matcherOut = condense(
                                    matcherOut === results ?
                                        matcherOut.splice( preexisting, matcherOut.length ) :
                                        matcherOut
                                );
                                if ( postFinder ) {
                                    postFinder( null, results, matcherOut, xml );
                                } else {
                                    push.apply( results, matcherOut );
                                }
                            }
                        });
                    }

                    function matcherFromTokens( tokens ) {
                        var checkContext, matcher, j,
                            len = tokens.length,
                            leadingRelative = Expr.relative[ tokens[0].type ],
                            implicitRelative = leadingRelative || Expr.relative[" "],
                            i = leadingRelative ? 1 : 0,

                            // The foundational matcher ensures that elements are reachable from top-level context(s)
                            matchContext = addCombinator( function( elem ) {
                                return elem === checkContext;
                            }, implicitRelative, true ),
                            matchAnyContext = addCombinator( function( elem ) {
                                return indexOf( checkContext, elem ) > -1;
                            }, implicitRelative, true ),
                            matchers = [ function( elem, context, xml ) {
                                var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
                                    (checkContext = context).nodeType ?
                                        matchContext( elem, context, xml ) :
                                        matchAnyContext( elem, context, xml ) );
                                // Avoid hanging onto element (issue #299)
                                checkContext = null;
                                return ret;
                            } ];

                        for ( ; i < len; i++ ) {
                            if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
                                matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
                            } else {
                                matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

                                // Return special upon seeing a positional matcher
                                if ( matcher[ expando ] ) {
                                    // Find the next relative operator (if any) for proper handling
                                    j = ++i;
                                    for ( ; j < len; j++ ) {
                                        if ( Expr.relative[ tokens[j].type ] ) {
                                            break;
                                        }
                                    }
                                    return setMatcher(
                                        i > 1 && elementMatcher( matchers ),
                                        i > 1 && toSelector(
                                            // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                                            tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
                                          ).replace( rtrim, "$1" ),
                                        matcher,
                                        i < j && matcherFromTokens( tokens.slice( i, j ) ),
                                        j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
                                        j < len && toSelector( tokens )
                                    );
                                }
                                matchers.push( matcher );
                            }
                        }

                        return elementMatcher( matchers );
                    }

                    function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
                        var bySet = setMatchers.length > 0,
                            byElement = elementMatchers.length > 0,
                            superMatcher = function( seed, context, xml, results, outermost ) {
                                var elem, j, matcher,
                                    matchedCount = 0,
                                    i = "0",
                                    unmatched = seed && [],
                                    setMatched = [],
                                    contextBackup = outermostContext,
                                    // We must always have either seed elements or outermost context
                                    elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
                                    // Use integer dirruns iff this is the outermost matcher
                                    dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                                    len = elems.length;

                                if ( outermost ) {
                                    outermostContext = context === document || context || outermost;
                                }

                                // Add elements passing elementMatchers directly to results
                                // Support: IE<9, Safari
                                // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                                for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
                                    if ( byElement && elem ) {
                                        j = 0;
                                        if ( !context && elem.ownerDocument !== document ) {
                                            setDocument( elem );
                                            xml = !documentIsHTML;
                                        }
                                        while ( (matcher = elementMatchers[j++]) ) {
                                            if ( matcher( elem, context || document, xml) ) {
                                                results.push( elem );
                                                break;
                                            }
                                        }
                                        if ( outermost ) {
                                            dirruns = dirrunsUnique;
                                        }
                                    }

                                    // Track unmatched elements for set filters
                                    if ( bySet ) {
                                        // They will have gone through all possible matchers
                                        if ( (elem = !matcher && elem) ) {
                                            matchedCount--;
                                        }

                                        // Lengthen the array for every element, matched or not
                                        if ( seed ) {
                                            unmatched.push( elem );
                                        }
                                    }
                                }

                                // `i` is now the count of elements visited above, and adding it to `matchedCount`
                                // makes the latter nonnegative.
                                matchedCount += i;

                                // Apply set filters to unmatched elements
                                // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
                                // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
                                // no element matchers and no seed.
                                // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
                                // case, which will result in a "00" `matchedCount` that differs from `i` but is also
                                // numerically zero.
                                if ( bySet && i !== matchedCount ) {
                                    j = 0;
                                    while ( (matcher = setMatchers[j++]) ) {
                                        matcher( unmatched, setMatched, context, xml );
                                    }

                                    if ( seed ) {
                                        // Reintegrate element matches to eliminate the need for sorting
                                        if ( matchedCount > 0 ) {
                                            while ( i-- ) {
                                                if ( !(unmatched[i] || setMatched[i]) ) {
                                                    setMatched[i] = pop.call( results );
                                                }
                                            }
                                        }

                                        // Discard index placeholder values to get only actual matches
                                        setMatched = condense( setMatched );
                                    }

                                    // Add matches to results
                                    push.apply( results, setMatched );

                                    // Seedless set matches succeeding multiple successful matchers stipulate sorting
                                    if ( outermost && !seed && setMatched.length > 0 &&
                                         ( matchedCount + setMatchers.length ) > 1 ) {

                                        Sizzle.uniqueSort( results );
                                    }
                                }

                                // Override manipulation of globals by nested matchers
                                if ( outermost ) {
                                    dirruns = dirrunsUnique;
                                    outermostContext = contextBackup;
                                }

                                return unmatched;
                            };

                        return bySet ?
                            markFunction( superMatcher ) :
                            superMatcher;
                    }

                    compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
                        var i,
                            setMatchers = [],
                            elementMatchers = [],
                            cached = compilerCache[ selector + " " ];

                        if ( !cached ) {
                            // Generate a function of recursive functions that can be used to check each element
                            if ( !match ) {
                                match = tokenize( selector );
                            }
                            i = match.length;
                            while ( i-- ) {
                                cached = matcherFromTokens( match[i] );
                                if ( cached[ expando ] ) {
                                    setMatchers.push( cached );
                                } else {
                                    elementMatchers.push( cached );
                                }
                            }

                            // Cache the compiled function
                            cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

                            // Save selector and tokenization
                            cached.selector = selector;
                        }
                        return cached;
                    };

                    /**
                     * A low-level selection function that works with Sizzle's compiled
                     *  selector functions
                     * @param {String|Function} selector A selector or a pre-compiled
                     *  selector function built with Sizzle.compile
                     * @param {Element} context
                     * @param {Array} [results]
                     * @param {Array} [seed] A set of elements to match against
                     */
                    select = Sizzle.select = function( selector, context, results, seed ) {
                        var i, tokens, token, type, find,
                            compiled = typeof selector === "function" && selector,
                            match = !seed && tokenize( (selector = compiled.selector || selector) );

                        results = results || [];

                        // Try to minimize operations if there is only one selector in the list and no seed
                        // (the latter of which guarantees us context)
                        if ( match.length === 1 ) {

                            // Reduce context if the leading compound selector is an ID
                            tokens = match[0] = match[0].slice( 0 );
                            if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                                 support.getById && context.nodeType === 9 && documentIsHTML &&
                                 Expr.relative[ tokens[1].type ] ) {

                                context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
                                if ( !context ) {
                                    return results;

                                    // Precompiled matchers will still verify ancestry, so step up a level
                                } else if ( compiled ) {
                                    context = context.parentNode;
                                }

                                selector = selector.slice( tokens.shift().value.length );
                            }

                            // Fetch a seed set for right-to-left matching
                            i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
                            while ( i-- ) {
                                token = tokens[i];

                                // Abort if we hit a combinator
                                if ( Expr.relative[ (type = token.type) ] ) {
                                    break;
                                }
                                if ( (find = Expr.find[ type ]) ) {
                                    // Search, expanding context for leading sibling combinators
                                    if ( (seed = find(
                                        token.matches[0].replace( runescape, funescape ),
                                        rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
                                    )) ) {

                                        // If seed is empty or no tokens remain, we can return early
                                        tokens.splice( i, 1 );
                                        selector = seed.length && toSelector( tokens );
                                        if ( !selector ) {
                                            push.apply( results, seed );
                                            return results;
                                        }

                                        break;
                                    }
                                }
                            }
                        }

                        // Compile and execute a filtering function if one is not provided
                        // Provide `match` to avoid retokenization if we modified the selector above
                        ( compiled || compile( selector, match ) )(
                            seed,
                            context,
                            !documentIsHTML,
                            results,
                            !context || rsibling.test( selector ) && testContext( context.parentNode ) || context
                        );
                        return results;
                    };

// One-time assignments

// Sort stability
                    support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
                    support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
                    setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
                    support.sortDetached = assert(function( div1 ) {
                        // Should return 1, but returns 4 (following)
                        return div1.compareDocumentPosition( document.createElement("div") ) & 1;
                    });

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
                    if ( !assert(function( div ) {
                        div.innerHTML = "<a href='#'></a>";
                        return div.firstChild.getAttribute("href") === "#" ;
                    }) ) {
                        addHandle( "type|href|height|width", function( elem, name, isXML ) {
                            if ( !isXML ) {
                                return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
                            }
                        });
                    }

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
                    if ( !support.attributes || !assert(function( div ) {
                        div.innerHTML = "<input/>";
                        div.firstChild.setAttribute( "value", "" );
                        return div.firstChild.getAttribute( "value" ) === "";
                    }) ) {
                        addHandle( "value", function( elem, name, isXML ) {
                            if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
                                return elem.defaultValue;
                            }
                        });
                    }

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
                    if ( !assert(function( div ) {
                        return div.getAttribute("disabled") == null;
                    }) ) {
                        addHandle( booleans, function( elem, name, isXML ) {
                            var val;
                            if ( !isXML ) {
                                return elem[ name ] === true ? name.toLowerCase() :
                                    (val = elem.getAttributeNode( name )) && val.specified ?
                                        val.value :
                                        null;
                            }
                        });
                    }

                    return Sizzle;

                })( window );



            jQuery.find = Sizzle;
            jQuery.expr = Sizzle.selectors;
            jQuery.expr[ ":" ] = jQuery.expr.pseudos;
            jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
            jQuery.text = Sizzle.getText;
            jQuery.isXMLDoc = Sizzle.isXML;
            jQuery.contains = Sizzle.contains;



            var dir = function( elem, dir, until ) {
                var matched = [],
                    truncate = until !== undefined;

                while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
                    if ( elem.nodeType === 1 ) {
                        if ( truncate && jQuery( elem ).is( until ) ) {
                            break;
                        }
                        matched.push( elem );
                    }
                }
                return matched;
            };


            var siblings = function( n, elem ) {
                var matched = [];

                for ( ; n; n = n.nextSibling ) {
                    if ( n.nodeType === 1 && n !== elem ) {
                        matched.push( n );
                    }
                }

                return matched;
            };


            var rneedsContext = jQuery.expr.match.needsContext;

            var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );



            var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
            function winnow( elements, qualifier, not ) {
                if ( jQuery.isFunction( qualifier ) ) {
                    return jQuery.grep( elements, function( elem, i ) {
                        /* jshint -W018 */
                        return !!qualifier.call( elem, i, elem ) !== not;
                    } );

                }

                if ( qualifier.nodeType ) {
                    return jQuery.grep( elements, function( elem ) {
                        return ( elem === qualifier ) !== not;
                    } );

                }

                if ( typeof qualifier === "string" ) {
                    if ( risSimple.test( qualifier ) ) {
                        return jQuery.filter( qualifier, elements, not );
                    }

                    qualifier = jQuery.filter( qualifier, elements );
                }

                return jQuery.grep( elements, function( elem ) {
                    return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
                } );
            }

            jQuery.filter = function( expr, elems, not ) {
                var elem = elems[ 0 ];

                if ( not ) {
                    expr = ":not(" + expr + ")";
                }

                return elems.length === 1 && elem.nodeType === 1 ?
                    jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
                    jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
                        return elem.nodeType === 1;
                    } ) );
            };

            jQuery.fn.extend( {
                                  find: function( selector ) {
                                      var i,
                                          len = this.length,
                                          ret = [],
                                          self = this;

                                      if ( typeof selector !== "string" ) {
                                          return this.pushStack( jQuery( selector ).filter( function() {
                                              for ( i = 0; i < len; i++ ) {
                                                  if ( jQuery.contains( self[ i ], this ) ) {
                                                      return true;
                                                  }
                                              }
                                          } ) );
                                      }

                                      for ( i = 0; i < len; i++ ) {
                                          jQuery.find( selector, self[ i ], ret );
                                      }

                                      // Needed because $( selector, context ) becomes $( context ).find( selector )
                                      ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
                                      ret.selector = this.selector ? this.selector + " " + selector : selector;
                                      return ret;
                                  },
                                  filter: function( selector ) {
                                      return this.pushStack( winnow( this, selector || [], false ) );
                                  },
                                  not: function( selector ) {
                                      return this.pushStack( winnow( this, selector || [], true ) );
                                  },
                                  is: function( selector ) {
                                      return !!winnow(
                                          this,

                                          // If this is a positional/relative selector, check membership in the returned set
                                          // so $("p:first").is("p:last") won't return true for a doc with two "p".
                                          typeof selector === "string" && rneedsContext.test( selector ) ?
                                              jQuery( selector ) :
                                              selector || [],
                                          false
                                      ).length;
                                  }
                              } );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
            var rootjQuery,

                // A simple way to check for HTML strings
                // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
                // Strict HTML recognition (#11290: must start with <)
                rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

                init = jQuery.fn.init = function( selector, context, root ) {
                    var match, elem;

                    // HANDLE: $(""), $(null), $(undefined), $(false)
                    if ( !selector ) {
                        return this;
                    }

                    // Method init() accepts an alternate rootjQuery
                    // so migrate can support jQuery.sub (gh-2101)
                    root = root || rootjQuery;

                    // Handle HTML strings
                    if ( typeof selector === "string" ) {
                        if ( selector[ 0 ] === "<" &&
                             selector[ selector.length - 1 ] === ">" &&
                             selector.length >= 3 ) {

                            // Assume that strings that start and end with <> are HTML and skip the regex check
                            match = [ null, selector, null ];

                        } else {
                            match = rquickExpr.exec( selector );
                        }

                        // Match html or make sure no context is specified for #id
                        if ( match && ( match[ 1 ] || !context ) ) {

                            // HANDLE: $(html) -> $(array)
                            if ( match[ 1 ] ) {
                                context = context instanceof jQuery ? context[ 0 ] : context;

                                // Option to run scripts is true for back-compat
                                // Intentionally let the error be thrown if parseHTML is not present
                                jQuery.merge( this, jQuery.parseHTML(
                                    match[ 1 ],
                                    context && context.nodeType ? context.ownerDocument || context : document,
                                    true
                                ) );

                                // HANDLE: $(html, props)
                                if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
                                    for ( match in context ) {

                                        // Properties of context are called as methods if possible
                                        if ( jQuery.isFunction( this[ match ] ) ) {
                                            this[ match ]( context[ match ] );

                                            // ...and otherwise set as attributes
                                        } else {
                                            this.attr( match, context[ match ] );
                                        }
                                    }
                                }

                                return this;

                                // HANDLE: $(#id)
                            } else {
                                elem = document.getElementById( match[ 2 ] );

                                // Support: Blackberry 4.6
                                // gEBID returns nodes no longer in the document (#6963)
                                if ( elem && elem.parentNode ) {

                                    // Inject the element directly into the jQuery object
                                    this.length = 1;
                                    this[ 0 ] = elem;
                                }

                                this.context = document;
                                this.selector = selector;
                                return this;
                            }

                            // HANDLE: $(expr, $(...))
                        } else if ( !context || context.jquery ) {
                            return ( context || root ).find( selector );

                            // HANDLE: $(expr, context)
                            // (which is just equivalent to: $(context).find(expr)
                        } else {
                            return this.constructor( context ).find( selector );
                        }

                        // HANDLE: $(DOMElement)
                    } else if ( selector.nodeType ) {
                        this.context = this[ 0 ] = selector;
                        this.length = 1;
                        return this;

                        // HANDLE: $(function)
                        // Shortcut for document ready
                    } else if ( jQuery.isFunction( selector ) ) {
                        return root.ready !== undefined ?
                            root.ready( selector ) :

                            // Execute immediately if ready is not present
                            selector( jQuery );
                    }

                    if ( selector.selector !== undefined ) {
                        this.selector = selector.selector;
                        this.context = selector.context;
                    }

                    return jQuery.makeArray( selector, this );
                };

// Give the init function the jQuery prototype for later instantiation
            init.prototype = jQuery.fn;

// Initialize central reference
            rootjQuery = jQuery( document );


            var rparentsprev = /^(?:parents|prev(?:Until|All))/,

                // Methods guaranteed to produce a unique set when starting from a unique set
                guaranteedUnique = {
                    children: true,
                    contents: true,
                    next: true,
                    prev: true
                };

            jQuery.fn.extend( {
                                  has: function( target ) {
                                      var targets = jQuery( target, this ),
                                          l = targets.length;

                                      return this.filter( function() {
                                          var i = 0;
                                          for ( ; i < l; i++ ) {
                                              if ( jQuery.contains( this, targets[ i ] ) ) {
                                                  return true;
                                              }
                                          }
                                      } );
                                  },

                                  closest: function( selectors, context ) {
                                      var cur,
                                          i = 0,
                                          l = this.length,
                                          matched = [],
                                          pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
                                              jQuery( selectors, context || this.context ) :
                                              0;

                                      for ( ; i < l; i++ ) {
                                          for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

                                              // Always skip document fragments
                                              if ( cur.nodeType < 11 && ( pos ?
                                                  pos.index( cur ) > -1 :

                                                  // Don't pass non-elements to Sizzle
                                                   cur.nodeType === 1 &&
                                                   jQuery.find.matchesSelector( cur, selectors ) ) ) {

                                                  matched.push( cur );
                                                  break;
                                              }
                                          }
                                      }

                                      return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
                                  },

                                  // Determine the position of an element within the set
                                  index: function( elem ) {

                                      // No argument, return index in parent
                                      if ( !elem ) {
                                          return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
                                      }

                                      // Index in selector
                                      if ( typeof elem === "string" ) {
                                          return indexOf.call( jQuery( elem ), this[ 0 ] );
                                      }

                                      // Locate the position of the desired element
                                      return indexOf.call( this,

                                                           // If it receives a jQuery object, the first element is used
                                                           elem.jquery ? elem[ 0 ] : elem
                                      );
                                  },

                                  add: function( selector, context ) {
                                      return this.pushStack(
                                          jQuery.uniqueSort(
                                              jQuery.merge( this.get(), jQuery( selector, context ) )
                                          )
                                      );
                                  },

                                  addBack: function( selector ) {
                                      return this.add( selector == null ?
                                                           this.prevObject : this.prevObject.filter( selector )
                                      );
                                  }
                              } );

            function sibling( cur, dir ) {
                while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
                return cur;
            }

            jQuery.each( {
                             parent: function( elem ) {
                                 var parent = elem.parentNode;
                                 return parent && parent.nodeType !== 11 ? parent : null;
                             },
                             parents: function( elem ) {
                                 return dir( elem, "parentNode" );
                             },
                             parentsUntil: function( elem, i, until ) {
                                 return dir( elem, "parentNode", until );
                             },
                             next: function( elem ) {
                                 return sibling( elem, "nextSibling" );
                             },
                             prev: function( elem ) {
                                 return sibling( elem, "previousSibling" );
                             },
                             nextAll: function( elem ) {
                                 return dir( elem, "nextSibling" );
                             },
                             prevAll: function( elem ) {
                                 return dir( elem, "previousSibling" );
                             },
                             nextUntil: function( elem, i, until ) {
                                 return dir( elem, "nextSibling", until );
                             },
                             prevUntil: function( elem, i, until ) {
                                 return dir( elem, "previousSibling", until );
                             },
                             siblings: function( elem ) {
                                 return siblings( ( elem.parentNode || {} ).firstChild, elem );
                             },
                             children: function( elem ) {
                                 return siblings( elem.firstChild );
                             },
                             contents: function( elem ) {
                                 return elem.contentDocument || jQuery.merge( [], elem.childNodes );
                             }
                         }, function( name, fn ) {
                jQuery.fn[ name ] = function( until, selector ) {
                    var matched = jQuery.map( this, fn, until );

                    if ( name.slice( -5 ) !== "Until" ) {
                        selector = until;
                    }

                    if ( selector && typeof selector === "string" ) {
                        matched = jQuery.filter( selector, matched );
                    }

                    if ( this.length > 1 ) {

                        // Remove duplicates
                        if ( !guaranteedUnique[ name ] ) {
                            jQuery.uniqueSort( matched );
                        }

                        // Reverse order for parents* and prev-derivatives
                        if ( rparentsprev.test( name ) ) {
                            matched.reverse();
                        }
                    }

                    return this.pushStack( matched );
                };
            } );
            var rnotwhite = ( /\S+/g );



// Convert String-formatted options into Object-formatted ones
            function createOptions( options ) {
                var object = {};
                jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
                    object[ flag ] = true;
                } );
                return object;
            }

            /*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
            jQuery.Callbacks = function( options ) {

                // Convert options from String-formatted to Object-formatted if needed
                // (we check in cache first)
                options = typeof options === "string" ?
                    createOptions( options ) :
                    jQuery.extend( {}, options );

                var // Flag to know if list is currently firing
                    firing,

                    // Last fire value for non-forgettable lists
                    memory,

                    // Flag to know if list was already fired
                    fired,

                    // Flag to prevent firing
                    locked,

                    // Actual callback list
                    list = [],

                    // Queue of execution data for repeatable lists
                    queue = [],

                    // Index of currently firing callback (modified by add/remove as needed)
                    firingIndex = -1,

                    // Fire callbacks
                    fire = function() {

                        // Enforce single-firing
                        locked = options.once;

                        // Execute callbacks for all pending executions,
                        // respecting firingIndex overrides and runtime changes
                        fired = firing = true;
                        for ( ; queue.length; firingIndex = -1 ) {
                            memory = queue.shift();
                            while ( ++firingIndex < list.length ) {

                                // Run callback and check for early termination
                                if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
                                     options.stopOnFalse ) {

                                    // Jump to end and forget the data so .add doesn't re-fire
                                    firingIndex = list.length;
                                    memory = false;
                                }
                            }
                        }

                        // Forget the data if we're done with it
                        if ( !options.memory ) {
                            memory = false;
                        }

                        firing = false;

                        // Clean up if we're done firing for good
                        if ( locked ) {

                            // Keep an empty list if we have data for future add calls
                            if ( memory ) {
                                list = [];

                                // Otherwise, this object is spent
                            } else {
                                list = "";
                            }
                        }
                    },

                    // Actual Callbacks object
                    self = {

                        // Add a callback or a collection of callbacks to the list
                        add: function() {
                            if ( list ) {

                                // If we have memory from a past run, we should fire after adding
                                if ( memory && !firing ) {
                                    firingIndex = list.length - 1;
                                    queue.push( memory );
                                }

                                ( function add( args ) {
                                    jQuery.each( args, function( _, arg ) {
                                        if ( jQuery.isFunction( arg ) ) {
                                            if ( !options.unique || !self.has( arg ) ) {
                                                list.push( arg );
                                            }
                                        } else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

                                            // Inspect recursively
                                            add( arg );
                                        }
                                    } );
                                } )( arguments );

                                if ( memory && !firing ) {
                                    fire();
                                }
                            }
                            return this;
                        },

                        // Remove a callback from the list
                        remove: function() {
                            jQuery.each( arguments, function( _, arg ) {
                                var index;
                                while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
                                    list.splice( index, 1 );

                                    // Handle firing indexes
                                    if ( index <= firingIndex ) {
                                        firingIndex--;
                                    }
                                }
                            } );
                            return this;
                        },

                        // Check if a given callback is in the list.
                        // If no argument is given, return whether or not list has callbacks attached.
                        has: function( fn ) {
                            return fn ?
                                jQuery.inArray( fn, list ) > -1 :
                                list.length > 0;
                        },

                        // Remove all callbacks from the list
                        empty: function() {
                            if ( list ) {
                                list = [];
                            }
                            return this;
                        },

                        // Disable .fire and .add
                        // Abort any current/pending executions
                        // Clear all callbacks and values
                        disable: function() {
                            locked = queue = [];
                            list = memory = "";
                            return this;
                        },
                        disabled: function() {
                            return !list;
                        },

                        // Disable .fire
                        // Also disable .add unless we have memory (since it would have no effect)
                        // Abort any pending executions
                        lock: function() {
                            locked = queue = [];
                            if ( !memory ) {
                                list = memory = "";
                            }
                            return this;
                        },
                        locked: function() {
                            return !!locked;
                        },

                        // Call all callbacks with the given context and arguments
                        fireWith: function( context, args ) {
                            if ( !locked ) {
                                args = args || [];
                                args = [ context, args.slice ? args.slice() : args ];
                                queue.push( args );
                                if ( !firing ) {
                                    fire();
                                }
                            }
                            return this;
                        },

                        // Call all the callbacks with the given arguments
                        fire: function() {
                            self.fireWith( this, arguments );
                            return this;
                        },

                        // To know if the callbacks have already been called at least once
                        fired: function() {
                            return !!fired;
                        }
                    };

                return self;
            };


            jQuery.extend( {

                               Deferred: function( func ) {
                                   var tuples = [

                                           // action, add listener, listener list, final state
                                           [ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
                                           [ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
                                           [ "notify", "progress", jQuery.Callbacks( "memory" ) ]
                                       ],
                                       state = "pending",
                                       promise = {
                                           state: function() {
                                               return state;
                                           },
                                           always: function() {
                                               deferred.done( arguments ).fail( arguments );
                                               return this;
                                           },
                                           then: function( /* fnDone, fnFail, fnProgress */ ) {
                                               var fns = arguments;
                                               return jQuery.Deferred( function( newDefer ) {
                                                   jQuery.each( tuples, function( i, tuple ) {
                                                       var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];

                                                       // deferred[ done | fail | progress ] for forwarding actions to newDefer
                                                       deferred[ tuple[ 1 ] ]( function() {
                                                           var returned = fn && fn.apply( this, arguments );
                                                           if ( returned && jQuery.isFunction( returned.promise ) ) {
                                                               returned.promise()
                                                                   .progress( newDefer.notify )
                                                                   .done( newDefer.resolve )
                                                                   .fail( newDefer.reject );
                                                           } else {
                                                               newDefer[ tuple[ 0 ] + "With" ](
                                                                   this === promise ? newDefer.promise() : this,
                                                                   fn ? [ returned ] : arguments
                                                               );
                                                           }
                                                       } );
                                                   } );
                                                   fns = null;
                                               } ).promise();
                                           },

                                           // Get a promise for this deferred
                                           // If obj is provided, the promise aspect is added to the object
                                           promise: function( obj ) {
                                               return obj != null ? jQuery.extend( obj, promise ) : promise;
                                           }
                                       },
                                       deferred = {};

                                   // Keep pipe for back-compat
                                   promise.pipe = promise.then;

                                   // Add list-specific methods
                                   jQuery.each( tuples, function( i, tuple ) {
                                       var list = tuple[ 2 ],
                                           stateString = tuple[ 3 ];

                                       // promise[ done | fail | progress ] = list.add
                                       promise[ tuple[ 1 ] ] = list.add;

                                       // Handle state
                                       if ( stateString ) {
                                           list.add( function() {

                                               // state = [ resolved | rejected ]
                                               state = stateString;

                                               // [ reject_list | resolve_list ].disable; progress_list.lock
                                           }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
                                       }

                                       // deferred[ resolve | reject | notify ]
                                       deferred[ tuple[ 0 ] ] = function() {
                                           deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
                                           return this;
                                       };
                                       deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
                                   } );

                                   // Make the deferred a promise
                                   promise.promise( deferred );

                                   // Call given func if any
                                   if ( func ) {
                                       func.call( deferred, deferred );
                                   }

                                   // All done!
                                   return deferred;
                               },

                               // Deferred helper
                               when: function( subordinate /* , ..., subordinateN */ ) {
                                   var i = 0,
                                       resolveValues = slice.call( arguments ),
                                       length = resolveValues.length,

                                       // the count of uncompleted subordinates
                                       remaining = length !== 1 ||
                                                   ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

                                       // the master Deferred.
                                       // If resolveValues consist of only a single Deferred, just use that.
                                       deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

                                       // Update function for both resolve and progress values
                                       updateFunc = function( i, contexts, values ) {
                                           return function( value ) {
                                               contexts[ i ] = this;
                                               values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
                                               if ( values === progressValues ) {
                                                   deferred.notifyWith( contexts, values );
                                               } else if ( !( --remaining ) ) {
                                                   deferred.resolveWith( contexts, values );
                                               }
                                           };
                                       },

                                       progressValues, progressContexts, resolveContexts;

                                   // Add listeners to Deferred subordinates; treat others as resolved
                                   if ( length > 1 ) {
                                       progressValues = new Array( length );
                                       progressContexts = new Array( length );
                                       resolveContexts = new Array( length );
                                       for ( ; i < length; i++ ) {
                                           if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
                                               resolveValues[ i ].promise()
                                                   .progress( updateFunc( i, progressContexts, progressValues ) )
                                                   .done( updateFunc( i, resolveContexts, resolveValues ) )
                                                   .fail( deferred.reject );
                                           } else {
                                               --remaining;
                                           }
                                       }
                                   }

                                   // If we're not waiting on anything, resolve the master
                                   if ( !remaining ) {
                                       deferred.resolveWith( resolveContexts, resolveValues );
                                   }

                                   return deferred.promise();
                               }
                           } );


// The deferred used on DOM ready
            var readyList;

            jQuery.fn.ready = function( fn ) {

                // Add the callback
                jQuery.ready.promise().done( fn );

                return this;
            };

            jQuery.extend( {

                               // Is the DOM ready to be used? Set to true once it occurs.
                               isReady: false,

                               // A counter to track how many items to wait for before
                               // the ready event fires. See #6781
                               readyWait: 1,

                               // Hold (or release) the ready event
                               holdReady: function( hold ) {
                                   if ( hold ) {
                                       jQuery.readyWait++;
                                   } else {
                                       jQuery.ready( true );
                                   }
                               },

                               // Handle when the DOM is ready
                               ready: function( wait ) {

                                   // Abort if there are pending holds or we're already ready
                                   if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
                                       return;
                                   }

                                   // Remember that the DOM is ready
                                   jQuery.isReady = true;

                                   // If a normal DOM Ready event fired, decrement, and wait if need be
                                   if ( wait !== true && --jQuery.readyWait > 0 ) {
                                       return;
                                   }

                                   // If there are functions bound, to execute
                                   readyList.resolveWith( document, [ jQuery ] );

                                   // Trigger any bound ready events
                                   if ( jQuery.fn.triggerHandler ) {
                                       jQuery( document ).triggerHandler( "ready" );
                                       jQuery( document ).off( "ready" );
                                   }
                               }
                           } );

            /**
             * The ready event handler and self cleanup method
             */
            function completed() {
                document.removeEventListener( "DOMContentLoaded", completed );
                window.removeEventListener( "load", completed );
                jQuery.ready();
            }

            jQuery.ready.promise = function( obj ) {
                if ( !readyList ) {

                    readyList = jQuery.Deferred();

                    // Catch cases where $(document).ready() is called
                    // after the browser event has already occurred.
                    // Support: IE9-10 only
                    // Older IE sometimes signals "interactive" too soon
                    if ( document.readyState === "complete" ||
                         ( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

                        // Handle it asynchronously to allow scripts the opportunity to delay ready
                        window.setTimeout( jQuery.ready );

                    } else {

                        // Use the handy event callback
                        document.addEventListener( "DOMContentLoaded", completed );

                        // A fallback to window.onload, that will always work
                        window.addEventListener( "load", completed );
                    }
                }
                return readyList.promise( obj );
            };

// Kick off the DOM ready check even if the user does not
            jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
            var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
                var i = 0,
                    len = elems.length,
                    bulk = key == null;

                // Sets many values
                if ( jQuery.type( key ) === "object" ) {
                    chainable = true;
                    for ( i in key ) {
                        access( elems, fn, i, key[ i ], true, emptyGet, raw );
                    }

                    // Sets one value
                } else if ( value !== undefined ) {
                    chainable = true;

                    if ( !jQuery.isFunction( value ) ) {
                        raw = true;
                    }

                    if ( bulk ) {

                        // Bulk operations run against the entire set
                        if ( raw ) {
                            fn.call( elems, value );
                            fn = null;

                            // ...except when executing function values
                        } else {
                            bulk = fn;
                            fn = function( elem, key, value ) {
                                return bulk.call( jQuery( elem ), value );
                            };
                        }
                    }

                    if ( fn ) {
                        for ( ; i < len; i++ ) {
                            fn(
                                elems[ i ], key, raw ?
                                    value :
                                    value.call( elems[ i ], i, fn( elems[ i ], key ) )
                            );
                        }
                    }
                }

                return chainable ?
                    elems :

                    // Gets
                    bulk ?
                        fn.call( elems ) :
                        len ? fn( elems[ 0 ], key ) : emptyGet;
            };
            var acceptData = function( owner ) {

                // Accepts only:
                //  - Node
                //    - Node.ELEMENT_NODE
                //    - Node.DOCUMENT_NODE
                //  - Object
                //    - Any
                /* jshint -W018 */
                return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
            };




            function Data() {
                this.expando = jQuery.expando + Data.uid++;
            }

            Data.uid = 1;

            Data.prototype = {

                register: function( owner, initial ) {
                    var value = initial || {};

                    // If it is a node unlikely to be stringify-ed or looped over
                    // use plain assignment
                    if ( owner.nodeType ) {
                        owner[ this.expando ] = value;

                        // Otherwise secure it in a non-enumerable, non-writable property
                        // configurability must be true to allow the property to be
                        // deleted with the delete operator
                    } else {
                        Object.defineProperty( owner, this.expando, {
                            value: value,
                            writable: true,
                            configurable: true
                        } );
                    }
                    return owner[ this.expando ];
                },
                cache: function( owner ) {

                    // We can accept data for non-element nodes in modern browsers,
                    // but we should not, see #8335.
                    // Always return an empty object.
                    if ( !acceptData( owner ) ) {
                        return {};
                    }

                    // Check if the owner object already has a cache
                    var value = owner[ this.expando ];

                    // If not, create one
                    if ( !value ) {
                        value = {};

                        // We can accept data for non-element nodes in modern browsers,
                        // but we should not, see #8335.
                        // Always return an empty object.
                        if ( acceptData( owner ) ) {

                            // If it is a node unlikely to be stringify-ed or looped over
                            // use plain assignment
                            if ( owner.nodeType ) {
                                owner[ this.expando ] = value;

                                // Otherwise secure it in a non-enumerable property
                                // configurable must be true to allow the property to be
                                // deleted when data is removed
                            } else {
                                Object.defineProperty( owner, this.expando, {
                                    value: value,
                                    configurable: true
                                } );
                            }
                        }
                    }

                    return value;
                },
                set: function( owner, data, value ) {
                    var prop,
                        cache = this.cache( owner );

                    // Handle: [ owner, key, value ] args
                    if ( typeof data === "string" ) {
                        cache[ data ] = value;

                        // Handle: [ owner, { properties } ] args
                    } else {

                        // Copy the properties one-by-one to the cache object
                        for ( prop in data ) {
                            cache[ prop ] = data[ prop ];
                        }
                    }
                    return cache;
                },
                get: function( owner, key ) {
                    return key === undefined ?
                        this.cache( owner ) :
                        owner[ this.expando ] && owner[ this.expando ][ key ];
                },
                access: function( owner, key, value ) {
                    var stored;

                    // In cases where either:
                    //
                    //   1. No key was specified
                    //   2. A string key was specified, but no value provided
                    //
                    // Take the "read" path and allow the get method to determine
                    // which value to return, respectively either:
                    //
                    //   1. The entire cache object
                    //   2. The data stored at the key
                    //
                    if ( key === undefined ||
                         ( ( key && typeof key === "string" ) && value === undefined ) ) {

                        stored = this.get( owner, key );

                        return stored !== undefined ?
                            stored : this.get( owner, jQuery.camelCase( key ) );
                    }

                    // When the key is not a string, or both a key and value
                    // are specified, set or extend (existing objects) with either:
                    //
                    //   1. An object of properties
                    //   2. A key and value
                    //
                    this.set( owner, key, value );

                    // Since the "set" path can have two possible entry points
                    // return the expected data based on which path was taken[*]
                    return value !== undefined ? value : key;
                },
                remove: function( owner, key ) {
                    var i, name, camel,
                        cache = owner[ this.expando ];

                    if ( cache === undefined ) {
                        return;
                    }

                    if ( key === undefined ) {
                        this.register( owner );

                    } else {

                        // Support array or space separated string of keys
                        if ( jQuery.isArray( key ) ) {

                            // If "name" is an array of keys...
                            // When data is initially created, via ("key", "val") signature,
                            // keys will be converted to camelCase.
                            // Since there is no way to tell _how_ a key was added, remove
                            // both plain key and camelCase key. #12786
                            // This will only penalize the array argument path.
                            name = key.concat( key.map( jQuery.camelCase ) );
                        } else {
                            camel = jQuery.camelCase( key );

                            // Try the string as a key before any manipulation
                            if ( key in cache ) {
                                name = [ key, camel ];
                            } else {

                                // If a key with the spaces exists, use it.
                                // Otherwise, create an array by matching non-whitespace
                                name = camel;
                                name = name in cache ?
                                    [ name ] : ( name.match( rnotwhite ) || [] );
                            }
                        }

                        i = name.length;

                        while ( i-- ) {
                            delete cache[ name[ i ] ];
                        }
                    }

                    // Remove the expando if there's no more data
                    if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

                        // Support: Chrome <= 35-45+
                        // Webkit & Blink performance suffers when deleting properties
                        // from DOM nodes, so set to undefined instead
                        // https://code.google.com/p/chromium/issues/detail?id=378607
                        if ( owner.nodeType ) {
                            owner[ this.expando ] = undefined;
                        } else {
                            delete owner[ this.expando ];
                        }
                    }
                },
                hasData: function( owner ) {
                    var cache = owner[ this.expando ];
                    return cache !== undefined && !jQuery.isEmptyObject( cache );
                }
            };
            var dataPriv = new Data();

            var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

            var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
                rmultiDash = /[A-Z]/g;

            function dataAttr( elem, key, data ) {
                var name;

                // If nothing was found internally, try to fetch any
                // data from the HTML5 data-* attribute
                if ( data === undefined && elem.nodeType === 1 ) {
                    name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
                    data = elem.getAttribute( name );

                    if ( typeof data === "string" ) {
                        try {
                            data = data === "true" ? true :
                                data === "false" ? false :
                                    data === "null" ? null :

                                        // Only convert to a number if it doesn't change the string
                                        +data + "" === data ? +data :
                                            rbrace.test( data ) ? jQuery.parseJSON( data ) :
                                                data;
                        } catch ( e ) {}

                        // Make sure we set the data so it isn't changed later
                        dataUser.set( elem, key, data );
                    } else {
                        data = undefined;
                    }
                }
                return data;
            }

            jQuery.extend( {
                               hasData: function( elem ) {
                                   return dataUser.hasData( elem ) || dataPriv.hasData( elem );
                               },

                               data: function( elem, name, data ) {
                                   return dataUser.access( elem, name, data );
                               },

                               removeData: function( elem, name ) {
                                   dataUser.remove( elem, name );
                               },

                               // TODO: Now that all calls to _data and _removeData have been replaced
                               // with direct calls to dataPriv methods, these can be deprecated.
                               _data: function( elem, name, data ) {
                                   return dataPriv.access( elem, name, data );
                               },

                               _removeData: function( elem, name ) {
                                   dataPriv.remove( elem, name );
                               }
                           } );

            jQuery.fn.extend( {
                                  data: function( key, value ) {
                                      var i, name, data,
                                          elem = this[ 0 ],
                                          attrs = elem && elem.attributes;

                                      // Gets all values
                                      if ( key === undefined ) {
                                          if ( this.length ) {
                                              data = dataUser.get( elem );

                                              if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
                                                  i = attrs.length;
                                                  while ( i-- ) {

                                                      // Support: IE11+
                                                      // The attrs elements can be null (#14894)
                                                      if ( attrs[ i ] ) {
                                                          name = attrs[ i ].name;
                                                          if ( name.indexOf( "data-" ) === 0 ) {
                                                              name = jQuery.camelCase( name.slice( 5 ) );
                                                              dataAttr( elem, name, data[ name ] );
                                                          }
                                                      }
                                                  }
                                                  dataPriv.set( elem, "hasDataAttrs", true );
                                              }
                                          }

                                          return data;
                                      }

                                      // Sets multiple values
                                      if ( typeof key === "object" ) {
                                          return this.each( function() {
                                              dataUser.set( this, key );
                                          } );
                                      }

                                      return access( this, function( value ) {
                                          var data, camelKey;

                                          // The calling jQuery object (element matches) is not empty
                                          // (and therefore has an element appears at this[ 0 ]) and the
                                          // `value` parameter was not undefined. An empty jQuery object
                                          // will result in `undefined` for elem = this[ 0 ] which will
                                          // throw an exception if an attempt to read a data cache is made.
                                          if ( elem && value === undefined ) {

                                              // Attempt to get data from the cache
                                              // with the key as-is
                                              data = dataUser.get( elem, key ) ||

                                                     // Try to find dashed key if it exists (gh-2779)
                                                     // This is for 2.2.x only
                                                     dataUser.get( elem, key.replace( rmultiDash, "-$&" ).toLowerCase() );

                                              if ( data !== undefined ) {
                                                  return data;
                                              }

                                              camelKey = jQuery.camelCase( key );

                                              // Attempt to get data from the cache
                                              // with the key camelized
                                              data = dataUser.get( elem, camelKey );
                                              if ( data !== undefined ) {
                                                  return data;
                                              }

                                              // Attempt to "discover" the data in
                                              // HTML5 custom data-* attrs
                                              data = dataAttr( elem, camelKey, undefined );
                                              if ( data !== undefined ) {
                                                  return data;
                                              }

                                              // We tried really hard, but the data doesn't exist.
                                              return;
                                          }

                                          // Set the data...
                                          camelKey = jQuery.camelCase( key );
                                          this.each( function() {

                                              // First, attempt to store a copy or reference of any
                                              // data that might've been store with a camelCased key.
                                              var data = dataUser.get( this, camelKey );

                                              // For HTML5 data-* attribute interop, we have to
                                              // store property names with dashes in a camelCase form.
                                              // This might not apply to all properties...*
                                              dataUser.set( this, camelKey, value );

                                              // *... In the case of properties that might _actually_
                                              // have dashes, we need to also store a copy of that
                                              // unchanged property.
                                              if ( key.indexOf( "-" ) > -1 && data !== undefined ) {
                                                  dataUser.set( this, key, value );
                                              }
                                          } );
                                      }, null, value, arguments.length > 1, null, true );
                                  },

                                  removeData: function( key ) {
                                      return this.each( function() {
                                          dataUser.remove( this, key );
                                      } );
                                  }
                              } );


            jQuery.extend( {
                               queue: function( elem, type, data ) {
                                   var queue;

                                   if ( elem ) {
                                       type = ( type || "fx" ) + "queue";
                                       queue = dataPriv.get( elem, type );

                                       // Speed up dequeue by getting out quickly if this is just a lookup
                                       if ( data ) {
                                           if ( !queue || jQuery.isArray( data ) ) {
                                               queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
                                           } else {
                                               queue.push( data );
                                           }
                                       }
                                       return queue || [];
                                   }
                               },

                               dequeue: function( elem, type ) {
                                   type = type || "fx";

                                   var queue = jQuery.queue( elem, type ),
                                       startLength = queue.length,
                                       fn = queue.shift(),
                                       hooks = jQuery._queueHooks( elem, type ),
                                       next = function() {
                                           jQuery.dequeue( elem, type );
                                       };

                                   // If the fx queue is dequeued, always remove the progress sentinel
                                   if ( fn === "inprogress" ) {
                                       fn = queue.shift();
                                       startLength--;
                                   }

                                   if ( fn ) {

                                       // Add a progress sentinel to prevent the fx queue from being
                                       // automatically dequeued
                                       if ( type === "fx" ) {
                                           queue.unshift( "inprogress" );
                                       }

                                       // Clear up the last queue stop function
                                       delete hooks.stop;
                                       fn.call( elem, next, hooks );
                                   }

                                   if ( !startLength && hooks ) {
                                       hooks.empty.fire();
                                   }
                               },

                               // Not public - generate a queueHooks object, or return the current one
                               _queueHooks: function( elem, type ) {
                                   var key = type + "queueHooks";
                                   return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
                                       empty: jQuery.Callbacks( "once memory" ).add( function() {
                                           dataPriv.remove( elem, [ type + "queue", key ] );
                                       } )
                                   } );
                               }
                           } );

            jQuery.fn.extend( {
                                  queue: function( type, data ) {
                                      var setter = 2;

                                      if ( typeof type !== "string" ) {
                                          data = type;
                                          type = "fx";
                                          setter--;
                                      }

                                      if ( arguments.length < setter ) {
                                          return jQuery.queue( this[ 0 ], type );
                                      }

                                      return data === undefined ?
                                          this :
                                          this.each( function() {
                                              var queue = jQuery.queue( this, type, data );

                                              // Ensure a hooks for this queue
                                              jQuery._queueHooks( this, type );

                                              if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
                                                  jQuery.dequeue( this, type );
                                              }
                                          } );
                                  },
                                  dequeue: function( type ) {
                                      return this.each( function() {
                                          jQuery.dequeue( this, type );
                                      } );
                                  },
                                  clearQueue: function( type ) {
                                      return this.queue( type || "fx", [] );
                                  },

                                  // Get a promise resolved when queues of a certain type
                                  // are emptied (fx is the type by default)
                                  promise: function( type, obj ) {
                                      var tmp,
                                          count = 1,
                                          defer = jQuery.Deferred(),
                                          elements = this,
                                          i = this.length,
                                          resolve = function() {
                                              if ( !( --count ) ) {
                                                  defer.resolveWith( elements, [ elements ] );
                                              }
                                          };

                                      if ( typeof type !== "string" ) {
                                          obj = type;
                                          type = undefined;
                                      }
                                      type = type || "fx";

                                      while ( i-- ) {
                                          tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
                                          if ( tmp && tmp.empty ) {
                                              count++;
                                              tmp.empty.add( resolve );
                                          }
                                      }
                                      resolve();
                                      return defer.promise( obj );
                                  }
                              } );
            var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

            var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


            var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

            var isHidden = function( elem, el ) {

                // isHidden might be called from jQuery#filter function;
                // in that case, element will be second argument
                elem = el || elem;
                return jQuery.css( elem, "display" ) === "none" ||
                       !jQuery.contains( elem.ownerDocument, elem );
            };



            function adjustCSS( elem, prop, valueParts, tween ) {
                var adjusted,
                    scale = 1,
                    maxIterations = 20,
                    currentValue = tween ?
                        function() { return tween.cur(); } :
                        function() { return jQuery.css( elem, prop, "" ); },
                    initial = currentValue(),
                    unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

                    // Starting value computation is required for potential unit mismatches
                    initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
                                    rcssNum.exec( jQuery.css( elem, prop ) );

                if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

                    // Trust units reported by jQuery.css
                    unit = unit || initialInUnit[ 3 ];

                    // Make sure we update the tween properties later on
                    valueParts = valueParts || [];

                    // Iteratively approximate from a nonzero starting point
                    initialInUnit = +initial || 1;

                    do {

                        // If previous iteration zeroed out, double until we get *something*.
                        // Use string for doubling so we don't accidentally see scale as unchanged below
                        scale = scale || ".5";

                        // Adjust and apply
                        initialInUnit = initialInUnit / scale;
                        jQuery.style( elem, prop, initialInUnit + unit );

                        // Update scale, tolerating zero or NaN from tween.cur()
                        // Break the loop if scale is unchanged or perfect, or if we've just had enough.
                    } while (
                        scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
                        );
                }

                if ( valueParts ) {
                    initialInUnit = +initialInUnit || +initial || 0;

                    // Apply relative offset (+=/-=) if specified
                    adjusted = valueParts[ 1 ] ?
                        initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
                        +valueParts[ 2 ];
                    if ( tween ) {
                        tween.unit = unit;
                        tween.start = initialInUnit;
                        tween.end = adjusted;
                    }
                }
                return adjusted;
            }
            var rcheckableType = ( /^(?:checkbox|radio)$/i );

            var rtagName = ( /<([\w:-]+)/ );

            var rscriptType = ( /^$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
            var wrapMap = {

                // Support: IE9
                option: [ 1, "<select multiple='multiple'>", "</select>" ],

                // XHTML parsers do not magically insert elements in the
                // same way that tag soup parsers do. So we cannot shorten
                // this by omitting <tbody> or other required elements.
                thead: [ 1, "<table>", "</table>" ],
                col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
                tr: [ 2, "<table><tbody>", "</tbody></table>" ],
                td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

                _default: [ 0, "", "" ]
            };

// Support: IE9
            wrapMap.optgroup = wrapMap.option;

            wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
            wrapMap.th = wrapMap.td;


            function getAll( context, tag ) {

                // Support: IE9-11+
                // Use typeof to avoid zero-argument method invocation on host objects (#15151)
                var ret = typeof context.getElementsByTagName !== "undefined" ?
                    context.getElementsByTagName( tag || "*" ) :
                    typeof context.querySelectorAll !== "undefined" ?
                        context.querySelectorAll( tag || "*" ) :
                        [];

                return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
                    jQuery.merge( [ context ], ret ) :
                    ret;
            }


// Mark scripts as having already been evaluated
            function setGlobalEval( elems, refElements ) {
                var i = 0,
                    l = elems.length;

                for ( ; i < l; i++ ) {
                    dataPriv.set(
                        elems[ i ],
                        "globalEval",
                        !refElements || dataPriv.get( refElements[ i ], "globalEval" )
                    );
                }
            }


            var rhtml = /<|&#?\w+;/;

            function buildFragment( elems, context, scripts, selection, ignored ) {
                var elem, tmp, tag, wrap, contains, j,
                    fragment = context.createDocumentFragment(),
                    nodes = [],
                    i = 0,
                    l = elems.length;

                for ( ; i < l; i++ ) {
                    elem = elems[ i ];

                    if ( elem || elem === 0 ) {

                        // Add nodes directly
                        if ( jQuery.type( elem ) === "object" ) {

                            // Support: Android<4.1, PhantomJS<2
                            // push.apply(_, arraylike) throws on ancient WebKit
                            jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

                            // Convert non-html into a text node
                        } else if ( !rhtml.test( elem ) ) {
                            nodes.push( context.createTextNode( elem ) );

                            // Convert html into DOM nodes
                        } else {
                            tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

                            // Deserialize a standard representation
                            tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
                            wrap = wrapMap[ tag ] || wrapMap._default;
                            tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

                            // Descend through wrappers to the right content
                            j = wrap[ 0 ];
                            while ( j-- ) {
                                tmp = tmp.lastChild;
                            }

                            // Support: Android<4.1, PhantomJS<2
                            // push.apply(_, arraylike) throws on ancient WebKit
                            jQuery.merge( nodes, tmp.childNodes );

                            // Remember the top-level container
                            tmp = fragment.firstChild;

                            // Ensure the created nodes are orphaned (#12392)
                            tmp.textContent = "";
                        }
                    }
                }

                // Remove wrapper from fragment
                fragment.textContent = "";

                i = 0;
                while ( ( elem = nodes[ i++ ] ) ) {

                    // Skip elements already in the context collection (trac-4087)
                    if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
                        if ( ignored ) {
                            ignored.push( elem );
                        }
                        continue;
                    }

                    contains = jQuery.contains( elem.ownerDocument, elem );

                    // Append to fragment
                    tmp = getAll( fragment.appendChild( elem ), "script" );

                    // Preserve script evaluation history
                    if ( contains ) {
                        setGlobalEval( tmp );
                    }

                    // Capture executables
                    if ( scripts ) {
                        j = 0;
                        while ( ( elem = tmp[ j++ ] ) ) {
                            if ( rscriptType.test( elem.type || "" ) ) {
                                scripts.push( elem );
                            }
                        }
                    }
                }

                return fragment;
            }


            ( function() {
                var fragment = document.createDocumentFragment(),
                    div = fragment.appendChild( document.createElement( "div" ) ),
                    input = document.createElement( "input" );

                // Support: Android 4.0-4.3, Safari<=5.1
                // Check state lost if the name is set (#11217)
                // Support: Windows Web Apps (WWA)
                // `name` and `type` must use .setAttribute for WWA (#14901)
                input.setAttribute( "type", "radio" );
                input.setAttribute( "checked", "checked" );
                input.setAttribute( "name", "t" );

                div.appendChild( input );

                // Support: Safari<=5.1, Android<4.2
                // Older WebKit doesn't clone checked state correctly in fragments
                support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

                // Support: IE<=11+
                // Make sure textarea (and checkbox) defaultValue is properly cloned
                div.innerHTML = "<textarea>x</textarea>";
                support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
            } )();


            var
                rkeyEvent = /^key/,
                rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
                rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

            function returnTrue() {
                return true;
            }

            function returnFalse() {
                return false;
            }

// Support: IE9
// See #13393 for more info
            function safeActiveElement() {
                try {
                    return document.activeElement;
                } catch ( err ) { }
            }

            function on( elem, types, selector, data, fn, one ) {
                var origFn, type;

                // Types can be a map of types/handlers
                if ( typeof types === "object" ) {

                    // ( types-Object, selector, data )
                    if ( typeof selector !== "string" ) {

                        // ( types-Object, data )
                        data = data || selector;
                        selector = undefined;
                    }
                    for ( type in types ) {
                        on( elem, type, selector, data, types[ type ], one );
                    }
                    return elem;
                }

                if ( data == null && fn == null ) {

                    // ( types, fn )
                    fn = selector;
                    data = selector = undefined;
                } else if ( fn == null ) {
                    if ( typeof selector === "string" ) {

                        // ( types, selector, fn )
                        fn = data;
                        data = undefined;
                    } else {

                        // ( types, data, fn )
                        fn = data;
                        data = selector;
                        selector = undefined;
                    }
                }
                if ( fn === false ) {
                    fn = returnFalse;
                } else if ( !fn ) {
                    return elem;
                }

                if ( one === 1 ) {
                    origFn = fn;
                    fn = function( event ) {

                        // Can use an empty set, since event contains the info
                        jQuery().off( event );
                        return origFn.apply( this, arguments );
                    };

                    // Use same guid so caller can remove using origFn
                    fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
                }
                return elem.each( function() {
                    jQuery.event.add( this, types, fn, data, selector );
                } );
            }

            /*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
            jQuery.event = {

                global: {},

                add: function( elem, types, handler, data, selector ) {

                    var handleObjIn, eventHandle, tmp,
                        events, t, handleObj,
                        special, handlers, type, namespaces, origType,
                        elemData = dataPriv.get( elem );

                    // Don't attach events to noData or text/comment nodes (but allow plain objects)
                    if ( !elemData ) {
                        return;
                    }

                    // Caller can pass in an object of custom data in lieu of the handler
                    if ( handler.handler ) {
                        handleObjIn = handler;
                        handler = handleObjIn.handler;
                        selector = handleObjIn.selector;
                    }

                    // Make sure that the handler has a unique ID, used to find/remove it later
                    if ( !handler.guid ) {
                        handler.guid = jQuery.guid++;
                    }

                    // Init the element's event structure and main handler, if this is the first
                    if ( !( events = elemData.events ) ) {
                        events = elemData.events = {};
                    }
                    if ( !( eventHandle = elemData.handle ) ) {
                        eventHandle = elemData.handle = function( e ) {

                            // Discard the second event of a jQuery.event.trigger() and
                            // when an event is called after a page has unloaded
                            return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
                                jQuery.event.dispatch.apply( elem, arguments ) : undefined;
                        };
                    }

                    // Handle multiple events separated by a space
                    types = ( types || "" ).match( rnotwhite ) || [ "" ];
                    t = types.length;
                    while ( t-- ) {
                        tmp = rtypenamespace.exec( types[ t ] ) || [];
                        type = origType = tmp[ 1 ];
                        namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

                        // There *must* be a type, no attaching namespace-only handlers
                        if ( !type ) {
                            continue;
                        }

                        // If event changes its type, use the special event handlers for the changed type
                        special = jQuery.event.special[ type ] || {};

                        // If selector defined, determine special event api type, otherwise given type
                        type = ( selector ? special.delegateType : special.bindType ) || type;

                        // Update special based on newly reset type
                        special = jQuery.event.special[ type ] || {};

                        // handleObj is passed to all event handlers
                        handleObj = jQuery.extend( {
                                                       type: type,
                                                       origType: origType,
                                                       data: data,
                                                       handler: handler,
                                                       guid: handler.guid,
                                                       selector: selector,
                                                       needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
                                                       namespace: namespaces.join( "." )
                                                   }, handleObjIn );

                        // Init the event handler queue if we're the first
                        if ( !( handlers = events[ type ] ) ) {
                            handlers = events[ type ] = [];
                            handlers.delegateCount = 0;

                            // Only use addEventListener if the special events handler returns false
                            if ( !special.setup ||
                                 special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

                                if ( elem.addEventListener ) {
                                    elem.addEventListener( type, eventHandle );
                                }
                            }
                        }

                        if ( special.add ) {
                            special.add.call( elem, handleObj );

                            if ( !handleObj.handler.guid ) {
                                handleObj.handler.guid = handler.guid;
                            }
                        }

                        // Add to the element's handler list, delegates in front
                        if ( selector ) {
                            handlers.splice( handlers.delegateCount++, 0, handleObj );
                        } else {
                            handlers.push( handleObj );
                        }

                        // Keep track of which events have ever been used, for event optimization
                        jQuery.event.global[ type ] = true;
                    }

                },

                // Detach an event or set of events from an element
                remove: function( elem, types, handler, selector, mappedTypes ) {

                    var j, origCount, tmp,
                        events, t, handleObj,
                        special, handlers, type, namespaces, origType,
                        elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

                    if ( !elemData || !( events = elemData.events ) ) {
                        return;
                    }

                    // Once for each type.namespace in types; type may be omitted
                    types = ( types || "" ).match( rnotwhite ) || [ "" ];
                    t = types.length;
                    while ( t-- ) {
                        tmp = rtypenamespace.exec( types[ t ] ) || [];
                        type = origType = tmp[ 1 ];
                        namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

                        // Unbind all events (on this namespace, if provided) for the element
                        if ( !type ) {
                            for ( type in events ) {
                                jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
                            }
                            continue;
                        }

                        special = jQuery.event.special[ type ] || {};
                        type = ( selector ? special.delegateType : special.bindType ) || type;
                        handlers = events[ type ] || [];
                        tmp = tmp[ 2 ] &&
                              new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

                        // Remove matching events
                        origCount = j = handlers.length;
                        while ( j-- ) {
                            handleObj = handlers[ j ];

                            if ( ( mappedTypes || origType === handleObj.origType ) &&
                                 ( !handler || handler.guid === handleObj.guid ) &&
                                 ( !tmp || tmp.test( handleObj.namespace ) ) &&
                                 ( !selector || selector === handleObj.selector ||
                                   selector === "**" && handleObj.selector ) ) {
                                handlers.splice( j, 1 );

                                if ( handleObj.selector ) {
                                    handlers.delegateCount--;
                                }
                                if ( special.remove ) {
                                    special.remove.call( elem, handleObj );
                                }
                            }
                        }

                        // Remove generic event handler if we removed something and no more handlers exist
                        // (avoids potential for endless recursion during removal of special event handlers)
                        if ( origCount && !handlers.length ) {
                            if ( !special.teardown ||
                                 special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

                                jQuery.removeEvent( elem, type, elemData.handle );
                            }

                            delete events[ type ];
                        }
                    }

                    // Remove data and the expando if it's no longer used
                    if ( jQuery.isEmptyObject( events ) ) {
                        dataPriv.remove( elem, "handle events" );
                    }
                },

                dispatch: function( event ) {

                    // Make a writable jQuery.Event from the native event object
                    event = jQuery.event.fix( event );

                    var i, j, ret, matched, handleObj,
                        handlerQueue = [],
                        args = slice.call( arguments ),
                        handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
                        special = jQuery.event.special[ event.type ] || {};

                    // Use the fix-ed jQuery.Event rather than the (read-only) native event
                    args[ 0 ] = event;
                    event.delegateTarget = this;

                    // Call the preDispatch hook for the mapped type, and let it bail if desired
                    if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
                        return;
                    }

                    // Determine handlers
                    handlerQueue = jQuery.event.handlers.call( this, event, handlers );

                    // Run delegates first; they may want to stop propagation beneath us
                    i = 0;
                    while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
                        event.currentTarget = matched.elem;

                        j = 0;
                        while ( ( handleObj = matched.handlers[ j++ ] ) &&
                                !event.isImmediatePropagationStopped() ) {

                            // Triggered event must either 1) have no namespace, or 2) have namespace(s)
                            // a subset or equal to those in the bound event (both can have no namespace).
                            if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

                                event.handleObj = handleObj;
                                event.data = handleObj.data;

                                ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
                                        handleObj.handler ).apply( matched.elem, args );

                                if ( ret !== undefined ) {
                                    if ( ( event.result = ret ) === false ) {
                                        event.preventDefault();
                                        event.stopPropagation();
                                    }
                                }
                            }
                        }
                    }

                    // Call the postDispatch hook for the mapped type
                    if ( special.postDispatch ) {
                        special.postDispatch.call( this, event );
                    }

                    return event.result;
                },

                handlers: function( event, handlers ) {
                    var i, matches, sel, handleObj,
                        handlerQueue = [],
                        delegateCount = handlers.delegateCount,
                        cur = event.target;

                    // Support (at least): Chrome, IE9
                    // Find delegate handlers
                    // Black-hole SVG <use> instance trees (#13180)
                    //
                    // Support: Firefox<=42+
                    // Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
                    if ( delegateCount && cur.nodeType &&
                         ( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {

                        for ( ; cur !== this; cur = cur.parentNode || this ) {

                            // Don't check non-elements (#13208)
                            // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                            if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
                                matches = [];
                                for ( i = 0; i < delegateCount; i++ ) {
                                    handleObj = handlers[ i ];

                                    // Don't conflict with Object.prototype properties (#13203)
                                    sel = handleObj.selector + " ";

                                    if ( matches[ sel ] === undefined ) {
                                        matches[ sel ] = handleObj.needsContext ?
                                            jQuery( sel, this ).index( cur ) > -1 :
                                            jQuery.find( sel, this, null, [ cur ] ).length;
                                    }
                                    if ( matches[ sel ] ) {
                                        matches.push( handleObj );
                                    }
                                }
                                if ( matches.length ) {
                                    handlerQueue.push( { elem: cur, handlers: matches } );
                                }
                            }
                        }
                    }

                    // Add the remaining (directly-bound) handlers
                    if ( delegateCount < handlers.length ) {
                        handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
                    }

                    return handlerQueue;
                },

                // Includes some event props shared by KeyEvent and MouseEvent
                props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
                         "metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),

                fixHooks: {},

                keyHooks: {
                    props: "char charCode key keyCode".split( " " ),
                    filter: function( event, original ) {

                        // Add which for key events
                        if ( event.which == null ) {
                            event.which = original.charCode != null ? original.charCode : original.keyCode;
                        }

                        return event;
                    }
                },

                mouseHooks: {
                    props: ( "button buttons clientX clientY offsetX offsetY pageX pageY " +
                             "screenX screenY toElement" ).split( " " ),
                    filter: function( event, original ) {
                        var eventDoc, doc, body,
                            button = original.button;

                        // Calculate pageX/Y if missing and clientX/Y available
                        if ( event.pageX == null && original.clientX != null ) {
                            eventDoc = event.target.ownerDocument || document;
                            doc = eventDoc.documentElement;
                            body = eventDoc.body;

                            event.pageX = original.clientX +
                                          ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
                                          ( doc && doc.clientLeft || body && body.clientLeft || 0 );
                            event.pageY = original.clientY +
                                          ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
                                          ( doc && doc.clientTop  || body && body.clientTop  || 0 );
                        }

                        // Add which for click: 1 === left; 2 === middle; 3 === right
                        // Note: button is not normalized, so don't use it
                        if ( !event.which && button !== undefined ) {
                            event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
                        }

                        return event;
                    }
                },

                fix: function( event ) {
                    if ( event[ jQuery.expando ] ) {
                        return event;
                    }

                    // Create a writable copy of the event object and normalize some properties
                    var i, prop, copy,
                        type = event.type,
                        originalEvent = event,
                        fixHook = this.fixHooks[ type ];

                    if ( !fixHook ) {
                        this.fixHooks[ type ] = fixHook =
                            rmouseEvent.test( type ) ? this.mouseHooks :
                                rkeyEvent.test( type ) ? this.keyHooks :
                                    {};
                    }
                    copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

                    event = new jQuery.Event( originalEvent );

                    i = copy.length;
                    while ( i-- ) {
                        prop = copy[ i ];
                        event[ prop ] = originalEvent[ prop ];
                    }

                    // Support: Cordova 2.5 (WebKit) (#13255)
                    // All events should have a target; Cordova deviceready doesn't
                    if ( !event.target ) {
                        event.target = document;
                    }

                    // Support: Safari 6.0+, Chrome<28
                    // Target should not be a text node (#504, #13143)
                    if ( event.target.nodeType === 3 ) {
                        event.target = event.target.parentNode;
                    }

                    return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
                },

                special: {
                    load: {

                        // Prevent triggered image.load events from bubbling to window.load
                        noBubble: true
                    },
                    focus: {

                        // Fire native event if possible so blur/focus sequence is correct
                        trigger: function() {
                            if ( this !== safeActiveElement() && this.focus ) {
                                this.focus();
                                return false;
                            }
                        },
                        delegateType: "focusin"
                    },
                    blur: {
                        trigger: function() {
                            if ( this === safeActiveElement() && this.blur ) {
                                this.blur();
                                return false;
                            }
                        },
                        delegateType: "focusout"
                    },
                    click: {

                        // For checkbox, fire native event so checked state will be right
                        trigger: function() {
                            if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
                                this.click();
                                return false;
                            }
                        },

                        // For cross-browser consistency, don't fire native .click() on links
                        _default: function( event ) {
                            return jQuery.nodeName( event.target, "a" );
                        }
                    },

                    beforeunload: {
                        postDispatch: function( event ) {

                            // Support: Firefox 20+
                            // Firefox doesn't alert if the returnValue field is not set.
                            if ( event.result !== undefined && event.originalEvent ) {
                                event.originalEvent.returnValue = event.result;
                            }
                        }
                    }
                }
            };

            jQuery.removeEvent = function( elem, type, handle ) {

                // This "if" is needed for plain objects
                if ( elem.removeEventListener ) {
                    elem.removeEventListener( type, handle );
                }
            };

            jQuery.Event = function( src, props ) {

                // Allow instantiation without the 'new' keyword
                if ( !( this instanceof jQuery.Event ) ) {
                    return new jQuery.Event( src, props );
                }

                // Event object
                if ( src && src.type ) {
                    this.originalEvent = src;
                    this.type = src.type;

                    // Events bubbling up the document may have been marked as prevented
                    // by a handler lower down the tree; reflect the correct value.
                    this.isDefaultPrevented = src.defaultPrevented ||
                                              src.defaultPrevented === undefined &&

                                              // Support: Android<4.0
                                              src.returnValue === false ?
                        returnTrue :
                        returnFalse;

                    // Event type
                } else {
                    this.type = src;
                }

                // Put explicitly provided properties onto the event object
                if ( props ) {
                    jQuery.extend( this, props );
                }

                // Create a timestamp if incoming event doesn't have one
                this.timeStamp = src && src.timeStamp || jQuery.now();

                // Mark it as fixed
                this[ jQuery.expando ] = true;
            };

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
            jQuery.Event.prototype = {
                constructor: jQuery.Event,
                isDefaultPrevented: returnFalse,
                isPropagationStopped: returnFalse,
                isImmediatePropagationStopped: returnFalse,
                isSimulated: false,

                preventDefault: function() {
                    var e = this.originalEvent;

                    this.isDefaultPrevented = returnTrue;

                    if ( e && !this.isSimulated ) {
                        e.preventDefault();
                    }
                },
                stopPropagation: function() {
                    var e = this.originalEvent;

                    this.isPropagationStopped = returnTrue;

                    if ( e && !this.isSimulated ) {
                        e.stopPropagation();
                    }
                },
                stopImmediatePropagation: function() {
                    var e = this.originalEvent;

                    this.isImmediatePropagationStopped = returnTrue;

                    if ( e && !this.isSimulated ) {
                        e.stopImmediatePropagation();
                    }

                    this.stopPropagation();
                }
            };

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://code.google.com/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
            jQuery.each( {
                             mouseenter: "mouseover",
                             mouseleave: "mouseout",
                             pointerenter: "pointerover",
                             pointerleave: "pointerout"
                         }, function( orig, fix ) {
                jQuery.event.special[ orig ] = {
                    delegateType: fix,
                    bindType: fix,

                    handle: function( event ) {
                        var ret,
                            target = this,
                            related = event.relatedTarget,
                            handleObj = event.handleObj;

                        // For mouseenter/leave call the handler if related is outside the target.
                        // NB: No relatedTarget if the mouse left/entered the browser window
                        if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
                            event.type = handleObj.origType;
                            ret = handleObj.handler.apply( this, arguments );
                            event.type = fix;
                        }
                        return ret;
                    }
                };
            } );

            jQuery.fn.extend( {
                                  on: function( types, selector, data, fn ) {
                                      return on( this, types, selector, data, fn );
                                  },
                                  one: function( types, selector, data, fn ) {
                                      return on( this, types, selector, data, fn, 1 );
                                  },
                                  off: function( types, selector, fn ) {
                                      var handleObj, type;
                                      if ( types && types.preventDefault && types.handleObj ) {

                                          // ( event )  dispatched jQuery.Event
                                          handleObj = types.handleObj;
                                          jQuery( types.delegateTarget ).off(
                                              handleObj.namespace ?
                                                  handleObj.origType + "." + handleObj.namespace :
                                                  handleObj.origType,
                                              handleObj.selector,
                                              handleObj.handler
                                          );
                                          return this;
                                      }
                                      if ( typeof types === "object" ) {

                                          // ( types-object [, selector] )
                                          for ( type in types ) {
                                              this.off( type, selector, types[ type ] );
                                          }
                                          return this;
                                      }
                                      if ( selector === false || typeof selector === "function" ) {

                                          // ( types [, fn] )
                                          fn = selector;
                                          selector = undefined;
                                      }
                                      if ( fn === false ) {
                                          fn = returnFalse;
                                      }
                                      return this.each( function() {
                                          jQuery.event.remove( this, types, fn, selector );
                                      } );
                                  }
                              } );


            var
                rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,

                // Support: IE 10-11, Edge 10240+
                // In IE/Edge using regex groups here causes severe slowdowns.
                // See https://connect.microsoft.com/IE/feedback/details/1736512/
                rnoInnerhtml = /<script|<style|<link/i,

                // checked="checked" or checked
                rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
                rscriptTypeMasked = /^true\/(.*)/,
                rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Manipulating tables requires a tbody
            function manipulationTarget( elem, content ) {
                return jQuery.nodeName( elem, "table" ) &&
                       jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

                    elem.getElementsByTagName( "tbody" )[ 0 ] ||
                    elem.appendChild( elem.ownerDocument.createElement( "tbody" ) ) :
                    elem;
            }

// Replace/restore the type attribute of script elements for safe DOM manipulation
            function disableScript( elem ) {
                elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
                return elem;
            }
            function restoreScript( elem ) {
                var match = rscriptTypeMasked.exec( elem.type );

                if ( match ) {
                    elem.type = match[ 1 ];
                } else {
                    elem.removeAttribute( "type" );
                }

                return elem;
            }

            function cloneCopyEvent( src, dest ) {
                var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

                if ( dest.nodeType !== 1 ) {
                    return;
                }

                // 1. Copy private data: events, handlers, etc.
                if ( dataPriv.hasData( src ) ) {
                    pdataOld = dataPriv.access( src );
                    pdataCur = dataPriv.set( dest, pdataOld );
                    events = pdataOld.events;

                    if ( events ) {
                        delete pdataCur.handle;
                        pdataCur.events = {};

                        for ( type in events ) {
                            for ( i = 0, l = events[ type ].length; i < l; i++ ) {
                                jQuery.event.add( dest, type, events[ type ][ i ] );
                            }
                        }
                    }
                }

                // 2. Copy user data
                if ( dataUser.hasData( src ) ) {
                    udataOld = dataUser.access( src );
                    udataCur = jQuery.extend( {}, udataOld );

                    dataUser.set( dest, udataCur );
                }
            }

// Fix IE bugs, see support tests
            function fixInput( src, dest ) {
                var nodeName = dest.nodeName.toLowerCase();

                // Fails to persist the checked state of a cloned checkbox or radio button.
                if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
                    dest.checked = src.checked;

                    // Fails to return the selected option to the default selected state when cloning options
                } else if ( nodeName === "input" || nodeName === "textarea" ) {
                    dest.defaultValue = src.defaultValue;
                }
            }

            function domManip( collection, args, callback, ignored ) {

                // Flatten any nested arrays
                args = concat.apply( [], args );

                var fragment, first, scripts, hasScripts, node, doc,
                    i = 0,
                    l = collection.length,
                    iNoClone = l - 1,
                    value = args[ 0 ],
                    isFunction = jQuery.isFunction( value );

                // We can't cloneNode fragments that contain checked, in WebKit
                if ( isFunction ||
                     ( l > 1 && typeof value === "string" &&
                       !support.checkClone && rchecked.test( value ) ) ) {
                    return collection.each( function( index ) {
                        var self = collection.eq( index );
                        if ( isFunction ) {
                            args[ 0 ] = value.call( this, index, self.html() );
                        }
                        domManip( self, args, callback, ignored );
                    } );
                }

                if ( l ) {
                    fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
                    first = fragment.firstChild;

                    if ( fragment.childNodes.length === 1 ) {
                        fragment = first;
                    }

                    // Require either new content or an interest in ignored elements to invoke the callback
                    if ( first || ignored ) {
                        scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
                        hasScripts = scripts.length;

                        // Use the original fragment for the last item
                        // instead of the first because it can end up
                        // being emptied incorrectly in certain situations (#8070).
                        for ( ; i < l; i++ ) {
                            node = fragment;

                            if ( i !== iNoClone ) {
                                node = jQuery.clone( node, true, true );

                                // Keep references to cloned scripts for later restoration
                                if ( hasScripts ) {

                                    // Support: Android<4.1, PhantomJS<2
                                    // push.apply(_, arraylike) throws on ancient WebKit
                                    jQuery.merge( scripts, getAll( node, "script" ) );
                                }
                            }

                            callback.call( collection[ i ], node, i );
                        }

                        if ( hasScripts ) {
                            doc = scripts[ scripts.length - 1 ].ownerDocument;

                            // Reenable scripts
                            jQuery.map( scripts, restoreScript );

                            // Evaluate executable scripts on first document insertion
                            for ( i = 0; i < hasScripts; i++ ) {
                                node = scripts[ i ];
                                if ( rscriptType.test( node.type || "" ) &&
                                     !dataPriv.access( node, "globalEval" ) &&
                                     jQuery.contains( doc, node ) ) {

                                    if ( node.src ) {

                                        // Optional AJAX dependency, but won't run scripts if not present
                                        if ( jQuery._evalUrl ) {
                                            jQuery._evalUrl( node.src );
                                        }
                                    } else {
                                        jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
                                    }
                                }
                            }
                        }
                    }
                }

                return collection;
            }

            function remove( elem, selector, keepData ) {
                var node,
                    nodes = selector ? jQuery.filter( selector, elem ) : elem,
                    i = 0;

                for ( ; ( node = nodes[ i ] ) != null; i++ ) {
                    if ( !keepData && node.nodeType === 1 ) {
                        jQuery.cleanData( getAll( node ) );
                    }

                    if ( node.parentNode ) {
                        if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
                            setGlobalEval( getAll( node, "script" ) );
                        }
                        node.parentNode.removeChild( node );
                    }
                }

                return elem;
            }

            jQuery.extend( {
                               htmlPrefilter: function( html ) {
                                   return html.replace( rxhtmlTag, "<$1></$2>" );
                               },

                               clone: function( elem, dataAndEvents, deepDataAndEvents ) {
                                   var i, l, srcElements, destElements,
                                       clone = elem.cloneNode( true ),
                                       inPage = jQuery.contains( elem.ownerDocument, elem );

                                   // Fix IE cloning issues
                                   if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
                                        !jQuery.isXMLDoc( elem ) ) {

                                       // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
                                       destElements = getAll( clone );
                                       srcElements = getAll( elem );

                                       for ( i = 0, l = srcElements.length; i < l; i++ ) {
                                           fixInput( srcElements[ i ], destElements[ i ] );
                                       }
                                   }

                                   // Copy the events from the original to the clone
                                   if ( dataAndEvents ) {
                                       if ( deepDataAndEvents ) {
                                           srcElements = srcElements || getAll( elem );
                                           destElements = destElements || getAll( clone );

                                           for ( i = 0, l = srcElements.length; i < l; i++ ) {
                                               cloneCopyEvent( srcElements[ i ], destElements[ i ] );
                                           }
                                       } else {
                                           cloneCopyEvent( elem, clone );
                                       }
                                   }

                                   // Preserve script evaluation history
                                   destElements = getAll( clone, "script" );
                                   if ( destElements.length > 0 ) {
                                       setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
                                   }

                                   // Return the cloned set
                                   return clone;
                               },

                               cleanData: function( elems ) {
                                   var data, elem, type,
                                       special = jQuery.event.special,
                                       i = 0;

                                   for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
                                       if ( acceptData( elem ) ) {
                                           if ( ( data = elem[ dataPriv.expando ] ) ) {
                                               if ( data.events ) {
                                                   for ( type in data.events ) {
                                                       if ( special[ type ] ) {
                                                           jQuery.event.remove( elem, type );

                                                           // This is a shortcut to avoid jQuery.event.remove's overhead
                                                       } else {
                                                           jQuery.removeEvent( elem, type, data.handle );
                                                       }
                                                   }
                                               }

                                               // Support: Chrome <= 35-45+
                                               // Assign undefined instead of using delete, see Data#remove
                                               elem[ dataPriv.expando ] = undefined;
                                           }
                                           if ( elem[ dataUser.expando ] ) {

                                               // Support: Chrome <= 35-45+
                                               // Assign undefined instead of using delete, see Data#remove
                                               elem[ dataUser.expando ] = undefined;
                                           }
                                       }
                                   }
                               }
                           } );

            jQuery.fn.extend( {

                                  // Keep domManip exposed until 3.0 (gh-2225)
                                  domManip: domManip,

                                  detach: function( selector ) {
                                      return remove( this, selector, true );
                                  },

                                  remove: function( selector ) {
                                      return remove( this, selector );
                                  },

                                  text: function( value ) {
                                      return access( this, function( value ) {
                                          return value === undefined ?
                                              jQuery.text( this ) :
                                              this.empty().each( function() {
                                                  if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                                                      this.textContent = value;
                                                  }
                                              } );
                                      }, null, value, arguments.length );
                                  },

                                  append: function() {
                                      return domManip( this, arguments, function( elem ) {
                                          if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                                              var target = manipulationTarget( this, elem );
                                              target.appendChild( elem );
                                          }
                                      } );
                                  },

                                  prepend: function() {
                                      return domManip( this, arguments, function( elem ) {
                                          if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                                              var target = manipulationTarget( this, elem );
                                              target.insertBefore( elem, target.firstChild );
                                          }
                                      } );
                                  },

                                  before: function() {
                                      return domManip( this, arguments, function( elem ) {
                                          if ( this.parentNode ) {
                                              this.parentNode.insertBefore( elem, this );
                                          }
                                      } );
                                  },

                                  after: function() {
                                      return domManip( this, arguments, function( elem ) {
                                          if ( this.parentNode ) {
                                              this.parentNode.insertBefore( elem, this.nextSibling );
                                          }
                                      } );
                                  },

                                  empty: function() {
                                      var elem,
                                          i = 0;

                                      for ( ; ( elem = this[ i ] ) != null; i++ ) {
                                          if ( elem.nodeType === 1 ) {

                                              // Prevent memory leaks
                                              jQuery.cleanData( getAll( elem, false ) );

                                              // Remove any remaining nodes
                                              elem.textContent = "";
                                          }
                                      }

                                      return this;
                                  },

                                  clone: function( dataAndEvents, deepDataAndEvents ) {
                                      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
                                      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

                                      return this.map( function() {
                                          return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
                                      } );
                                  },

                                  html: function( value ) {
                                      return access( this, function( value ) {
                                          var elem = this[ 0 ] || {},
                                              i = 0,
                                              l = this.length;

                                          if ( value === undefined && elem.nodeType === 1 ) {
                                              return elem.innerHTML;
                                          }

                                          // See if we can take a shortcut and just use innerHTML
                                          if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
                                               !wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

                                              value = jQuery.htmlPrefilter( value );

                                              try {
                                                  for ( ; i < l; i++ ) {
                                                      elem = this[ i ] || {};

                                                      // Remove element nodes and prevent memory leaks
                                                      if ( elem.nodeType === 1 ) {
                                                          jQuery.cleanData( getAll( elem, false ) );
                                                          elem.innerHTML = value;
                                                      }
                                                  }

                                                  elem = 0;

                                                  // If using innerHTML throws an exception, use the fallback method
                                              } catch ( e ) {}
                                          }

                                          if ( elem ) {
                                              this.empty().append( value );
                                          }
                                      }, null, value, arguments.length );
                                  },

                                  replaceWith: function() {
                                      var ignored = [];

                                      // Make the changes, replacing each non-ignored context element with the new content
                                      return domManip( this, arguments, function( elem ) {
                                          var parent = this.parentNode;

                                          if ( jQuery.inArray( this, ignored ) < 0 ) {
                                              jQuery.cleanData( getAll( this ) );
                                              if ( parent ) {
                                                  parent.replaceChild( elem, this );
                                              }
                                          }

                                          // Force callback invocation
                                      }, ignored );
                                  }
                              } );

            jQuery.each( {
                             appendTo: "append",
                             prependTo: "prepend",
                             insertBefore: "before",
                             insertAfter: "after",
                             replaceAll: "replaceWith"
                         }, function( name, original ) {
                jQuery.fn[ name ] = function( selector ) {
                    var elems,
                        ret = [],
                        insert = jQuery( selector ),
                        last = insert.length - 1,
                        i = 0;

                    for ( ; i <= last; i++ ) {
                        elems = i === last ? this : this.clone( true );
                        jQuery( insert[ i ] )[ original ]( elems );

                        // Support: QtWebKit
                        // .get() because push.apply(_, arraylike) throws
                        push.apply( ret, elems.get() );
                    }

                    return this.pushStack( ret );
                };
            } );


            var iframe,
                elemdisplay = {

                    // Support: Firefox
                    // We have to pre-define these values for FF (#10227)
                    HTML: "block",
                    BODY: "block"
                };

            /**
             * Retrieve the actual display of a element
             * @param {String} name nodeName of the element
             * @param {Object} doc Document object
             */

// Called only from within defaultDisplay
            function actualDisplay( name, doc ) {
                var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

                    display = jQuery.css( elem[ 0 ], "display" );

                // We don't have any data stored on the element,
                // so use "detach" method as fast way to get rid of the element
                elem.detach();

                return display;
            }

            /**
             * Try to determine the default display value of an element
             * @param {String} nodeName
             */
            function defaultDisplay( nodeName ) {
                var doc = document,
                    display = elemdisplay[ nodeName ];

                if ( !display ) {
                    display = actualDisplay( nodeName, doc );

                    // If the simple way fails, read from inside an iframe
                    if ( display === "none" || !display ) {

                        // Use the already-created iframe if possible
                        iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
                            .appendTo( doc.documentElement );

                        // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
                        doc = iframe[ 0 ].contentDocument;

                        // Support: IE
                        doc.write();
                        doc.close();

                        display = actualDisplay( nodeName, doc );
                        iframe.detach();
                    }

                    // Store the correct default display
                    elemdisplay[ nodeName ] = display;
                }

                return display;
            }
            var rmargin = ( /^margin/ );

            var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

            var getStyles = function( elem ) {

                // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
                // IE throws on elements created in popups
                // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
                var view = elem.ownerDocument.defaultView;

                if ( !view || !view.opener ) {
                    view = window;
                }

                return view.getComputedStyle( elem );
            };

            var swap = function( elem, options, callback, args ) {
                var ret, name,
                    old = {};

                // Remember the old values, and insert the new ones
                for ( name in options ) {
                    old[ name ] = elem.style[ name ];
                    elem.style[ name ] = options[ name ];
                }

                ret = callback.apply( elem, args || [] );

                // Revert the old values
                for ( name in options ) {
                    elem.style[ name ] = old[ name ];
                }

                return ret;
            };


            var documentElement = document.documentElement;



            ( function() {
                var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
                    container = document.createElement( "div" ),
                    div = document.createElement( "div" );

                // Finish early in limited (non-browser) environments
                if ( !div.style ) {
                    return;
                }

                // Support: IE9-11+
                // Style of cloned element affects source element cloned (#8908)
                div.style.backgroundClip = "content-box";
                div.cloneNode( true ).style.backgroundClip = "";
                support.clearCloneStyle = div.style.backgroundClip === "content-box";

                container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
                                          "padding:0;margin-top:1px;position:absolute";
                container.appendChild( div );

                // Executing both pixelPosition & boxSizingReliable tests require only one layout
                // so they're executed at the same time to save the second computation.
                function computeStyleTests() {
                    div.style.cssText =

                        // Support: Firefox<29, Android 2.3
                        // Vendor-prefix box-sizing
                        "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
                        "position:relative;display:block;" +
                        "margin:auto;border:1px;padding:1px;" +
                        "top:1%;width:50%";
                    div.innerHTML = "";
                    documentElement.appendChild( container );

                    var divStyle = window.getComputedStyle( div );
                    pixelPositionVal = divStyle.top !== "1%";
                    reliableMarginLeftVal = divStyle.marginLeft === "2px";
                    boxSizingReliableVal = divStyle.width === "4px";

                    // Support: Android 4.0 - 4.3 only
                    // Some styles come back with percentage values, even though they shouldn't
                    div.style.marginRight = "50%";
                    pixelMarginRightVal = divStyle.marginRight === "4px";

                    documentElement.removeChild( container );
                }

                jQuery.extend( support, {
                    pixelPosition: function() {

                        // This test is executed only once but we still do memoizing
                        // since we can use the boxSizingReliable pre-computing.
                        // No need to check if the test was already performed, though.
                        computeStyleTests();
                        return pixelPositionVal;
                    },
                    boxSizingReliable: function() {
                        if ( boxSizingReliableVal == null ) {
                            computeStyleTests();
                        }
                        return boxSizingReliableVal;
                    },
                    pixelMarginRight: function() {

                        // Support: Android 4.0-4.3
                        // We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
                        // since that compresses better and they're computed together anyway.
                        if ( boxSizingReliableVal == null ) {
                            computeStyleTests();
                        }
                        return pixelMarginRightVal;
                    },
                    reliableMarginLeft: function() {

                        // Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
                        if ( boxSizingReliableVal == null ) {
                            computeStyleTests();
                        }
                        return reliableMarginLeftVal;
                    },
                    reliableMarginRight: function() {

                        // Support: Android 2.3
                        // Check if div with explicit width and no margin-right incorrectly
                        // gets computed margin-right based on width of container. (#3333)
                        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                        // This support function is only executed once so no memoizing is needed.
                        var ret,
                            marginDiv = div.appendChild( document.createElement( "div" ) );

                        // Reset CSS: box-sizing; display; margin; border; padding
                        marginDiv.style.cssText = div.style.cssText =

                            // Support: Android 2.3
                            // Vendor-prefix box-sizing
                            "-webkit-box-sizing:content-box;box-sizing:content-box;" +
                            "display:block;margin:0;border:0;padding:0";
                        marginDiv.style.marginRight = marginDiv.style.width = "0";
                        div.style.width = "1px";
                        documentElement.appendChild( container );

                        ret = !parseFloat( window.getComputedStyle( marginDiv ).marginRight );

                        documentElement.removeChild( container );
                        div.removeChild( marginDiv );

                        return ret;
                    }
                } );
            } )();


            function curCSS( elem, name, computed ) {
                var width, minWidth, maxWidth, ret,
                    style = elem.style;

                computed = computed || getStyles( elem );
                ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

                // Support: Opera 12.1x only
                // Fall back to style even without computed
                // computed is undefined for elems on document fragments
                if ( ( ret === "" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {
                    ret = jQuery.style( elem, name );
                }

                // Support: IE9
                // getPropertyValue is only needed for .css('filter') (#12537)
                if ( computed ) {

                    // A tribute to the "awesome hack by Dean Edwards"
                    // Android Browser returns percentage for some values,
                    // but width seems to be reliably pixels.
                    // This is against the CSSOM draft spec:
                    // http://dev.w3.org/csswg/cssom/#resolved-values
                    if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

                        // Remember the original values
                        width = style.width;
                        minWidth = style.minWidth;
                        maxWidth = style.maxWidth;

                        // Put in the new values to get a computed value out
                        style.minWidth = style.maxWidth = style.width = ret;
                        ret = computed.width;

                        // Revert the changed values
                        style.width = width;
                        style.minWidth = minWidth;
                        style.maxWidth = maxWidth;
                    }
                }

                return ret !== undefined ?

                    // Support: IE9-11+
                    // IE returns zIndex value as an integer.
                    ret + "" :
                    ret;
            }


            function addGetHookIf( conditionFn, hookFn ) {

                // Define the hook, we'll check on the first run if it's really needed.
                return {
                    get: function() {
                        if ( conditionFn() ) {

                            // Hook not needed (or it's not possible to use it due
                            // to missing dependency), remove it.
                            delete this.get;
                            return;
                        }

                        // Hook needed; redefine it so that the support test is not executed again.
                        return ( this.get = hookFn ).apply( this, arguments );
                    }
                };
            }


            var

                // Swappable if display is none or starts with table
                // except "table", "table-cell", or "table-caption"
                // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
                rdisplayswap = /^(none|table(?!-c[ea]).+)/,

                cssShow = { position: "absolute", visibility: "hidden", display: "block" },
                cssNormalTransform = {
                    letterSpacing: "0",
                    fontWeight: "400"
                },

                cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
                emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
            function vendorPropName( name ) {

                // Shortcut for names that are not vendor prefixed
                if ( name in emptyStyle ) {
                    return name;
                }

                // Check for vendor prefixed names
                var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
                    i = cssPrefixes.length;

                while ( i-- ) {
                    name = cssPrefixes[ i ] + capName;
                    if ( name in emptyStyle ) {
                        return name;
                    }
                }
            }

            function setPositiveNumber( elem, value, subtract ) {

                // Any relative (+/-) values have already been
                // normalized at this point
                var matches = rcssNum.exec( value );
                return matches ?

                    // Guard against undefined "subtract", e.g., when used as in cssHooks
                    Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
                    value;
            }

            function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
                var i = extra === ( isBorderBox ? "border" : "content" ) ?

                    // If we already have the right measurement, avoid augmentation
                    4 :

                    // Otherwise initialize for horizontal or vertical properties
                    name === "width" ? 1 : 0,

                    val = 0;

                for ( ; i < 4; i += 2 ) {

                    // Both box models exclude margin, so add it if we want it
                    if ( extra === "margin" ) {
                        val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
                    }

                    if ( isBorderBox ) {

                        // border-box includes padding, so remove it if we want content
                        if ( extra === "content" ) {
                            val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
                        }

                        // At this point, extra isn't border nor margin, so remove border
                        if ( extra !== "margin" ) {
                            val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
                        }
                    } else {

                        // At this point, extra isn't content, so add padding
                        val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

                        // At this point, extra isn't content nor padding, so add border
                        if ( extra !== "padding" ) {
                            val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
                        }
                    }
                }

                return val;
            }

            function getWidthOrHeight( elem, name, extra ) {

                // Start with offset property, which is equivalent to the border-box value
                var valueIsBorderBox = true,
                    val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
                    styles = getStyles( elem ),
                    isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

                // Some non-html elements return undefined for offsetWidth, so check for null/undefined
                // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
                // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
                if ( val <= 0 || val == null ) {

                    // Fall back to computed then uncomputed css if necessary
                    val = curCSS( elem, name, styles );
                    if ( val < 0 || val == null ) {
                        val = elem.style[ name ];
                    }

                    // Computed unit is not pixels. Stop here and return.
                    if ( rnumnonpx.test( val ) ) {
                        return val;
                    }

                    // Check for style in case a browser which returns unreliable values
                    // for getComputedStyle silently falls back to the reliable elem.style
                    valueIsBorderBox = isBorderBox &&
                                       ( support.boxSizingReliable() || val === elem.style[ name ] );

                    // Normalize "", auto, and prepare for extra
                    val = parseFloat( val ) || 0;
                }

                // Use the active box-sizing model to add/subtract irrelevant styles
                return ( val +
                       augmentWidthOrHeight(
                           elem,
                           name,
                           extra || ( isBorderBox ? "border" : "content" ),
                           valueIsBorderBox,
                           styles
                       )
                       ) + "px";
            }

            function showHide( elements, show ) {
                var display, elem, hidden,
                    values = [],
                    index = 0,
                    length = elements.length;

                for ( ; index < length; index++ ) {
                    elem = elements[ index ];
                    if ( !elem.style ) {
                        continue;
                    }

                    values[ index ] = dataPriv.get( elem, "olddisplay" );
                    display = elem.style.display;
                    if ( show ) {

                        // Reset the inline display of this element to learn if it is
                        // being hidden by cascaded rules or not
                        if ( !values[ index ] && display === "none" ) {
                            elem.style.display = "";
                        }

                        // Set elements which have been overridden with display: none
                        // in a stylesheet to whatever the default browser style is
                        // for such an element
                        if ( elem.style.display === "" && isHidden( elem ) ) {
                            values[ index ] = dataPriv.access(
                                elem,
                                "olddisplay",
                                defaultDisplay( elem.nodeName )
                            );
                        }
                    } else {
                        hidden = isHidden( elem );

                        if ( display !== "none" || !hidden ) {
                            dataPriv.set(
                                elem,
                                "olddisplay",
                                hidden ? display : jQuery.css( elem, "display" )
                            );
                        }
                    }
                }

                // Set the display of most of the elements in a second loop
                // to avoid the constant reflow
                for ( index = 0; index < length; index++ ) {
                    elem = elements[ index ];
                    if ( !elem.style ) {
                        continue;
                    }
                    if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
                        elem.style.display = show ? values[ index ] || "" : "none";
                    }
                }

                return elements;
            }

            jQuery.extend( {

                               // Add in style property hooks for overriding the default
                               // behavior of getting and setting a style property
                               cssHooks: {
                                   opacity: {
                                       get: function( elem, computed ) {
                                           if ( computed ) {

                                               // We should always get a number back from opacity
                                               var ret = curCSS( elem, "opacity" );
                                               return ret === "" ? "1" : ret;
                                           }
                                       }
                                   }
                               },

                               // Don't automatically add "px" to these possibly-unitless properties
                               cssNumber: {
                                   "animationIterationCount": true,
                                   "columnCount": true,
                                   "fillOpacity": true,
                                   "flexGrow": true,
                                   "flexShrink": true,
                                   "fontWeight": true,
                                   "lineHeight": true,
                                   "opacity": true,
                                   "order": true,
                                   "orphans": true,
                                   "widows": true,
                                   "zIndex": true,
                                   "zoom": true
                               },

                               // Add in properties whose names you wish to fix before
                               // setting or getting the value
                               cssProps: {
                                   "float": "cssFloat"
                               },

                               // Get and set the style property on a DOM Node
                               style: function( elem, name, value, extra ) {

                                   // Don't set styles on text and comment nodes
                                   if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
                                       return;
                                   }

                                   // Make sure that we're working with the right name
                                   var ret, type, hooks,
                                       origName = jQuery.camelCase( name ),
                                       style = elem.style;

                                   name = jQuery.cssProps[ origName ] ||
                                          ( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

                                   // Gets hook for the prefixed version, then unprefixed version
                                   hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

                                   // Check if we're setting a value
                                   if ( value !== undefined ) {
                                       type = typeof value;

                                       // Convert "+=" or "-=" to relative numbers (#7345)
                                       if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
                                           value = adjustCSS( elem, name, ret );

                                           // Fixes bug #9237
                                           type = "number";
                                       }

                                       // Make sure that null and NaN values aren't set (#7116)
                                       if ( value == null || value !== value ) {
                                           return;
                                       }

                                       // If a number was passed in, add the unit (except for certain CSS properties)
                                       if ( type === "number" ) {
                                           value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
                                       }

                                       // Support: IE9-11+
                                       // background-* props affect original clone's values
                                       if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
                                           style[ name ] = "inherit";
                                       }

                                       // If a hook was provided, use that value, otherwise just set the specified value
                                       if ( !hooks || !( "set" in hooks ) ||
                                            ( value = hooks.set( elem, value, extra ) ) !== undefined ) {

                                           style[ name ] = value;
                                       }

                                   } else {

                                       // If a hook was provided get the non-computed value from there
                                       if ( hooks && "get" in hooks &&
                                            ( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

                                           return ret;
                                       }

                                       // Otherwise just get the value from the style object
                                       return style[ name ];
                                   }
                               },

                               css: function( elem, name, extra, styles ) {
                                   var val, num, hooks,
                                       origName = jQuery.camelCase( name );

                                   // Make sure that we're working with the right name
                                   name = jQuery.cssProps[ origName ] ||
                                          ( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

                                   // Try prefixed name followed by the unprefixed name
                                   hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

                                   // If a hook was provided get the computed value from there
                                   if ( hooks && "get" in hooks ) {
                                       val = hooks.get( elem, true, extra );
                                   }

                                   // Otherwise, if a way to get the computed value exists, use that
                                   if ( val === undefined ) {
                                       val = curCSS( elem, name, styles );
                                   }

                                   // Convert "normal" to computed value
                                   if ( val === "normal" && name in cssNormalTransform ) {
                                       val = cssNormalTransform[ name ];
                                   }

                                   // Make numeric if forced or a qualifier was provided and val looks numeric
                                   if ( extra === "" || extra ) {
                                       num = parseFloat( val );
                                       return extra === true || isFinite( num ) ? num || 0 : val;
                                   }
                                   return val;
                               }
                           } );

            jQuery.each( [ "height", "width" ], function( i, name ) {
                jQuery.cssHooks[ name ] = {
                    get: function( elem, computed, extra ) {
                        if ( computed ) {

                            // Certain elements can have dimension info if we invisibly show them
                            // but it must have a current display style that would benefit
                            return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
                                   elem.offsetWidth === 0 ?
                                swap( elem, cssShow, function() {
                                    return getWidthOrHeight( elem, name, extra );
                                } ) :
                                getWidthOrHeight( elem, name, extra );
                        }
                    },

                    set: function( elem, value, extra ) {
                        var matches,
                            styles = extra && getStyles( elem ),
                            subtract = extra && augmentWidthOrHeight(
                                elem,
                                name,
                                extra,
                                jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
                                styles
                            );

                        // Convert to pixels if value adjustment is needed
                        if ( subtract && ( matches = rcssNum.exec( value ) ) &&
                             ( matches[ 3 ] || "px" ) !== "px" ) {

                            elem.style[ name ] = value;
                            value = jQuery.css( elem, name );
                        }

                        return setPositiveNumber( elem, value, subtract );
                    }
                };
            } );

            jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
                                                       function( elem, computed ) {
                                                           if ( computed ) {
                                                               return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
                                                                        elem.getBoundingClientRect().left -
                                                                        swap( elem, { marginLeft: 0 }, function() {
                                                                            return elem.getBoundingClientRect().left;
                                                                        } )
                                                                      ) + "px";
                                                           }
                                                       }
            );

// Support: Android 2.3
            jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
                                                        function( elem, computed ) {
                                                            if ( computed ) {
                                                                return swap( elem, { "display": "inline-block" },
                                                                             curCSS, [ elem, "marginRight" ] );
                                                            }
                                                        }
            );

// These hooks are used by animate to expand properties
            jQuery.each( {
                             margin: "",
                             padding: "",
                             border: "Width"
                         }, function( prefix, suffix ) {
                jQuery.cssHooks[ prefix + suffix ] = {
                    expand: function( value ) {
                        var i = 0,
                            expanded = {},

                            // Assumes a single number if not a string
                            parts = typeof value === "string" ? value.split( " " ) : [ value ];

                        for ( ; i < 4; i++ ) {
                            expanded[ prefix + cssExpand[ i ] + suffix ] =
                                parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
                        }

                        return expanded;
                    }
                };

                if ( !rmargin.test( prefix ) ) {
                    jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
                }
            } );

            jQuery.fn.extend( {
                                  css: function( name, value ) {
                                      return access( this, function( elem, name, value ) {
                                          var styles, len,
                                              map = {},
                                              i = 0;

                                          if ( jQuery.isArray( name ) ) {
                                              styles = getStyles( elem );
                                              len = name.length;

                                              for ( ; i < len; i++ ) {
                                                  map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
                                              }

                                              return map;
                                          }

                                          return value !== undefined ?
                                              jQuery.style( elem, name, value ) :
                                              jQuery.css( elem, name );
                                      }, name, value, arguments.length > 1 );
                                  },
                                  show: function() {
                                      return showHide( this, true );
                                  },
                                  hide: function() {
                                      return showHide( this );
                                  },
                                  toggle: function( state ) {
                                      if ( typeof state === "boolean" ) {
                                          return state ? this.show() : this.hide();
                                      }

                                      return this.each( function() {
                                          if ( isHidden( this ) ) {
                                              jQuery( this ).show();
                                          } else {
                                              jQuery( this ).hide();
                                          }
                                      } );
                                  }
                              } );


            function Tween( elem, options, prop, end, easing ) {
                return new Tween.prototype.init( elem, options, prop, end, easing );
            }
            jQuery.Tween = Tween;

            Tween.prototype = {
                constructor: Tween,
                init: function( elem, options, prop, end, easing, unit ) {
                    this.elem = elem;
                    this.prop = prop;
                    this.easing = easing || jQuery.easing._default;
                    this.options = options;
                    this.start = this.now = this.cur();
                    this.end = end;
                    this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
                },
                cur: function() {
                    var hooks = Tween.propHooks[ this.prop ];

                    return hooks && hooks.get ?
                        hooks.get( this ) :
                        Tween.propHooks._default.get( this );
                },
                run: function( percent ) {
                    var eased,
                        hooks = Tween.propHooks[ this.prop ];

                    if ( this.options.duration ) {
                        this.pos = eased = jQuery.easing[ this.easing ](
                            percent, this.options.duration * percent, 0, 1, this.options.duration
                        );
                    } else {
                        this.pos = eased = percent;
                    }
                    this.now = ( this.end - this.start ) * eased + this.start;

                    if ( this.options.step ) {
                        this.options.step.call( this.elem, this.now, this );
                    }

                    if ( hooks && hooks.set ) {
                        hooks.set( this );
                    } else {
                        Tween.propHooks._default.set( this );
                    }
                    return this;
                }
            };

            Tween.prototype.init.prototype = Tween.prototype;

            Tween.propHooks = {
                _default: {
                    get: function( tween ) {
                        var result;

                        // Use a property on the element directly when it is not a DOM element,
                        // or when there is no matching style property that exists.
                        if ( tween.elem.nodeType !== 1 ||
                             tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
                            return tween.elem[ tween.prop ];
                        }

                        // Passing an empty string as a 3rd parameter to .css will automatically
                        // attempt a parseFloat and fallback to a string if the parse fails.
                        // Simple values such as "10px" are parsed to Float;
                        // complex values such as "rotate(1rad)" are returned as-is.
                        result = jQuery.css( tween.elem, tween.prop, "" );

                        // Empty strings, null, undefined and "auto" are converted to 0.
                        return !result || result === "auto" ? 0 : result;
                    },
                    set: function( tween ) {

                        // Use step hook for back compat.
                        // Use cssHook if its there.
                        // Use .style if available and use plain properties where available.
                        if ( jQuery.fx.step[ tween.prop ] ) {
                            jQuery.fx.step[ tween.prop ]( tween );
                        } else if ( tween.elem.nodeType === 1 &&
                                    ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
                                      jQuery.cssHooks[ tween.prop ] ) ) {
                            jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
                        } else {
                            tween.elem[ tween.prop ] = tween.now;
                        }
                    }
                }
            };

// Support: IE9
// Panic based approach to setting things on disconnected nodes
            Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
                set: function( tween ) {
                    if ( tween.elem.nodeType && tween.elem.parentNode ) {
                        tween.elem[ tween.prop ] = tween.now;
                    }
                }
            };

            jQuery.easing = {
                linear: function( p ) {
                    return p;
                },
                swing: function( p ) {
                    return 0.5 - Math.cos( p * Math.PI ) / 2;
                },
                _default: "swing"
            };

            jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
            jQuery.fx.step = {};




            var
                fxNow, timerId,
                rfxtypes = /^(?:toggle|show|hide)$/,
                rrun = /queueHooks$/;

// Animations created synchronously will run synchronously
            function createFxNow() {
                window.setTimeout( function() {
                    fxNow = undefined;
                } );
                return ( fxNow = jQuery.now() );
            }

// Generate parameters to create a standard animation
            function genFx( type, includeWidth ) {
                var which,
                    i = 0,
                    attrs = { height: type };

                // If we include width, step value is 1 to do all cssExpand values,
                // otherwise step value is 2 to skip over Left and Right
                includeWidth = includeWidth ? 1 : 0;
                for ( ; i < 4 ; i += 2 - includeWidth ) {
                    which = cssExpand[ i ];
                    attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
                }

                if ( includeWidth ) {
                    attrs.opacity = attrs.width = type;
                }

                return attrs;
            }

            function createTween( value, prop, animation ) {
                var tween,
                    collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
                    index = 0,
                    length = collection.length;
                for ( ; index < length; index++ ) {
                    if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

                        // We're done with this property
                        return tween;
                    }
                }
            }

            function defaultPrefilter( elem, props, opts ) {
                /* jshint validthis: true */
                var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
                    anim = this,
                    orig = {},
                    style = elem.style,
                    hidden = elem.nodeType && isHidden( elem ),
                    dataShow = dataPriv.get( elem, "fxshow" );

                // Handle queue: false promises
                if ( !opts.queue ) {
                    hooks = jQuery._queueHooks( elem, "fx" );
                    if ( hooks.unqueued == null ) {
                        hooks.unqueued = 0;
                        oldfire = hooks.empty.fire;
                        hooks.empty.fire = function() {
                            if ( !hooks.unqueued ) {
                                oldfire();
                            }
                        };
                    }
                    hooks.unqueued++;

                    anim.always( function() {

                        // Ensure the complete handler is called before this completes
                        anim.always( function() {
                            hooks.unqueued--;
                            if ( !jQuery.queue( elem, "fx" ).length ) {
                                hooks.empty.fire();
                            }
                        } );
                    } );
                }

                // Height/width overflow pass
                if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {

                    // Make sure that nothing sneaks out
                    // Record all 3 overflow attributes because IE9-10 do not
                    // change the overflow attribute when overflowX and
                    // overflowY are set to the same value
                    opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

                    // Set display property to inline-block for height/width
                    // animations on inline elements that are having width/height animated
                    display = jQuery.css( elem, "display" );

                    // Test default display if display is currently "none"
                    checkDisplay = display === "none" ?
                        dataPriv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

                    if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
                        style.display = "inline-block";
                    }
                }

                if ( opts.overflow ) {
                    style.overflow = "hidden";
                    anim.always( function() {
                        style.overflow = opts.overflow[ 0 ];
                        style.overflowX = opts.overflow[ 1 ];
                        style.overflowY = opts.overflow[ 2 ];
                    } );
                }

                // show/hide pass
                for ( prop in props ) {
                    value = props[ prop ];
                    if ( rfxtypes.exec( value ) ) {
                        delete props[ prop ];
                        toggle = toggle || value === "toggle";
                        if ( value === ( hidden ? "hide" : "show" ) ) {

                            // If there is dataShow left over from a stopped hide or show
                            // and we are going to proceed with show, we should pretend to be hidden
                            if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
                                hidden = true;
                            } else {
                                continue;
                            }
                        }
                        orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

                        // Any non-fx value stops us from restoring the original display value
                    } else {
                        display = undefined;
                    }
                }

                if ( !jQuery.isEmptyObject( orig ) ) {
                    if ( dataShow ) {
                        if ( "hidden" in dataShow ) {
                            hidden = dataShow.hidden;
                        }
                    } else {
                        dataShow = dataPriv.access( elem, "fxshow", {} );
                    }

                    // Store state if its toggle - enables .stop().toggle() to "reverse"
                    if ( toggle ) {
                        dataShow.hidden = !hidden;
                    }
                    if ( hidden ) {
                        jQuery( elem ).show();
                    } else {
                        anim.done( function() {
                            jQuery( elem ).hide();
                        } );
                    }
                    anim.done( function() {
                        var prop;

                        dataPriv.remove( elem, "fxshow" );
                        for ( prop in orig ) {
                            jQuery.style( elem, prop, orig[ prop ] );
                        }
                    } );
                    for ( prop in orig ) {
                        tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

                        if ( !( prop in dataShow ) ) {
                            dataShow[ prop ] = tween.start;
                            if ( hidden ) {
                                tween.end = tween.start;
                                tween.start = prop === "width" || prop === "height" ? 1 : 0;
                            }
                        }
                    }

                    // If this is a noop like .hide().hide(), restore an overwritten display value
                } else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
                    style.display = display;
                }
            }

            function propFilter( props, specialEasing ) {
                var index, name, easing, value, hooks;

                // camelCase, specialEasing and expand cssHook pass
                for ( index in props ) {
                    name = jQuery.camelCase( index );
                    easing = specialEasing[ name ];
                    value = props[ index ];
                    if ( jQuery.isArray( value ) ) {
                        easing = value[ 1 ];
                        value = props[ index ] = value[ 0 ];
                    }

                    if ( index !== name ) {
                        props[ name ] = value;
                        delete props[ index ];
                    }

                    hooks = jQuery.cssHooks[ name ];
                    if ( hooks && "expand" in hooks ) {
                        value = hooks.expand( value );
                        delete props[ name ];

                        // Not quite $.extend, this won't overwrite existing keys.
                        // Reusing 'index' because we have the correct "name"
                        for ( index in value ) {
                            if ( !( index in props ) ) {
                                props[ index ] = value[ index ];
                                specialEasing[ index ] = easing;
                            }
                        }
                    } else {
                        specialEasing[ name ] = easing;
                    }
                }
            }

            function Animation( elem, properties, options ) {
                var result,
                    stopped,
                    index = 0,
                    length = Animation.prefilters.length,
                    deferred = jQuery.Deferred().always( function() {

                        // Don't match elem in the :animated selector
                        delete tick.elem;
                    } ),
                    tick = function() {
                        if ( stopped ) {
                            return false;
                        }
                        var currentTime = fxNow || createFxNow(),
                            remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

                            // Support: Android 2.3
                            // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
                            temp = remaining / animation.duration || 0,
                            percent = 1 - temp,
                            index = 0,
                            length = animation.tweens.length;

                        for ( ; index < length ; index++ ) {
                            animation.tweens[ index ].run( percent );
                        }

                        deferred.notifyWith( elem, [ animation, percent, remaining ] );

                        if ( percent < 1 && length ) {
                            return remaining;
                        } else {
                            deferred.resolveWith( elem, [ animation ] );
                            return false;
                        }
                    },
                    animation = deferred.promise( {
                                                      elem: elem,
                                                      props: jQuery.extend( {}, properties ),
                                                      opts: jQuery.extend( true, {
                                                          specialEasing: {},
                                                          easing: jQuery.easing._default
                                                      }, options ),
                                                      originalProperties: properties,
                                                      originalOptions: options,
                                                      startTime: fxNow || createFxNow(),
                                                      duration: options.duration,
                                                      tweens: [],
                                                      createTween: function( prop, end ) {
                                                          var tween = jQuery.Tween( elem, animation.opts, prop, end,
                                                                                    animation.opts.specialEasing[ prop ] || animation.opts.easing );
                                                          animation.tweens.push( tween );
                                                          return tween;
                                                      },
                                                      stop: function( gotoEnd ) {
                                                          var index = 0,

                                                              // If we are going to the end, we want to run all the tweens
                                                              // otherwise we skip this part
                                                              length = gotoEnd ? animation.tweens.length : 0;
                                                          if ( stopped ) {
                                                              return this;
                                                          }
                                                          stopped = true;
                                                          for ( ; index < length ; index++ ) {
                                                              animation.tweens[ index ].run( 1 );
                                                          }

                                                          // Resolve when we played the last frame; otherwise, reject
                                                          if ( gotoEnd ) {
                                                              deferred.notifyWith( elem, [ animation, 1, 0 ] );
                                                              deferred.resolveWith( elem, [ animation, gotoEnd ] );
                                                          } else {
                                                              deferred.rejectWith( elem, [ animation, gotoEnd ] );
                                                          }
                                                          return this;
                                                      }
                                                  } ),
                    props = animation.props;

                propFilter( props, animation.opts.specialEasing );

                for ( ; index < length ; index++ ) {
                    result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
                    if ( result ) {
                        if ( jQuery.isFunction( result.stop ) ) {
                            jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
                                jQuery.proxy( result.stop, result );
                        }
                        return result;
                    }
                }

                jQuery.map( props, createTween, animation );

                if ( jQuery.isFunction( animation.opts.start ) ) {
                    animation.opts.start.call( elem, animation );
                }

                jQuery.fx.timer(
                    jQuery.extend( tick, {
                        elem: elem,
                        anim: animation,
                        queue: animation.opts.queue
                    } )
                );

                // attach callbacks from options
                return animation.progress( animation.opts.progress )
                    .done( animation.opts.done, animation.opts.complete )
                    .fail( animation.opts.fail )
                    .always( animation.opts.always );
            }

            jQuery.Animation = jQuery.extend( Animation, {
                tweeners: {
                    "*": [ function( prop, value ) {
                        var tween = this.createTween( prop, value );
                        adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
                        return tween;
                    } ]
                },

                tweener: function( props, callback ) {
                    if ( jQuery.isFunction( props ) ) {
                        callback = props;
                        props = [ "*" ];
                    } else {
                        props = props.match( rnotwhite );
                    }

                    var prop,
                        index = 0,
                        length = props.length;

                    for ( ; index < length ; index++ ) {
                        prop = props[ index ];
                        Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
                        Animation.tweeners[ prop ].unshift( callback );
                    }
                },

                prefilters: [ defaultPrefilter ],

                prefilter: function( callback, prepend ) {
                    if ( prepend ) {
                        Animation.prefilters.unshift( callback );
                    } else {
                        Animation.prefilters.push( callback );
                    }
                }
            } );

            jQuery.speed = function( speed, easing, fn ) {
                var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
                    complete: fn || !fn && easing ||
                              jQuery.isFunction( speed ) && speed,
                    duration: speed,
                    easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
                };

                opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ?
                    opt.duration : opt.duration in jQuery.fx.speeds ?
                        jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

                // Normalize opt.queue - true/undefined/null -> "fx"
                if ( opt.queue == null || opt.queue === true ) {
                    opt.queue = "fx";
                }

                // Queueing
                opt.old = opt.complete;

                opt.complete = function() {
                    if ( jQuery.isFunction( opt.old ) ) {
                        opt.old.call( this );
                    }

                    if ( opt.queue ) {
                        jQuery.dequeue( this, opt.queue );
                    }
                };

                return opt;
            };

            jQuery.fn.extend( {
                                  fadeTo: function( speed, to, easing, callback ) {

                                      // Show any hidden elements after setting opacity to 0
                                      return this.filter( isHidden ).css( "opacity", 0 ).show()

                                          // Animate to the value specified
                                          .end().animate( { opacity: to }, speed, easing, callback );
                                  },
                                  animate: function( prop, speed, easing, callback ) {
                                      var empty = jQuery.isEmptyObject( prop ),
                                          optall = jQuery.speed( speed, easing, callback ),
                                          doAnimation = function() {

                                              // Operate on a copy of prop so per-property easing won't be lost
                                              var anim = Animation( this, jQuery.extend( {}, prop ), optall );

                                              // Empty animations, or finishing resolves immediately
                                              if ( empty || dataPriv.get( this, "finish" ) ) {
                                                  anim.stop( true );
                                              }
                                          };
                                      doAnimation.finish = doAnimation;

                                      return empty || optall.queue === false ?
                                          this.each( doAnimation ) :
                                          this.queue( optall.queue, doAnimation );
                                  },
                                  stop: function( type, clearQueue, gotoEnd ) {
                                      var stopQueue = function( hooks ) {
                                          var stop = hooks.stop;
                                          delete hooks.stop;
                                          stop( gotoEnd );
                                      };

                                      if ( typeof type !== "string" ) {
                                          gotoEnd = clearQueue;
                                          clearQueue = type;
                                          type = undefined;
                                      }
                                      if ( clearQueue && type !== false ) {
                                          this.queue( type || "fx", [] );
                                      }

                                      return this.each( function() {
                                          var dequeue = true,
                                              index = type != null && type + "queueHooks",
                                              timers = jQuery.timers,
                                              data = dataPriv.get( this );

                                          if ( index ) {
                                              if ( data[ index ] && data[ index ].stop ) {
                                                  stopQueue( data[ index ] );
                                              }
                                          } else {
                                              for ( index in data ) {
                                                  if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
                                                      stopQueue( data[ index ] );
                                                  }
                                              }
                                          }

                                          for ( index = timers.length; index--; ) {
                                              if ( timers[ index ].elem === this &&
                                                   ( type == null || timers[ index ].queue === type ) ) {

                                                  timers[ index ].anim.stop( gotoEnd );
                                                  dequeue = false;
                                                  timers.splice( index, 1 );
                                              }
                                          }

                                          // Start the next in the queue if the last step wasn't forced.
                                          // Timers currently will call their complete callbacks, which
                                          // will dequeue but only if they were gotoEnd.
                                          if ( dequeue || !gotoEnd ) {
                                              jQuery.dequeue( this, type );
                                          }
                                      } );
                                  },
                                  finish: function( type ) {
                                      if ( type !== false ) {
                                          type = type || "fx";
                                      }
                                      return this.each( function() {
                                          var index,
                                              data = dataPriv.get( this ),
                                              queue = data[ type + "queue" ],
                                              hooks = data[ type + "queueHooks" ],
                                              timers = jQuery.timers,
                                              length = queue ? queue.length : 0;

                                          // Enable finishing flag on private data
                                          data.finish = true;

                                          // Empty the queue first
                                          jQuery.queue( this, type, [] );

                                          if ( hooks && hooks.stop ) {
                                              hooks.stop.call( this, true );
                                          }

                                          // Look for any active animations, and finish them
                                          for ( index = timers.length; index--; ) {
                                              if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
                                                  timers[ index ].anim.stop( true );
                                                  timers.splice( index, 1 );
                                              }
                                          }

                                          // Look for any animations in the old queue and finish them
                                          for ( index = 0; index < length; index++ ) {
                                              if ( queue[ index ] && queue[ index ].finish ) {
                                                  queue[ index ].finish.call( this );
                                              }
                                          }

                                          // Turn off finishing flag
                                          delete data.finish;
                                      } );
                                  }
                              } );

            jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
                var cssFn = jQuery.fn[ name ];
                jQuery.fn[ name ] = function( speed, easing, callback ) {
                    return speed == null || typeof speed === "boolean" ?
                        cssFn.apply( this, arguments ) :
                        this.animate( genFx( name, true ), speed, easing, callback );
                };
            } );

// Generate shortcuts for custom animations
            jQuery.each( {
                             slideDown: genFx( "show" ),
                             slideUp: genFx( "hide" ),
                             slideToggle: genFx( "toggle" ),
                             fadeIn: { opacity: "show" },
                             fadeOut: { opacity: "hide" },
                             fadeToggle: { opacity: "toggle" }
                         }, function( name, props ) {
                jQuery.fn[ name ] = function( speed, easing, callback ) {
                    return this.animate( props, speed, easing, callback );
                };
            } );

            jQuery.timers = [];
            jQuery.fx.tick = function() {
                var timer,
                    i = 0,
                    timers = jQuery.timers;

                fxNow = jQuery.now();

                for ( ; i < timers.length; i++ ) {
                    timer = timers[ i ];

                    // Checks the timer has not already been removed
                    if ( !timer() && timers[ i ] === timer ) {
                        timers.splice( i--, 1 );
                    }
                }

                if ( !timers.length ) {
                    jQuery.fx.stop();
                }
                fxNow = undefined;
            };

            jQuery.fx.timer = function( timer ) {
                jQuery.timers.push( timer );
                if ( timer() ) {
                    jQuery.fx.start();
                } else {
                    jQuery.timers.pop();
                }
            };

            jQuery.fx.interval = 13;
            jQuery.fx.start = function() {
                if ( !timerId ) {
                    timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
                }
            };

            jQuery.fx.stop = function() {
                window.clearInterval( timerId );

                timerId = null;
            };

            jQuery.fx.speeds = {
                slow: 600,
                fast: 200,

                // Default speed
                _default: 400
            };


// Based off of the plugin by Clint Helfers, with permission.
// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
            jQuery.fn.delay = function( time, type ) {
                time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
                type = type || "fx";

                return this.queue( type, function( next, hooks ) {
                    var timeout = window.setTimeout( next, time );
                    hooks.stop = function() {
                        window.clearTimeout( timeout );
                    };
                } );
            };


            ( function() {
                var input = document.createElement( "input" ),
                    select = document.createElement( "select" ),
                    opt = select.appendChild( document.createElement( "option" ) );

                input.type = "checkbox";

                // Support: iOS<=5.1, Android<=4.2+
                // Default value for a checkbox should be "on"
                support.checkOn = input.value !== "";

                // Support: IE<=11+
                // Must access selectedIndex to make default options select
                support.optSelected = opt.selected;

                // Support: Android<=2.3
                // Options inside disabled selects are incorrectly marked as disabled
                select.disabled = true;
                support.optDisabled = !opt.disabled;

                // Support: IE<=11+
                // An input loses its value after becoming a radio
                input = document.createElement( "input" );
                input.value = "t";
                input.type = "radio";
                support.radioValue = input.value === "t";
            } )();


            var boolHook,
                attrHandle = jQuery.expr.attrHandle;

            jQuery.fn.extend( {
                                  attr: function( name, value ) {
                                      return access( this, jQuery.attr, name, value, arguments.length > 1 );
                                  },

                                  removeAttr: function( name ) {
                                      return this.each( function() {
                                          jQuery.removeAttr( this, name );
                                      } );
                                  }
                              } );

            jQuery.extend( {
                               attr: function( elem, name, value ) {
                                   var ret, hooks,
                                       nType = elem.nodeType;

                                   // Don't get/set attributes on text, comment and attribute nodes
                                   if ( nType === 3 || nType === 8 || nType === 2 ) {
                                       return;
                                   }

                                   // Fallback to prop when attributes are not supported
                                   if ( typeof elem.getAttribute === "undefined" ) {
                                       return jQuery.prop( elem, name, value );
                                   }

                                   // All attributes are lowercase
                                   // Grab necessary hook if one is defined
                                   if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
                                       name = name.toLowerCase();
                                       hooks = jQuery.attrHooks[ name ] ||
                                               ( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
                                   }

                                   if ( value !== undefined ) {
                                       if ( value === null ) {
                                           jQuery.removeAttr( elem, name );
                                           return;
                                       }

                                       if ( hooks && "set" in hooks &&
                                            ( ret = hooks.set( elem, value, name ) ) !== undefined ) {
                                           return ret;
                                       }

                                       elem.setAttribute( name, value + "" );
                                       return value;
                                   }

                                   if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
                                       return ret;
                                   }

                                   ret = jQuery.find.attr( elem, name );

                                   // Non-existent attributes return null, we normalize to undefined
                                   return ret == null ? undefined : ret;
                               },

                               attrHooks: {
                                   type: {
                                       set: function( elem, value ) {
                                           if ( !support.radioValue && value === "radio" &&
                                                jQuery.nodeName( elem, "input" ) ) {
                                               var val = elem.value;
                                               elem.setAttribute( "type", value );
                                               if ( val ) {
                                                   elem.value = val;
                                               }
                                               return value;
                                           }
                                       }
                                   }
                               },

                               removeAttr: function( elem, value ) {
                                   var name, propName,
                                       i = 0,
                                       attrNames = value && value.match( rnotwhite );

                                   if ( attrNames && elem.nodeType === 1 ) {
                                       while ( ( name = attrNames[ i++ ] ) ) {
                                           propName = jQuery.propFix[ name ] || name;

                                           // Boolean attributes get special treatment (#10870)
                                           if ( jQuery.expr.match.bool.test( name ) ) {

                                               // Set corresponding property to false
                                               elem[ propName ] = false;
                                           }

                                           elem.removeAttribute( name );
                                       }
                                   }
                               }
                           } );

// Hooks for boolean attributes
            boolHook = {
                set: function( elem, value, name ) {
                    if ( value === false ) {

                        // Remove boolean attributes when set to false
                        jQuery.removeAttr( elem, name );
                    } else {
                        elem.setAttribute( name, name );
                    }
                    return name;
                }
            };
            jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
                var getter = attrHandle[ name ] || jQuery.find.attr;

                attrHandle[ name ] = function( elem, name, isXML ) {
                    var ret, handle;
                    if ( !isXML ) {

                        // Avoid an infinite loop by temporarily removing this function from the getter
                        handle = attrHandle[ name ];
                        attrHandle[ name ] = ret;
                        ret = getter( elem, name, isXML ) != null ?
                            name.toLowerCase() :
                            null;
                        attrHandle[ name ] = handle;
                    }
                    return ret;
                };
            } );




            var rfocusable = /^(?:input|select|textarea|button)$/i,
                rclickable = /^(?:a|area)$/i;

            jQuery.fn.extend( {
                                  prop: function( name, value ) {
                                      return access( this, jQuery.prop, name, value, arguments.length > 1 );
                                  },

                                  removeProp: function( name ) {
                                      return this.each( function() {
                                          delete this[ jQuery.propFix[ name ] || name ];
                                      } );
                                  }
                              } );

            jQuery.extend( {
                               prop: function( elem, name, value ) {
                                   var ret, hooks,
                                       nType = elem.nodeType;

                                   // Don't get/set properties on text, comment and attribute nodes
                                   if ( nType === 3 || nType === 8 || nType === 2 ) {
                                       return;
                                   }

                                   if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

                                       // Fix name and attach hooks
                                       name = jQuery.propFix[ name ] || name;
                                       hooks = jQuery.propHooks[ name ];
                                   }

                                   if ( value !== undefined ) {
                                       if ( hooks && "set" in hooks &&
                                            ( ret = hooks.set( elem, value, name ) ) !== undefined ) {
                                           return ret;
                                       }

                                       return ( elem[ name ] = value );
                                   }

                                   if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
                                       return ret;
                                   }

                                   return elem[ name ];
                               },

                               propHooks: {
                                   tabIndex: {
                                       get: function( elem ) {

                                           // elem.tabIndex doesn't always return the
                                           // correct value when it hasn't been explicitly set
                                           // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                                           // Use proper attribute retrieval(#12072)
                                           var tabindex = jQuery.find.attr( elem, "tabindex" );

                                           return tabindex ?
                                               parseInt( tabindex, 10 ) :
                                               rfocusable.test( elem.nodeName ) ||
                                               rclickable.test( elem.nodeName ) && elem.href ?
                                                   0 :
                                                   -1;
                                       }
                                   }
                               },

                               propFix: {
                                   "for": "htmlFor",
                                   "class": "className"
                               }
                           } );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
            if ( !support.optSelected ) {
                jQuery.propHooks.selected = {
                    get: function( elem ) {
                        var parent = elem.parentNode;
                        if ( parent && parent.parentNode ) {
                            parent.parentNode.selectedIndex;
                        }
                        return null;
                    },
                    set: function( elem ) {
                        var parent = elem.parentNode;
                        if ( parent ) {
                            parent.selectedIndex;

                            if ( parent.parentNode ) {
                                parent.parentNode.selectedIndex;
                            }
                        }
                    }
                };
            }

            jQuery.each( [
                             "tabIndex",
                             "readOnly",
                             "maxLength",
                             "cellSpacing",
                             "cellPadding",
                             "rowSpan",
                             "colSpan",
                             "useMap",
                             "frameBorder",
                             "contentEditable"
                         ], function() {
                jQuery.propFix[ this.toLowerCase() ] = this;
            } );




            var rclass = /[\t\r\n\f]/g;

            function getClass( elem ) {
                return elem.getAttribute && elem.getAttribute( "class" ) || "";
            }

            jQuery.fn.extend( {
                                  addClass: function( value ) {
                                      var classes, elem, cur, curValue, clazz, j, finalValue,
                                          i = 0;

                                      if ( jQuery.isFunction( value ) ) {
                                          return this.each( function( j ) {
                                              jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
                                          } );
                                      }

                                      if ( typeof value === "string" && value ) {
                                          classes = value.match( rnotwhite ) || [];

                                          while ( ( elem = this[ i++ ] ) ) {
                                              curValue = getClass( elem );
                                              cur = elem.nodeType === 1 &&
                                                    ( " " + curValue + " " ).replace( rclass, " " );

                                              if ( cur ) {
                                                  j = 0;
                                                  while ( ( clazz = classes[ j++ ] ) ) {
                                                      if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
                                                          cur += clazz + " ";
                                                      }
                                                  }

                                                  // Only assign if different to avoid unneeded rendering.
                                                  finalValue = jQuery.trim( cur );
                                                  if ( curValue !== finalValue ) {
                                                      elem.setAttribute( "class", finalValue );
                                                  }
                                              }
                                          }
                                      }

                                      return this;
                                  },

                                  removeClass: function( value ) {
                                      var classes, elem, cur, curValue, clazz, j, finalValue,
                                          i = 0;

                                      if ( jQuery.isFunction( value ) ) {
                                          return this.each( function( j ) {
                                              jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
                                          } );
                                      }

                                      if ( !arguments.length ) {
                                          return this.attr( "class", "" );
                                      }

                                      if ( typeof value === "string" && value ) {
                                          classes = value.match( rnotwhite ) || [];

                                          while ( ( elem = this[ i++ ] ) ) {
                                              curValue = getClass( elem );

                                              // This expression is here for better compressibility (see addClass)
                                              cur = elem.nodeType === 1 &&
                                                    ( " " + curValue + " " ).replace( rclass, " " );

                                              if ( cur ) {
                                                  j = 0;
                                                  while ( ( clazz = classes[ j++ ] ) ) {

                                                      // Remove *all* instances
                                                      while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
                                                          cur = cur.replace( " " + clazz + " ", " " );
                                                      }
                                                  }

                                                  // Only assign if different to avoid unneeded rendering.
                                                  finalValue = jQuery.trim( cur );
                                                  if ( curValue !== finalValue ) {
                                                      elem.setAttribute( "class", finalValue );
                                                  }
                                              }
                                          }
                                      }

                                      return this;
                                  },

                                  toggleClass: function( value, stateVal ) {
                                      var type = typeof value;

                                      if ( typeof stateVal === "boolean" && type === "string" ) {
                                          return stateVal ? this.addClass( value ) : this.removeClass( value );
                                      }

                                      if ( jQuery.isFunction( value ) ) {
                                          return this.each( function( i ) {
                                              jQuery( this ).toggleClass(
                                                  value.call( this, i, getClass( this ), stateVal ),
                                                  stateVal
                                              );
                                          } );
                                      }

                                      return this.each( function() {
                                          var className, i, self, classNames;

                                          if ( type === "string" ) {

                                              // Toggle individual class names
                                              i = 0;
                                              self = jQuery( this );
                                              classNames = value.match( rnotwhite ) || [];

                                              while ( ( className = classNames[ i++ ] ) ) {

                                                  // Check each className given, space separated list
                                                  if ( self.hasClass( className ) ) {
                                                      self.removeClass( className );
                                                  } else {
                                                      self.addClass( className );
                                                  }
                                              }

                                              // Toggle whole class name
                                          } else if ( value === undefined || type === "boolean" ) {
                                              className = getClass( this );
                                              if ( className ) {

                                                  // Store className if set
                                                  dataPriv.set( this, "__className__", className );
                                              }

                                              // If the element has a class name or if we're passed `false`,
                                              // then remove the whole classname (if there was one, the above saved it).
                                              // Otherwise bring back whatever was previously saved (if anything),
                                              // falling back to the empty string if nothing was stored.
                                              if ( this.setAttribute ) {
                                                  this.setAttribute( "class",
                                                                     className || value === false ?
                                                                         "" :
                                                                         dataPriv.get( this, "__className__" ) || ""
                                                  );
                                              }
                                          }
                                      } );
                                  },

                                  hasClass: function( selector ) {
                                      var className, elem,
                                          i = 0;

                                      className = " " + selector + " ";
                                      while ( ( elem = this[ i++ ] ) ) {
                                          if ( elem.nodeType === 1 &&
                                               ( " " + getClass( elem ) + " " ).replace( rclass, " " )
                                                   .indexOf( className ) > -1
                                          ) {
                                              return true;
                                          }
                                      }

                                      return false;
                                  }
                              } );




            var rreturn = /\r/g,
                rspaces = /[\x20\t\r\n\f]+/g;

            jQuery.fn.extend( {
                                  val: function( value ) {
                                      var hooks, ret, isFunction,
                                          elem = this[ 0 ];

                                      if ( !arguments.length ) {
                                          if ( elem ) {
                                              hooks = jQuery.valHooks[ elem.type ] ||
                                                      jQuery.valHooks[ elem.nodeName.toLowerCase() ];

                                              if ( hooks &&
                                                   "get" in hooks &&
                                                   ( ret = hooks.get( elem, "value" ) ) !== undefined
                                              ) {
                                                  return ret;
                                              }

                                              ret = elem.value;

                                              return typeof ret === "string" ?

                                                  // Handle most common string cases
                                                  ret.replace( rreturn, "" ) :

                                                  // Handle cases where value is null/undef or number
                                                  ret == null ? "" : ret;
                                          }

                                          return;
                                      }

                                      isFunction = jQuery.isFunction( value );

                                      return this.each( function( i ) {
                                          var val;

                                          if ( this.nodeType !== 1 ) {
                                              return;
                                          }

                                          if ( isFunction ) {
                                              val = value.call( this, i, jQuery( this ).val() );
                                          } else {
                                              val = value;
                                          }

                                          // Treat null/undefined as ""; convert numbers to string
                                          if ( val == null ) {
                                              val = "";

                                          } else if ( typeof val === "number" ) {
                                              val += "";

                                          } else if ( jQuery.isArray( val ) ) {
                                              val = jQuery.map( val, function( value ) {
                                                  return value == null ? "" : value + "";
                                              } );
                                          }

                                          hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

                                          // If set returns undefined, fall back to normal setting
                                          if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
                                              this.value = val;
                                          }
                                      } );
                                  }
                              } );

            jQuery.extend( {
                               valHooks: {
                                   option: {
                                       get: function( elem ) {

                                           var val = jQuery.find.attr( elem, "value" );
                                           return val != null ?
                                               val :

                                               // Support: IE10-11+
                                               // option.text throws exceptions (#14686, #14858)
                                               // Strip and collapse whitespace
                                               // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                                               jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
                                       }
                                   },
                                   select: {
                                       get: function( elem ) {
                                           var value, option,
                                               options = elem.options,
                                               index = elem.selectedIndex,
                                               one = elem.type === "select-one" || index < 0,
                                               values = one ? null : [],
                                               max = one ? index + 1 : options.length,
                                               i = index < 0 ?
                                                   max :
                                                   one ? index : 0;

                                           // Loop through all the selected options
                                           for ( ; i < max; i++ ) {
                                               option = options[ i ];

                                               // IE8-9 doesn't update selected after form reset (#2551)
                                               if ( ( option.selected || i === index ) &&

                                                    // Don't return options that are disabled or in a disabled optgroup
                                                    ( support.optDisabled ?
                                                        !option.disabled : option.getAttribute( "disabled" ) === null ) &&
                                                    ( !option.parentNode.disabled ||
                                                      !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

                                                   // Get the specific value for the option
                                                   value = jQuery( option ).val();

                                                   // We don't need an array for one selects
                                                   if ( one ) {
                                                       return value;
                                                   }

                                                   // Multi-Selects return an array
                                                   values.push( value );
                                               }
                                           }

                                           return values;
                                       },

                                       set: function( elem, value ) {
                                           var optionSet, option,
                                               options = elem.options,
                                               values = jQuery.makeArray( value ),
                                               i = options.length;

                                           while ( i-- ) {
                                               option = options[ i ];
                                               if ( option.selected =
                                                   jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
                                               ) {
                                                   optionSet = true;
                                               }
                                           }

                                           // Force browsers to behave consistently when non-matching value is set
                                           if ( !optionSet ) {
                                               elem.selectedIndex = -1;
                                           }
                                           return values;
                                       }
                                   }
                               }
                           } );

// Radios and checkboxes getter/setter
            jQuery.each( [ "radio", "checkbox" ], function() {
                jQuery.valHooks[ this ] = {
                    set: function( elem, value ) {
                        if ( jQuery.isArray( value ) ) {
                            return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
                        }
                    }
                };
                if ( !support.checkOn ) {
                    jQuery.valHooks[ this ].get = function( elem ) {
                        return elem.getAttribute( "value" ) === null ? "on" : elem.value;
                    };
                }
            } );




// Return jQuery for attributes-only inclusion


            var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

            jQuery.extend( jQuery.event, {

                trigger: function( event, data, elem, onlyHandlers ) {

                    var i, cur, tmp, bubbleType, ontype, handle, special,
                        eventPath = [ elem || document ],
                        type = hasOwn.call( event, "type" ) ? event.type : event,
                        namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

                    cur = tmp = elem = elem || document;

                    // Don't do events on text and comment nodes
                    if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
                        return;
                    }

                    // focus/blur morphs to focusin/out; ensure we're not firing them right now
                    if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
                        return;
                    }

                    if ( type.indexOf( "." ) > -1 ) {

                        // Namespaced trigger; create a regexp to match event type in handle()
                        namespaces = type.split( "." );
                        type = namespaces.shift();
                        namespaces.sort();
                    }
                    ontype = type.indexOf( ":" ) < 0 && "on" + type;

                    // Caller can pass in a jQuery.Event object, Object, or just an event type string
                    event = event[ jQuery.expando ] ?
                        event :
                        new jQuery.Event( type, typeof event === "object" && event );

                    // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
                    event.isTrigger = onlyHandlers ? 2 : 3;
                    event.namespace = namespaces.join( "." );
                    event.rnamespace = event.namespace ?
                        new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
                        null;

                    // Clean up the event in case it is being reused
                    event.result = undefined;
                    if ( !event.target ) {
                        event.target = elem;
                    }

                    // Clone any incoming data and prepend the event, creating the handler arg list
                    data = data == null ?
                        [ event ] :
                        jQuery.makeArray( data, [ event ] );

                    // Allow special events to draw outside the lines
                    special = jQuery.event.special[ type ] || {};
                    if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
                        return;
                    }

                    // Determine event propagation path in advance, per W3C events spec (#9951)
                    // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
                    if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

                        bubbleType = special.delegateType || type;
                        if ( !rfocusMorph.test( bubbleType + type ) ) {
                            cur = cur.parentNode;
                        }
                        for ( ; cur; cur = cur.parentNode ) {
                            eventPath.push( cur );
                            tmp = cur;
                        }

                        // Only add window if we got to document (e.g., not plain obj or detached DOM)
                        if ( tmp === ( elem.ownerDocument || document ) ) {
                            eventPath.push( tmp.defaultView || tmp.parentWindow || window );
                        }
                    }

                    // Fire handlers on the event path
                    i = 0;
                    while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

                        event.type = i > 1 ?
                            bubbleType :
                            special.bindType || type;

                        // jQuery handler
                        handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
                                 dataPriv.get( cur, "handle" );
                        if ( handle ) {
                            handle.apply( cur, data );
                        }

                        // Native handler
                        handle = ontype && cur[ ontype ];
                        if ( handle && handle.apply && acceptData( cur ) ) {
                            event.result = handle.apply( cur, data );
                            if ( event.result === false ) {
                                event.preventDefault();
                            }
                        }
                    }
                    event.type = type;

                    // If nobody prevented the default action, do it now
                    if ( !onlyHandlers && !event.isDefaultPrevented() ) {

                        if ( ( !special._default ||
                               special._default.apply( eventPath.pop(), data ) === false ) &&
                             acceptData( elem ) ) {

                            // Call a native DOM method on the target with the same name name as the event.
                            // Don't do default actions on window, that's where global variables be (#6170)
                            if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

                                // Don't re-trigger an onFOO event when we call its FOO() method
                                tmp = elem[ ontype ];

                                if ( tmp ) {
                                    elem[ ontype ] = null;
                                }

                                // Prevent re-triggering of the same event, since we already bubbled it above
                                jQuery.event.triggered = type;
                                elem[ type ]();
                                jQuery.event.triggered = undefined;

                                if ( tmp ) {
                                    elem[ ontype ] = tmp;
                                }
                            }
                        }
                    }

                    return event.result;
                },

                // Piggyback on a donor event to simulate a different one
                // Used only for `focus(in | out)` events
                simulate: function( type, elem, event ) {
                    var e = jQuery.extend(
                        new jQuery.Event(),
                        event,
                        {
                            type: type,
                            isSimulated: true
                        }
                    );

                    jQuery.event.trigger( e, null, elem );
                }

            } );

            jQuery.fn.extend( {

                                  trigger: function( type, data ) {
                                      return this.each( function() {
                                          jQuery.event.trigger( type, data, this );
                                      } );
                                  },
                                  triggerHandler: function( type, data ) {
                                      var elem = this[ 0 ];
                                      if ( elem ) {
                                          return jQuery.event.trigger( type, data, elem, true );
                                      }
                                  }
                              } );


            jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
                           "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
                           "change select submit keydown keypress keyup error contextmenu" ).split( " " ),
                         function( i, name ) {

                             // Handle event binding
                             jQuery.fn[ name ] = function( data, fn ) {
                                 return arguments.length > 0 ?
                                     this.on( name, null, data, fn ) :
                                     this.trigger( name );
                             };
                         } );

            jQuery.fn.extend( {
                                  hover: function( fnOver, fnOut ) {
                                      return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
                                  }
                              } );




            support.focusin = "onfocusin" in window;


// Support: Firefox
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome, Safari
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
            if ( !support.focusin ) {
                jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

                    // Attach a single capturing handler on the document while someone wants focusin/focusout
                    var handler = function( event ) {
                        jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
                    };

                    jQuery.event.special[ fix ] = {
                        setup: function() {
                            var doc = this.ownerDocument || this,
                                attaches = dataPriv.access( doc, fix );

                            if ( !attaches ) {
                                doc.addEventListener( orig, handler, true );
                            }
                            dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
                        },
                        teardown: function() {
                            var doc = this.ownerDocument || this,
                                attaches = dataPriv.access( doc, fix ) - 1;

                            if ( !attaches ) {
                                doc.removeEventListener( orig, handler, true );
                                dataPriv.remove( doc, fix );

                            } else {
                                dataPriv.access( doc, fix, attaches );
                            }
                        }
                    };
                } );
            }
            var location = window.location;

            var nonce = jQuery.now();

            var rquery = ( /\?/ );



// Support: Android 2.3
// Workaround failure to string-cast null input
            jQuery.parseJSON = function( data ) {
                return JSON.parse( data + "" );
            };


// Cross-browser xml parsing
            jQuery.parseXML = function( data ) {
                var xml;
                if ( !data || typeof data !== "string" ) {
                    return null;
                }

                // Support: IE9
                try {
                    xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
                } catch ( e ) {
                    xml = undefined;
                }

                if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
                    jQuery.error( "Invalid XML: " + data );
                }
                return xml;
            };


            var
                rhash = /#.*$/,
                rts = /([?&])_=[^&]*/,
                rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

                // #7653, #8125, #8152: local protocol detection
                rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
                rnoContent = /^(?:GET|HEAD)$/,
                rprotocol = /^\/\//,

                /* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
                prefilters = {},

                /* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
                transports = {},

                // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
                allTypes = "*/".concat( "*" ),

                // Anchor tag for parsing the document origin
                originAnchor = document.createElement( "a" );
            originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
            function addToPrefiltersOrTransports( structure ) {

                // dataTypeExpression is optional and defaults to "*"
                return function( dataTypeExpression, func ) {

                    if ( typeof dataTypeExpression !== "string" ) {
                        func = dataTypeExpression;
                        dataTypeExpression = "*";
                    }

                    var dataType,
                        i = 0,
                        dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

                    if ( jQuery.isFunction( func ) ) {

                        // For each dataType in the dataTypeExpression
                        while ( ( dataType = dataTypes[ i++ ] ) ) {

                            // Prepend if requested
                            if ( dataType[ 0 ] === "+" ) {
                                dataType = dataType.slice( 1 ) || "*";
                                ( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

                                // Otherwise append
                            } else {
                                ( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
                            }
                        }
                    }
                };
            }

// Base inspection function for prefilters and transports
            function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

                var inspected = {},
                    seekingTransport = ( structure === transports );

                function inspect( dataType ) {
                    var selected;
                    inspected[ dataType ] = true;
                    jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
                        var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
                        if ( typeof dataTypeOrTransport === "string" &&
                             !seekingTransport && !inspected[ dataTypeOrTransport ] ) {

                            options.dataTypes.unshift( dataTypeOrTransport );
                            inspect( dataTypeOrTransport );
                            return false;
                        } else if ( seekingTransport ) {
                            return !( selected = dataTypeOrTransport );
                        }
                    } );
                    return selected;
                }

                return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
            }

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
            function ajaxExtend( target, src ) {
                var key, deep,
                    flatOptions = jQuery.ajaxSettings.flatOptions || {};

                for ( key in src ) {
                    if ( src[ key ] !== undefined ) {
                        ( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
                    }
                }
                if ( deep ) {
                    jQuery.extend( true, target, deep );
                }

                return target;
            }

            /* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
            function ajaxHandleResponses( s, jqXHR, responses ) {

                var ct, type, finalDataType, firstDataType,
                    contents = s.contents,
                    dataTypes = s.dataTypes;

                // Remove auto dataType and get content-type in the process
                while ( dataTypes[ 0 ] === "*" ) {
                    dataTypes.shift();
                    if ( ct === undefined ) {
                        ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
                    }
                }

                // Check if we're dealing with a known content-type
                if ( ct ) {
                    for ( type in contents ) {
                        if ( contents[ type ] && contents[ type ].test( ct ) ) {
                            dataTypes.unshift( type );
                            break;
                        }
                    }
                }

                // Check to see if we have a response for the expected dataType
                if ( dataTypes[ 0 ] in responses ) {
                    finalDataType = dataTypes[ 0 ];
                } else {

                    // Try convertible dataTypes
                    for ( type in responses ) {
                        if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
                            finalDataType = type;
                            break;
                        }
                        if ( !firstDataType ) {
                            firstDataType = type;
                        }
                    }

                    // Or just use first one
                    finalDataType = finalDataType || firstDataType;
                }

                // If we found a dataType
                // We add the dataType to the list if needed
                // and return the corresponding response
                if ( finalDataType ) {
                    if ( finalDataType !== dataTypes[ 0 ] ) {
                        dataTypes.unshift( finalDataType );
                    }
                    return responses[ finalDataType ];
                }
            }

            /* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
            function ajaxConvert( s, response, jqXHR, isSuccess ) {
                var conv2, current, conv, tmp, prev,
                    converters = {},

                    // Work with a copy of dataTypes in case we need to modify it for conversion
                    dataTypes = s.dataTypes.slice();

                // Create converters map with lowercased keys
                if ( dataTypes[ 1 ] ) {
                    for ( conv in s.converters ) {
                        converters[ conv.toLowerCase() ] = s.converters[ conv ];
                    }
                }

                current = dataTypes.shift();

                // Convert to each sequential dataType
                while ( current ) {

                    if ( s.responseFields[ current ] ) {
                        jqXHR[ s.responseFields[ current ] ] = response;
                    }

                    // Apply the dataFilter if provided
                    if ( !prev && isSuccess && s.dataFilter ) {
                        response = s.dataFilter( response, s.dataType );
                    }

                    prev = current;
                    current = dataTypes.shift();

                    if ( current ) {

                        // There's only work to do if current dataType is non-auto
                        if ( current === "*" ) {

                            current = prev;

                            // Convert response if prev dataType is non-auto and differs from current
                        } else if ( prev !== "*" && prev !== current ) {

                            // Seek a direct converter
                            conv = converters[ prev + " " + current ] || converters[ "* " + current ];

                            // If none found, seek a pair
                            if ( !conv ) {
                                for ( conv2 in converters ) {

                                    // If conv2 outputs current
                                    tmp = conv2.split( " " );
                                    if ( tmp[ 1 ] === current ) {

                                        // If prev can be converted to accepted input
                                        conv = converters[ prev + " " + tmp[ 0 ] ] ||
                                               converters[ "* " + tmp[ 0 ] ];
                                        if ( conv ) {

                                            // Condense equivalence converters
                                            if ( conv === true ) {
                                                conv = converters[ conv2 ];

                                                // Otherwise, insert the intermediate dataType
                                            } else if ( converters[ conv2 ] !== true ) {
                                                current = tmp[ 0 ];
                                                dataTypes.unshift( tmp[ 1 ] );
                                            }
                                            break;
                                        }
                                    }
                                }
                            }

                            // Apply converter (if not an equivalence)
                            if ( conv !== true ) {

                                // Unless errors are allowed to bubble, catch and return them
                                if ( conv && s.throws ) {
                                    response = conv( response );
                                } else {
                                    try {
                                        response = conv( response );
                                    } catch ( e ) {
                                        return {
                                            state: "parsererror",
                                            error: conv ? e : "No conversion from " + prev + " to " + current
                                        };
                                    }
                                }
                            }
                        }
                    }
                }

                return { state: "success", data: response };
            }

            jQuery.extend( {

                               // Counter for holding the number of active queries
                               active: 0,

                               // Last-Modified header cache for next request
                               lastModified: {},
                               etag: {},

                               ajaxSettings: {
                                   url: location.href,
                                   type: "GET",
                                   isLocal: rlocalProtocol.test( location.protocol ),
                                   global: true,
                                   processData: true,
                                   async: true,
                                   contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                                   /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

                                   accepts: {
                                       "*": allTypes,
                                       text: "text/plain",
                                       html: "text/html",
                                       xml: "application/xml, text/xml",
                                       json: "application/json, text/javascript"
                                   },

                                   contents: {
                                       xml: /\bxml\b/,
                                       html: /\bhtml/,
                                       json: /\bjson\b/
                                   },

                                   responseFields: {
                                       xml: "responseXML",
                                       text: "responseText",
                                       json: "responseJSON"
                                   },

                                   // Data converters
                                   // Keys separate source (or catchall "*") and destination types with a single space
                                   converters: {

                                       // Convert anything to text
                                       "* text": String,

                                       // Text to html (true = no transformation)
                                       "text html": true,

                                       // Evaluate text as a json expression
                                       "text json": jQuery.parseJSON,

                                       // Parse text as xml
                                       "text xml": jQuery.parseXML
                                   },

                                   // For options that shouldn't be deep extended:
                                   // you can add your own custom options here if
                                   // and when you create one that shouldn't be
                                   // deep extended (see ajaxExtend)
                                   flatOptions: {
                                       url: true,
                                       context: true
                                   }
                               },

                               // Creates a full fledged settings object into target
                               // with both ajaxSettings and settings fields.
                               // If target is omitted, writes into ajaxSettings.
                               ajaxSetup: function( target, settings ) {
                                   return settings ?

                                       // Building a settings object
                                       ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

                                       // Extending ajaxSettings
                                       ajaxExtend( jQuery.ajaxSettings, target );
                               },

                               ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
                               ajaxTransport: addToPrefiltersOrTransports( transports ),

                               // Main method
                               ajax: function( url, options ) {

                                   // If url is an object, simulate pre-1.5 signature
                                   if ( typeof url === "object" ) {
                                       options = url;
                                       url = undefined;
                                   }

                                   // Force options to be an object
                                   options = options || {};

                                   var transport,

                                       // URL without anti-cache param
                                       cacheURL,

                                       // Response headers
                                       responseHeadersString,
                                       responseHeaders,

                                       // timeout handle
                                       timeoutTimer,

                                       // Url cleanup var
                                       urlAnchor,

                                       // To know if global events are to be dispatched
                                       fireGlobals,

                                       // Loop variable
                                       i,

                                       // Create the final options object
                                       s = jQuery.ajaxSetup( {}, options ),

                                       // Callbacks context
                                       callbackContext = s.context || s,

                                       // Context for global events is callbackContext if it is a DOM node or jQuery collection
                                       globalEventContext = s.context &&
                                                            ( callbackContext.nodeType || callbackContext.jquery ) ?
                                           jQuery( callbackContext ) :
                                           jQuery.event,

                                       // Deferreds
                                       deferred = jQuery.Deferred(),
                                       completeDeferred = jQuery.Callbacks( "once memory" ),

                                       // Status-dependent callbacks
                                       statusCode = s.statusCode || {},

                                       // Headers (they are sent all at once)
                                       requestHeaders = {},
                                       requestHeadersNames = {},

                                       // The jqXHR state
                                       state = 0,

                                       // Default abort message
                                       strAbort = "canceled",

                                       // Fake xhr
                                       jqXHR = {
                                           readyState: 0,

                                           // Builds headers hashtable if needed
                                           getResponseHeader: function( key ) {
                                               var match;
                                               if ( state === 2 ) {
                                                   if ( !responseHeaders ) {
                                                       responseHeaders = {};
                                                       while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
                                                           responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
                                                       }
                                                   }
                                                   match = responseHeaders[ key.toLowerCase() ];
                                               }
                                               return match == null ? null : match;
                                           },

                                           // Raw string
                                           getAllResponseHeaders: function() {
                                               return state === 2 ? responseHeadersString : null;
                                           },

                                           // Caches the header
                                           setRequestHeader: function( name, value ) {
                                               var lname = name.toLowerCase();
                                               if ( !state ) {
                                                   name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                                                   requestHeaders[ name ] = value;
                                               }
                                               return this;
                                           },

                                           // Overrides response content-type header
                                           overrideMimeType: function( type ) {
                                               if ( !state ) {
                                                   s.mimeType = type;
                                               }
                                               return this;
                                           },

                                           // Status-dependent callbacks
                                           statusCode: function( map ) {
                                               var code;
                                               if ( map ) {
                                                   if ( state < 2 ) {
                                                       for ( code in map ) {

                                                           // Lazy-add the new callback in a way that preserves old ones
                                                           statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
                                                       }
                                                   } else {

                                                       // Execute the appropriate callbacks
                                                       jqXHR.always( map[ jqXHR.status ] );
                                                   }
                                               }
                                               return this;
                                           },

                                           // Cancel the request
                                           abort: function( statusText ) {
                                               var finalText = statusText || strAbort;
                                               if ( transport ) {
                                                   transport.abort( finalText );
                                               }
                                               done( 0, finalText );
                                               return this;
                                           }
                                       };

                                   // Attach deferreds
                                   deferred.promise( jqXHR ).complete = completeDeferred.add;
                                   jqXHR.success = jqXHR.done;
                                   jqXHR.error = jqXHR.fail;

                                   // Remove hash character (#7531: and string promotion)
                                   // Add protocol if not provided (prefilters might expect it)
                                   // Handle falsy url in the settings object (#10093: consistency with old signature)
                                   // We also use the url parameter if available
                                   s.url = ( ( url || s.url || location.href ) + "" ).replace( rhash, "" )
                                       .replace( rprotocol, location.protocol + "//" );

                                   // Alias method option to type as per ticket #12004
                                   s.type = options.method || options.type || s.method || s.type;

                                   // Extract dataTypes list
                                   s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

                                   // A cross-domain request is in order when the origin doesn't match the current origin.
                                   if ( s.crossDomain == null ) {
                                       urlAnchor = document.createElement( "a" );

                                       // Support: IE8-11+
                                       // IE throws exception if url is malformed, e.g. http://example.com:80x/
                                       try {
                                           urlAnchor.href = s.url;

                                           // Support: IE8-11+
                                           // Anchor's host property isn't correctly set when s.url is relative
                                           urlAnchor.href = urlAnchor.href;
                                           s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
                                                           urlAnchor.protocol + "//" + urlAnchor.host;
                                       } catch ( e ) {

                                           // If there is an error parsing the URL, assume it is crossDomain,
                                           // it can be rejected by the transport if it is invalid
                                           s.crossDomain = true;
                                       }
                                   }

                                   // Convert data if not already a string
                                   if ( s.data && s.processData && typeof s.data !== "string" ) {
                                       s.data = jQuery.param( s.data, s.traditional );
                                   }

                                   // Apply prefilters
                                   inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

                                   // If request was aborted inside a prefilter, stop there
                                   if ( state === 2 ) {
                                       return jqXHR;
                                   }

                                   // We can fire global events as of now if asked to
                                   // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
                                   fireGlobals = jQuery.event && s.global;

                                   // Watch for a new set of requests
                                   if ( fireGlobals && jQuery.active++ === 0 ) {
                                       jQuery.event.trigger( "ajaxStart" );
                                   }

                                   // Uppercase the type
                                   s.type = s.type.toUpperCase();

                                   // Determine if request has content
                                   s.hasContent = !rnoContent.test( s.type );

                                   // Save the URL in case we're toying with the If-Modified-Since
                                   // and/or If-None-Match header later on
                                   cacheURL = s.url;

                                   // More options handling for requests with no content
                                   if ( !s.hasContent ) {

                                       // If data is available, append data to url
                                       if ( s.data ) {
                                           cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );

                                           // #9682: remove data so that it's not used in an eventual retry
                                           delete s.data;
                                       }

                                       // Add anti-cache in url if needed
                                       if ( s.cache === false ) {
                                           s.url = rts.test( cacheURL ) ?

                                               // If there is already a '_' parameter, set its value
                                               cacheURL.replace( rts, "$1_=" + nonce++ ) :

                                               // Otherwise add one to the end
                                               cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
                                       }
                                   }

                                   // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                                   if ( s.ifModified ) {
                                       if ( jQuery.lastModified[ cacheURL ] ) {
                                           jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
                                       }
                                       if ( jQuery.etag[ cacheURL ] ) {
                                           jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
                                       }
                                   }

                                   // Set the correct header, if data is being sent
                                   if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
                                       jqXHR.setRequestHeader( "Content-Type", s.contentType );
                                   }

                                   // Set the Accepts header for the server, depending on the dataType
                                   jqXHR.setRequestHeader(
                                       "Accept",
                                       s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
                                           s.accepts[ s.dataTypes[ 0 ] ] +
                                           ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
                                           s.accepts[ "*" ]
                                   );

                                   // Check for headers option
                                   for ( i in s.headers ) {
                                       jqXHR.setRequestHeader( i, s.headers[ i ] );
                                   }

                                   // Allow custom headers/mimetypes and early abort
                                   if ( s.beforeSend &&
                                        ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {

                                       // Abort if not done already and return
                                       return jqXHR.abort();
                                   }

                                   // Aborting is no longer a cancellation
                                   strAbort = "abort";

                                   // Install callbacks on deferreds
                                   for ( i in { success: 1, error: 1, complete: 1 } ) {
                                       jqXHR[ i ]( s[ i ] );
                                   }

                                   // Get transport
                                   transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

                                   // If no transport, we auto-abort
                                   if ( !transport ) {
                                       done( -1, "No Transport" );
                                   } else {
                                       jqXHR.readyState = 1;

                                       // Send global event
                                       if ( fireGlobals ) {
                                           globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
                                       }

                                       // If request was aborted inside ajaxSend, stop there
                                       if ( state === 2 ) {
                                           return jqXHR;
                                       }

                                       // Timeout
                                       if ( s.async && s.timeout > 0 ) {
                                           timeoutTimer = window.setTimeout( function() {
                                               jqXHR.abort( "timeout" );
                                           }, s.timeout );
                                       }

                                       try {
                                           state = 1;
                                           transport.send( requestHeaders, done );
                                       } catch ( e ) {

                                           // Propagate exception as error if not done
                                           if ( state < 2 ) {
                                               done( -1, e );

                                               // Simply rethrow otherwise
                                           } else {
                                               throw e;
                                           }
                                       }
                                   }

                                   // Callback for when everything is done
                                   function done( status, nativeStatusText, responses, headers ) {
                                       var isSuccess, success, error, response, modified,
                                           statusText = nativeStatusText;

                                       // Called once
                                       if ( state === 2 ) {
                                           return;
                                       }

                                       // State is "done" now
                                       state = 2;

                                       // Clear timeout if it exists
                                       if ( timeoutTimer ) {
                                           window.clearTimeout( timeoutTimer );
                                       }

                                       // Dereference transport for early garbage collection
                                       // (no matter how long the jqXHR object will be used)
                                       transport = undefined;

                                       // Cache response headers
                                       responseHeadersString = headers || "";

                                       // Set readyState
                                       jqXHR.readyState = status > 0 ? 4 : 0;

                                       // Determine if successful
                                       isSuccess = status >= 200 && status < 300 || status === 304;

                                       // Get response data
                                       if ( responses ) {
                                           response = ajaxHandleResponses( s, jqXHR, responses );
                                       }

                                       // Convert no matter what (that way responseXXX fields are always set)
                                       response = ajaxConvert( s, response, jqXHR, isSuccess );

                                       // If successful, handle type chaining
                                       if ( isSuccess ) {

                                           // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                                           if ( s.ifModified ) {
                                               modified = jqXHR.getResponseHeader( "Last-Modified" );
                                               if ( modified ) {
                                                   jQuery.lastModified[ cacheURL ] = modified;
                                               }
                                               modified = jqXHR.getResponseHeader( "etag" );
                                               if ( modified ) {
                                                   jQuery.etag[ cacheURL ] = modified;
                                               }
                                           }

                                           // if no content
                                           if ( status === 204 || s.type === "HEAD" ) {
                                               statusText = "nocontent";

                                               // if not modified
                                           } else if ( status === 304 ) {
                                               statusText = "notmodified";

                                               // If we have data, let's convert it
                                           } else {
                                               statusText = response.state;
                                               success = response.data;
                                               error = response.error;
                                               isSuccess = !error;
                                           }
                                       } else {

                                           // Extract error from statusText and normalize for non-aborts
                                           error = statusText;
                                           if ( status || !statusText ) {
                                               statusText = "error";
                                               if ( status < 0 ) {
                                                   status = 0;
                                               }
                                           }
                                       }

                                       // Set data for the fake xhr object
                                       jqXHR.status = status;
                                       jqXHR.statusText = ( nativeStatusText || statusText ) + "";

                                       // Success/Error
                                       if ( isSuccess ) {
                                           deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
                                       } else {
                                           deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
                                       }

                                       // Status-dependent callbacks
                                       jqXHR.statusCode( statusCode );
                                       statusCode = undefined;

                                       if ( fireGlobals ) {
                                           globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
                                                                       [ jqXHR, s, isSuccess ? success : error ] );
                                       }

                                       // Complete
                                       completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

                                       if ( fireGlobals ) {
                                           globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

                                           // Handle the global AJAX counter
                                           if ( !( --jQuery.active ) ) {
                                               jQuery.event.trigger( "ajaxStop" );
                                           }
                                       }
                                   }

                                   return jqXHR;
                               },

                               getJSON: function( url, data, callback ) {
                                   return jQuery.get( url, data, callback, "json" );
                               },

                               getScript: function( url, callback ) {
                                   return jQuery.get( url, undefined, callback, "script" );
                               }
                           } );

            jQuery.each( [ "get", "post" ], function( i, method ) {
                jQuery[ method ] = function( url, data, callback, type ) {

                    // Shift arguments if data argument was omitted
                    if ( jQuery.isFunction( data ) ) {
                        type = type || callback;
                        callback = data;
                        data = undefined;
                    }

                    // The url can be an options object (which then must have .url)
                    return jQuery.ajax( jQuery.extend( {
                                                           url: url,
                                                           type: method,
                                                           dataType: type,
                                                           data: data,
                                                           success: callback
                                                       }, jQuery.isPlainObject( url ) && url ) );
                };
            } );


            jQuery._evalUrl = function( url ) {
                return jQuery.ajax( {
                                        url: url,

                                        // Make this explicit, since user can override this through ajaxSetup (#11264)
                                        type: "GET",
                                        dataType: "script",
                                        async: false,
                                        global: false,
                                        "throws": true
                                    } );
            };


            jQuery.fn.extend( {
                                  wrapAll: function( html ) {
                                      var wrap;

                                      if ( jQuery.isFunction( html ) ) {
                                          return this.each( function( i ) {
                                              jQuery( this ).wrapAll( html.call( this, i ) );
                                          } );
                                      }

                                      if ( this[ 0 ] ) {

                                          // The elements to wrap the target around
                                          wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

                                          if ( this[ 0 ].parentNode ) {
                                              wrap.insertBefore( this[ 0 ] );
                                          }

                                          wrap.map( function() {
                                              var elem = this;

                                              while ( elem.firstElementChild ) {
                                                  elem = elem.firstElementChild;
                                              }

                                              return elem;
                                          } ).append( this );
                                      }

                                      return this;
                                  },

                                  wrapInner: function( html ) {
                                      if ( jQuery.isFunction( html ) ) {
                                          return this.each( function( i ) {
                                              jQuery( this ).wrapInner( html.call( this, i ) );
                                          } );
                                      }

                                      return this.each( function() {
                                          var self = jQuery( this ),
                                              contents = self.contents();

                                          if ( contents.length ) {
                                              contents.wrapAll( html );

                                          } else {
                                              self.append( html );
                                          }
                                      } );
                                  },

                                  wrap: function( html ) {
                                      var isFunction = jQuery.isFunction( html );

                                      return this.each( function( i ) {
                                          jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
                                      } );
                                  },

                                  unwrap: function() {
                                      return this.parent().each( function() {
                                          if ( !jQuery.nodeName( this, "body" ) ) {
                                              jQuery( this ).replaceWith( this.childNodes );
                                          }
                                      } ).end();
                                  }
                              } );


            jQuery.expr.filters.hidden = function( elem ) {
                return !jQuery.expr.filters.visible( elem );
            };
            jQuery.expr.filters.visible = function( elem ) {

                // Support: Opera <= 12.12
                // Opera reports offsetWidths and offsetHeights less than zero on some elements
                // Use OR instead of AND as the element is not visible if either is true
                // See tickets #10406 and #13132
                return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
            };




            var r20 = /%20/g,
                rbracket = /\[\]$/,
                rCRLF = /\r?\n/g,
                rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
                rsubmittable = /^(?:input|select|textarea|keygen)/i;

            function buildParams( prefix, obj, traditional, add ) {
                var name;

                if ( jQuery.isArray( obj ) ) {

                    // Serialize array item.
                    jQuery.each( obj, function( i, v ) {
                        if ( traditional || rbracket.test( prefix ) ) {

                            // Treat each array item as a scalar.
                            add( prefix, v );

                        } else {

                            // Item is non-scalar (array or object), encode its numeric index.
                            buildParams(
                                prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
                                v,
                                traditional,
                                add
                            );
                        }
                    } );

                } else if ( !traditional && jQuery.type( obj ) === "object" ) {

                    // Serialize object item.
                    for ( name in obj ) {
                        buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
                    }

                } else {

                    // Serialize scalar item.
                    add( prefix, obj );
                }
            }

// Serialize an array of form elements or a set of
// key/values into a query string
            jQuery.param = function( a, traditional ) {
                var prefix,
                    s = [],
                    add = function( key, value ) {

                        // If value is a function, invoke it and return its value
                        value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
                        s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
                    };

                // Set traditional to true for jQuery <= 1.3.2 behavior.
                if ( traditional === undefined ) {
                    traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
                }

                // If an array was passed in, assume that it is an array of form elements.
                if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

                    // Serialize the form elements
                    jQuery.each( a, function() {
                        add( this.name, this.value );
                    } );

                } else {

                    // If traditional, encode the "old" way (the way 1.3.2 or older
                    // did it), otherwise encode params recursively.
                    for ( prefix in a ) {
                        buildParams( prefix, a[ prefix ], traditional, add );
                    }
                }

                // Return the resulting serialization
                return s.join( "&" ).replace( r20, "+" );
            };

            jQuery.fn.extend( {
                                  serialize: function() {
                                      return jQuery.param( this.serializeArray() );
                                  },
                                  serializeArray: function() {
                                      return this.map( function() {

                                          // Can add propHook for "elements" to filter or add form elements
                                          var elements = jQuery.prop( this, "elements" );
                                          return elements ? jQuery.makeArray( elements ) : this;
                                      } )
                                          .filter( function() {
                                              var type = this.type;

                                              // Use .is( ":disabled" ) so that fieldset[disabled] works
                                              return this.name && !jQuery( this ).is( ":disabled" ) &&
                                                     rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
                                                     ( this.checked || !rcheckableType.test( type ) );
                                          } )
                                          .map( function( i, elem ) {
                                              var val = jQuery( this ).val();

                                              return val == null ?
                                                  null :
                                                  jQuery.isArray( val ) ?
                                                      jQuery.map( val, function( val ) {
                                                          return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                                                      } ) :
                                                      { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                                          } ).get();
                                  }
                              } );


            jQuery.ajaxSettings.xhr = function() {
                try {
                    return new window.XMLHttpRequest();
                } catch ( e ) {}
            };

            var xhrSuccessStatus = {

                    // File protocol always yields status code 0, assume 200
                    0: 200,

                    // Support: IE9
                    // #1450: sometimes IE returns 1223 when it should be 204
                    1223: 204
                },
                xhrSupported = jQuery.ajaxSettings.xhr();

            support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
            support.ajax = xhrSupported = !!xhrSupported;

            jQuery.ajaxTransport( function( options ) {
                var callback, errorCallback;

                // Cross domain only allowed if supported through XMLHttpRequest
                if ( support.cors || xhrSupported && !options.crossDomain ) {
                    return {
                        send: function( headers, complete ) {
                            var i,
                                xhr = options.xhr();

                            xhr.open(
                                options.type,
                                options.url,
                                options.async,
                                options.username,
                                options.password
                            );

                            // Apply custom fields if provided
                            if ( options.xhrFields ) {
                                for ( i in options.xhrFields ) {
                                    xhr[ i ] = options.xhrFields[ i ];
                                }
                            }

                            // Override mime type if needed
                            if ( options.mimeType && xhr.overrideMimeType ) {
                                xhr.overrideMimeType( options.mimeType );
                            }

                            // X-Requested-With header
                            // For cross-domain requests, seeing as conditions for a preflight are
                            // akin to a jigsaw puzzle, we simply never set it to be sure.
                            // (it can always be set on a per-request basis or even using ajaxSetup)
                            // For same-domain requests, won't change header if already provided.
                            if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
                                headers[ "X-Requested-With" ] = "XMLHttpRequest";
                            }

                            // Set headers
                            for ( i in headers ) {
                                xhr.setRequestHeader( i, headers[ i ] );
                            }

                            // Callback
                            callback = function( type ) {
                                return function() {
                                    if ( callback ) {
                                        callback = errorCallback = xhr.onload =
                                            xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

                                        if ( type === "abort" ) {
                                            xhr.abort();
                                        } else if ( type === "error" ) {

                                            // Support: IE9
                                            // On a manual native abort, IE9 throws
                                            // errors on any property access that is not readyState
                                            if ( typeof xhr.status !== "number" ) {
                                                complete( 0, "error" );
                                            } else {
                                                complete(

                                                    // File: protocol always yields status 0; see #8605, #14207
                                                    xhr.status,
                                                    xhr.statusText
                                                );
                                            }
                                        } else {
                                            complete(
                                                xhrSuccessStatus[ xhr.status ] || xhr.status,
                                                xhr.statusText,

                                                // Support: IE9 only
                                                // IE9 has no XHR2 but throws on binary (trac-11426)
                                                // For XHR2 non-text, let the caller handle it (gh-2498)
                                                ( xhr.responseType || "text" ) !== "text"  ||
                                                typeof xhr.responseText !== "string" ?
                                                    { binary: xhr.response } :
                                                    { text: xhr.responseText },
                                                xhr.getAllResponseHeaders()
                                            );
                                        }
                                    }
                                };
                            };

                            // Listen to events
                            xhr.onload = callback();
                            errorCallback = xhr.onerror = callback( "error" );

                            // Support: IE9
                            // Use onreadystatechange to replace onabort
                            // to handle uncaught aborts
                            if ( xhr.onabort !== undefined ) {
                                xhr.onabort = errorCallback;
                            } else {
                                xhr.onreadystatechange = function() {

                                    // Check readyState before timeout as it changes
                                    if ( xhr.readyState === 4 ) {

                                        // Allow onerror to be called first,
                                        // but that will not handle a native abort
                                        // Also, save errorCallback to a variable
                                        // as xhr.onerror cannot be accessed
                                        window.setTimeout( function() {
                                            if ( callback ) {
                                                errorCallback();
                                            }
                                        } );
                                    }
                                };
                            }

                            // Create the abort callback
                            callback = callback( "abort" );

                            try {

                                // Do send the request (this may raise an exception)
                                xhr.send( options.hasContent && options.data || null );
                            } catch ( e ) {

                                // #14683: Only rethrow if this hasn't been notified as an error yet
                                if ( callback ) {
                                    throw e;
                                }
                            }
                        },

                        abort: function() {
                            if ( callback ) {
                                callback();
                            }
                        }
                    };
                }
            } );




// Install script dataType
            jQuery.ajaxSetup( {
                                  accepts: {
                                      script: "text/javascript, application/javascript, " +
                                              "application/ecmascript, application/x-ecmascript"
                                  },
                                  contents: {
                                      script: /\b(?:java|ecma)script\b/
                                  },
                                  converters: {
                                      "text script": function( text ) {
                                          jQuery.globalEval( text );
                                          return text;
                                      }
                                  }
                              } );

// Handle cache's special case and crossDomain
            jQuery.ajaxPrefilter( "script", function( s ) {
                if ( s.cache === undefined ) {
                    s.cache = false;
                }
                if ( s.crossDomain ) {
                    s.type = "GET";
                }
            } );

// Bind script tag hack transport
            jQuery.ajaxTransport( "script", function( s ) {

                // This transport only deals with cross domain requests
                if ( s.crossDomain ) {
                    var script, callback;
                    return {
                        send: function( _, complete ) {
                            script = jQuery( "<script>" ).prop( {
                                                                    charset: s.scriptCharset,
                                                                    src: s.url
                                                                } ).on(
                                "load error",
                                callback = function( evt ) {
                                    script.remove();
                                    callback = null;
                                    if ( evt ) {
                                        complete( evt.type === "error" ? 404 : 200, evt.type );
                                    }
                                }
                            );

                            // Use native DOM manipulation to avoid our domManip AJAX trickery
                            document.head.appendChild( script[ 0 ] );
                        },
                        abort: function() {
                            if ( callback ) {
                                callback();
                            }
                        }
                    };
                }
            } );




            var oldCallbacks = [],
                rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
            jQuery.ajaxSetup( {
                                  jsonp: "callback",
                                  jsonpCallback: function() {
                                      var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
                                      this[ callback ] = true;
                                      return callback;
                                  }
                              } );

// Detect, normalize options and install callbacks for jsonp requests
            jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

                var callbackName, overwritten, responseContainer,
                    jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
                            "url" :
                               typeof s.data === "string" &&
                               ( s.contentType || "" )
                                   .indexOf( "application/x-www-form-urlencoded" ) === 0 &&
                               rjsonp.test( s.data ) && "data"
                    );

                // Handle iff the expected data type is "jsonp" or we have a parameter to set
                if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

                    // Get callback name, remembering preexisting value associated with it
                    callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
                        s.jsonpCallback() :
                        s.jsonpCallback;

                    // Insert callback into url or form data
                    if ( jsonProp ) {
                        s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
                    } else if ( s.jsonp !== false ) {
                        s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
                    }

                    // Use data converter to retrieve json after script execution
                    s.converters[ "script json" ] = function() {
                        if ( !responseContainer ) {
                            jQuery.error( callbackName + " was not called" );
                        }
                        return responseContainer[ 0 ];
                    };

                    // Force json dataType
                    s.dataTypes[ 0 ] = "json";

                    // Install callback
                    overwritten = window[ callbackName ];
                    window[ callbackName ] = function() {
                        responseContainer = arguments;
                    };

                    // Clean-up function (fires after converters)
                    jqXHR.always( function() {

                        // If previous value didn't exist - remove it
                        if ( overwritten === undefined ) {
                            jQuery( window ).removeProp( callbackName );

                            // Otherwise restore preexisting value
                        } else {
                            window[ callbackName ] = overwritten;
                        }

                        // Save back as free
                        if ( s[ callbackName ] ) {

                            // Make sure that re-using the options doesn't screw things around
                            s.jsonpCallback = originalSettings.jsonpCallback;

                            // Save the callback name for future use
                            oldCallbacks.push( callbackName );
                        }

                        // Call if it was a function and we have a response
                        if ( responseContainer && jQuery.isFunction( overwritten ) ) {
                            overwritten( responseContainer[ 0 ] );
                        }

                        responseContainer = overwritten = undefined;
                    } );

                    // Delegate to script
                    return "script";
                }
            } );




// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
            jQuery.parseHTML = function( data, context, keepScripts ) {
                if ( !data || typeof data !== "string" ) {
                    return null;
                }
                if ( typeof context === "boolean" ) {
                    keepScripts = context;
                    context = false;
                }
                context = context || document;

                var parsed = rsingleTag.exec( data ),
                    scripts = !keepScripts && [];

                // Single tag
                if ( parsed ) {
                    return [ context.createElement( parsed[ 1 ] ) ];
                }

                parsed = buildFragment( [ data ], context, scripts );

                if ( scripts && scripts.length ) {
                    jQuery( scripts ).remove();
                }

                return jQuery.merge( [], parsed.childNodes );
            };


// Keep a copy of the old load method
            var _load = jQuery.fn.load;

            /**
             * Load a url into a page
             */
            jQuery.fn.load = function( url, params, callback ) {
                if ( typeof url !== "string" && _load ) {
                    return _load.apply( this, arguments );
                }

                var selector, type, response,
                    self = this,
                    off = url.indexOf( " " );

                if ( off > -1 ) {
                    selector = jQuery.trim( url.slice( off ) );
                    url = url.slice( 0, off );
                }

                // If it's a function
                if ( jQuery.isFunction( params ) ) {

                    // We assume that it's the callback
                    callback = params;
                    params = undefined;

                    // Otherwise, build a param string
                } else if ( params && typeof params === "object" ) {
                    type = "POST";
                }

                // If we have elements to modify, make the request
                if ( self.length > 0 ) {
                    jQuery.ajax( {
                                     url: url,

                                     // If "type" variable is undefined, then "GET" method will be used.
                                     // Make value of this field explicit since
                                     // user can override it through ajaxSetup method
                                     type: type || "GET",
                                     dataType: "html",
                                     data: params
                                 } ).done( function( responseText ) {

                        // Save response for use in complete callback
                        response = arguments;

                        self.html( selector ?

                                       // If a selector was specified, locate the right elements in a dummy div
                                       // Exclude scripts to avoid IE 'Permission Denied' errors
                                       jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

                                       // Otherwise use the full result
                                       responseText );

                        // If the request succeeds, this function gets "data", "status", "jqXHR"
                        // but they are ignored because response was set above.
                        // If it fails, this function gets "jqXHR", "status", "error"
                    } ).always( callback && function( jqXHR, status ) {
                        self.each( function() {
                            callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
                        } );
                    } );
                }

                return this;
            };




// Attach a bunch of functions for handling common AJAX events
            jQuery.each( [
                             "ajaxStart",
                             "ajaxStop",
                             "ajaxComplete",
                             "ajaxError",
                             "ajaxSuccess",
                             "ajaxSend"
                         ], function( i, type ) {
                jQuery.fn[ type ] = function( fn ) {
                    return this.on( type, fn );
                };
            } );




            jQuery.expr.filters.animated = function( elem ) {
                return jQuery.grep( jQuery.timers, function( fn ) {
                    return elem === fn.elem;
                } ).length;
            };




            /**
             * Gets a window from an element
             */
            function getWindow( elem ) {
                return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
            }

            jQuery.offset = {
                setOffset: function( elem, options, i ) {
                    var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                        position = jQuery.css( elem, "position" ),
                        curElem = jQuery( elem ),
                        props = {};

                    // Set position first, in-case top/left are set even on static elem
                    if ( position === "static" ) {
                        elem.style.position = "relative";
                    }

                    curOffset = curElem.offset();
                    curCSSTop = jQuery.css( elem, "top" );
                    curCSSLeft = jQuery.css( elem, "left" );
                    calculatePosition = ( position === "absolute" || position === "fixed" ) &&
                                        ( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

                    // Need to be able to calculate position if either
                    // top or left is auto and position is either absolute or fixed
                    if ( calculatePosition ) {
                        curPosition = curElem.position();
                        curTop = curPosition.top;
                        curLeft = curPosition.left;

                    } else {
                        curTop = parseFloat( curCSSTop ) || 0;
                        curLeft = parseFloat( curCSSLeft ) || 0;
                    }

                    if ( jQuery.isFunction( options ) ) {

                        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
                        options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
                    }

                    if ( options.top != null ) {
                        props.top = ( options.top - curOffset.top ) + curTop;
                    }
                    if ( options.left != null ) {
                        props.left = ( options.left - curOffset.left ) + curLeft;
                    }

                    if ( "using" in options ) {
                        options.using.call( elem, props );

                    } else {
                        curElem.css( props );
                    }
                }
            };

            jQuery.fn.extend( {
                                  offset: function( options ) {
                                      if ( arguments.length ) {
                                          return options === undefined ?
                                              this :
                                              this.each( function( i ) {
                                                  jQuery.offset.setOffset( this, options, i );
                                              } );
                                      }

                                      var docElem, win,
                                          elem = this[ 0 ],
                                          box = { top: 0, left: 0 },
                                          doc = elem && elem.ownerDocument;

                                      if ( !doc ) {
                                          return;
                                      }

                                      docElem = doc.documentElement;

                                      // Make sure it's not a disconnected DOM node
                                      if ( !jQuery.contains( docElem, elem ) ) {
                                          return box;
                                      }

                                      box = elem.getBoundingClientRect();
                                      win = getWindow( doc );
                                      return {
                                          top: box.top + win.pageYOffset - docElem.clientTop,
                                          left: box.left + win.pageXOffset - docElem.clientLeft
                                      };
                                  },

                                  position: function() {
                                      if ( !this[ 0 ] ) {
                                          return;
                                      }

                                      var offsetParent, offset,
                                          elem = this[ 0 ],
                                          parentOffset = { top: 0, left: 0 };

                                      // Fixed elements are offset from window (parentOffset = {top:0, left: 0},
                                      // because it is its only offset parent
                                      if ( jQuery.css( elem, "position" ) === "fixed" ) {

                                          // Assume getBoundingClientRect is there when computed position is fixed
                                          offset = elem.getBoundingClientRect();

                                      } else {

                                          // Get *real* offsetParent
                                          offsetParent = this.offsetParent();

                                          // Get correct offsets
                                          offset = this.offset();
                                          if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
                                              parentOffset = offsetParent.offset();
                                          }

                                          // Add offsetParent borders
                                          parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
                                          parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
                                      }

                                      // Subtract parent offsets and element margins
                                      return {
                                          top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
                                          left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
                                      };
                                  },

                                  // This method will return documentElement in the following cases:
                                  // 1) For the element inside the iframe without offsetParent, this method will return
                                  //    documentElement of the parent window
                                  // 2) For the hidden or detached element
                                  // 3) For body or html element, i.e. in case of the html node - it will return itself
                                  //
                                  // but those exceptions were never presented as a real life use-cases
                                  // and might be considered as more preferable results.
                                  //
                                  // This logic, however, is not guaranteed and can change at any point in the future
                                  offsetParent: function() {
                                      return this.map( function() {
                                          var offsetParent = this.offsetParent;

                                          while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
                                              offsetParent = offsetParent.offsetParent;
                                          }

                                          return offsetParent || documentElement;
                                      } );
                                  }
                              } );

// Create scrollLeft and scrollTop methods
            jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
                var top = "pageYOffset" === prop;

                jQuery.fn[ method ] = function( val ) {
                    return access( this, function( elem, method, val ) {
                        var win = getWindow( elem );

                        if ( val === undefined ) {
                            return win ? win[ prop ] : elem[ method ];
                        }

                        if ( win ) {
                            win.scrollTo(
                                !top ? val : win.pageXOffset,
                                top ? val : win.pageYOffset
                            );

                        } else {
                            elem[ method ] = val;
                        }
                    }, method, val, arguments.length );
                };
            } );

// Support: Safari<7-8+, Chrome<37-44+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
            jQuery.each( [ "top", "left" ], function( i, prop ) {
                jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
                                                        function( elem, computed ) {
                                                            if ( computed ) {
                                                                computed = curCSS( elem, prop );

                                                                // If curCSS returns percentage, fallback to offset
                                                                return rnumnonpx.test( computed ) ?
                                                                    jQuery( elem ).position()[ prop ] + "px" :
                                                                    computed;
                                                            }
                                                        }
                );
            } );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
            jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
                jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
                             function( defaultExtra, funcName ) {

                                 // Margin is only for outerHeight, outerWidth
                                 jQuery.fn[ funcName ] = function( margin, value ) {
                                     var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
                                         extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

                                     return access( this, function( elem, type, value ) {
                                         var doc;

                                         if ( jQuery.isWindow( elem ) ) {

                                             // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                                             // isn't a whole lot we can do. See pull request at this URL for discussion:
                                             // https://github.com/jquery/jquery/pull/764
                                             return elem.document.documentElement[ "client" + name ];
                                         }

                                         // Get document width or height
                                         if ( elem.nodeType === 9 ) {
                                             doc = elem.documentElement;

                                             // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                                             // whichever is greatest
                                             return Math.max(
                                                 elem.body[ "scroll" + name ], doc[ "scroll" + name ],
                                                 elem.body[ "offset" + name ], doc[ "offset" + name ],
                                                 doc[ "client" + name ]
                                             );
                                         }

                                         return value === undefined ?

                                             // Get width or height on the element, requesting but not forcing parseFloat
                                             jQuery.css( elem, type, extra ) :

                                             // Set width or height on the element
                                             jQuery.style( elem, type, value, extra );
                                     }, type, chainable ? margin : undefined, chainable, null );
                                 };
                             } );
            } );


            jQuery.fn.extend( {

                                  bind: function( types, data, fn ) {
                                      return this.on( types, null, data, fn );
                                  },
                                  unbind: function( types, fn ) {
                                      return this.off( types, null, fn );
                                  },

                                  delegate: function( selector, types, data, fn ) {
                                      return this.on( types, selector, data, fn );
                                  },
                                  undelegate: function( selector, types, fn ) {

                                      // ( namespace ) or ( selector, types [, fn] )
                                      return arguments.length === 1 ?
                                          this.off( selector, "**" ) :
                                          this.off( types, selector || "**", fn );
                                  },
                                  size: function() {
                                      return this.length;
                                  }
                              } );

            jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

            if ( typeof define === "function" && define.amd ) {
                define( "jquery", [], function() {
                    return jQuery;
                } );
            }



            var

                // Map over jQuery in case of overwrite
                _jQuery = window.jQuery,

                // Map over the $ in case of overwrite
                _$ = window.$;

            jQuery.noConflict = function( deep ) {
                if ( window.$ === jQuery ) {
                    window.$ = _$;
                }

                if ( deep && window.jQuery === jQuery ) {
                    window.jQuery = _jQuery;
                }

                return jQuery;
            };

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
            if ( !noGlobal ) {
                window.jQuery = window.$ = jQuery;
            }

            return jQuery;
        }));

    },{}],3:[function(require,module,exports){
        /**
         * imagefill.js
         * Author & copyright (c) 2013: John Polacek
         * johnpolacek.com
         * https://twitter.com/johnpolacek
         *
         * Dual MIT & GPL license
         *
         * Project Page: http://johnpolacek.github.io/imagefill.js
         *
         * The jQuery plugin for making images fill their containers (and be centered)
         *
         * EXAMPLE
         * Given this html:
         * <div class="container"><img src="myawesomeimage" /></div>
         * $('.container').imagefill(); // image stretches to fill container
         *
         * REQUIRES:
         * imagesLoaded - https://github.com/desandro/imagesloaded
         *
         */
        ;(function($) {

            $.fn.imagefill = function(options) {

                var $container = this,
                    imageAspect = 1/1,
                    containersH = 0,
                    containersW = 0,
                    defaults = {
                        runOnce: false,
                        target: 'img',
                        throttle : 200  // 5fps
                    },
                    settings = $.extend({}, defaults, options);

                var $img = $container.find(settings.target).addClass('loading').css({'position':'absolute'});

                // make sure container isn't position:static
                var containerPos = $container.css('position');
                $container.css({'overflow':'hidden','position':(containerPos === 'static') ? 'relative' : containerPos});

                // set containerH, containerW
                $container.each(function() {
                    containersH += $(this).outerHeight();
                    containersW += $(this).outerWidth();
                });

                // wait for image to load, then fit it inside the container
                $container.imagesLoaded().done(function(img) {
                    imageAspect = $img.width() / $img.height();
                    $img.removeClass('loading');
                    fitImages();
                    if (!settings.runOnce) {
                        checkSizeChange();
                    }
                });

                function fitImages() {
                    containersH  = 0;
                    containersW = 0;
                    $container.each(function() {
                        imageAspect = $(this).find(settings.target).width() / $(this).find(settings.target).height();
                        var containerW = $(this).outerWidth(),
                            containerH = $(this).outerHeight();
                        containersH += $(this).outerHeight();
                        containersW += $(this).outerWidth();

                        var containerAspect = containerW/containerH;
                        if (containerAspect < imageAspect) {
                            // taller
                            $(this).find(settings.target).css({
                                                                  width: 'auto',
                                                                  height: containerH,
                                                                  top:0,
                                                                  left:-(containerH*imageAspect-containerW)/2
                                                              });
                        } else {
                            // wider
                            $(this).find(settings.target).css({
                                                                  width: containerW,
                                                                  height: 'auto',
                                                                  //top:-(containerW/imageAspect-containerH)/2,
                                                                  top :0,
                                                                  left:0
                                                              });
                        }
                    });
                }

                function checkSizeChange() {
                    var checkW = 0,
                        checkH = 0;
                    $container.each(function() {
                        checkH += $(this).outerHeight();
                        checkW += $(this).outerWidth();
                    });
                    if (containersH !== checkH || containersW !== checkW) {
                        fitImages();
                    }
                    setTimeout(checkSizeChange, settings.throttle);
                }

                return this;
            };

        }(jQuery));

    },{}],4:[function(require,module,exports){
        /*!
 * jQuery imagesLoaded plugin v2.1.0
 * http://github.com/desandro/imagesloaded
 *
 * MIT License. by Paul Irish et al.
 */

        /*jshint curly: true, eqeqeq: true, noempty: true, strict: true, undef: true, browser: true */
        /*global jQuery: false */

        ;(function($, undefined) {
            'use strict';

// blank image data-uri bypasses webkit log warning (thx doug jones)
            var BLANK = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';

            $.fn.imagesLoaded = function( callback ) {
                var $this = this,
                    deferred = $.isFunction($.Deferred) ? $.Deferred() : 0,
                    hasNotify = $.isFunction(deferred.notify),
                    $images = $this.find('img').add( $this.filter('img') ),
                    loaded = [],
                    proper = [],
                    broken = [];

                // Register deferred callbacks
                if ($.isPlainObject(callback)) {
                    $.each(callback, function (key, value) {
                        if (key === 'callback') {
                            callback = value;
                        } else if (deferred) {
                            deferred[key](value);
                        }
                    });
                }

                function doneLoading() {
                    var $proper = $(proper),
                        $broken = $(broken);

                    if ( deferred ) {
                        if ( broken.length ) {
                            deferred.reject( $images, $proper, $broken );
                        } else {
                            deferred.resolve( $images );
                        }
                    }

                    if ( $.isFunction( callback ) ) {
                        callback.call( $this, $images, $proper, $broken );
                    }
                }

                function imgLoaded( img, isBroken ) {
                    // don't proceed if BLANK image, or image is already loaded
                    if ( img.src === BLANK || $.inArray( img, loaded ) !== -1 ) {
                        return;
                    }

                    // store element in loaded images array
                    loaded.push( img );

                    // keep track of broken and properly loaded images
                    if ( isBroken ) {
                        broken.push( img );
                    } else {
                        proper.push( img );
                    }

                    // cache image and its state for future calls
                    $.data( img, 'imagesLoaded', { isBroken: isBroken, src: img.src } );

                    // trigger deferred progress method if present
                    if ( hasNotify ) {
                        deferred.notifyWith( $(img), [ isBroken, $images, $(proper), $(broken) ] );
                    }

                    // call doneLoading and clean listeners if all images are loaded
                    if ( $images.length === loaded.length ){
                        setTimeout( doneLoading );
                        $images.unbind( '.imagesLoaded' );
                    }
                }

                // if no images, trigger immediately
                if ( !$images.length ) {
                    doneLoading();
                } else {
                    $images.bind( 'load.imagesLoaded error.imagesLoaded', function( event ){
                        // trigger imgLoaded
                        imgLoaded( event.target, event.type === 'error' );
                    }).each( function( i, el ) {
                        var src = el.src;

                        // find out if this image has been already checked for status
                        // if it was, and src has not changed, call imgLoaded on it
                        var cached = $.data( el, 'imagesLoaded' );
                        if ( cached && cached.src === src ) {
                            imgLoaded( el, cached.isBroken );
                            return;
                        }

                        // if complete is true and browser supports natural sizes, try
                        // to check for image status manually
                        if ( el.complete && el.naturalWidth !== undefined ) {
                            imgLoaded( el, el.naturalWidth === 0 || el.naturalHeight === 0 );
                            return;
                        }

                        // cached images don't fire load sometimes, so we reset src, but only when
                        // dealing with IE, or image is complete (loaded) and failed manual check
                        // webkit hack from http://groups.google.com/group/jquery-dev/browse_thread/thread/eee6ab7b2da50e1f
                        if ( el.readyState || el.complete ) {
                            el.src = BLANK;
                            el.src = src;
                        }
                    });
                }

                return deferred ? deferred.promise( $this ) : $this;
            };

        })(jQuery);

    },{}],5:[function(require,module,exports){
        (function (ELEMENT) {
            ELEMENT.matches = ELEMENT.matches || ELEMENT.mozMatchesSelector || ELEMENT.msMatchesSelector || ELEMENT.oMatchesSelector || ELEMENT.webkitMatchesSelector || function matches(selector) {
                var
                    element = this,
                    elements = (element.document || element.ownerDocument).querySelectorAll(selector),
                    index = 0;

                while (elements[index] && elements[index] !== element) {
                    ++index;
                }

                return elements[index] ? true : false;
            };

            ELEMENT.closest = ELEMENT.closest || function closest(selector) {
                var element = this;

                while (element) {
                    if (element.matches(selector)) {
                        break;
                    }

                    element = element.parentElement;
                }

                return element;
            };
        }(Element.prototype));

        /*!
 * A polyfill for Webkit's window.getMatchedCSSRules, based on
 * https://gist.github.com/ydaniv/3033012
 *
 * @author: Yehonatan Daniv
 * @author: ssafejava
 * @author: Christian "Schepp" Schaefer <schaepp@gmx.de>
 *
 */

        'use strict';

        (function () {
            // polyfill window.getMatchedCSSRules() in FireFox 6+
            if (typeof window.getMatchedCSSRules === 'function') {
                return;
            }

            var ELEMENT_RE = /[\w-]+/g,
                ID_RE = /#[\w-]+/g,
                CLASS_RE = /\.[\w-]+/g,
                ATTR_RE = /\[[^\]]+\]/g,
                // :not() pseudo-class does not add to specificity, but its content does as if it was outside it
                PSEUDO_CLASSES_RE = /\:(?!not)[\w-]+(\(.*\))?/g,
                PSEUDO_ELEMENTS_RE = /\:\:?(after|before|first-letter|first-line|selection)/g;

            // convert an array-like object to array
            var toArray = function (list) {
                var items = [];
                var i = 0;
                var listLength = list.length;

                for (; i < listLength; i++) {
                    items.push(list[i]);
                }

                return items;
            };

            // get host of stylesheet
            var getCSSHost = function (href) {
                var fakeLinkOfSheet = document.createElement('a');

                fakeLinkOfSheet.href = href;

                return fakeLinkOfSheet.host;
            };

            // handles extraction of `cssRules` as an `Array` from a stylesheet or something that behaves the same
            var getSheetRules = function (stylesheet) {
                var sheetMedia = stylesheet.media && stylesheet.media.mediaText;
                var sheetHost;

                // if this sheet is cross-origin and option is set skip it
                if (objectFit.disableCrossDomain == 'true') {
                    sheetHost = getCSSHost(stylesheet.href);

                    if ((sheetHost !== window.location.host)) {
                        return [];
                    }
                }


                // if this sheet is disabled skip it
                if (stylesheet.disabled) {
                    return [];
                }

                if (!window.matchMedia) {
                    if (sheetMedia && sheetMedia.length) {
                        return [];
                    }
                }
                // if this sheet's media is specified and doesn't match the viewport then skip it
                else if (sheetMedia && sheetMedia.length && ! window.matchMedia(sheetMedia).matches) {
                    return [];
                }

                // get the style rules of this sheet
                return toArray(stylesheet.cssRules);
            };

            var _find = function (string, re) {
                var matches = string.match(re);

                return re ? re.length : 0;
            };

            // calculates the specificity of a given `selector`
            var calculateScore = function (selector) {
                var score = [0, 0, 0];
                var parts = selector.split(' ');
                var part;
                var match;

                //TODO: clean the ':not' part since the last ELEMENT_RE will pick it up
                while (part = parts.shift(), typeof part === 'string') {
                    // find all pseudo-elements
                    match = _find(part, PSEUDO_ELEMENTS_RE);
                    score[2] = match;
                    // and remove them
                    match && (part = part.replace(PSEUDO_ELEMENTS_RE, ''));
                    // find all pseudo-classes
                    match = _find(part, PSEUDO_CLASSES_RE);
                    score[1] = match;
                    // and remove them
                    match && (part = part.replace(PSEUDO_CLASSES_RE, ''));
                    // find all attributes
                    match = _find(part, ATTR_RE);
                    score[1] += match;
                    // and remove them
                    match && (part = part.replace(ATTR_RE, ''));
                    // find all IDs
                    match = _find(part, ID_RE);
                    score[0] = match;
                    // and remove them
                    match && (part = part.replace(ID_RE, ''));
                    // find all classes
                    match = _find(part, CLASS_RE);
                    score[1] += match;
                    // and remove them
                    match && (part = part.replace(CLASS_RE, ''));
                    // find all elements
                    score[2] += _find(part, ELEMENT_RE);
                }

                return parseInt(score.join(''), 10);
            };

            // returns the heights possible specificity score an element can get from a give rule's selectorText
            var getSpecificityScore = function (element, selectorText) {
                var selectors = selectorText.split(','),
                    selector, score, result = 0;

                while (selector = selectors.shift()) {
                    if (element.closest(selector)) {
                        score = calculateScore(selector);
                        result = score > result ? score : result;
                    }
                }

                return result;
            };

            var sortBySpecificity = function (element, rules) {
                // comparing function that sorts CSSStyleRules according to specificity of their `selectorText`
                var compareSpecificity = function (a, b) {
                    return getSpecificityScore(element, b.selectorText) - getSpecificityScore(element, a.selectorText);
                };

                return rules.sort(compareSpecificity);
            };

            //TODO: not supporting 2nd argument for selecting pseudo elements
            //TODO: not supporting 3rd argument for checking author style sheets only
            window.getMatchedCSSRules = function (element) {  /*, pseudo, author_only*/
                var styleSheets;
                var result = [];
                var sheet;
                var rules;
                var rule;

                // get stylesheets and convert to a regular Array
                styleSheets = toArray(window.document.styleSheets);

                // assuming the browser hands us stylesheets in order of appearance
                // we iterate them from the beginning to follow proper cascade order
                while (sheet = styleSheets.shift()) {
                    // get the style rules of this sheet
                    rules = getSheetRules(sheet);

                    // loop the rules in order of appearance
                    while (rule = rules.shift()) {
                        // if this is an @import rule
                        if (rule.styleSheet) {
                            // insert the imported stylesheet's rules at the beginning of this stylesheet's rules
                            rules = getSheetRules(rule.styleSheet).concat(rules);
                            // and skip this rule
                            continue;
                        }
                        // if there's no stylesheet attribute BUT there IS a media attribute it's a media rule
                        else if (rule.media) {
                            // insert the contained rules of this media rule to the beginning of this stylesheet's rules
                            rules = getSheetRules(rule).concat(rules);
                            // and skip it
                            continue;
                        }

                        // check if this element matches this rule's selector
                        if (element.closest(rule.selectorText)) {
                            // push the rule to the results set
                            result.push(rule);
                        }
                    }
                }
                // sort according to specificity
                return sortBySpecificity(element, result);
            };
        }());

        /*
 * raf.js
 * https://github.com/ngryman/raf.js
 *
 * original requestAnimationFrame polyfill by Erik Möller
 * inspired from paul_irish gist and post
 *
 * Copyright (c) 2013 ngryman
 * Licensed under the MIT license.
 */

        (function(window) {
            var lastTime = 0,
                vendors = ['webkit', 'moz'],
                requestAnimationFrame = window.requestAnimationFrame,
                cancelAnimationFrame = window.cancelAnimationFrame,
                i = vendors.length;

            // try to un-prefix existing raf
            while (--i >= 0 && !requestAnimationFrame) {
                requestAnimationFrame = window[vendors[i] + 'RequestAnimationFrame'];
                cancelAnimationFrame = window[vendors[i] + 'CancelAnimationFrame'];
            }

            // polyfill with setTimeout fallback
            // heavily inspired from @darius gist mod: https://gist.github.com/paulirish/1579671#comment-837945
            if (!requestAnimationFrame || !cancelAnimationFrame) {
                requestAnimationFrame = function(callback) {
                    var now = +new Date(), nextTime = Math.max(lastTime + 16, now);
                    return setTimeout(function() {
                        callback(lastTime = nextTime);
                    }, nextTime - now);
                };

                cancelAnimationFrame = clearTimeout;
            }

            // export to window
            window.requestAnimationFrame = requestAnimationFrame;
            window.cancelAnimationFrame = cancelAnimationFrame;
        }(window));

        /*!
 * Polyfill CSS object-fit
 * http://helloanselm.com/object-fit
 *
 * @author: Anselm Hannemann <hello@anselm-hannemann.com>
 * @author: Christian "Schepp" Schaefer <schaepp@gmx.de>
 * @version: 0.3.4
 *
 */

        (function (global) {

            'use strict';

            // Storage variable
            var objectFit = {};

            objectFit._debug = false;

            objectFit.observer = null;

            objectFit.disableCrossDomain = 'false';

            objectFit.getComputedStyle = function(element, context) {
                context = context || window;

                if (context.getComputedStyle) {
                    return context.getComputedStyle(element, null);
                }
                else {
                    return element.currentStyle;
                }
            };

            objectFit.getDefaultComputedStyle = function(element){
                var newelement = element.cloneNode(true);
                var styles = {};
                var iframe = document.createElement('iframe');
                document.body.appendChild(iframe);
                iframe.contentWindow.document.open();
                iframe.contentWindow.document.write('<body></body>');
                iframe.contentWindow.document.body.appendChild(newelement);
                iframe.contentWindow.document.close();

                var defaultElement = iframe.contentWindow.document.querySelectorAll(element.nodeName.toLowerCase())[0];
                var defaultComputedStyle = this.getComputedStyle(defaultElement, iframe.contentWindow);
                var value;
                var property;

                for (property in defaultComputedStyle) {
                    if (defaultComputedStyle.getPropertyValue === true) {
                        value = defaultComputedStyle.getPropertyValue(property);
                    } else {
                        value = defaultComputedStyle[property];
                    }

                    if (value !== null) {
                        switch (property) {
                            default:
                                styles[property] = value;
                                break;

                            case 'width':
                            case 'height':
                            case 'minWidth':
                            case 'minHeight':
                            case 'maxWidth':
                            case 'maxHeight':
                                break;
                        }
                    }
                }

                document.body.removeChild(iframe);

                return styles;
            };

            objectFit.getMatchedStyle = function(element, property){
                // element property has highest priority
                var val = null;
                var inlineval = null;

                if (element.style.getPropertyValue) {
                    inlineval = element.style.getPropertyValue(property);
                } else if (element.currentStyle) {
                    inlineval = element.currentStyle[property];
                }

                // get matched rules
                var rules = window.getMatchedCSSRules(element);
                var i = rules.length;
                var r;
                var important;

                if (i) {
                    // iterate the rules backwards
                    // rules are ordered by priority, highest last
                    for (; i --> 0;) {
                        r = rules[i];
                        important = r.style.getPropertyPriority(property);

                        // if set, only reset if important
                        if (val === null || important) {
                            val = r.style.getPropertyValue(property);

                            // done if important
                            if (important) {
                                break;
                            }
                        }
                    }
                }

                // if it's important, we are done
                if (!val && inlineval !== null) {
                    val = inlineval;
                }

                return val;
            };

            // Detects orientation
            objectFit.orientation = function(replacedElement) {
                if (replacedElement.parentNode && replacedElement.parentNode.nodeName.toLowerCase() === 'x-object-fit') {
                    var width = replacedElement.naturalWidth || replacedElement.clientWidth;
                    var height = replacedElement.naturalHeight || replacedElement.clientHeight;
                    var parentWidth = replacedElement.parentNode.clientWidth;
                    var parentHeight = replacedElement.parentNode.clientHeight;

                    if (!height || width / height > parentWidth / parentHeight) {
                        if (replacedElement.getAttribute('data-x-object-relation') !== 'wider') {
                            replacedElement.setAttribute('data-x-object-relation','wider');
                            replacedElement.className = 'x-object-fit-wider';

                            if (this._debug && window.console) {
                                console.log('x-object-fit-wider');
                            }
                        }
                    } else {
                        if (replacedElement.getAttribute('data-x-object-relation') !== 'taller') {
                            replacedElement.setAttribute('data-x-object-relation','taller');
                            replacedElement.className = 'x-object-fit-taller';

                            if (this._debug && window.console) {
                                console.log('x-object-fit-taller');
                            }
                        }
                    }
                }
            };

            objectFit.process = function(args) {
                if (!args.selector || !args.replacedElements) {
                    return;
                }

                // Set option objectFit.disableCrossDomain
                objectFit.disableCrossDomain = args.disableCrossDomain || 'false';

                // Set option fit-type
                args.fittype = args.fittype || 'none';

                switch (args.fittype) {
                    default:
                        return;

                    case 'none':
                    case 'fill':
                    case 'contain':
                    case 'cover':
                        break;
                }

                // Set option replacedElements
                var replacedElements = args.replacedElements;

                if(!replacedElements.length) {
                    return;
                }

                for (var i = 0, replacedElementsLength = replacedElements.length; i < replacedElementsLength; i++) {
                    this.processElement(replacedElements[i], args);
                }
            };

            objectFit.processElement = function(replacedElement, args) {
                var property;
                var value;
                var replacedElementStyles = objectFit.getComputedStyle(replacedElement);
                var replacedElementDefaultStyles = objectFit.getDefaultComputedStyle(replacedElement);
                var wrapperElement = document.createElement('x-object-fit');

                if (objectFit._debug && window.console) {
                    console.log('Applying to WRAPPER-------------------------------------------------------');
                }

                for (property in replacedElementStyles) {
                    switch (property) {
                        default:
                            value = objectFit.getMatchedStyle(replacedElement, property);

                            if (value !== null && value !== '') {
                                if (objectFit._debug && window.console) {
                                    console.log(property + ': ' + value);
                                }

                                wrapperElement.style[property] = value;
                            }
                            break;

                        case 'length':
                        case 'parentRule':
                            break;
                    }
                }

                if (objectFit._debug && window.console) {
                    console.log('Applying to REPLACED ELEMENT-------------------------------------------------------');
                }
                for (property in replacedElementDefaultStyles) {
                    switch (property) {
                        default:
                            value = replacedElementDefaultStyles[property];

                            if (objectFit._debug && window.console && value !== '') {
                                console.log(property + ': ' + value);

                                if (replacedElement.style[property] === undefined) {
                                    console.log('Indexed style properties (`' + property + '`) not supported in: ' + window.navigator.userAgent);
                                }
                            }

                            if (replacedElement.style[property]) {
                                replacedElement.style[property] = value; // should work in Firefox 35+ and all other browsers
                            } else {
                                replacedElement.style.property = value;
                            }
                            break;

                        case 'length':
                        case 'parentRule':
                            break;
                    }
                }

                wrapperElement.setAttribute('class','x-object-fit-' + args.fittype);
                replacedElement.parentNode.insertBefore(wrapperElement, replacedElement);
                wrapperElement.appendChild(replacedElement);

                objectFit.orientation(replacedElement);

                var resizeTimer = null;
                var resizeAction = function () {
                    if (resizeTimer !== null) {
                        window.cancelAnimationFrame(resizeTimer);
                    }
                    resizeTimer = window.requestAnimationFrame(function(){
                        objectFit.orientation(replacedElement);
                    });
                };

                switch (args.fittype) {
                    default:
                        break;

                    case 'contain':
                    case 'cover':
                        if (window.addEventListener) {
                            replacedElement.addEventListener('load', resizeAction, false);
                            window.addEventListener('resize', resizeAction, false);
                            window.addEventListener('orientationchange', resizeAction, false);
                        } else {
                            replacedElement.attachEvent('onload', resizeAction);
                            window.attachEvent('onresize', resizeAction);
                        }
                        break;
                }
            };

            objectFit.listen = function (args) {
                var domInsertedAction = function (element){
                    var i = 0;
                    var argsLength = args.length;

                    for (; i < argsLength; i++) {
                        if ((element.mozMatchesSelector && element.mozMatchesSelector(args[i].selector)) ||
                            (element.msMatchesSelector && element.msMatchesSelector(args[i].selector)) ||
                            (element.oMatchesSelector && element.oMatchesSelector(args[i].selector)) ||
                            (element.webkitMatchesSelector && element.webkitMatchesSelector(args[i].selector))
                        ) {
                            args[i].replacedElements = [element];
                            objectFit.process(args[i]);

                            if (objectFit._debug && window.console) {
                                console.log('Matching node inserted: ' + element.nodeName);
                            }
                        }
                    }
                };

                var domInsertedObserverFunction = function (element) {
                    objectFit.observer.disconnect();
                    domInsertedAction(element);
                    objectFit.observer.observe(document.documentElement, {
                        childList: true,
                        subtree: true
                    });
                };

                var domInsertedEventFunction = function (event) {
                    window.removeEventListener('DOMNodeInserted', domInsertedEventFunction, false);
                    domInsertedAction(event.target);
                    window.addEventListener('DOMNodeInserted', domInsertedEventFunction, false);
                };

                var domRemovedAction = function (element) {
                    if (element.nodeName.toLowerCase() === 'x-object-fit') {
                        element.parentNode.removeChild(element);

                        if (objectFit._debug && window.console) {
                            console.log('Matching node removed: ' + element.nodeName);
                        }
                    }
                };

                var domRemovedObserverFunction = function (element) {
                    objectFit.observer.disconnect();
                    domRemovedAction(element);
                    objectFit.observer.observe(document.documentElement, {
                        childList: true,
                        subtree: true
                    });
                };

                var domRemovedEventFunction = function (event) {
                    window.removeEventListener('DOMNodeRemoved', domRemovedEventFunction, false);
                    domRemovedAction(event.target.parentNode);
                    window.addEventListener('DOMNodeRemoved', domRemovedEventFunction, false);
                };

                if (window.MutationObserver) {
                    if (objectFit._debug && window.console) {
                        console.log('DOM MutationObserver');
                    }

                    this.observer = new MutationObserver(function(mutations) {
                        mutations.forEach(function(mutation) {
                            if (mutation.addedNodes && mutation.addedNodes.length) {
                                var nodes = mutation.addedNodes;
                                for (var i = 0, nodesLength = nodes.length; i < nodesLength; i++) {
                                    domInsertedObserverFunction(nodes[i]);
                                }
                            }
                            if (mutation.removedNodes && mutation.removedNodes.length) {
                                domRemovedObserverFunction(mutation.target);
                            }
                        });
                    });

                    this.observer.observe(document.documentElement, {
                        childList: true,
                        subtree: true
                    });
                } else if (window.addEventListener) {
                    if (objectFit._debug && window.console) {
                        console.log('DOM Mutation Events');
                    }

                    window.addEventListener('DOMNodeInserted', domInsertedEventFunction, false);
                    window.addEventListener('DOMNodeRemoved', domRemovedEventFunction, false);
                }
            };

            objectFit.init = function (args) {
                if (!args) {
                    return;
                }

                if (!(args instanceof Array)) {
                    args = [args];
                }

                var i = 0;
                var argsLength = args.length;

                for (; i < argsLength; i++) {
                    args[i].replacedElements = document.querySelectorAll(args[i].selector);
                    this.process(args[i]);
                }

                this.listen(args);
            };

            objectFit.polyfill = function (args) {
                if('objectFit' in document.documentElement.style === false) {
                    if (objectFit._debug && window.console) {
                        console.log('object-fit not natively supported');
                    }

                    // If the library is loaded after document onload event
                    if (document.readyState === 'complete') {
                        objectFit.init(args);
                    } else {
                        // Otherwise attach event listeners
                        if (window.addEventListener) {
                            window.addEventListener('load', function(){
                                objectFit.init(args);
                            }, false);
                        } else {
                            window.attachEvent('onload', function(){
                                objectFit.init(args);
                            });
                        }
                    }
                } else {
                    if (objectFit._debug && window.console) {
                        console.log('object-fit natively supported');
                    }
                }
            };

            /*
	 * AMD, module loader, global registration
	 */

            // Expose modal for loaders that implement the Node module pattern.
            if (typeof module === 'object' && module && typeof module.exports === 'object') {
                module.exports = objectFit;

                // Register as an AMD module
            } else if (typeof define === 'function' && define.amd) {
                define([], function () { return objectFit; });

                // Export into global space
            } else if (typeof global === 'object' && typeof global.document === 'object') {
                global.objectFit = objectFit;
            }

        }(window));

    },{}],6:[function(require,module,exports){
// Sticky Plugin v1.0.2 for jQuery
// =============
// Author: Anthony Garand
// Improvements by German M. Bravo (Kronuz) and Ruud Kamphuis (ruudk)
// Improvements by Leonardo C. Daronco (daronco)
// Created: 2/14/2011
// Date: 16/04/2015
// Website: http://labs.anthonygarand.com/sticky
// Description: Makes an element on the page stick on the screen as you scroll
//       It will only set the 'top' and 'position' of your element, you
//       might need to adjust the width in some cases.

        (function($) {
            var slice = Array.prototype.slice; // save ref to original slice()
            var splice = Array.prototype.splice; // save ref to original slice()

            var defaults = {
                    topSpacing: 0,
                    bottomSpacing: 0,
                    className: 'is-sticky',
                    wrapperClassName: 'sticky-wrapper',
                    center: false,
                    getWidthFrom: '',
                    widthFromWrapper: true, // works only when .getWidthFrom is empty
                    responsiveWidth: false
                },
                $window = $(window),
                $document = $(document),
                sticked = [],
                windowHeight = $window.height(),
                scroller = function() {
                    var scrollTop = $window.scrollTop(),
                        documentHeight = $document.height(),
                        dwh = documentHeight - windowHeight,
                        extra = (scrollTop > dwh) ? dwh - scrollTop : 0;

                    for (var i = 0; i < sticked.length; i++) {
                        var s = sticked[i],
                            elementTop = s.stickyWrapper.offset().top,
                            etse = elementTop - s.topSpacing - extra;

                        if (scrollTop <= etse) {
                            if (s.currentTop !== null) {
                                s.stickyElement
                                    .css({
                                             'width': '',
                                             'position': '',
                                             'top': ''
                                         });
                                s.stickyElement.parent().removeClass(s.className);
                                s.stickyElement.trigger('sticky-end', [s]);
                                s.currentTop = null;
                            }
                        }
                        else {
                            var newTop = documentHeight - s.stickyElement.outerHeight()
                                         - s.topSpacing - s.bottomSpacing - scrollTop - extra;
                            if (newTop < 0) {
                                newTop = newTop + s.topSpacing;
                            } else {
                                newTop = s.topSpacing;
                            }
                            if (s.currentTop != newTop) {
                                var newWidth;
                                if ( s.getWidthFrom ) {
                                    newWidth = $(s.getWidthFrom).width() || null;
                                }
                                else if(s.widthFromWrapper) {
                                    newWidth = s.stickyWrapper.width();
                                }
                                if ( newWidth == null ) {
                                    newWidth = s.stickyElement.width();
                                }
                                s.stickyElement
                                    .css('width', newWidth)
                                    .css('position', 'fixed')
                                    .css('top', newTop);

                                s.stickyElement.parent().addClass(s.className);

                                if (s.currentTop === null) {
                                    s.stickyElement.trigger('sticky-start', [s]);
                                } else {
                                    // sticky is started but it have to be repositioned
                                    s.stickyElement.trigger('sticky-update', [s]);
                                }

                                if (s.currentTop === s.topSpacing && s.currentTop > newTop || s.currentTop === null && newTop < s.topSpacing) {
                                    // just reached bottom || just started to stick but bottom is already reached
                                    s.stickyElement.trigger('sticky-bottom-reached', [s]);
                                } else if(s.currentTop !== null && newTop === s.topSpacing && s.currentTop < newTop) {
                                    // sticky is started && sticked at topSpacing && overflowing from top just finished
                                    s.stickyElement.trigger('sticky-bottom-unreached', [s]);
                                }

                                s.currentTop = newTop;
                            }
                        }
                    }
                },
                resizer = function() {
                    windowHeight = $window.height();

                    for (var i = 0; i < sticked.length; i++) {
                        var s = sticked[i];
                        var newWidth = null;
                        if ( s.getWidthFrom ) {
                            if ( s.responsiveWidth === true ) {
                                newWidth = $(s.getWidthFrom).width();
                            }
                        }
                        else if(s.widthFromWrapper) {
                            newWidth = s.stickyWrapper.width();
                        }
                        if ( newWidth != null ) {
                            s.stickyElement.css('width', newWidth);
                        }
                    }
                },
                methods = {
                    init: function(options) {
                        var o = $.extend({}, defaults, options);
                        return this.each(function() {
                            var stickyElement = $(this);

                            var stickyId = stickyElement.attr('id');
                            var stickyHeight = stickyElement.outerHeight();
                            var wrapperId = stickyId ? stickyId + '-' + defaults.wrapperClassName : defaults.wrapperClassName
                            var wrapper = $('<div></div>')
                                .attr('id', wrapperId)
                                .addClass(o.wrapperClassName);

                            stickyElement.wrapAll(wrapper);

                            var stickyWrapper = stickyElement.parent();

                            if (o.center) {
                                stickyWrapper.css({width:stickyElement.outerWidth(),marginLeft:"auto",marginRight:"auto"});
                            }

                            if (stickyElement.css("float") == "right") {
                                stickyElement.css({"float":"none"}).parent().css({"float":"right"});
                            }

                            stickyWrapper.css('min-height', stickyHeight);

                            o.stickyElement = stickyElement;
                            o.stickyWrapper = stickyWrapper;
                            o.currentTop    = null;

                            sticked.push(o);
                        });
                    },
                    update: scroller,
                    unstick: function(options) {
                        return this.each(function() {
                            var that = this;
                            var unstickyElement = $(that);

                            var removeIdx = -1;
                            var i = sticked.length;
                            while ( i-- > 0 )
                            {
                                if (sticked[i].stickyElement.get(0) === that)
                                {
                                    splice.call(sticked,i,1);
                                    removeIdx = i;
                                }
                            }
                            if(removeIdx != -1)
                            {
                                unstickyElement.unwrap();
                                unstickyElement
                                    .css({
                                             'width': '',
                                             'position': '',
                                             'top': '',
                                             'float': ''
                                         })
                                ;
                            }
                        });
                    }
                };

            // should be more efficient than using $window.scroll(scroller) and $window.resize(resizer):
            if (window.addEventListener) {
                window.addEventListener('scroll', scroller, false);
                window.addEventListener('resize', resizer, false);
            } else if (window.attachEvent) {
                window.attachEvent('onscroll', scroller);
                window.attachEvent('onresize', resizer);
            }

            $.fn.sticky = function(method) {
                if (methods[method]) {
                    return methods[method].apply(this, slice.call(arguments, 1));
                } else if (typeof method === 'object' || !method ) {
                    return methods.init.apply( this, arguments );
                } else {
                    $.error('Method ' + method + ' does not exist on jQuery.sticky');
                }
            };

            $.fn.unstick = function(method) {
                if (methods[method]) {
                    return methods[method].apply(this, slice.call(arguments, 1));
                } else if (typeof method === 'object' || !method ) {
                    return methods.unstick.apply( this, arguments );
                } else {
                    $.error('Method ' + method + ' does not exist on jQuery.sticky');
                }

            };
            $(function() {
                setTimeout(scroller, 0);
            });
        })(jQuery);

    },{}],7:[function(require,module,exports){
        /*!
 * jQuery throttle / debounce - v1.1 - 3/7/2010
 * http://benalman.com/projects/jquery-throttle-debounce-plugin/
 *
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery throttle / debounce: Sometimes, less is more!
//
// *Version: 1.1, Last updated: 3/7/2010*
//
// Project Home - http://benalman.com/projects/jquery-throttle-debounce-plugin/
// GitHub       - http://github.com/cowboy/jquery-throttle-debounce/
// Source       - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.js
// (Minified)   - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.min.js (0.7kb)
//
// About: License
//
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
//
// About: Examples
//
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
//
// Throttle - http://benalman.com/code/projects/jquery-throttle-debounce/examples/throttle/
// Debounce - http://benalman.com/code/projects/jquery-throttle-debounce/examples/debounce/
//
// About: Support and Testing
//
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
//
// jQuery Versions - none, 1.3.2, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.6, Safari 3-4, Chrome 4-5, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-throttle-debounce/unit/
//
// About: Release History
//
// 1.1 - (3/7/2010) Fixed a bug in <jQuery.throttle> where trailing callbacks
//       executed later than they should. Reworked a fair amount of internal
//       logic as well.
// 1.0 - (3/6/2010) Initial release as a stand-alone project. Migrated over
//       from jquery-misc repo v0.4 to jquery-throttle repo v1.0, added the
//       no_trailing throttle parameter and debounce functionality.
//
// Topic: Note for non-jQuery users
//
// jQuery isn't actually required for this plugin, because nothing internal
// uses any jQuery methods or properties. jQuery is just used as a namespace
// under which these methods can exist.
//
// Since jQuery isn't actually required for this plugin, if jQuery doesn't exist
// when this plugin is loaded, the method described below will be created in
// the `Cowboy` namespace. Usage will be exactly the same, but instead of
// $.method() or jQuery.method(), you'll need to use Cowboy.method().

        (function(jQuery){
            '$:nomunge'; // Used by YUI compressor.

            // Since jQuery really isn't required for this plugin, use `jQuery` as the
            // namespace only if it already exists, otherwise use the `Cowboy` namespace,
            // creating it if necessary.
            var $ = jQuery || window.jQuery,

                // Internal method reference.
                jq_throttle;

            // Method: jQuery.throttle
            //
            // Throttle execution of a function. Especially useful for rate limiting
            // execution of handlers on events like resize and scroll. If you want to
            // rate-limit execution of a function to a single time, see the
            // <jQuery.debounce> method.
            //
            // In this visualization, | is a throttled-function call and X is the actual
            // callback execution:
            //
            // > Throttled with `no_trailing` specified as false or unspecified:
            // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
            // > X    X    X    X    X    X        X    X    X    X    X    X
            // >
            // > Throttled with `no_trailing` specified as true:
            // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
            // > X    X    X    X    X             X    X    X    X    X
            //
            // Usage:
            //
            // > var throttled = jQuery.throttle( delay, [ no_trailing, ] callback );
            // >
            // > jQuery('selector').bind( 'someevent', throttled );
            // > jQuery('selector').unbind( 'someevent', throttled );
            //
            // This also works in jQuery 1.4+:
            //
            // > jQuery('selector').bind( 'someevent', jQuery.throttle( delay, [ no_trailing, ] callback ) );
            // > jQuery('selector').unbind( 'someevent', callback );
            //
            // Arguments:
            //
            //  delay - (Number) A zero-or-greater delay in milliseconds. For event
            //    callbacks, values around 100 or 250 (or even higher) are most useful.
            //  no_trailing - (Boolean) Optional, defaults to false. If no_trailing is
            //    true, callback will only execute every `delay` milliseconds while the
            //    throttled-function is being called. If no_trailing is false or
            //    unspecified, callback will be executed one final time after the last
            //    throttled-function call. (After the throttled-function has not been
            //    called for `delay` milliseconds, the internal counter is reset)
            //  callback - (Function) A function to be executed after delay milliseconds.
            //    The `this` context and all arguments are passed through, as-is, to
            //    `callback` when the throttled-function is executed.
            //
            // Returns:
            //
            //  (Function) A new, throttled, function.

            $.throttle = jq_throttle = function( delay, no_trailing, callback, debounce_mode ) {
                // After wrapper has stopped being called, this timeout ensures that
                // `callback` is executed at the proper times in `throttle` and `end`
                // debounce modes.
                var timeout_id,

                    // Keep track of the last time `callback` was executed.
                    last_exec = 0;

                // `no_trailing` defaults to falsy.
                if ( typeof no_trailing !== 'boolean' ) {
                    debounce_mode = callback;
                    callback = no_trailing;
                    no_trailing = undefined;
                }

                // The `wrapper` function encapsulates all of the throttling / debouncing
                // functionality and when executed will limit the rate at which `callback`
                // is executed.
                function wrapper() {
                    var that = this,
                        elapsed = +new Date() - last_exec,
                        args = arguments;

                    // Execute `callback` and update the `last_exec` timestamp.
                    function exec() {
                        last_exec = +new Date();
                        callback.apply( that, args );
                    };

                    // If `debounce_mode` is true (at_begin) this is used to clear the flag
                    // to allow future `callback` executions.
                    function clear() {
                        timeout_id = undefined;
                    };

                    if ( debounce_mode && !timeout_id ) {
                        // Since `wrapper` is being called for the first time and
                        // `debounce_mode` is true (at_begin), execute `callback`.
                        exec();
                    }

                    // Clear any existing timeout.
                    timeout_id && clearTimeout( timeout_id );

                    if ( debounce_mode === undefined && elapsed > delay ) {
                        // In throttle mode, if `delay` time has been exceeded, execute
                        // `callback`.
                        exec();

                    } else if ( no_trailing !== true ) {
                        // In trailing throttle mode, since `delay` time has not been
                        // exceeded, schedule `callback` to execute `delay` ms after most
                        // recent execution.
                        //
                        // If `debounce_mode` is true (at_begin), schedule `clear` to execute
                        // after `delay` ms.
                        //
                        // If `debounce_mode` is false (at end), schedule `callback` to
                        // execute after `delay` ms.
                        timeout_id = setTimeout( debounce_mode ? clear : exec, debounce_mode === undefined ? delay - elapsed : delay );
                    }
                };

                // Set the guid of `wrapper` function to the same of original callback, so
                // it can be removed in jQuery 1.4+ .unbind or .die by using the original
                // callback as a reference.
                if ( $.guid ) {
                    wrapper.guid = callback.guid = callback.guid || $.guid++;
                }

                // Return the wrapper function.
                return wrapper;
            };

            // Method: jQuery.debounce
            //
            // Debounce execution of a function. Debouncing, unlike throttling,
            // guarantees that a function is only executed a single time, either at the
            // very beginning of a series of calls, or at the very end. If you want to
            // simply rate-limit execution of a function, see the <jQuery.throttle>
            // method.
            //
            // In this visualization, | is a debounced-function call and X is the actual
            // callback execution:
            //
            // > Debounced with `at_begin` specified as false or unspecified:
            // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
            // >                          X                                 X
            // >
            // > Debounced with `at_begin` specified as true:
            // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
            // > X                                 X
            //
            // Usage:
            //
            // > var debounced = jQuery.debounce( delay, [ at_begin, ] callback );
            // >
            // > jQuery('selector').bind( 'someevent', debounced );
            // > jQuery('selector').unbind( 'someevent', debounced );
            //
            // This also works in jQuery 1.4+:
            //
            // > jQuery('selector').bind( 'someevent', jQuery.debounce( delay, [ at_begin, ] callback ) );
            // > jQuery('selector').unbind( 'someevent', callback );
            //
            // Arguments:
            //
            //  delay - (Number) A zero-or-greater delay in milliseconds. For event
            //    callbacks, values around 100 or 250 (or even higher) are most useful.
            //  at_begin - (Boolean) Optional, defaults to false. If at_begin is false or
            //    unspecified, callback will only be executed `delay` milliseconds after
            //    the last debounced-function call. If at_begin is true, callback will be
            //    executed only at the first debounced-function call. (After the
            //    throttled-function has not been called for `delay` milliseconds, the
            //    internal counter is reset)
            //  callback - (Function) A function to be executed after delay milliseconds.
            //    The `this` context and all arguments are passed through, as-is, to
            //    `callback` when the debounced-function is executed.
            //
            // Returns:
            //
            //  (Function) A new, debounced, function.

            jQuery.debounce = function( delay, at_begin, callback ) {
                return callback === undefined
                    ? jq_throttle( delay, at_begin, false )
                    : jq_throttle( delay, callback, at_begin !== false );
            };

        })(require('jquery'));

    },{"jquery":2}],8:[function(require,module,exports){
        var browser = {};
        var os = {};
        var device = {};
        var touch = false;
        var ua = navigator.userAgent;
        var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/),
            android = ua.match(/(Android);?[\s\/]+([\d.]+)?/),
            ipad = ua.match(/(iPad).*OS\s([\d_]+)/),
            ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/),
            iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/),
            webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/),
            touchpad = webos && ua.match(/TouchPad/),
            kindle = ua.match(/Kindle\/([\d.]+)/),
            silk = ua.match(/Silk\/([\d._]+)/),
            blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/),
            bb10 = ua.match(/(BB10).*Version\/([\d.]+)/),
            rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/),
            playbook = ua.match(/PlayBook/),
            chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/),
            firefox = ua.match(/Firefox\/([\d.]+)/),
            ie = ua.match(/(Trident|MSIE\s([\d.])+)/),
            edge = ua.match(/(Edge\/([\d.])+)/),
            //webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/),
            wp8 = ua.match(/Trident\/([\d.]+)/) && ua.match(/IEMobile\/([\d.]+)/)
        safari = webkit && ua.match(/Safari\//) && !chrome && !wp8

        if (browser.webkit = !!webkit) browser.version = webkit[1]

        if (android) os.android = true, os.version = android[2]
        if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.')
        if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.')
        if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null
        if (webos) os.webos = true, os.version = webos[2]
        if (touchpad) os.touchpad = true
        if (blackberry) os.blackberry = true, os.version = blackberry[2]
        if (bb10) os.bb10 = true, os.version = bb10[2]
        if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2]
        if (playbook) browser.playbook = true
        if (kindle) os.kindle = true, os.version = kindle[1]
        if (silk) browser.silk = true, browser.version = silk[1]
        if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true
        if (edge) browser.edge = true, browser.version = edge[0].split('/')[1], delete browser.webkit;
        if (chrome && !edge) browser.chrome = true, browser.version = chrome[1];
        if (firefox) browser.firefox = true, browser.version = firefox[1];
        if (ie) browser.ie = true, browser.version = ie[1];
        if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
//if (webkit && android && !chrome && !edge) browser.webview = true;
        if (wp8) browser.ie = true, os.android = os.ios = os.ipad = os.iphone = browser.webkit = browser.safari = browser.webview = false;

        device.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
                           (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
        device.phone = !!(!device.tablet && !os.ipod && (android || iphone || webos || blackberry || bb10 ||
                          (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
                          (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))) || (wp8));
        device.desktop = !device.tablet && !device.phone;

        function toString() {
            var classes = [];

            for (var i in os)
                if (os[i] === true)
                    classes.push(i);

            for (var i in browser)
                if (browser[i] === true)
                    classes.push(i);

            for (var i in device)
                if (device[i] === true)
                    classes.push(i);

            if (device.desktop) {
                if (touch = isTouchDevice() === true)
                    classes.push('touch');
            } else {
                touch = true;
                classes.push('touch');
            }

            return classes.join(' ');
        }

        function isTouchDevice() {
            try {
                document.createEvent("TouchEvent");
                return true;
            } catch (e) {
                return false;
            }
        };

        document.body.className += ' ' + toString();

        module.exports = {
            'os': os,
            'browser': browser,
            'device': device,
            'touch': touch,
            'toString': toString
        };

    },{}],9:[function(require,module,exports){
        var Signal = require('./signal');
        var EVENTS = {};

        EVENTS.START = 'touchstart';
        EVENTS.MOVE = 'touchmove';
        EVENTS.END = ['touchend', 'touchcancel'];

        if (window.PointerEvent) {
            EVENTS.START = 'pointerdown';
            EVENTS.MOVE = 'pointermove';
            EVENTS.END = 'pointerout';
        } else if (window.MSPointerEvent) {
            EVENTS.START = 'MSPointerDown';
            EVENTS.MOVE = 'MSPointerMove';
            EVENTS.END = 'MSPointerOut';
        }


        /*
 * Base API
 */
        function Gestures() {};
        Gestures.prototype.touches = {};
        Gestures.prototype.onTouchStart = new Signal();
        Gestures.prototype.onTouchMove  = new Signal();
        Gestures.prototype.onTouchEnd   = new Signal();

        Gestures.prototype.getEventTouches = function(event) {return []};
        Gestures.prototype.getTouchId = function(touch) {return 0};
        Gestures.prototype.getTouchX  = function(touch) {return 0};
        Gestures.prototype.getTouchY  = function(touch) {return 0};

        Gestures.prototype.sort = function(a, b) {
            return b.time - a.time;
        };

        Gestures.prototype.toList = function() {
            var results = [];
            for (var id in this.touches)
                results.push(this.touches[id]);
            return results.sort(this.sort);
        };

        Gestures.prototype.enable = function() {
            document.body.addEventListener(EVENTS.START, this.touchstart.bind(this));
            document.body.addEventListener(EVENTS.MOVE,  this.touchmove.bind(this));

            if (EVENTS.END instanceof Array) {
                for (var i = 0; i < EVENTS.END.length; i++)
                    document.body.addEventListener(EVENTS.END[i], this.touchend.bind(this));
            } else
                document.body.addEventListener(EVENTS.END,   this.touchend.bind(this));
        };

        Gestures.prototype.disable = function() {
            document.body.removeEventListener(EVENTS.START, this.touchstart.bind(this));
            document.body.removeEventListener(EVENTS.MOVE,  this.touchmove.bind(this));

            if (EVENTS.END instanceof Array) {
                for (var i = 0; i < EVENTS.END.length; i++)
                    document.body.removeEventListener(EVENTS.END[i], this.touchend.bind(this));
            } else
                document.body.removeEventListener(EVENTS.END,   this.touchend.bind(this));
        };

        Gestures.prototype.updateTouch = function(newTouch) {
            var id = this.getTouchId(newTouch);
            var touch = this.touches[id];
            var x = this.getTouchX(newTouch);
            var y = this.getTouchY(newTouch);
            touch.x = x;
            touch.y = y;
            touch.dx = touch.x - touch.sx;
            touch.dy = touch.y - touch.sy;
            return touch;
        };

        Gestures.prototype.touchstart = function(event) {
            var touches = this.getEventTouches(event);
            for (var i = 0; i < touches.length; i++) {
                var id = this.getTouchId(touches[i]);
                var x = this.getTouchX(touches[i]);
                var y = this.getTouchY(touches[i]);
                var touch = this.touches[id] = {
                    'id': id,
                    'x': x,
                    'y': y,
                    'sx': x,
                    'sy': y,
                    'dx': 0,
                    'dy': 0,
                    'time': Date.now(),
                    'target': event.target
                };
                this.onTouchStart.send(event.target, touch, event);
            }
        };

        Gestures.prototype.touchmove = function(event) {
            var touches = this.getEventTouches(event);
            for (var i = 0; i < touches.length; i++) {
                var id = this.getTouchId(touches[i]);
                if (!this.touches[id])
                    continue;
                this.onTouchMove.send(event.target, this.updateTouch(touches[i]), event);
            }
        };

        Gestures.prototype.touchend = function(event) {
            var touches = this.getEventTouches(event);
            for (var i = 0; i < touches.length; i++) {
                var id = this.getTouchId(touches[i]);
                if (!this.touches[id])
                    continue;
                var touch = this.updateTouch(touches[i]);
                this.onTouchEnd.send(event.target, touch, event);
                delete this.touches[touch.id];
            }
        };



        /*
 * Touch API
 */
        function TouchApi() {}
        TouchApi.prototype = Object.create(Gestures.prototype);

        TouchApi.prototype.getEventTouches = function(event) {return event.touches.length ? event.touches : event.changedTouches};
        TouchApi.prototype.getTouchId = function(touch) {return touch.identifier};
        TouchApi.prototype.getTouchX = function(touch) {return touch.pageX};
        TouchApi.prototype.getTouchY = function(touch) {return touch.pageY};



        /*
 * Pointer API
 */
        function PointerApi() {}

        PointerApi.prototype = Object.create(Gestures.prototype);

        PointerApi.prototype.getEventTouches = function(event) {return [event]};
        PointerApi.prototype.getTouchId = function(pointer) {return pointer.pointerId};
        PointerApi.prototype.getTouchX = function(pointer) {return pointer.pageX};
        PointerApi.prototype.getTouchY = function(pointer) {return pointer.pageY};



        if (window.PointerEvent || window.MSPointerEvent)
            module.exports = new PointerApi();
        else
            module.exports = new TouchApi();

    },{"./signal":12}],10:[function(require,module,exports){
        'use strict';


        function sum() {
            return Array.prototype.slice.apply(arguments).reduce(function(result, value) {
                if (value instanceof Array)
                    return result + sum.apply(undefined, value);
                else if (isNaN(Number(value)))
                    throw new TypeError('sum(): `' + value + '` is not a number');
                else
                    return result + Number(value);
            }, 0);
        }


        function multiply() {
            return Array.prototype.slice.apply(arguments).reduce(function(result, value) {
                if (value instanceof Array)
                    return result * multiply.apply(undefined, value);
                else if (isNaN(Number(value)))
                    throw new TypeError('sum(): `' + value + '` is not a number');
                else
                    return result * Number(value);
            }, 1);
        }


        function fract(n) {
            return n - Math.trunc(n);
        }


        function mod(n, m) {
            // Alternative modulo operation where result's sign is the same as divisor's.
            return ((n % m) + m) % m;
        }


        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }


        function mix(min, max, alpha) {
            return min * (1 - alpha) + max * alpha;
        }


        function step(edge, n) {
            return n < edge ? 0 : 1;
        }


        function smoothStep(minEdge, maxEdge, n) {
            // See also: http://en.wikipedia.org/wiki/Smoothstep
            var t = this.clamp((n - minEdge) / (maxEdge - minEdge), 0, 1);
            return t * t * (3 - 2*t);
        }


        function scale(n, currentMin, currentMax, newMin, newMax) {
            // Scales n from one range to another.
            return newMin + (n - currentMin) * (newMax - newMin) / (currentMax - currentMin);
        }


        function range(start, stop, step) {
            /*
     * Generate an integer Array containing an arithmetic progression. A port of the native Python `range()`
     * function. See the Python documentation: http://docs.python.org/library/functions.html#range.
     */
            if (arguments.length < 2) {
                stop = start;
                start = 0;
            }
            if (arguments.length < 3)
                step = start > stop ? -1 : 1;
            var length = Math.max(Math.ceil((stop - start) / step), 0);
            var idx = 0;
            var range = new Array(length);

            while (idx < length) {
                range[idx++] = start;
                start += step;
            }

            return range;
        }


        function toFixed(num, precision) {
            // Consistently across browsers converts a number to given precision.
            return (+(Math.round(+(num + 'e' + precision)) + 'e' + -precision)).toFixed(precision);
        }


        function format(number, decimalPlaces, decimalSeparator, thousandsSeparator) {
            /*
     * © 2011 Esa-Matti Suuronen
     * Adapted from https://github.com/epeli/underscore.string
     */
            if (isNaN(number) || number == null)
                return '';
            if (arguments.length < 4)
                thousandsSeparator = ',';
            if (arguments.length < 3)
                decimalSeparator = '.';
            if (arguments.length < 2)
                decimalPlaces = 2;
            number = toFixed(number, decimalPlaces);
            var parts = number.split('.');
            var fnums = parts[0];
            var decimals = parts[1] ? decimalSeparator + parts[1] : '';
            return fnums.replace(/(\d)(?=(?:\d{3})+$)/g, '$1' + thousandsSeparator) + decimals;
        }


        function distance(x1, y1, x2, y2) {
            var dx = x1 - x2, dy = y1 - y2;
            return Math.sqrt(dx*dx + dy*dy);
        }


        function radians(angle) {
            return angle * Math.PI / 180;
        }


        function degrees(angle) {
            return angle * 180 / Math.PI;
        }


        function isPowerOfTwo(n) {
            /*
     * Returns `true` if `n` is a power of 2. `n` must be a positive integer. Works only up to 2^31.
     * Source: https://graphics.stanford.edu/~seander/bithacks.html#DetermineIfPowerOf2
     */
            if (n <= 0 || (n !== 2147483648 && n !== ~~n))
                return false;
            return !(n & (n - 1));
        }


        function nextPowerOfTwo(n) {
            /*
     * Returns power of 2 greater or equal to `n`.
     * Source: https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
     */
            if (n < 1)
                return 1;
            if (this.isPowerOfTwo(n))
                return n;
            n -= 1;
            n |= n >> 1;
            n |= n >> 2;
            n |= n >> 4;
            n |= n >> 8;
            n |= n >> 16;
            return n + 1;
        }


        module.exports ={
            'sum': sum,
            'multiply': multiply,
            'fract': fract,
            'mod': mod,
            'clamp': clamp,
            'mix': mix,
            'step': step,
            'smoothStep': smoothStep,
            'scale': scale,
            'range': range,
            'format': format,
            'distance': distance,
            'radians': radians,
            'degrees': degrees,
            'isPowerOfTwo': isPowerOfTwo,
            'nextPowerOfTwo': nextPowerOfTwo
        }

    },{}],11:[function(require,module,exports){
        /*
 * Put global configuration options here.
 */
        module.exports = {
            // Enable or disable jQuery 'no conflict' mode. Defaults to `true`.
            'JQUERY_NO_CONFLICT': true,

            // Some libraries use naming that is not compatible with our strict naming rules. Using the mapping below you
            // can make these libraries load properly under a new, compatible name.
            //'ALIASES': {
            //    'Phaser': 'phaser',
            //    'PIXI': 'pixi'
            //},

            'VIEWPORTS': {
                '320': [0, 320],
                '768': [321, 768],
                '1024': [769, Infinity]
            },
            // Uncomment this to disable 'viewport-portrait' and 'viewport-landscape' classes added automatically to body.
            // 'VIEWPORT_ORIENTATION_CLASS': true,

            'SMART_BLOCKS': {
                // Example smart block configuration.
                // Initial element selector.
                // '.block': {
                //     //Additional classes that will be applied when width of parent is between given numbers.
                //     'small': [0, 299],
                //     'medium': [300, 699],
                //     'big': [700, Infinity],
                // },
                // '.self-block': {
                //    // Additional classes that will be applied when width of element is between given numbers.
                //    'small': [0, 299, 'self'],
                //    'medium': [300, 699, 'self'],
                //    'big': [700, Infinity, 'self'],
                //}
            },

            'TRANSLATIONS': {
                'ENG': {
                    'no_file': 'Click to select',
                    'characters': 'characters',
                    'hide': 'hide',
                    'message_delete_confirm': 'Do you really want to delete this message?',
                    'validation_required': 'Field is required',
                    'validation_email': 'Invalid email format',
                    'validation_minlength': 'Min. {0} characters',
                    'validation_equal': 'Equal field',
                    'validation_phone': 'Invalid phone number',
                    'validation_numbers': 'Numbers only',
                    'validation_letters-only': 'Letters only'
                }
            }
        };

    },{}],12:[function(require,module,exports){
        /*
 * Simple signal dispatcher implementation.
 */
        'use strict';
        var detect = require('./detect');

        function connect() {
            var kwargs = typeof arguments[0] === 'function' ? {'receiver': arguments[0]} : arguments[0];
            if (typeof kwargs.receiver !== 'function')
                throw new Error("can't connect receiver to a signal, receiver is not a function");
            for (var i = 0; i < this.receivers.length; i++)
                if (this.receivers[i].receiver === kwargs.receiver && this.receivers[i].context === kwargs.context && this.receivers[i].sender === kwargs.sender)
                    throw new Error("can't connect receiver to a signal, this receiver with same context and same sender is already connected");
            this.receivers.push({
                                    'receiver': kwargs.receiver,
                                    'sender': kwargs.sender,
                                    'context': kwargs.context});
        }

        function disconnect() {
            // Given receiver will not be notified about this signal sending anymore.
            var receiver = typeof arguments[0] === 'function' ? arguments[0] : arguments[0].receiver;
            for (var i = 0; i < this.receivers.length; i++)
                if (this.receivers[i].receiver === receiver) {
                    this.receivers.splice(i, 1);
                    return;
                }
        }

        function send(sender) {
            // Execute all connected receivers, forwarding all arguments.
            for (var i = 0; i < this.receivers.length; i++) {
                var entry = this.receivers[i];
                if (typeof entry.sender === 'undefined' || entry.sender === sender)
                    entry.receiver.apply(entry.context, arguments);
            }
        }

        function Signal() {
            /*
     * This is constructor that should be called with the `new` operator, but it returns a function with
     * attributes and methods. In this way signal instances can be called directly, i.e. they can be used as
     * a function.
     */
            function signal() {
                connect.apply(signal, arguments);
            }
            signal.receivers = [];
            signal.connect = connect.bind(signal);
            signal.disconnect = disconnect.bind(signal);
            signal.send = send.bind(signal);
            return signal;
        }


        module.exports = Signal;

    },{"./detect":8}],13:[function(require,module,exports){
        /*
 * Automatically applies additional classes to an element based on width of this element or its parent.
 *
 * Example, simple settings:
 *
 *     'SMART_BLOCKS': {
 *         // Initial element selector, can be any CSS selector supported by browser.
 *         '.block': {
 *             // Additional classes that will be applied when width of parent is between given numbers.
 *             'small': [0, 299],
 *             'medium': [300, 699],
 *             'medium': 'viewportname',
 *             'big': [700, Infinity],
 *             'big': function(block) {...},
 *         }
 *     }
 */
        'use strict';

        var settings = require('./settings');
        var Signal = require('./signal');
        var viewport = require('./viewport');
// Signal sent whenever any of the blocks had class changed.
        var onUpdate = new Signal();


        function clean(block, args) {
            if (typeof args === 'function')
                return args(block);
            else if (args instanceof Array && (args.length == 2 || (args.length == 3 && args[2] === 'self')) &&
                     typeof args[0] === 'number' && typeof args[1] === 'number' && args[0] <= args[1]) {
                var width = args[2] === 'self' ? block.offsetWidth : block.parentNode.offsetWidth;
                return args[0] <= width && width <= args[1];
            } else if (typeof args === 'string')
                return viewport.is(args);
            throw new Error('Invalid smart blocks args: ' + args);
        }


        function updateBlock(block, specification, selector) {
            var classModified = false;
            for (var className in specification) {
                var classAdded = block.classList.contains(className);

                if (clean(block, specification[className])) {
                    if (!classAdded) {
                        block.classList.add(className);
                        classModified = true;
                    }
                } else if (classAdded) {
                    block.classList.remove(className);
                    classModified = true;
                }
            }
            if (classModified)
                onUpdate.send(selector, block);
        }


        function updateTree(root) {
            var BLOCKS = settings['SMART_BLOCKS'];
            var selector, blocks, i;
            for (selector in BLOCKS) {
                blocks = root.querySelectorAll(selector);
                for (i = 0; i < blocks.length; i++)
                    updateBlock(blocks[i], BLOCKS[selector], selector);
            }
        }


        function updateDocument() {
            updateTree(window.document.body);
        }


        function enable() {
            window.addEventListener('resize', updateDocument);
        }


        function disable() {
            window.removeEventListener('resize', updateDocument);
        }


        module.exports = {
            'onUpdate': onUpdate,
            'updateBlock': updateBlock,
            'updateTree': updateTree,
            'updateDocument': updateDocument,
            'enable': enable,
            'disable': disable
        };

    },{"./settings":11,"./signal":12,"./viewport":16}],14:[function(require,module,exports){
        /*
 * Throttle execution of a function.
 * Especially useful for rate limiting execution of handlers on events like resize and scroll.
 * Executes callback every X seconds defined in rate variable.
 *
 *  Usage example:
 *      jQuery.on('mousemove', throttle(this, 250, function(event) {
 *          // Event handling code
 *      });
 *
 *  Arguments:
 *      scope - (Object) Passing scope
 *      delay - (Number) > 0 Time beetween callback firing
 *      callback - (Function) callback function
 */
        module.exports = function(scope, delay, callback) {
            var delay = delay || 250;
            var lastExecution, timer;

            return function () {
                clearTimeout(timer);

                var context = scope || this;

                var now = new Date,
                    args = arguments;

                var fn = function () {
                    lastExecution = now.getTime();
                    callback.apply(context, args);
                };

                if (lastExecution && now.getTime() < lastExecution + delay)
                    timer = setTimeout(fn, delay);
                else
                    fn();
            };
        };

    },{}],15:[function(require,module,exports){
        'use strict';
        var settings = require('./settings');
        function translate(key, variables) {
            var translation;
            // var language = settings['LANGUAGE'];

            if (typeof settings[key] != 'undefined')
                translation = settings[key];
            else
                translation = settings['TRANSLATIONS'][language][key];

            return translation.replace(/{(\d+)}/g, function(match, number) {
                return typeof variables[number] != 'undefined' ? variables[number] : match;
            });
        }

        module.exports = translate;

    },{"./settings":11}],16:[function(require,module,exports){
        /*
 * Allows to define custom viewports using settings file and then react, when viewport changes (due to browser resize
 * or device orientation change).
 *
 * To specify own viewports add this setting:
 *
 *     'VIEWPORTS': {
 *         'my viewport name': [0, 500],
 *         'other viewport': [501, 1000],
 *         'something else': '(min-width: 1001px) or (max-width: 9999px)',
 *         ...
 *     }
 *
 * Each viewport consists of a alias and specification. A specification may be a function, two-element array or
 * media query string.
 *
 * Only one viewport is active in given moment, even when two specifications are overlapping
 * (random one will be returned), thus it's recommened to define non-overlapping breakpoints.
 */
        'use strict';
        var settings = require('./settings');
        var Signal = require('./signal');
        var active = undefined, portrait = undefined;
        var onChange = new Signal();

        function _check(specification) {
            /*
     * Returns `true` if given viewport specification (may be a function, array or media query string)
     * is active.
     */
            if (typeof specification === 'function')
                return specification();
            else if (specification instanceof Array && specification.length === 2 &&
                     typeof specification[0] === 'number' && typeof specification[1] === 'number' &&
                     specification[0] <= specification[1])
                return specification[0] <= width() && width() <= specification[1];
            else if (typeof specification === 'string') {
                    if (!window.matchMedia)
                        throw new Error('matchMedia is not available in this browser, please add a polyfill');
                    return window.matchMedia(specification).matches;
                }
            throw new Error('Invalid viewport specification: ' + specification);
        }

        function _changeOrientation(newPortrait) {
            if (newPortrait !== portrait) {
                // if (settings['VIEWPORT_ORIENTATION_CLASS'] === true)) {
                var VIEWPORT_CLASS_PREFIX = 'viewport-';
                window.document.body.classList.remove(VIEWPORT_CLASS_PREFIX + (portrait ? 'portrait' : 'landscape'));
                window.document.body.classList.add(VIEWPORT_CLASS_PREFIX + (newPortrait ? 'portrait' : 'landscape'));
                // }
                portrait = newPortrait;
            }
        }

        function _changeViewport(newClass) {
            var previousClass = active || null;
            if (newClass !== active) {
                var VIEWPORT_CLASS_PREFIX = 'viewport-';
                if (active)
                    window.document.body.classList.remove(VIEWPORT_CLASS_PREFIX + active);
                if (newClass)
                    window.document.body.classList.add(VIEWPORT_CLASS_PREFIX + newClass);
                active = newClass;
                onChange.send(previousClass, active);
            }
        }

        function _update() {
            var VIEWPORTS = settings['VIEWPORTS'], newClass = null;

            for (var alias in VIEWPORTS)
                if (_check(VIEWPORTS[alias])) {
                    newClass = alias;
                    break;
                }

            _changeViewport(newClass);
            _changeOrientation(height() >= width());
        }

        function _is(alias) {
            /*
     * Returns `true` if given `alias` is currently active. `alias` must be one of the viewport names defined
     * in settings.
     */
            var VIEWPORTS = settings['VIEWPORTS'];
            if (alias in VIEWPORTS)
                return alias === active;
            throw new Error('Unknown viewport alias: ' + alias);
        }

        function is(aliases) {
            if (!isEnabled())
                throw new Error('You must call `viewport.enable()` first to use `viewport.is()`');
            /*
     * Returns `true` if any of the aliases is currently active. `aliases` must be a string with any
     * viewport names defined in settings, separated by space.
     */
            aliases = aliases.split(' ');
            for (var i = 0; i < aliases.length; i++)
                if (_is(aliases[i]))
                    return true;
            return false;
        }

        function get() {
            if (!isEnabled())
                throw new Error('You must call `viewport.enable()` first to use `viewport.get()`');
            /*
     * Returns name of currently active viewport. May return `null` if none viewport is active.
     */
            return active;
        }

        function width() {
            /*
     * Returns window width, excluding toolbars and scrollbars.
     */
            return window.innerWidth || window.document.documentElement.clientWidth;
        }

        function height() {
            /*
     * Returns window height, excluding toolbars and scrollbars.
     */
            return window.innerHeight || window.document.documentElement.clientHeight;
        }

        function isPortrait() {
            if (!isEnabled())
                throw new Error('You must call `viewport.enable()` first to use `viewport.isPortrait()`');
            return portrait;
        }

        function isLandscape() {
            if (!isEnabled())
                throw new Error('You must call `viewport.enable()` first to use `viewport.isLandscape()`');
            return !portrait;
        }

        function enable() {
            _update();
            window.addEventListener('resize', _update);
        }

        function disable() {
            window.removeEventListener('resize', _update);
            active = portrait = undefined;
        }

        function isEnabled() {
            return typeof active !== 'undefined';
        }

        module.exports = {
            '_changeOrientation': _changeOrientation,
            '_changeViewport': _changeViewport,
            '_check': _check,
            '_update': _update,
            'width': width,
            'height': height,
            'is': is,
            'get': get,
            'isPortrait': isPortrait,
            'isLandscape': isLandscape,
            'onChange': onChange,
            'enable': enable,
            'disable': disable,
            'isEnabled': isEnabled
        }

    },{"./settings":11,"./signal":12}],17:[function(require,module,exports){
        /**
         * Autoplay Plugin
         * @version 2.1.0
         * @author Bartosz Wojciechowski
         * @author Artus Kolanowski
         * @author David Deutsch
         * @license The MIT License (MIT)
         */
        ;(function($, window, document, undefined) {

            /**
             * Creates the autoplay plugin.
             * @class The Autoplay Plugin
             * @param {Owl} scope - The Owl Carousel
             */
            var Autoplay = function(carousel) {
                /**
                 * Reference to the core.
                 * @protected
                 * @type {Owl}
                 */
                this._core = carousel;

                /**
                 * The autoplay timeout.
                 * @type {Timeout}
                 */
                this._timeout = null;

                /**
                 * Indicates whenever the autoplay is paused.
                 * @type {Boolean}
                 */
                this._paused = false;

                /**
                 * All event handlers.
                 * @protected
                 * @type {Object}
                 */
                this._handlers = {
                    'changed.owl.carousel': $.proxy(function(e) {
                        if (e.namespace && e.property.name === 'settings') {
                            if (this._core.settings.autoplay) {
                                this.play();
                            } else {
                                this.stop();
                            }
                        } else if (e.namespace && e.property.name === 'position') {
                            //console.log('play?', e);
                            if (this._core.settings.autoplay) {
                                this._setAutoPlayInterval();
                            }
                        }
                    }, this),
                    'initialized.owl.carousel': $.proxy(function(e) {
                        if (e.namespace && this._core.settings.autoplay) {
                            this.play();
                        }
                    }, this),
                    'play.owl.autoplay': $.proxy(function(e, t, s) {
                        if (e.namespace) {
                            this.play(t, s);
                        }
                    }, this),
                    'stop.owl.autoplay': $.proxy(function(e) {
                        if (e.namespace) {
                            this.stop();
                        }
                    }, this),
                    'mouseover.owl.autoplay': $.proxy(function() {
                        if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
                            this.pause();
                        }
                    }, this),
                    'mouseleave.owl.autoplay': $.proxy(function() {
                        if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
                            this.play();
                        }
                    }, this),
                    'touchstart.owl.core': $.proxy(function() {
                        if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
                            this.pause();
                        }
                    }, this),
                    'touchend.owl.core': $.proxy(function() {
                        if (this._core.settings.autoplayHoverPause) {
                            this.play();
                        }
                    }, this)
                };

                // register event handlers
                this._core.$element.on(this._handlers);

                // set default options
                this._core.options = $.extend({}, Autoplay.Defaults, this._core.options);
            };

            /**
             * Default options.
             * @public
             */
            Autoplay.Defaults = {
                autoplay: false,
                autoplayTimeout: 5000,
                autoplayHoverPause: false,
                autoplaySpeed: false
            };

            /**
             * Starts the autoplay.
             * @public
             * @param {Number} [timeout] - The interval before the next animation starts.
             * @param {Number} [speed] - The animation speed for the animations.
             */
            Autoplay.prototype.play = function(timeout, speed) {
                this._paused = false;

                if (this._core.is('rotating')) {
                    return;
                }

                this._core.enter('rotating');

                this._setAutoPlayInterval();
            };

            /**
             * Gets a new timeout
             * @private
             * @param {Number} [timeout] - The interval before the next animation starts.
             * @param {Number} [speed] - The animation speed for the animations.
             * @return {Timeout}
             */
            Autoplay.prototype._getNextTimeout = function(timeout, speed) {
                if ( this._timeout ) {
                    window.clearTimeout(this._timeout);
                }
                return window.setTimeout($.proxy(function() {
                    if (this._paused || this._core.is('busy') || this._core.is('interacting') || document.hidden) {
                        return;
                    }
                    this._core.next(speed || this._core.settings.autoplaySpeed);
                }, this), timeout || this._core.settings.autoplayTimeout);
            };

            /**
             * Sets autoplay in motion.
             * @private
             */
            Autoplay.prototype._setAutoPlayInterval = function() {
                this._timeout = this._getNextTimeout();
            };

            /**
             * Stops the autoplay.
             * @public
             */
            Autoplay.prototype.stop = function() {
                if (!this._core.is('rotating')) {
                    return;
                }

                window.clearTimeout(this._timeout);
                this._core.leave('rotating');
            };

            /**
             * Stops the autoplay.
             * @public
             */
            Autoplay.prototype.pause = function() {
                if (!this._core.is('rotating')) {
                    return;
                }

                this._paused = true;
            };

            /**
             * Destroys the plugin.
             */
            Autoplay.prototype.destroy = function() {
                var handler, property;

                this.stop();

                for (handler in this._handlers) {
                    this._core.$element.off(handler, this._handlers[handler]);
                }
                for (property in Object.getOwnPropertyNames(this)) {
                    typeof this[property] != 'function' && (this[property] = null);
                }
            };

            $.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;

        })(window.Zepto || window.jQuery, window, document);

    },{}],18:[function(require,module,exports){
        /**
         * Owl carousel
         * @version 2.1.6
         * @author Bartosz Wojciechowski
         * @author David Deutsch
         * @license The MIT License (MIT)
         * @todo Lazy Load Icon
         * @todo prevent animationend bubling
         * @todo itemsScaleUp
         * @todo Test Zepto
         * @todo stagePadding calculate wrong active classes
         */
        ;(function($, window, document, undefined) {

            /**
             * Creates a carousel.
             * @class The Owl Carousel.
             * @public
             * @param {HTMLElement|jQuery} element - The element to create the carousel for.
             * @param {Object} [options] - The options
             */
            function Owl(element, options) {

                /**
                 * Current settings for the carousel.
                 * @public
                 */
                this.settings = null;

                /**
                 * Current options set by the caller including defaults.
                 * @public
                 */
                this.options = $.extend({}, Owl.Defaults, options);

                /**
                 * Plugin element.
                 * @public
                 */
                this.$element = $(element);

                /**
                 * Proxied event handlers.
                 * @protected
                 */
                this._handlers = {};

                /**
                 * References to the running plugins of this carousel.
                 * @protected
                 */
                this._plugins = {};

                /**
                 * Currently suppressed events to prevent them from beeing retriggered.
                 * @protected
                 */
                this._supress = {};

                /**
                 * Absolute current position.
                 * @protected
                 */
                this._current = null;

                /**
                 * Animation speed in milliseconds.
                 * @protected
                 */
                this._speed = null;

                /**
                 * Coordinates of all items in pixel.
                 * @todo The name of this member is missleading.
                 * @protected
                 */
                this._coordinates = [];

                /**
                 * Current breakpoint.
                 * @todo Real media queries would be nice.
                 * @protected
                 */
                this._breakpoint = null;

                /**
                 * Current width of the plugin element.
                 */
                this._width = null;

                /**
                 * All real items.
                 * @protected
                 */
                this._items = [];

                /**
                 * All cloned items.
                 * @protected
                 */
                this._clones = [];

                /**
                 * Merge values of all items.
                 * @todo Maybe this could be part of a plugin.
                 * @protected
                 */
                this._mergers = [];

                /**
                 * Widths of all items.
                 */
                this._widths = [];

                /**
                 * Invalidated parts within the update process.
                 * @protected
                 */
                this._invalidated = {};

                /**
                 * Ordered list of workers for the update process.
                 * @protected
                 */
                this._pipe = [];

                /**
                 * Current state information for the drag operation.
                 * @todo #261
                 * @protected
                 */
                this._drag = {
                    time: null,
                    target: null,
                    pointer: null,
                    stage: {
                        start: null,
                        current: null
                    },
                    direction: null
                };

                /**
                 * Current state information and their tags.
                 * @type {Object}
                 * @protected
                 */
                this._states = {
                    current: {},
                    tags: {
                        'initializing': [ 'busy' ],
                        'animating': [ 'busy' ],
                        'dragging': [ 'interacting' ]
                    }
                };

                $.each([ 'onResize', 'onThrottledResize' ], $.proxy(function(i, handler) {
                    this._handlers[handler] = $.proxy(this[handler], this);
                }, this));

                $.each(Owl.Plugins, $.proxy(function(key, plugin) {
                    this._plugins[key.charAt(0).toLowerCase() + key.slice(1)]
                        = new plugin(this);
                }, this));

                $.each(Owl.Workers, $.proxy(function(priority, worker) {
                    this._pipe.push({
                                        'filter': worker.filter,
                                        'run': $.proxy(worker.run, this)
                                    });
                }, this));

                this.setup();
                this.initialize();
            }

            /**
             * Default options for the carousel.
             * @public
             */
            Owl.Defaults = {
                items: 3,
                loop: false,
                center: false,
                rewind: false,

                mouseDrag: true,
                touchDrag: true,
                pullDrag: true,
                freeDrag: false,

                margin: 0,
                stagePadding: 0,

                merge: false,
                mergeFit: true,
                autoWidth: false,

                startPosition: 0,
                rtl: false,

                smartSpeed: 250,
                fluidSpeed: false,
                dragEndSpeed: false,

                responsive: {},
                responsiveRefreshRate: 200,
                responsiveBaseElement: window,

                fallbackEasing: 'swing',

                info: false,

                nestedItemSelector: false,
                itemElement: 'div',
                stageElement: 'div',

                refreshClass: 'owl-refresh',
                loadedClass: 'owl-loaded',
                loadingClass: 'owl-loading',
                rtlClass: 'owl-rtl',
                responsiveClass: 'owl-responsive',
                dragClass: 'owl-drag',
                itemClass: 'owl-item',
                stageClass: 'owl-stage',
                stageOuterClass: 'owl-stage-outer',
                grabClass: 'owl-grab'
            };

            /**
             * Enumeration for width.
             * @public
             * @readonly
             * @enum {String}
             */
            Owl.Width = {
                Default: 'default',
                Inner: 'inner',
                Outer: 'outer'
            };

            /**
             * Enumeration for types.
             * @public
             * @readonly
             * @enum {String}
             */
            Owl.Type = {
                Event: 'event',
                State: 'state'
            };

            /**
             * Contains all registered plugins.
             * @public
             */
            Owl.Plugins = {};

            /**
             * List of workers involved in the update process.
             */
            Owl.Workers = [ {
                filter: [ 'width', 'settings' ],
                run: function() {
                    this._width = this.$element.width();
                }
            }, {
                filter: [ 'width', 'items', 'settings' ],
                run: function(cache) {
                    cache.current = this._items && this._items[this.relative(this._current)];
                }
            }, {
                filter: [ 'items', 'settings' ],
                run: function() {
                    this.$stage.children('.cloned').remove();
                }
            }, {
                filter: [ 'width', 'items', 'settings' ],
                run: function(cache) {
                    var margin = this.settings.margin || '',
                        grid = !this.settings.autoWidth,
                        rtl = this.settings.rtl,
                        css = {
                            'width': 'auto',
                            'margin-left': rtl ? margin : '',
                            'margin-right': rtl ? '' : margin
                        };

                    !grid && this.$stage.children().css(css);

                    cache.css = css;
                }
            }, {
                filter: [ 'width', 'items', 'settings' ],
                run: function(cache) {
                    var width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,
                        merge = null,
                        iterator = this._items.length,
                        grid = !this.settings.autoWidth,
                        widths = [];

                    cache.items = {
                        merge: false,
                        width: width
                    };

                    while (iterator--) {
                        merge = this._mergers[iterator];
                        merge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge;

                        cache.items.merge = merge > 1 || cache.items.merge;

                        widths[iterator] = !grid ? this._items[iterator].width() : width * merge;
                    }

                    this._widths = widths;
                }
            }, {
                filter: [ 'items', 'settings' ],
                run: function() {
                    var clones = [],
                        items = this._items,
                        settings = this.settings,
                        // TODO: Should be computed from number of min width items in stage
                        view = Math.max(settings.items * 2, 4),
                        size = Math.ceil(items.length / 2) * 2,
                        repeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0,
                        append = '',
                        prepend = '';

                    repeat /= 2;

                    while (repeat--) {
                        // Switch to only using appended clones
                        clones.push(this.normalize(clones.length / 2, true));
                        append = append + items[clones[clones.length - 1]][0].outerHTML;
                        clones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, true));
                        prepend = items[clones[clones.length - 1]][0].outerHTML + prepend;
                    }

                    this._clones = clones;

                    $(append).addClass('cloned').appendTo(this.$stage);
                    $(prepend).addClass('cloned').prependTo(this.$stage);
                }
            }, {
                filter: [ 'width', 'items', 'settings' ],
                run: function() {
                    var rtl = this.settings.rtl ? 1 : -1,
                        size = this._clones.length + this._items.length,
                        iterator = -1,
                        previous = 0,
                        current = 0,
                        coordinates = [];

                    while (++iterator < size) {
                        previous = coordinates[iterator - 1] || 0;
                        current = this._widths[this.relative(iterator)] + this.settings.margin;
                        coordinates.push(previous + current * rtl);
                    }

                    this._coordinates = coordinates;
                }
            }, {
                filter: [ 'width', 'items', 'settings' ],
                run: function() {
                    var padding = this.settings.stagePadding,
                        coordinates = this._coordinates,
                        css = {
                            'width': Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + padding * 2,
                            'padding-left': padding || '',
                            'padding-right': padding || ''
                        };

                    this.$stage.css(css);
                }
            }, {
                filter: [ 'width', 'items', 'settings' ],
                run: function(cache) {
                    var iterator = this._coordinates.length,
                        grid = !this.settings.autoWidth,
                        items = this.$stage.children();

                    if (grid && cache.items.merge) {
                        while (iterator--) {
                            cache.css.width = this._widths[this.relative(iterator)];
                            items.eq(iterator).css(cache.css);
                        }
                    } else if (grid) {
                        cache.css.width = cache.items.width;
                        items.css(cache.css);
                    }
                }
            }, {
                filter: [ 'items' ],
                run: function() {
                    this._coordinates.length < 1 && this.$stage.removeAttr('style');
                }
            }, {
                filter: [ 'width', 'items', 'settings' ],
                run: function(cache) {
                    cache.current = cache.current ? this.$stage.children().index(cache.current) : 0;
                    cache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current));
                    this.reset(cache.current);
                }
            }, {
                filter: [ 'position' ],
                run: function() {
                    this.animate(this.coordinates(this._current));
                }
            }, {
                filter: [ 'width', 'position', 'items', 'settings' ],
                run: function() {
                    var rtl = this.settings.rtl ? 1 : -1,
                        padding = this.settings.stagePadding * 2,
                        begin = this.coordinates(this.current()) + padding,
                        end = begin + this.width() * rtl,
                        inner, outer, matches = [], i, n;

                    for (i = 0, n = this._coordinates.length; i < n; i++) {
                        inner = this._coordinates[i - 1] || 0;
                        outer = Math.abs(this._coordinates[i]) + padding * rtl;

                        if ((this.op(inner, '<=', begin) && (this.op(inner, '>', end)))
                            || (this.op(outer, '<', begin) && this.op(outer, '>', end))) {
                            matches.push(i);
                        }
                    }

                    this.$stage.children('.active').removeClass('active');
                    this.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass('active');

                    if (this.settings.center) {
                        this.$stage.children('.center').removeClass('center');
                        this.$stage.children().eq(this.current()).addClass('center');
                    }
                }
            } ];

            /**
             * Initializes the carousel.
             * @protected
             */
            Owl.prototype.initialize = function() {
                this.enter('initializing');
                this.trigger('initialize');

                this.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);

                if (this.settings.autoWidth && !this.is('pre-loading')) {
                    var imgs, nestedSelector, width;
                    imgs = this.$element.find('img');
                    nestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;
                    width = this.$element.children(nestedSelector).width();

                    if (imgs.length && width <= 0) {
                        this.preloadAutoWidthImages(imgs);
                    }
                }

                this.$element.addClass(this.options.loadingClass);

                // create stage
                this.$stage = $('<' + this.settings.stageElement + ' class="' + this.settings.stageClass + '"/>')
                    .wrap('<div class="' + this.settings.stageOuterClass + '"/>');

                // append stage
                this.$element.append(this.$stage.parent());

                // append content
                this.replace(this.$element.children().not(this.$stage.parent()));

                // check visibility
                if (this.$element.is(':visible')) {
                    // update view
                    this.refresh();
                } else {
                    // invalidate width
                    this.invalidate('width');
                }

                this.$element
                    .removeClass(this.options.loadingClass)
                    .addClass(this.options.loadedClass);

                // register event handlers
                this.registerEventHandlers();

                this.leave('initializing');
                this.trigger('initialized');
            };

            /**
             * Setups the current settings.
             * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?
             * @todo Support for media queries by using `matchMedia` would be nice.
             * @public
             */
            Owl.prototype.setup = function() {
                var viewport = this.viewport(),
                    overwrites = this.options.responsive,
                    match = -1,
                    settings = null;

                if (!overwrites) {
                    settings = $.extend({}, this.options);
                } else {
                    $.each(overwrites, function(breakpoint) {
                        if (breakpoint <= viewport && breakpoint > match) {
                            match = Number(breakpoint);
                        }
                    });

                    settings = $.extend({}, this.options, overwrites[match]);
                    if (typeof settings.stagePadding === 'function') {
                        settings.stagePadding = settings.stagePadding();
                    }
                    delete settings.responsive;

                    // responsive class
                    if (settings.responsiveClass) {
                        this.$element.attr('class',
                                           this.$element.attr('class').replace(new RegExp('(' + this.options.responsiveClass + '-)\\S+\\s', 'g'), '$1' + match)
                        );
                    }
                }

                this.trigger('change', { property: { name: 'settings', value: settings } });
                this._breakpoint = match;
                this.settings = settings;
                this.invalidate('settings');
                this.trigger('changed', { property: { name: 'settings', value: this.settings } });
            };

            /**
             * Updates option logic if necessery.
             * @protected
             */
            Owl.prototype.optionsLogic = function() {
                if (this.settings.autoWidth) {
                    this.settings.stagePadding = false;
                    this.settings.merge = false;
                }
            };

            /**
             * Prepares an item before add.
             * @todo Rename event parameter `content` to `item`.
             * @protected
             * @returns {jQuery|HTMLElement} - The item container.
             */
            Owl.prototype.prepare = function(item) {
                var event = this.trigger('prepare', { content: item });

                if (!event.data) {
                    event.data = $('<' + this.settings.itemElement + '/>')
                        .addClass(this.options.itemClass).append(item)
                }

                this.trigger('prepared', { content: event.data });

                return event.data;
            };

            /**
             * Updates the view.
             * @public
             */
            Owl.prototype.update = function() {
                var i = 0,
                    n = this._pipe.length,
                    filter = $.proxy(function(p) { return this[p] }, this._invalidated),
                    cache = {};

                while (i < n) {
                    if (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {
                        this._pipe[i].run(cache);
                    }
                    i++;
                }

                this._invalidated = {};

                !this.is('valid') && this.enter('valid');
            };

            /**
             * Gets the width of the view.
             * @public
             * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.
             * @returns {Number} - The width of the view in pixel.
             */
            Owl.prototype.width = function(dimension) {
                dimension = dimension || Owl.Width.Default;
                switch (dimension) {
                    case Owl.Width.Inner:
                    case Owl.Width.Outer:
                        return this._width;
                    default:
                        return this._width - this.settings.stagePadding * 2 + this.settings.margin;
                }
            };

            /**
             * Refreshes the carousel primarily for adaptive purposes.
             * @public
             */
            Owl.prototype.refresh = function() {
                this.enter('refreshing');
                this.trigger('refresh');

                this.setup();

                this.optionsLogic();

                this.$element.addClass(this.options.refreshClass);

                this.update();

                this.$element.removeClass(this.options.refreshClass);

                this.leave('refreshing');
                this.trigger('refreshed');
            };

            /**
             * Checks window `resize` event.
             * @protected
             */
            Owl.prototype.onThrottledResize = function() {
                window.clearTimeout(this.resizeTimer);
                this.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);
            };

            /**
             * Checks window `resize` event.
             * @protected
             */
            Owl.prototype.onResize = function() {
                if (!this._items.length) {
                    return false;
                }

                if (this._width === this.$element.width()) {
                    return false;
                }

                if (!this.$element.is(':visible')) {
                    return false;
                }

                this.enter('resizing');

                if (this.trigger('resize').isDefaultPrevented()) {
                    this.leave('resizing');
                    return false;
                }

                this.invalidate('width');

                this.refresh();

                this.leave('resizing');
                this.trigger('resized');
            };

            /**
             * Registers event handlers.
             * @todo Check `msPointerEnabled`
             * @todo #261
             * @protected
             */
            Owl.prototype.registerEventHandlers = function() {
                if ($.support.transition) {
                    this.$stage.on($.support.transition.end + '.owl.core', $.proxy(this.onTransitionEnd, this));
                }

                if (this.settings.responsive !== false) {
                    this.on(window, 'resize', this._handlers.onThrottledResize);
                }

                if (this.settings.mouseDrag) {
                    this.$element.addClass(this.options.dragClass);
                    this.$stage.on('mousedown.owl.core', $.proxy(this.onDragStart, this));
                    this.$stage.on('dragstart.owl.core selectstart.owl.core', function() { return false });
                }

                if (this.settings.touchDrag){
                    this.$stage.on('touchstart.owl.core', $.proxy(this.onDragStart, this));
                    this.$stage.on('touchcancel.owl.core', $.proxy(this.onDragEnd, this));
                }
            };

            /**
             * Handles `touchstart` and `mousedown` events.
             * @todo Horizontal swipe threshold as option
             * @todo #261
             * @protected
             * @param {Event} event - The event arguments.
             */
            Owl.prototype.onDragStart = function(event) {
                var stage = null;

                if (event.which === 3) {
                    return;
                }

                if ($.support.transform) {
                    stage = this.$stage.css('transform').replace(/.*\(|\)| /g, '').split(',');
                    stage = {
                        x: stage[stage.length === 16 ? 12 : 4],
                        y: stage[stage.length === 16 ? 13 : 5]
                    };
                } else {
                    stage = this.$stage.position();
                    stage = {
                        x: this.settings.rtl ?
                            stage.left + this.$stage.width() - this.width() + this.settings.margin :
                            stage.left,
                        y: stage.top
                    };
                }

                if (this.is('animating')) {
                    $.support.transform ? this.animate(stage.x) : this.$stage.stop()
                    this.invalidate('position');
                }

                this.$element.toggleClass(this.options.grabClass, event.type === 'mousedown');

                this.speed(0);

                this._drag.time = new Date().getTime();
                this._drag.target = $(event.target);
                this._drag.stage.start = stage;
                this._drag.stage.current = stage;
                this._drag.pointer = this.pointer(event);

                $(document).on('mouseup.owl.core touchend.owl.core', $.proxy(this.onDragEnd, this));

                $(document).one('mousemove.owl.core touchmove.owl.core', $.proxy(function(event) {
                    var delta = this.difference(this._drag.pointer, this.pointer(event));

                    $(document).on('mousemove.owl.core touchmove.owl.core', $.proxy(this.onDragMove, this));

                    if (Math.abs(delta.x) < Math.abs(delta.y) && this.is('valid')) {
                        return;
                    }

                    event.preventDefault();

                    this.enter('dragging');
                    this.trigger('drag');
                }, this));
            };

            /**
             * Handles the `touchmove` and `mousemove` events.
             * @todo #261
             * @protected
             * @param {Event} event - The event arguments.
             */
            Owl.prototype.onDragMove = function(event) {
                var minimum = null,
                    maximum = null,
                    pull = null,
                    delta = this.difference(this._drag.pointer, this.pointer(event)),
                    stage = this.difference(this._drag.stage.start, delta);

                if (!this.is('dragging')) {
                    return;
                }

                event.preventDefault();

                if (this.settings.loop) {
                    minimum = this.coordinates(this.minimum());
                    maximum = this.coordinates(this.maximum() + 1) - minimum;
                    stage.x = (((stage.x - minimum) % maximum + maximum) % maximum) + minimum;
                } else {
                    minimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());
                    maximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());
                    pull = this.settings.pullDrag ? -1 * delta.x / 5 : 0;
                    stage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull);
                }

                this._drag.stage.current = stage;

                this.animate(stage.x);
            };

            /**
             * Handles the `touchend` and `mouseup` events.
             * @todo #261
             * @todo Threshold for click event
             * @protected
             * @param {Event} event - The event arguments.
             */
            Owl.prototype.onDragEnd = function(event) {
                var delta = this.difference(this._drag.pointer, this.pointer(event)),
                    stage = this._drag.stage.current,
                    direction = delta.x > 0 ^ this.settings.rtl ? 'left' : 'right';

                $(document).off('.owl.core');

                this.$element.removeClass(this.options.grabClass);

                if (delta.x !== 0 && this.is('dragging') || !this.is('valid')) {
                    this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);
                    this.current(this.closest(stage.x, delta.x !== 0 ? direction : this._drag.direction));
                    this.invalidate('position');
                    this.update();

                    this._drag.direction = direction;

                    if (Math.abs(delta.x) > 3 || new Date().getTime() - this._drag.time > 300) {
                        this._drag.target.one('click.owl.core', function() { return false; });
                    }
                }

                if (!this.is('dragging')) {
                    return;
                }

                this.leave('dragging');
                this.trigger('dragged');
            };

            /**
             * Gets absolute position of the closest item for a coordinate.
             * @todo Setting `freeDrag` makes `closest` not reusable. See #165.
             * @protected
             * @param {Number} coordinate - The coordinate in pixel.
             * @param {String} direction - The direction to check for the closest item. Ether `left` or `right`.
             * @return {Number} - The absolute position of the closest item.
             */
            Owl.prototype.closest = function(coordinate, direction) {
                var position = -1,
                    pull = 30,
                    width = this.width(),
                    coordinates = this.coordinates();

                if (!this.settings.freeDrag) {
                    // check closest item
                    $.each(coordinates, $.proxy(function(index, value) {
                        // on a left pull, check on current index
                        if (direction === 'left' && coordinate > value - pull && coordinate < value + pull) {
                            position = index;
                            // on a right pull, check on previous index
                            // to do so, subtract width from value and set position = index + 1
                        } else if (direction === 'right' && coordinate > value - width - pull && coordinate < value - width + pull) {
                            position = index + 1;
                        } else if (this.op(coordinate, '<', value)
                                   && this.op(coordinate, '>', coordinates[index + 1] || value - width)) {
                            position = direction === 'left' ? index + 1 : index;
                        }
                        return position === -1;
                    }, this));
                }

                if (!this.settings.loop) {
                    // non loop boundries
                    if (this.op(coordinate, '>', coordinates[this.minimum()])) {
                        position = coordinate = this.minimum();
                    } else if (this.op(coordinate, '<', coordinates[this.maximum()])) {
                        position = coordinate = this.maximum();
                    }
                }

                return position;
            };

            /**
             * Animates the stage.
             * @todo #270
             * @public
             * @param {Number} coordinate - The coordinate in pixels.
             */
            Owl.prototype.animate = function(coordinate) {
                var animate = this.speed() > 0;

                this.is('animating') && this.onTransitionEnd();

                if (animate) {
                    this.enter('animating');
                    this.trigger('translate');
                }

                if ($.support.transform3d && $.support.transition) {
                    this.$stage.css({
                                        transform: 'translate3d(' + coordinate + 'px,0px,0px)',
                                        transition: (this.speed() / 1000) + 's'
                                    });
                } else if (animate) {
                    this.$stage.animate({
                                            left: coordinate + 'px'
                                        }, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this));
                } else {
                    this.$stage.css({
                                        left: coordinate + 'px'
                                    });
                }
            };

            /**
             * Checks whether the carousel is in a specific state or not.
             * @param {String} state - The state to check.
             * @returns {Boolean} - The flag which indicates if the carousel is busy.
             */
            Owl.prototype.is = function(state) {
                return this._states.current[state] && this._states.current[state] > 0;
            };

            /**
             * Sets the absolute position of the current item.
             * @public
             * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.
             * @returns {Number} - The absolute position of the current item.
             */
            Owl.prototype.current = function(position) {
                if (position === undefined) {
                    return this._current;
                }

                if (this._items.length === 0) {
                    return undefined;
                }

                position = this.normalize(position);

                if (this._current !== position) {
                    var event = this.trigger('change', { property: { name: 'position', value: position } });

                    if (event.data !== undefined) {
                        position = this.normalize(event.data);
                    }

                    this._current = position;

                    this.invalidate('position');

                    this.trigger('changed', { property: { name: 'position', value: this._current } });
                }

                return this._current;
            };

            /**
             * Invalidates the given part of the update routine.
             * @param {String} [part] - The part to invalidate.
             * @returns {Array.<String>} - The invalidated parts.
             */
            Owl.prototype.invalidate = function(part) {
                if ($.type(part) === 'string') {
                    this._invalidated[part] = true;
                    this.is('valid') && this.leave('valid');
                }
                return $.map(this._invalidated, function(v, i) { return i });
            };

            /**
             * Resets the absolute position of the current item.
             * @public
             * @param {Number} position - The absolute position of the new item.
             */
            Owl.prototype.reset = function(position) {
                position = this.normalize(position);

                if (position === undefined) {
                    return;
                }

                this._speed = 0;
                this._current = position;

                this.suppress([ 'translate', 'translated' ]);

                this.animate(this.coordinates(position));

                this.release([ 'translate', 'translated' ]);
            };

            /**
             * Normalizes an absolute or a relative position of an item.
             * @public
             * @param {Number} position - The absolute or relative position to normalize.
             * @param {Boolean} [relative=false] - Whether the given position is relative or not.
             * @returns {Number} - The normalized position.
             */
            Owl.prototype.normalize = function(position, relative) {
                var n = this._items.length,
                    m = relative ? 0 : this._clones.length;

                if (!this.isNumeric(position) || n < 1) {
                    position = undefined;
                } else if (position < 0 || position >= n + m) {
                    position = ((position - m / 2) % n + n) % n + m / 2;
                }

                return position;
            };

            /**
             * Converts an absolute position of an item into a relative one.
             * @public
             * @param {Number} position - The absolute position to convert.
             * @returns {Number} - The converted position.
             */
            Owl.prototype.relative = function(position) {
                position -= this._clones.length / 2;
                return this.normalize(position, true);
            };

            /**
             * Gets the maximum position for the current item.
             * @public
             * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.
             * @returns {Number}
             */
            Owl.prototype.maximum = function(relative) {
                var settings = this.settings,
                    maximum = this._coordinates.length,
                    iterator,
                    reciprocalItemsWidth,
                    elementWidth;

                if (settings.loop) {
                    maximum = this._clones.length / 2 + this._items.length - 1;
                } else if (settings.autoWidth || settings.merge) {
                    iterator = this._items.length;
                    reciprocalItemsWidth = this._items[--iterator].width();
                    elementWidth = this.$element.width();
                    while (iterator--) {
                        reciprocalItemsWidth += this._items[iterator].width() + this.settings.margin;
                        if (reciprocalItemsWidth > elementWidth) {
                            break;
                        }
                    }
                    maximum = iterator + 1;
                } else if (settings.center) {
                    maximum = this._items.length - 1;
                } else {
                    maximum = this._items.length - settings.items;
                }

                if (relative) {
                    maximum -= this._clones.length / 2;
                }

                return Math.max(maximum, 0);
            };

            /**
             * Gets the minimum position for the current item.
             * @public
             * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.
             * @returns {Number}
             */
            Owl.prototype.minimum = function(relative) {
                return relative ? 0 : this._clones.length / 2;
            };

            /**
             * Gets an item at the specified relative position.
             * @public
             * @param {Number} [position] - The relative position of the item.
             * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.
             */
            Owl.prototype.items = function(position) {
                if (position === undefined) {
                    return this._items.slice();
                }

                position = this.normalize(position, true);
                return this._items[position];
            };

            /**
             * Gets an item at the specified relative position.
             * @public
             * @param {Number} [position] - The relative position of the item.
             * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.
             */
            Owl.prototype.mergers = function(position) {
                if (position === undefined) {
                    return this._mergers.slice();
                }

                position = this.normalize(position, true);
                return this._mergers[position];
            };

            /**
             * Gets the absolute positions of clones for an item.
             * @public
             * @param {Number} [position] - The relative position of the item.
             * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.
             */
            Owl.prototype.clones = function(position) {
                var odd = this._clones.length / 2,
                    even = odd + this._items.length,
                    map = function(index) { return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2 };

                if (position === undefined) {
                    return $.map(this._clones, function(v, i) { return map(i) });
                }

                return $.map(this._clones, function(v, i) { return v === position ? map(i) : null });
            };

            /**
             * Sets the current animation speed.
             * @public
             * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.
             * @returns {Number} - The current animation speed in milliseconds.
             */
            Owl.prototype.speed = function(speed) {
                if (speed !== undefined) {
                    this._speed = speed;
                }

                return this._speed;
            };

            /**
             * Gets the coordinate of an item.
             * @todo The name of this method is missleanding.
             * @public
             * @param {Number} position - The absolute position of the item within `minimum()` and `maximum()`.
             * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.
             */
            Owl.prototype.coordinates = function(position) {
                var multiplier = 1,
                    newPosition = position - 1,
                    coordinate;

                if (position === undefined) {
                    return $.map(this._coordinates, $.proxy(function(coordinate, index) {
                        return this.coordinates(index);
                    }, this));
                }

                if (this.settings.center) {
                    if (this.settings.rtl) {
                        multiplier = -1;
                        newPosition = position + 1;
                    }

                    coordinate = this._coordinates[position];
                    coordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier;
                } else {
                    coordinate = this._coordinates[newPosition] || 0;
                }

                coordinate = Math.ceil(coordinate);

                return coordinate;
            };

            /**
             * Calculates the speed for a translation.
             * @protected
             * @param {Number} from - The absolute position of the start item.
             * @param {Number} to - The absolute position of the target item.
             * @param {Number} [factor=undefined] - The time factor in milliseconds.
             * @returns {Number} - The time in milliseconds for the translation.
             */
            Owl.prototype.duration = function(from, to, factor) {
                if (factor === 0) {
                    return 0;
                }

                return Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs((factor || this.settings.smartSpeed));
            };

            /**
             * Slides to the specified item.
             * @public
             * @param {Number} position - The position of the item.
             * @param {Number} [speed] - The time in milliseconds for the transition.
             */
            Owl.prototype.to = function(position, speed) {
                var current = this.current(),
                    revert = null,
                    distance = position - this.relative(current),
                    direction = (distance > 0) - (distance < 0),
                    items = this._items.length,
                    minimum = this.minimum(),
                    maximum = this.maximum();

                if (this.settings.loop) {
                    if (!this.settings.rewind && Math.abs(distance) > items / 2) {
                        distance += direction * -1 * items;
                    }

                    position = current + distance;
                    revert = ((position - minimum) % items + items) % items + minimum;

                    if (revert !== position && revert - distance <= maximum && revert - distance > 0) {
                        current = revert - distance;
                        position = revert;
                        this.reset(current);
                    }
                } else if (this.settings.rewind) {
                    maximum += 1;
                    position = (position % maximum + maximum) % maximum;
                } else {
                    position = Math.max(minimum, Math.min(maximum, position));
                }

                this.speed(this.duration(current, position, speed));
                this.current(position);

                if (this.$element.is(':visible')) {
                    this.update();
                }
            };

            /**
             * Slides to the next item.
             * @public
             * @param {Number} [speed] - The time in milliseconds for the transition.
             */
            Owl.prototype.next = function(speed) {
                speed = speed || false;
                this.to(this.relative(this.current()) + 1, speed);
            };

            /**
             * Slides to the previous item.
             * @public
             * @param {Number} [speed] - The time in milliseconds for the transition.
             */
            Owl.prototype.prev = function(speed) {
                speed = speed || false;
                this.to(this.relative(this.current()) - 1, speed);
            };

            /**
             * Handles the end of an animation.
             * @protected
             * @param {Event} event - The event arguments.
             */
            Owl.prototype.onTransitionEnd = function(event) {

                // if css2 animation then event object is undefined
                if (event !== undefined) {
                    event.stopPropagation();

                    // Catch only owl-stage transitionEnd event
                    if ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {
                        return false;
                    }
                }

                this.leave('animating');
                this.trigger('translated');
            };

            /**
             * Gets viewport width.
             * @protected
             * @return {Number} - The width in pixel.
             */
            Owl.prototype.viewport = function() {
                var width;
                if (this.options.responsiveBaseElement !== window) {
                    width = $(this.options.responsiveBaseElement).width();
                } else if (window.innerWidth) {
                    width = window.innerWidth;
                } else if (document.documentElement && document.documentElement.clientWidth) {
                    width = document.documentElement.clientWidth;
                } else {
                    throw 'Can not detect viewport width.';
                }
                return width;
            };

            /**
             * Replaces the current content.
             * @public
             * @param {HTMLElement|jQuery|String} content - The new content.
             */
            Owl.prototype.replace = function(content) {
                this.$stage.empty();
                this._items = [];

                if (content) {
                    content = (content instanceof jQuery) ? content : $(content);
                }

                if (this.settings.nestedItemSelector) {
                    content = content.find('.' + this.settings.nestedItemSelector);
                }

                content.filter(function() {
                    return this.nodeType === 1;
                }).each($.proxy(function(index, item) {
                    item = this.prepare(item);
                    this.$stage.append(item);
                    this._items.push(item);
                    this._mergers.push(item.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
                }, this));

                this.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);

                this.invalidate('items');
            };

            /**
             * Adds an item.
             * @todo Use `item` instead of `content` for the event arguments.
             * @public
             * @param {HTMLElement|jQuery|String} content - The item content to add.
             * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.
             */
            Owl.prototype.add = function(content, position) {
                var current = this.relative(this._current);

                position = position === undefined ? this._items.length : this.normalize(position, true);
                content = content instanceof jQuery ? content : $(content);

                this.trigger('add', { content: content, position: position });

                content = this.prepare(content);

                if (this._items.length === 0 || position === this._items.length) {
                    this._items.length === 0 && this.$stage.append(content);
                    this._items.length !== 0 && this._items[position - 1].after(content);
                    this._items.push(content);
                    this._mergers.push(content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
                } else {
                    this._items[position].before(content);
                    this._items.splice(position, 0, content);
                    this._mergers.splice(position, 0, content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
                }

                this._items[current] && this.reset(this._items[current].index());

                this.invalidate('items');

                this.trigger('added', { content: content, position: position });
            };

            /**
             * Removes an item by its position.
             * @todo Use `item` instead of `content` for the event arguments.
             * @public
             * @param {Number} position - The relative position of the item to remove.
             */
            Owl.prototype.remove = function(position) {
                position = this.normalize(position, true);

                if (position === undefined) {
                    return;
                }

                this.trigger('remove', { content: this._items[position], position: position });

                this._items[position].remove();
                this._items.splice(position, 1);
                this._mergers.splice(position, 1);

                this.invalidate('items');

                this.trigger('removed', { content: null, position: position });
            };

            /**
             * Preloads images with auto width.
             * @todo Replace by a more generic approach
             * @protected
             */
            Owl.prototype.preloadAutoWidthImages = function(images) {
                images.each($.proxy(function(i, element) {
                    this.enter('pre-loading');
                    element = $(element);
                    $(new Image()).one('load', $.proxy(function(e) {
                        element.attr('src', e.target.src);
                        element.css('opacity', 1);
                        this.leave('pre-loading');
                        !this.is('pre-loading') && !this.is('initializing') && this.refresh();
                    }, this)).attr('src', element.attr('src') || element.attr('data-src') || element.attr('data-src-retina'));
                }, this));
            };

            /**
             * Destroys the carousel.
             * @public
             */
            Owl.prototype.destroy = function() {

                this.$element.off('.owl.core');
                this.$stage.off('.owl.core');
                $(document).off('.owl.core');

                if (this.settings.responsive !== false) {
                    window.clearTimeout(this.resizeTimer);
                    this.off(window, 'resize', this._handlers.onThrottledResize);
                }

                for (var i in this._plugins) {
                    this._plugins[i].destroy();
                }

                this.$stage.children('.cloned').remove();

                this.$stage.unwrap();
                this.$stage.children().contents().unwrap();
                this.$stage.children().unwrap();

                this.$element
                    .removeClass(this.options.refreshClass)
                    .removeClass(this.options.loadingClass)
                    .removeClass(this.options.loadedClass)
                    .removeClass(this.options.rtlClass)
                    .removeClass(this.options.dragClass)
                    .removeClass(this.options.grabClass)
                    .attr('class', this.$element.attr('class').replace(new RegExp(this.options.responsiveClass + '-\\S+\\s', 'g'), ''))
                    .removeData('owl.carousel');
            };

            /**
             * Operators to calculate right-to-left and left-to-right.
             * @protected
             * @param {Number} [a] - The left side operand.
             * @param {String} [o] - The operator.
             * @param {Number} [b] - The right side operand.
             */
            Owl.prototype.op = function(a, o, b) {
                var rtl = this.settings.rtl;
                switch (o) {
                    case '<':
                        return rtl ? a > b : a < b;
                    case '>':
                        return rtl ? a < b : a > b;
                    case '>=':
                        return rtl ? a <= b : a >= b;
                    case '<=':
                        return rtl ? a >= b : a <= b;
                    default:
                        break;
                }
            };

            /**
             * Attaches to an internal event.
             * @protected
             * @param {HTMLElement} element - The event source.
             * @param {String} event - The event name.
             * @param {Function} listener - The event handler to attach.
             * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.
             */
            Owl.prototype.on = function(element, event, listener, capture) {
                if (element.addEventListener) {
                    element.addEventListener(event, listener, capture);
                } else if (element.attachEvent) {
                    element.attachEvent('on' + event, listener);
                }
            };

            /**
             * Detaches from an internal event.
             * @protected
             * @param {HTMLElement} element - The event source.
             * @param {String} event - The event name.
             * @param {Function} listener - The attached event handler to detach.
             * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.
             */
            Owl.prototype.off = function(element, event, listener, capture) {
                if (element.removeEventListener) {
                    element.removeEventListener(event, listener, capture);
                } else if (element.detachEvent) {
                    element.detachEvent('on' + event, listener);
                }
            };

            /**
             * Triggers a public event.
             * @todo Remove `status`, `relatedTarget` should be used instead.
             * @protected
             * @param {String} name - The event name.
             * @param {*} [data=null] - The event data.
             * @param {String} [namespace=carousel] - The event namespace.
             * @param {String} [state] - The state which is associated with the event.
             * @param {Boolean} [enter=false] - Indicates if the call enters the specified state or not.
             * @returns {Event} - The event arguments.
             */
            Owl.prototype.trigger = function(name, data, namespace, state, enter) {
                var status = {
                    item: { count: this._items.length, index: this.current() }
                }, handler = $.camelCase(
                    $.grep([ 'on', name, namespace ], function(v) { return v })
                        .join('-').toLowerCase()
                ), event = $.Event(
                    [ name, 'owl', namespace || 'carousel' ].join('.').toLowerCase(),
                    $.extend({ relatedTarget: this }, status, data)
                );

                if (!this._supress[name]) {
                    $.each(this._plugins, function(name, plugin) {
                        if (plugin.onTrigger) {
                            plugin.onTrigger(event);
                        }
                    });

                    this.register({ type: Owl.Type.Event, name: name });
                    this.$element.trigger(event);

                    if (this.settings && typeof this.settings[handler] === 'function') {
                        this.settings[handler].call(this, event);
                    }
                }

                return event;
            };

            /**
             * Enters a state.
             * @param name - The state name.
             */
            Owl.prototype.enter = function(name) {
                $.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {
                    if (this._states.current[name] === undefined) {
                        this._states.current[name] = 0;
                    }

                    this._states.current[name]++;
                }, this));
            };

            /**
             * Leaves a state.
             * @param name - The state name.
             */
            Owl.prototype.leave = function(name) {
                $.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {
                    this._states.current[name]--;
                }, this));
            };

            /**
             * Registers an event or state.
             * @public
             * @param {Object} object - The event or state to register.
             */
            Owl.prototype.register = function(object) {
                if (object.type === Owl.Type.Event) {
                    if (!$.event.special[object.name]) {
                        $.event.special[object.name] = {};
                    }

                    if (!$.event.special[object.name].owl) {
                        var _default = $.event.special[object.name]._default;
                        $.event.special[object.name]._default = function(e) {
                            if (_default && _default.apply && (!e.namespace || e.namespace.indexOf('owl') === -1)) {
                                return _default.apply(this, arguments);
                            }
                            return e.namespace && e.namespace.indexOf('owl') > -1;
                        };
                        $.event.special[object.name].owl = true;
                    }
                } else if (object.type === Owl.Type.State) {
                    if (!this._states.tags[object.name]) {
                        this._states.tags[object.name] = object.tags;
                    } else {
                        this._states.tags[object.name] = this._states.tags[object.name].concat(object.tags);
                    }

                    this._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function(tag, i) {
                        return $.inArray(tag, this._states.tags[object.name]) === i;
                    }, this));
                }
            };

            /**
             * Suppresses events.
             * @protected
             * @param {Array.<String>} events - The events to suppress.
             */
            Owl.prototype.suppress = function(events) {
                $.each(events, $.proxy(function(index, event) {
                    this._supress[event] = true;
                }, this));
            };

            /**
             * Releases suppressed events.
             * @protected
             * @param {Array.<String>} events - The events to release.
             */
            Owl.prototype.release = function(events) {
                $.each(events, $.proxy(function(index, event) {
                    delete this._supress[event];
                }, this));
            };

            /**
             * Gets unified pointer coordinates from event.
             * @todo #261
             * @protected
             * @param {Event} - The `mousedown` or `touchstart` event.
             * @returns {Object} - Contains `x` and `y` coordinates of current pointer position.
             */
            Owl.prototype.pointer = function(event) {
                var result = { x: null, y: null };

                event = event.originalEvent || event || window.event;

                event = event.touches && event.touches.length ?
                    event.touches[0] : event.changedTouches && event.changedTouches.length ?
                        event.changedTouches[0] : event;

                if (event.pageX) {
                    result.x = event.pageX;
                    result.y = event.pageY;
                } else {
                    result.x = event.clientX;
                    result.y = event.clientY;
                }

                return result;
            };

            /**
             * Determines if the input is a Number or something that can be coerced to a Number
             * @protected
             * @param {Number|String|Object|Array|Boolean|RegExp|Function|Symbol} - The input to be tested
             * @returns {Boolean} - An indication if the input is a Number or can be coerced to a Number
             */
            Owl.prototype.isNumeric = function(number) {
                return !isNaN(parseFloat(number));
            };

            /**
             * Gets the difference of two vectors.
             * @todo #261
             * @protected
             * @param {Object} - The first vector.
             * @param {Object} - The second vector.
             * @returns {Object} - The difference.
             */
            Owl.prototype.difference = function(first, second) {
                return {
                    x: first.x - second.x,
                    y: first.y - second.y
                };
            };

            /**
             * The jQuery Plugin for the Owl Carousel
             * @todo Navigation plugin `next` and `prev`
             * @public
             */
            $.fn.owlCarousel = function(option) {
                var args = Array.prototype.slice.call(arguments, 1);

                return this.each(function() {
                    var $this = $(this),
                        data = $this.data('owl.carousel');

                    if (!data) {
                        data = new Owl(this, typeof option == 'object' && option);
                        $this.data('owl.carousel', data);

                        $.each([
                                   'next', 'prev', 'to', 'destroy', 'refresh', 'replace', 'add', 'remove'
                               ], function(i, event) {
                            data.register({ type: Owl.Type.Event, name: event });
                            data.$element.on(event + '.owl.carousel.core', $.proxy(function(e) {
                                if (e.namespace && e.relatedTarget !== this) {
                                    this.suppress([ event ]);
                                    data[event].apply(this, [].slice.call(arguments, 1));
                                    this.release([ event ]);
                                }
                            }, data));
                        });
                    }

                    if (typeof option == 'string' && option.charAt(0) !== '_') {
                        data[option].apply(data, args);
                    }
                });
            };

            /**
             * The constructor for the jQuery Plugin
             * @public
             */
            $.fn.owlCarousel.Constructor = Owl;

        })(window.Zepto || window.jQuery, window, document);

    },{}],19:[function(require,module,exports){
        /*
    StackBlur - a fast almost Gaussian Blur For Canvas

    Version:     0.5
    Author:        Mario Klingemann
    Contact:     mario@quasimondo.com
    Website:    http://www.quasimondo.com/StackBlurForCanvas
    Twitter:    @quasimondo

    In case you find this class useful - especially in commercial projects -
    I am not totally unhappy for a small donation to my PayPal account
    mario@quasimondo.de

    Or support me on flattr:
    https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

    Copyright (c) 2010 Mario Klingemann

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.
    */


        var mul_table = [
            512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,
            454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,
            482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,
            437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,
            497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,
            320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,
            446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,
            329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,
            505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,
            399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,
            324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,
            268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,
            451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,
            385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,
            332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,
            289,287,285,282,280,278,275,273,271,269,267,265,263,261,259];


        var shg_table = [
            9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17,
            17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19,
            19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
            20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
            21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
            21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22,
            22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
            22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23,
            23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
            23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
            23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
            23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
            24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
            24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
            24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
            24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 ];


        function processImage(img, canvas, radius, blurAlphaChannel)
        {
            if (typeof(img) == 'string') {
                var img = document.getElementById(img);
            }
            else if (typeof HTMLImageElement !== 'undefined' && !img instanceof HTMLImageElement) {
                return;
            }
            var w = img.naturalWidth;
            var h = img.naturalHeight;

            if (typeof(canvas) == 'string') {
                var canvas = document.getElementById(canvas);
            }
            else if (typeof HTMLCanvasElement !== 'undefined' && !canvas instanceof HTMLCanvasElement) {
                return;
            }

            canvas.style.width  = 100 + '%';
            canvas.style.height = 100 + '%';
            canvas.width = w;
            canvas.height = h;

            var context = canvas.getContext('2d');
            context.clearRect(0, 0, w, h);
            context.drawImage(img, 0, 0);

            if (isNaN(radius) || radius < 1) return;

            if (blurAlphaChannel)
                processCanvasRGBA(canvas, 0, 0, w, h, radius);
            else
                processCanvasRGB(canvas, 0, 0, w, h, radius);
        }

        function getImageDataFromCanvas(canvas, top_x, top_y, width, height)
        {
            if (typeof(canvas) == 'string')
                var canvas  = document.getElementById(canvas);
            else if (typeof HTMLCanvasElement !== 'undefined' && !canvas instanceof HTMLCanvasElement)
                return;

            var context = canvas.getContext('2d');
            var imageData;

            try {
                try {
                    imageData = context.getImageData(top_x, top_y, width, height);
                } catch(e) {
                    throw new Error("unable to access local image data: " + e);
                    return;
                }
            } catch(e) {
                throw new Error("unable to access image data: " + e);
            }

            return imageData;
        }

        function processCanvasRGBA(canvas, top_x, top_y, width, height, radius)
        {
            if (isNaN(radius) || radius < 1) return;
            radius |= 0;

            var imageData = getImageDataFromCanvas(canvas, top_x, top_y, width, height);

            imageData = processImageDataRGBA(imageData, top_x, top_y, width, height, radius);

            canvas.getContext('2d').putImageData(imageData, top_x, top_y);
        }

        function processImageDataRGBA(imageData, top_x, top_y, width, height, radius)
        {
            var pixels = imageData.data;

            var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum,
                r_out_sum, g_out_sum, b_out_sum, a_out_sum,
                r_in_sum, g_in_sum, b_in_sum, a_in_sum,
                pr, pg, pb, pa, rbs;

            var div = radius + radius + 1;
            var w4 = width << 2;
            var widthMinus1  = width - 1;
            var heightMinus1 = height - 1;
            var radiusPlus1  = radius + 1;
            var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;

            var stackStart = new BlurStack();
            var stack = stackStart;
            for (i = 1; i < div; i++)
            {
                stack = stack.next = new BlurStack();
                if (i == radiusPlus1) var stackEnd = stack;
            }
            stack.next = stackStart;
            var stackIn = null;
            var stackOut = null;

            yw = yi = 0;

            var mul_sum = mul_table[radius];
            var shg_sum = shg_table[radius];

            for (y = 0; y < height; y++)
            {
                r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;

                r_out_sum = radiusPlus1 * (pr = pixels[yi]);
                g_out_sum = radiusPlus1 * (pg = pixels[yi+1]);
                b_out_sum = radiusPlus1 * (pb = pixels[yi+2]);
                a_out_sum = radiusPlus1 * (pa = pixels[yi+3]);

                r_sum += sumFactor * pr;
                g_sum += sumFactor * pg;
                b_sum += sumFactor * pb;
                a_sum += sumFactor * pa;

                stack = stackStart;

                for (i = 0; i < radiusPlus1; i++)
                {
                    stack.r = pr;
                    stack.g = pg;
                    stack.b = pb;
                    stack.a = pa;
                    stack = stack.next;
                }

                for (i = 1; i < radiusPlus1; i++)
                {
                    p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
                    r_sum += (stack.r = (pr = pixels[p])) * (rbs = radiusPlus1 - i);
                    g_sum += (stack.g = (pg = pixels[p+1])) * rbs;
                    b_sum += (stack.b = (pb = pixels[p+2])) * rbs;
                    a_sum += (stack.a = (pa = pixels[p+3])) * rbs;

                    r_in_sum += pr;
                    g_in_sum += pg;
                    b_in_sum += pb;
                    a_in_sum += pa;

                    stack = stack.next;
                }


                stackIn = stackStart;
                stackOut = stackEnd;
                for (x = 0; x < width; x++)
                {
                    pixels[yi+3] = pa = (a_sum * mul_sum) >> shg_sum;
                    if (pa != 0)
                    {
                        pa = 255 / pa;
                        pixels[yi]   = ((r_sum * mul_sum) >> shg_sum) * pa;
                        pixels[yi+1] = ((g_sum * mul_sum) >> shg_sum) * pa;
                        pixels[yi+2] = ((b_sum * mul_sum) >> shg_sum) * pa;
                    } else {
                        pixels[yi] = pixels[yi+1] = pixels[yi+2] = 0;
                    }

                    r_sum -= r_out_sum;
                    g_sum -= g_out_sum;
                    b_sum -= b_out_sum;
                    a_sum -= a_out_sum;

                    r_out_sum -= stackIn.r;
                    g_out_sum -= stackIn.g;
                    b_out_sum -= stackIn.b;
                    a_out_sum -= stackIn.a;

                    p =  (yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)) << 2;

                    r_in_sum += (stackIn.r = pixels[p]);
                    g_in_sum += (stackIn.g = pixels[p+1]);
                    b_in_sum += (stackIn.b = pixels[p+2]);
                    a_in_sum += (stackIn.a = pixels[p+3]);

                    r_sum += r_in_sum;
                    g_sum += g_in_sum;
                    b_sum += b_in_sum;
                    a_sum += a_in_sum;

                    stackIn = stackIn.next;

                    r_out_sum += (pr = stackOut.r);
                    g_out_sum += (pg = stackOut.g);
                    b_out_sum += (pb = stackOut.b);
                    a_out_sum += (pa = stackOut.a);

                    r_in_sum -= pr;
                    g_in_sum -= pg;
                    b_in_sum -= pb;
                    a_in_sum -= pa;

                    stackOut = stackOut.next;

                    yi += 4;
                }
                yw += width;
            }


            for (x = 0; x < width; x++)
            {
                g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;

                yi = x << 2;
                r_out_sum = radiusPlus1 * (pr = pixels[yi]);
                g_out_sum = radiusPlus1 * (pg = pixels[yi+1]);
                b_out_sum = radiusPlus1 * (pb = pixels[yi+2]);
                a_out_sum = radiusPlus1 * (pa = pixels[yi+3]);

                r_sum += sumFactor * pr;
                g_sum += sumFactor * pg;
                b_sum += sumFactor * pb;
                a_sum += sumFactor * pa;

                stack = stackStart;

                for (i = 0; i < radiusPlus1; i++)
                {
                    stack.r = pr;
                    stack.g = pg;
                    stack.b = pb;
                    stack.a = pa;
                    stack = stack.next;
                }

                yp = width;

                for (i = 1; i <= radius; i++)
                {
                    yi = (yp + x) << 2;

                    r_sum += (stack.r = (pr = pixels[yi])) * (rbs = radiusPlus1 - i);
                    g_sum += (stack.g = (pg = pixels[yi+1])) * rbs;
                    b_sum += (stack.b = (pb = pixels[yi+2])) * rbs;
                    a_sum += (stack.a = (pa = pixels[yi+3])) * rbs;

                    r_in_sum += pr;
                    g_in_sum += pg;
                    b_in_sum += pb;
                    a_in_sum += pa;

                    stack = stack.next;

                    if(i < heightMinus1)
                    {
                        yp += width;
                    }
                }

                yi = x;
                stackIn = stackStart;
                stackOut = stackEnd;
                for (y = 0; y < height; y++)
                {
                    p = yi << 2;
                    pixels[p+3] = pa = (a_sum * mul_sum) >> shg_sum;
                    if (pa > 0)
                    {
                        pa = 255 / pa;
                        pixels[p]   = ((r_sum * mul_sum) >> shg_sum) * pa;
                        pixels[p+1] = ((g_sum * mul_sum) >> shg_sum) * pa;
                        pixels[p+2] = ((b_sum * mul_sum) >> shg_sum) * pa;
                    } else {
                        pixels[p] = pixels[p+1] = pixels[p+2] = 0;
                    }

                    r_sum -= r_out_sum;
                    g_sum -= g_out_sum;
                    b_sum -= b_out_sum;
                    a_sum -= a_out_sum;

                    r_out_sum -= stackIn.r;
                    g_out_sum -= stackIn.g;
                    b_out_sum -= stackIn.b;
                    a_out_sum -= stackIn.a;

                    p = (x + (((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width)) << 2;

                    r_sum += (r_in_sum += (stackIn.r = pixels[p]));
                    g_sum += (g_in_sum += (stackIn.g = pixels[p+1]));
                    b_sum += (b_in_sum += (stackIn.b = pixels[p+2]));
                    a_sum += (a_in_sum += (stackIn.a = pixels[p+3]));

                    stackIn = stackIn.next;

                    r_out_sum += (pr = stackOut.r);
                    g_out_sum += (pg = stackOut.g);
                    b_out_sum += (pb = stackOut.b);
                    a_out_sum += (pa = stackOut.a);

                    r_in_sum -= pr;
                    g_in_sum -= pg;
                    b_in_sum -= pb;
                    a_in_sum -= pa;

                    stackOut = stackOut.next;

                    yi += width;
                }
            }
            return imageData;
        }

        function processCanvasRGB(canvas, top_x, top_y, width, height, radius)
        {
            if (isNaN(radius) || radius < 1) return;
            radius |= 0;

            var imageData = getImageDataFromCanvas(canvas, top_x, top_y, width, height);
            imageData = processImageDataRGB(imageData, top_x, top_y, width, height, radius);

            canvas.getContext('2d').putImageData(imageData, top_x, top_y);
        }

        function processImageDataRGB(imageData, top_x, top_y, width, height, radius)
        {
            var pixels = imageData.data;

            var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum,
                r_out_sum, g_out_sum, b_out_sum,
                r_in_sum, g_in_sum, b_in_sum,
                pr, pg, pb, rbs;

            var div = radius + radius + 1;
            var w4 = width << 2;
            var widthMinus1  = width - 1;
            var heightMinus1 = height - 1;
            var radiusPlus1  = radius + 1;
            var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;

            var stackStart = new BlurStack();
            var stack = stackStart;
            for (i = 1; i < div; i++)
            {
                stack = stack.next = new BlurStack();
                if (i == radiusPlus1) var stackEnd = stack;
            }
            stack.next = stackStart;
            var stackIn = null;
            var stackOut = null;

            yw = yi = 0;

            var mul_sum = mul_table[radius];
            var shg_sum = shg_table[radius];

            for (y = 0; y < height; y++)
            {
                r_in_sum = g_in_sum = b_in_sum = r_sum = g_sum = b_sum = 0;

                r_out_sum = radiusPlus1 * (pr = pixels[yi]);
                g_out_sum = radiusPlus1 * (pg = pixels[yi+1]);
                b_out_sum = radiusPlus1 * (pb = pixels[yi+2]);

                r_sum += sumFactor * pr;
                g_sum += sumFactor * pg;
                b_sum += sumFactor * pb;

                stack = stackStart;

                for (i = 0; i < radiusPlus1; i++)
                {
                    stack.r = pr;
                    stack.g = pg;
                    stack.b = pb;
                    stack = stack.next;
                }

                for (i = 1; i < radiusPlus1; i++)
                {
                    p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
                    r_sum += (stack.r = (pr = pixels[p])) * (rbs = radiusPlus1 - i);
                    g_sum += (stack.g = (pg = pixels[p+1])) * rbs;
                    b_sum += (stack.b = (pb = pixels[p+2])) * rbs;

                    r_in_sum += pr;
                    g_in_sum += pg;
                    b_in_sum += pb;

                    stack = stack.next;
                }


                stackIn = stackStart;
                stackOut = stackEnd;
                for (x = 0; x < width; x++)
                {
                    pixels[yi]   = (r_sum * mul_sum) >> shg_sum;
                    pixels[yi+1] = (g_sum * mul_sum) >> shg_sum;
                    pixels[yi+2] = (b_sum * mul_sum) >> shg_sum;

                    r_sum -= r_out_sum;
                    g_sum -= g_out_sum;
                    b_sum -= b_out_sum;

                    r_out_sum -= stackIn.r;
                    g_out_sum -= stackIn.g;
                    b_out_sum -= stackIn.b;

                    p =  (yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)) << 2;

                    r_in_sum += (stackIn.r = pixels[p]);
                    g_in_sum += (stackIn.g = pixels[p+1]);
                    b_in_sum += (stackIn.b = pixels[p+2]);

                    r_sum += r_in_sum;
                    g_sum += g_in_sum;
                    b_sum += b_in_sum;

                    stackIn = stackIn.next;

                    r_out_sum += (pr = stackOut.r);
                    g_out_sum += (pg = stackOut.g);
                    b_out_sum += (pb = stackOut.b);

                    r_in_sum -= pr;
                    g_in_sum -= pg;
                    b_in_sum -= pb;

                    stackOut = stackOut.next;

                    yi += 4;
                }
                yw += width;
            }


            for (x = 0; x < width; x++)
            {
                g_in_sum = b_in_sum = r_in_sum = g_sum = b_sum = r_sum = 0;

                yi = x << 2;
                r_out_sum = radiusPlus1 * (pr = pixels[yi]);
                g_out_sum = radiusPlus1 * (pg = pixels[yi+1]);
                b_out_sum = radiusPlus1 * (pb = pixels[yi+2]);

                r_sum += sumFactor * pr;
                g_sum += sumFactor * pg;
                b_sum += sumFactor * pb;

                stack = stackStart;

                for (i = 0; i < radiusPlus1; i++)
                {
                    stack.r = pr;
                    stack.g = pg;
                    stack.b = pb;
                    stack = stack.next;
                }

                yp = width;

                for (i = 1; i <= radius; i++)
                {
                    yi = (yp + x) << 2;

                    r_sum += (stack.r = (pr = pixels[yi])) * (rbs = radiusPlus1 - i);
                    g_sum += (stack.g = (pg = pixels[yi+1])) * rbs;
                    b_sum += (stack.b = (pb = pixels[yi+2])) * rbs;

                    r_in_sum += pr;
                    g_in_sum += pg;
                    b_in_sum += pb;

                    stack = stack.next;

                    if(i < heightMinus1)
                    {
                        yp += width;
                    }
                }

                yi = x;
                stackIn = stackStart;
                stackOut = stackEnd;
                for (y = 0; y < height; y++)
                {
                    p = yi << 2;
                    pixels[p]   = (r_sum * mul_sum) >> shg_sum;
                    pixels[p+1] = (g_sum * mul_sum) >> shg_sum;
                    pixels[p+2] = (b_sum * mul_sum) >> shg_sum;

                    r_sum -= r_out_sum;
                    g_sum -= g_out_sum;
                    b_sum -= b_out_sum;

                    r_out_sum -= stackIn.r;
                    g_out_sum -= stackIn.g;
                    b_out_sum -= stackIn.b;

                    p = (x + (((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width)) << 2;

                    r_sum += (r_in_sum += (stackIn.r = pixels[p]));
                    g_sum += (g_in_sum += (stackIn.g = pixels[p+1]));
                    b_sum += (b_in_sum += (stackIn.b = pixels[p+2]));

                    stackIn = stackIn.next;

                    r_out_sum += (pr = stackOut.r);
                    g_out_sum += (pg = stackOut.g);
                    b_out_sum += (pb = stackOut.b);

                    r_in_sum -= pr;
                    g_in_sum -= pg;
                    b_in_sum -= pb;

                    stackOut = stackOut.next;

                    yi += width;
                }
            }

            return imageData;
        }

        function BlurStack()
        {
            this.r = 0;
            this.g = 0;
            this.b = 0;
            this.a = 0;
            this.next = null;
        }

        module.exports = {
            image: processImage,
            canvasRGBA: processCanvasRGBA,
            canvasRGB: processCanvasRGB,
            imageDataRGBA: processImageDataRGBA,
            imageDataRGB: processImageDataRGB
        };

    },{}],20:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0

        /**
         @license Sticky-kit v1.1.3 | MIT | Leaf Corcoran 2015 | http://leafo.net
         */

        (function() {
            var $, win;

            $ = window.jQuery;

            win = $(window);

            $.fn.stick_in_parent = function(opts) {
                var doc, elm, enable_bottoming, fn, i, inner_scrolling, len, manual_spacer, offset_top, outer_width, parent_selector, recalc_every, sticky_class;
                if (opts == null) {
                    opts = {};
                }
                sticky_class = opts.sticky_class, inner_scrolling = opts.inner_scrolling, recalc_every = opts.recalc_every, parent_selector = opts.parent, offset_top = opts.offset_top, manual_spacer = opts.spacer, enable_bottoming = opts.bottoming;
                if (offset_top == null) {
                    offset_top = 0;
                }
                if (parent_selector == null) {
                    parent_selector = void 0;
                }
                if (inner_scrolling == null) {
                    inner_scrolling = true;
                }
                if (sticky_class == null) {
                    sticky_class = "is_stuck";
                }
                doc = $(document);
                if (enable_bottoming == null) {
                    enable_bottoming = true;
                }
                outer_width = function(el) {
                    var _el, computed, w;
                    if (window.getComputedStyle) {
                        _el = el[0];
                        computed = window.getComputedStyle(el[0]);
                        w = parseFloat(computed.getPropertyValue("width")) + parseFloat(computed.getPropertyValue("margin-left")) + parseFloat(computed.getPropertyValue("margin-right"));
                        if (computed.getPropertyValue("box-sizing") !== "border-box") {
                            w += parseFloat(computed.getPropertyValue("border-left-width")) + parseFloat(computed.getPropertyValue("border-right-width")) + parseFloat(computed.getPropertyValue("padding-left")) + parseFloat(computed.getPropertyValue("padding-right"));
                        }
                        return w;
                    } else {
                        return el.outerWidth(true);
                    }
                };
                fn = function(elm, padding_bottom, parent_top, parent_height, top, height, el_float, detached) {
                    var bottomed, detach, fixed, last_pos, last_scroll_height, offset, parent, recalc, recalc_and_tick, recalc_counter, spacer, tick;
                    if (elm.data("sticky_kit")) {
                        return;
                    }
                    elm.data("sticky_kit", true);
                    last_scroll_height = doc.height();
                    parent = elm.parent();
                    if (parent_selector != null) {
                        parent = parent.closest(parent_selector);
                    }
                    if (!parent.length) {
                        throw "failed to find stick parent";
                    }
                    fixed = false;
                    bottomed = false;
                    spacer = manual_spacer != null ? manual_spacer && elm.closest(manual_spacer) : $("<div />");
                    if (spacer) {
                        spacer.css('position', elm.css('position'));
                    }
                    recalc = function() {
                        var border_top, padding_top, restore;
                        if (detached) {
                            return;
                        }
                        last_scroll_height = doc.height();
                        border_top = parseInt(parent.css("border-top-width"), 10);
                        padding_top = parseInt(parent.css("padding-top"), 10);
                        padding_bottom = parseInt(parent.css("padding-bottom"), 10);
                        parent_top = parent.offset().top + border_top + padding_top;
                        parent_height = parent.height();
                        if (fixed) {
                            fixed = false;
                            bottomed = false;
                            if (manual_spacer == null) {
                                elm.insertAfter(spacer);
                                spacer.detach();
                            }
                            elm.css({
                                        position: "",
                                        top: "",
                                        width: "",
                                        bottom: ""
                                    }).removeClass(sticky_class);
                            restore = true;
                        }
                        top = elm.offset().top - (parseInt(elm.css("margin-top"), 10) || 0) - offset_top;
                        height = elm.outerHeight(true);
                        el_float = elm.css("float");
                        if (spacer) {
                            spacer.css({
                                           width: outer_width(elm),
                                           height: height,
                                           display: elm.css("display"),
                                           "vertical-align": elm.css("vertical-align"),
                                           "float": el_float
                                       });
                        }
                        if (restore) {
                            return tick();
                        }
                    };
                    recalc();
                    if (height === parent_height) {
                        return;
                    }
                    last_pos = void 0;
                    offset = offset_top;
                    recalc_counter = recalc_every;
                    tick = function() {
                        var css, delta, recalced, scroll, will_bottom, win_height;
                        if (detached) {
                            return;
                        }
                        recalced = false;
                        if (recalc_counter != null) {
                            recalc_counter -= 1;
                            if (recalc_counter <= 0) {
                                recalc_counter = recalc_every;
                                recalc();
                                recalced = true;
                            }
                        }
                        if (!recalced && doc.height() !== last_scroll_height) {
                            recalc();
                            recalced = true;
                        }
                        scroll = win.scrollTop();
                        if (last_pos != null) {
                            delta = scroll - last_pos;
                        }
                        last_pos = scroll;
                        if (fixed) {
                            if (enable_bottoming) {
                                will_bottom = scroll + height + offset > parent_height + parent_top;
                                if (bottomed && !will_bottom) {
                                    bottomed = false;
                                    elm.css({
                                                position: "fixed",
                                                bottom: "",
                                                top: offset
                                            }).trigger("sticky_kit:unbottom");
                                }
                            }
                            if (scroll < top) {
                                fixed = false;
                                offset = offset_top;
                                if (manual_spacer == null) {
                                    if (el_float === "left" || el_float === "right") {
                                        elm.insertAfter(spacer);
                                    }
                                    spacer.detach();
                                }
                                css = {
                                    position: "",
                                    width: "",
                                    top: ""
                                };
                                elm.css(css).removeClass(sticky_class).trigger("sticky_kit:unstick");
                            }
                            if (inner_scrolling) {
                                win_height = win.height();
                                if (height + offset_top > win_height) {
                                    if (!bottomed) {
                                        offset -= delta;
                                        offset = Math.max(win_height - height, offset);
                                        offset = Math.min(offset_top, offset);
                                        if (fixed) {
                                            elm.css({
                                                        top: offset + "px"
                                                    });
                                        }
                                    }
                                }
                            }
                        } else {
                            if (scroll > top) {
                                fixed = true;
                                css = {
                                    position: "fixed",
                                    top: offset
                                };
                                css.width = elm.css("box-sizing") === "border-box" ? elm.outerWidth() + "px" : elm.width() + "px";
                                elm.css(css).addClass(sticky_class);
                                if (manual_spacer == null) {
                                    elm.after(spacer);
                                    if (el_float === "left" || el_float === "right") {
                                        spacer.append(elm);
                                    }
                                }
                                elm.trigger("sticky_kit:stick");
                            }
                        }
                        if (fixed && enable_bottoming) {
                            if (will_bottom == null) {
                                will_bottom = scroll + height + offset > parent_height + parent_top;
                            }
                            if (!bottomed && will_bottom) {
                                bottomed = true;
                                if (parent.css("position") === "static") {
                                    parent.css({
                                                   position: "relative"
                                               });
                                }
                                return elm.css({
                                                   position: "absolute",
                                                   bottom: padding_bottom,
                                                   top: "auto"
                                               }).trigger("sticky_kit:bottom");
                            }
                        }
                    };
                    recalc_and_tick = function() {
                        recalc();
                        return tick();
                    };
                    detach = function() {
                        detached = true;
                        win.off("touchmove", tick);
                        win.off("scroll", tick);
                        win.off("resize", recalc_and_tick);
                        $(document.body).off("sticky_kit:recalc", recalc_and_tick);
                        elm.off("sticky_kit:detach", detach);
                        elm.removeData("sticky_kit");
                        elm.css({
                                    position: "",
                                    bottom: "",
                                    top: "",
                                    width: ""
                                });
                        parent.position("position", "");
                        if (fixed) {
                            if (manual_spacer == null) {
                                if (el_float === "left" || el_float === "right") {
                                    elm.insertAfter(spacer);
                                }
                                spacer.remove();
                            }
                            return elm.removeClass(sticky_class);
                        }
                    };
                    win.on("touchmove", tick);
                    win.on("scroll", tick);
                    win.on("resize", recalc_and_tick);
                    $(document.body).on("sticky_kit:recalc", recalc_and_tick);
                    elm.on("sticky_kit:detach", detach);
                    return setTimeout(tick, 0);
                };
                for (i = 0, len = this.length; i < len; i++) {
                    elm = this[i];
                    fn($(elm));
                }
                return this;
            };

        }).call(this);
    },{}],21:[function(require,module,exports){
        function AjaxApi(element) {
            var self = this;
            this.element = element;
            this.elementType = element.prop('tagName');

            if (this.elementType === 'FORM' && this.element.hasClass('ajax')) {
                this.sendForm(this.element);
            } else if (this.elementType === 'A' && this.element.hasClass('ajax')) {
                this.sendLink(this.element);
            }
            if (this.element.hasClass('ajax-feedback') && this.element.hasClass('ajax')) {
                this.element.find('input, textarea, select').each(function() {
                    self.sendField(jQuery(this));
                });
            } else if (this.element.hasClass('ajax-feedback')) {
                this.sendField(this.element);
            } else if ((this.element.closest('form.ajax.ajax-feedback').length > 0) && (this.element.is('input') || this.element.is('select') || this.element.is('textarea'))) {
                this.sendField(this.element);
            }
            if (this.element.hasClass('ajax-override')) {
                this.overrideForm(this.element);
            }
            if (this.element.hasClass('ajax-send')) {
                this.sendFormByLink(this.element);
            }
            if (this.element.hasClass('ajax-override-submit')) {
                this.sendNormalFormByLink(this.element);
            }
        }

        AjaxApi.prototype.sendForm = function(form) {
            var self = this;
            form.on('submit', function(event) {
                if (!form.hasClass('override-submit')) {
                    event.preventDefault();
                    var url = form.attr('action');
                    var data = form.serializeArray();
                    var type = form.data('page-type');

                    // set special param if auto-complete is active
                    if (form.find('input[type=search]').is(':focus')) {
                        data.unshift({'name': 'searchautocomplete', 'value': 1});
                    }
                    self.ajaxRequest(url, data, type);
                }
            });
        };

        AjaxApi.prototype.sendLink = function(link) {
            var self = this;
            link.on('click', function(event) {
                event.preventDefault();
                var url = link.attr('href');
                var data = [];
                var type = link.data('page-type');
                if (! link.hasClass('disabled')) {
                    self.ajaxRequest(url, data, type);

                    if (link.hasClass('next-page')) {
                        jQuery(document).trigger('next-page', link);
                    }
                }
            });
        };

        AjaxApi.prototype.sendField = function(field) {
            if (!field.hasClass('feedback-field')) {
                field.addClass('feedback-field');

                var self = this;
                var url;
                var data;
                var type;

                if (typeof field.attr('data-feedback-url') !== 'undefined') {
                    url = field.data('feedback-url');
                    type = field.data('page-type');
                } else {
                    url = field.closest('form.ajax').data('feedback-url');
                    type = field.closest('form.ajax').data('page-type');
                }
                if (field.is(':radio') || field.is(':checkbox') || field.is('select')) {
                    field.on('change', function() {
                        data = field.serializeArray();
                        self.ajaxRequest(url, data, type);
                    });
                } else {
                    field.on('blur', function() {
                        data = field.serializeArray();
                        self.ajaxRequest(url, data, type);
                    });
                }
            }
        };

        AjaxApi.prototype.overrideForm = function(element) {
            var self = this;
            var data;
            var type;
            if (element.prop('tagName') === 'A') {
                element.on('click', function(event) {
                    event.preventDefault();
                    var form = element.closest('form.ajax');
                    var url = element.attr('href');
                    type = form.data('page-type');
                    data = form.serializeArray();
                    self.ajaxRequest(url, data, type);
                });
            } else if (element.prop('tagName') === 'SELECT') {
                element.on('change', function() {
                    var select = jQuery(this);
                    if (select.val()) {
                        var form = select.closest('form.ajax');
                        var url = select.val();
                        type = form.data('page-type');
                        data = form.serializeArray();
                        self.ajaxRequest(url, data, type);
                    }
                });
            }
        };

        AjaxApi.prototype.sendFormByLink = function(link) {
            var self = this;
            link.on('click', function(event) {
                event.preventDefault();
                var form = link.closest('form.ajax');
                var url = form.attr('action');
                var data = form.serializeArray();
                var type = form.data('page-type');

                self.ajaxRequest(url, data, type);
            });
        };

        AjaxApi.prototype.sendNormalFormByLink = function(link) {
            var self = this;
            link.on('click', function(event) {
                event.preventDefault();
                var form = link.closest('form.ajax');
                form.attr('action', link.attr('href')).addClass('override-submit');
                form.submit();
            });
        };

        AjaxApi.prototype.ajaxRequest = function(url, data, type) {
            var self = this;
            if (! type)
                type = 1433770902;
            data.unshift({'name': 'type', 'value': type});
            jQuery.ajax({
                            'method': 'get',
                            'url': url,
                            'data': jQuery.param(data),
                            'dataType': 'json',
                            //'username': 'rkw-kompetenz',
                            //'password': 'nvFHKGG6578zfasfF',
                            'complete': function (response) {
                                // console.log(response);
                                try {
                                    response = JSON.parse(response.responseText);
                                    self.parseContent(response);
                                } catch (error) {
                                    console.log(error.message);
                                }
                            }
                        });
        };

        AjaxApi.prototype.parseContent = function(json) {
            var self = this;
            var parent;
            for (var property in json) {
                if (property === 'message') {
                    var messageObject = json[property];
                    for (parent in messageObject) {
                        var messageContent = self.getMessageBox(messageObject[parent].message, messageObject[parent].type, parent);
                        self.appendContent(parent, messageContent);
                    }
                } else if (property === 'data') {
                    if (this.element.prop('tagName') === 'FORM') {
                        jQuery.data(this.element[0], 'dataObject', json[property]);
                        this.element.trigger('ajax-data-object');
                    } else if (this.element.closest('form.ajax').length) {
                        jQuery.data(this.element.closest('form.ajax')[0], 'dataObject', json[property]);
                        this.element.closest('form.ajax').trigger('ajax-data-object');
                    }
                } else if (property === 'html') {
                    var htmlObject = json[property];
                    for (parent in htmlObject) {
                        for (var method in htmlObject[parent]) {
                            if (method === 'append') {
                                self.appendContent(parent, htmlObject[parent][method]);
                            } else if (method === 'prepend') {
                                self.prependContent(parent, htmlObject[parent][method]);
                            } else if (method === 'replace') {
                                self.replaceContent(parent, htmlObject[parent][method]);
                            }
                        }
                    }
                } else if (
                    (property === 'javaScriptBefore')
                    || (property === 'javaScriptAfter')
                ) {
                    try {
                        eval(json[property]);
                    } catch (error) {
                        console.log(error.message);
                    }
                }
            }

            jQuery(document).on('next-page', function(event, element) {
                jQuery.data(element, 'json-ajax', json);
            });
        };

        AjaxApi.prototype.getMessageBox = function(text, type, parent) {
            var box = jQuery('<div class="message-box" data-for="#' + parent + '">' + text + '</div>');
            if (type === 1) {
                box.addClass('success');
            } else if (type === 2) {
                box.addClass('hint');
            } else if (type === 99) {
                box.addClass('error');
            }

            return box;
        };

        AjaxApi.prototype.appendContent = function(element, content) {
            try {
                var newContent = jQuery(content).appendTo(jQuery('#' + element));
                jQuery('#' + element).find('.box-loading').remove();
                jQuery(document).trigger('rkw-ajax-api-content-changed', newContent.parent());
            } catch (error) {}
        };

        AjaxApi.prototype.prependContent = function(element, content) {
            try {
                var newContent = jQuery(content).prependTo(jQuery('#' + element));
                jQuery('#' + element).find('.box-loading').remove();
                jQuery(document).trigger('rkw-ajax-api-content-changed', newContent.parent());

            } catch (error) {}
        };

        AjaxApi.prototype.replaceContent = function(element, content) {
            try {
                if (jQuery(content).length > 0) {
                    var newContent = jQuery(content).appendTo(jQuery('#' + element).empty());
                    jQuery(document).trigger('rkw-ajax-api-content-changed', newContent);
                } else {
                    jQuery('#' + element).empty().append(content);
                }
            } catch (error) {}
        };

        jQuery.fn.ajaxApi = function() {
            jQuery(this).each(function() {
                new AjaxApi(jQuery(this));
            });
        };

        module.exports = AjaxApi;

    },{}],22:[function(require,module,exports){
        var jQuery = require('jquery');

        function Collapse(element) {
            var self = this;
            this.element = jQuery(element);

            this.element.wrap('<div class="collapsed-text__container"></div>');
            this.container = this.element.parent();


            this.showLabel = this.element.data('show') || 'Show more';
            this.hideLabel = this.element.data('hide') || 'Hide';

            this.container.addClass('collapsed-text--hidden');
            this.container.after('<a class="collapsed-text__toggle">' + this.showLabel + '</a>');
            this.checkSize();

            this.toggleHandler = this.container.next('.collapsed-text__toggle');

            jQuery(window).resize(this.checkSize.bind(this));
            jQuery(window).on('font-reload', this.checkSize.bind(this));

            this.toggleHandler.click(function(event) {
                event.preventDefault();
                if (this.container.hasClass('collapsed-text--hidden')) {
                    jQuery('.collapsed-text__container:not(.collapsed-text--hidden)').addClass('collapsed-text--hidden').css('height', '').next('.collapsed-text__toggle').html(this.showLabel);
                    this.show();
                } else {
                    this.hide();
                }

            }.bind(this));
        }

        Collapse.prototype.checkSize = function() {
            this.textHeight = this.element.height();

            if (!this.container.hasClass('collapsed-text--hidden'))
                if (this.textHeight > 100)
                    this.container.css('height', this.textHeight);
                else
                    this.container.css('height', '');

            if (this.textHeight <= 100)
                this.container.addClass('collapsed-text--visible');
            else
                this.container.removeClass('collapsed-text--visible');
        };

        Collapse.prototype.show = function() {
            this.container.removeClass('collapsed-text--hidden');
            this.container.css('height', this.textHeight);
            this.toggleHandler.html(this.hideLabel);
        };

        Collapse.prototype.hide = function() {
            this.container.addClass('collapsed-text--hidden');
            this.container.css('height', '');
            this.toggleHandler.html(this.showLabel);
        };

        Collapse.prototype.onSlideChange = function(itemIndex) {
            var self = this;
        };

        jQuery.fn.collapse = function() {
            return jQuery(this).each(function() {
                new Collapse(jQuery(this));
            });
        };

        module.exports = Collapse;

    },{"jquery":2}],23:[function(require,module,exports){
        var jQuery = require('jquery');
        var viewport = require('../utils/viewport');
        var groups = {};

        function add(element) {
            element = jQuery(element);
            var groupName = element.data('equal-width-group');
            groups[groupName] = true;
        }

        function updateAll() {
            for (var groupName in groups)
                updateGroup(groupName);
        }

        function updateGroup(groupName) {
            var width = 0;
            var elements = [];

            jQuery('[data-equal-width-group="' + groupName + '"]').css('width', '').each(function() {
                var element = jQuery(this);

                if (typeof element.attr('data-group-viewport') != 'undefined') {
                    var viewports = element.data('group-viewport').toString().split(' ');
                    for (var i = 0; i < viewports.length; i++) {
                        if (viewport.is(viewports[i]))
                            elements.push(element);
                    }
                } else
                    elements.push(element);
            });

            for (var i = 0; i < elements.length; i++)
                width = Math.max(width, elements[i].outerWidth());

            for (var i = 0; i < elements.length; i++)
                elements[i].css('width', width);
        }

        function handler() {
            add(this);
        }

        jQuery(window).resize(updateAll);
        viewport.onChange.connect(updateAll);

        module.exports = {
            'handler': handler,
            'add': add,
            'updateGroup': updateGroup,
            'updateAll': updateAll
        };

    },{"../utils/viewport":16,"jquery":2}],24:[function(require,module,exports){
        function Home(container) {
            this.self = this;
            this.container = container;
            this.body = jQuery('body');
            this.window = jQuery(window);

            this.setOwl();
            jQuery(window).on('resize', this.setOwl.bind(this));
        }

        Home.prototype.setOwl = function() {
            if ($(window).width() >= 960){
                var slider = this.container.find('.title__slider--desktop');
            } else {
                var slider = this.container.find('.title__slider--mobile');
            }

            slider.owlCarousel({
                                   loop: true,
                                   autoplay: true,
                                   autoplayTimeout: 5000,
                                   items: 1
                               });
        }

        jQuery.fn.Home = function() {
            return jQuery(this).each(function() {
                new Home(jQuery(this));
            });
        };

        module.exports = {
            Home: Home
        };
    },{}],25:[function(require,module,exports){
        /*!
 * JavaScript Custom Forms : Checkbox Module
 *
 * Copyright 2014-2015 PSD2HTML - http://psd2html.com/jcf
 * Released under the MIT license (LICENSE.txt)
 *
 * Version: 1.1.2
 */
        ;(function($) {
            'use strict';

            jcf.addModule({
                              name: 'Checkbox',
                              selector: 'input[type="checkbox"]',
                              options: {
                                  wrapNative: true,
                                  checkedClass: 'jcf-checked',
                                  uncheckedClass: 'jcf-unchecked',
                                  labelActiveClass: 'jcf-label-active',
                                  fakeStructure: '<span class="jcf-checkbox"><span></span></span>'
                              },
                              matchElement: function(element) {
                                  return element.is(':checkbox');
                              },
                              init: function() {
                                  this.initStructure();
                                  this.attachEvents();
                                  this.refresh();
                              },
                              initStructure: function() {
                                  // prepare structure
                                  this.doc = $(document);
                                  this.realElement = $(this.options.element);
                                  this.fakeElement = $(this.options.fakeStructure).insertAfter(this.realElement);
                                  this.labelElement = this.getLabelFor();

                                  if (this.options.wrapNative) {
                                      // wrap native checkbox inside fake block
                                      this.realElement.appendTo(this.fakeElement).css({
                                                                                          position: 'absolute',
                                                                                          height: '100%',
                                                                                          width: '100%',
                                                                                          opacity: 0,
                                                                                          margin: 0
                                                                                      });
                                  } else {
                                      // just hide native checkbox
                                      this.realElement.addClass(this.options.hiddenClass);
                                  }
                              },
                              attachEvents: function() {
                                  // add event handlers
                                  this.realElement.on({
                                                          focus: this.onFocus,
                                                          click: this.onRealClick
                                                      });
                                  this.fakeElement.on('click', this.onFakeClick);
                                  this.fakeElement.on('jcf-pointerdown', this.onPress);
                              },
                              onRealClick: function(e) {
                                  // just redraw fake element (setTimeout handles click that might be prevented)
                                  var self = this;
                                  this.savedEventObject = e;
                                  setTimeout(function() {
                                      self.refresh();
                                  }, 0);
                              },
                              onFakeClick: function(e) {
                                  // skip event if clicked on real element inside wrapper
                                  if (this.options.wrapNative && this.realElement.is(e.target)) {
                                      return;
                                  }

                                  // toggle checked class
                                  if (!this.realElement.is(':disabled')) {
                                      delete this.savedEventObject;
                                      this.stateChecked = this.realElement.prop('checked');
                                      this.realElement.prop('checked', !this.stateChecked);
                                      this.fireNativeEvent(this.realElement, 'click');
                                      if (this.savedEventObject && this.savedEventObject.isDefaultPrevented()) {
                                          this.realElement.prop('checked', this.stateChecked);
                                      } else {
                                          this.fireNativeEvent(this.realElement, 'change');
                                      }
                                      delete this.savedEventObject;
                                  }
                              },
                              onFocus: function() {
                                  if (!this.pressedFlag || !this.focusedFlag) {
                                      this.focusedFlag = true;
                                      this.fakeElement.addClass(this.options.focusClass);
                                      this.realElement.on('blur', this.onBlur);
                                  }
                              },
                              onBlur: function() {
                                  if (!this.pressedFlag) {
                                      this.focusedFlag = false;
                                      this.fakeElement.removeClass(this.options.focusClass);
                                      this.realElement.off('blur', this.onBlur);
                                  }
                              },
                              onPress: function(e) {
                                  if (!this.focusedFlag && e.pointerType === 'mouse') {
                                      this.realElement.focus();
                                  }
                                  this.pressedFlag = true;
                                  this.fakeElement.addClass(this.options.pressedClass);
                                  this.doc.on('jcf-pointerup', this.onRelease);
                              },
                              onRelease: function(e) {
                                  if (this.focusedFlag && e.pointerType === 'mouse') {
                                      this.realElement.focus();
                                  }
                                  this.pressedFlag = false;
                                  this.fakeElement.removeClass(this.options.pressedClass);
                                  this.doc.off('jcf-pointerup', this.onRelease);
                              },
                              getLabelFor: function() {
                                  var parentLabel = this.realElement.closest('label'),
                                      elementId = this.realElement.prop('id');

                                  if (!parentLabel.length && elementId) {
                                      parentLabel = $('label[for="' + elementId + '"]');
                                  }
                                  return parentLabel.length ? parentLabel : null;
                              },
                              refresh: function() {
                                  // redraw custom checkbox
                                  var isChecked = this.realElement.is(':checked'),
                                      isDisabled = this.realElement.is(':disabled');

                                  this.fakeElement.toggleClass(this.options.checkedClass, isChecked)
                                      .toggleClass(this.options.uncheckedClass, !isChecked)
                                      .toggleClass(this.options.disabledClass, isDisabled);

                                  if (this.labelElement) {
                                      this.labelElement.toggleClass(this.options.labelActiveClass, isChecked);
                                  }
                              },
                              destroy: function() {
                                  // restore structure
                                  if (this.options.wrapNative) {
                                      this.realElement.insertBefore(this.fakeElement).css({
                                                                                              position: '',
                                                                                              width: '',
                                                                                              height: '',
                                                                                              opacity: '',
                                                                                              margin: ''
                                                                                          });
                                  } else {
                                      this.realElement.removeClass(this.options.hiddenClass);
                                  }

                                  // removing element will also remove its event handlers
                                  this.fakeElement.off('jcf-pointerdown', this.onPress);
                                  this.fakeElement.remove();

                                  // remove other event handlers
                                  this.doc.off('jcf-pointerup', this.onRelease);
                                  this.realElement.off({
                                                           focus: this.onFocus,
                                                           click: this.onRealClick
                                                       });
                              }
                          });

        }(jQuery));

    },{}],26:[function(require,module,exports){
        /*!
 * JavaScript Custom Forms : File Module
 *
 * Copyright 2014-2015 PSD2HTML - http://psd2html.com/jcf
 * Released under the MIT license (LICENSE.txt)
 *
 * Version: 1.1.2
 */
        ;(function($) {
            'use strict';

            jcf.addModule({
                              name: 'File',
                              selector: 'input[type="file"]',
                              options: {
                                  fakeStructure: '<span class="jcf-file"><span class="jcf-fake-input"></span><span class="jcf-upload-button"><span class="jcf-button-content"></span></span></span>',
                                  buttonText: 'Choose file',
                                  placeholderText: 'No file chosen',
                                  realElementClass: 'jcf-real-element',
                                  extensionPrefixClass: 'jcf-extension-',
                                  selectedFileBlock: '.jcf-fake-input',
                                  buttonTextBlock: '.jcf-button-content'
                              },
                              matchElement: function(element) {
                                  return element.is('input[type="file"]');
                              },
                              init: function() {
                                  this.initStructure();
                                  this.attachEvents();
                                  this.refresh();
                              },
                              initStructure: function() {
                                  this.doc = $(document);
                                  this.realElement = $(this.options.element).addClass(this.options.realElementClass);
                                  this.fakeElement = $(this.options.fakeStructure).insertBefore(this.realElement);
                                  this.fileNameBlock = this.fakeElement.find(this.options.selectedFileBlock);
                                  this.buttonTextBlock = this.fakeElement.find(this.options.buttonTextBlock).text(this.options.buttonText);

                                  this.realElement.appendTo(this.fakeElement).css({
                                                                                      position: 'absolute',
                                                                                      opacity: 0
                                                                                  });
                              },
                              attachEvents: function() {
                                  this.realElement.on({
                                                          'jcf-pointerdown': this.onPress,
                                                          change: this.onChange,
                                                          focus: this.onFocus
                                                      });
                              },
                              onChange: function() {
                                  this.refresh();
                              },
                              onFocus: function() {
                                  this.fakeElement.addClass(this.options.focusClass);
                                  this.realElement.on('blur', this.onBlur);
                              },
                              onBlur: function() {
                                  this.fakeElement.removeClass(this.options.focusClass);
                                  this.realElement.off('blur', this.onBlur);
                              },
                              onPress: function() {
                                  this.fakeElement.addClass(this.options.pressedClass);
                                  this.doc.on('jcf-pointerup', this.onRelease);
                              },
                              onRelease: function() {
                                  this.fakeElement.removeClass(this.options.pressedClass);
                                  this.doc.off('jcf-pointerup', this.onRelease);
                              },
                              getFileName: function() {
                                  var resultFileName = '',
                                      files = this.realElement.prop('files');

                                  if (files && files.length) {
                                      $.each(files, function(index, file) {
                                          resultFileName += (index > 0 ? ', ' : '') + file.name;
                                      });
                                  } else {
                                      resultFileName = this.realElement.val().replace(/^[\s\S]*(?:\\|\/)([\s\S^\\\/]*)$/g, '$1');
                                  }

                                  return resultFileName;
                              },
                              getFileExtension: function() {
                                  var fileName = this.realElement.val();
                                  return fileName.lastIndexOf('.') < 0 ? '' : fileName.substring(fileName.lastIndexOf('.') + 1).toLowerCase();
                              },
                              updateExtensionClass: function() {
                                  var currentExtension = this.getFileExtension(),
                                      currentClassList = this.fakeElement.prop('className'),
                                      cleanedClassList = currentClassList.replace(new RegExp('(\\s|^)' + this.options.extensionPrefixClass + '[^ ]+','gi'), '');

                                  this.fakeElement.prop('className', cleanedClassList);
                                  if (currentExtension) {
                                      this.fakeElement.addClass(this.options.extensionPrefixClass + currentExtension);
                                  }
                              },
                              refresh: function() {
                                  var selectedFileName = this.getFileName() || this.options.placeholderText;
                                  this.fakeElement.toggleClass(this.options.disabledClass, this.realElement.is(':disabled'));
                                  this.fileNameBlock.text(selectedFileName);
                                  this.updateExtensionClass();
                              },
                              destroy: function() {
                                  // reset styles and restore element position
                                  this.realElement.insertBefore(this.fakeElement).removeClass(this.options.realElementClass).css({
                                                                                                                                     position: '',
                                                                                                                                     opacity: ''
                                                                                                                                 });
                                  this.fakeElement.remove();

                                  // remove event handlers
                                  this.realElement.off({
                                                           'jcf-pointerdown': this.onPress,
                                                           change: this.onChange,
                                                           focus: this.onFocus,
                                                           blur: this.onBlur
                                                       });
                                  this.doc.off('jcf-pointerup', this.onRelease);
                              }
                          });

        }(jQuery));

    },{}],27:[function(require,module,exports){
        /*!
 * JavaScript Custom Forms
 *
 * Copyright 2014-2015 PSD2HTML - http://psd2html.com/jcf
 * Released under the MIT license (LICENSE.txt)
 *
 * Version: 1.1.2
 */
        ;(function(root, factory) {
            'use strict';
            if (typeof define === 'function' && define.amd) {
                define(['jquery'], factory);
            } else if (typeof exports === 'object') {
                module.exports = factory(require('jquery'));
            } else {
                root.jcf = factory(jQuery);
            }
        }(this, function($) {
            'use strict';

            // define version
            var version = '1.1.2';

            // private variables
            var customInstances = [];

            // default global options
            var commonOptions = {
                optionsKey: 'jcf',
                dataKey: 'jcf-instance',
                rtlClass: 'jcf-rtl',
                focusClass: 'jcf-focus',
                pressedClass: 'jcf-pressed',
                disabledClass: 'jcf-disabled',
                hiddenClass: 'jcf-hidden',
                resetAppearanceClass: 'jcf-reset-appearance',
                unselectableClass: 'jcf-unselectable'
            };

            // detect device type
            var isTouchDevice = ('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch,
                isWinPhoneDevice = /Windows Phone/.test(navigator.userAgent);
            commonOptions.isMobileDevice = !!(isTouchDevice || isWinPhoneDevice);

            // create global stylesheet if custom forms are used
            var createStyleSheet = function() {
                var styleTag = $('<style>').appendTo('head'),
                    styleSheet = styleTag.prop('sheet') || styleTag.prop('styleSheet');

                // crossbrowser style handling
                var addCSSRule = function(selector, rules, index) {
                    if (styleSheet.insertRule) {
                        styleSheet.insertRule(selector + '{' + rules + '}', index);
                    } else {
                        styleSheet.addRule(selector, rules, index);
                    }
                };

                // add special rules
                addCSSRule('.' + commonOptions.hiddenClass, 'position:absolute !important;left:-9999px !important;height:1px !important;width:1px !important;margin:0 !important;border-width:0 !important;-webkit-appearance:none;-moz-appearance:none;appearance:none');
                addCSSRule('.' + commonOptions.rtlClass + ' .' + commonOptions.hiddenClass, 'right:-9999px !important; left: auto !important');
                addCSSRule('.' + commonOptions.unselectableClass, '-webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-tap-highlight-color: rgba(0,0,0,0);');
                addCSSRule('.' + commonOptions.resetAppearanceClass, 'background: none; border: none; -webkit-appearance: none; appearance: none; opacity: 0; filter: alpha(opacity=0);');

                // detect rtl pages
                var html = $('html'), body = $('body');
                if (html.css('direction') === 'rtl' || body.css('direction') === 'rtl') {
                    html.addClass(commonOptions.rtlClass);
                }

                // handle form reset event
                html.on('reset', function() {
                    setTimeout(function() {
                        api.refreshAll();
                    }, 0);
                });

                // mark stylesheet as created
                commonOptions.styleSheetCreated = true;
            };

            // simplified pointer events handler
            (function() {
                var pointerEventsSupported = navigator.pointerEnabled || navigator.msPointerEnabled,
                    touchEventsSupported = ('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch,
                    eventList, eventMap = {}, eventPrefix = 'jcf-';

                // detect events to attach
                if (pointerEventsSupported) {
                    eventList = {
                        pointerover: navigator.pointerEnabled ? 'pointerover' : 'MSPointerOver',
                        pointerdown: navigator.pointerEnabled ? 'pointerdown' : 'MSPointerDown',
                        pointermove: navigator.pointerEnabled ? 'pointermove' : 'MSPointerMove',
                        pointerup: navigator.pointerEnabled ? 'pointerup' : 'MSPointerUp'
                    };
                } else {
                    eventList = {
                        pointerover: 'mouseover',
                        pointerdown: 'mousedown' + (touchEventsSupported ? ' touchstart' : ''),
                        pointermove: 'mousemove' + (touchEventsSupported ? ' touchmove' : ''),
                        pointerup: 'mouseup' + (touchEventsSupported ? ' touchend' : '')
                    };
                }

                // create event map
                $.each(eventList, function(targetEventName, fakeEventList) {
                    $.each(fakeEventList.split(' '), function(index, fakeEventName) {
                        eventMap[fakeEventName] = targetEventName;
                    });
                });

                // jQuery event hooks
                $.each(eventList, function(eventName, eventHandlers) {
                    eventHandlers = eventHandlers.split(' ');
                    $.event.special[eventPrefix + eventName] = {
                        setup: function() {
                            var self = this;
                            $.each(eventHandlers, function(index, fallbackEvent) {
                                if (self.addEventListener) self.addEventListener(fallbackEvent, fixEvent, false);
                                else self['on' + fallbackEvent] = fixEvent;
                            });
                        },
                        teardown: function() {
                            var self = this;
                            $.each(eventHandlers, function(index, fallbackEvent) {
                                if (self.addEventListener) self.removeEventListener(fallbackEvent, fixEvent, false);
                                else self['on' + fallbackEvent] = null;
                            });
                        }
                    };
                });

                // check that mouse event are not simulated by mobile browsers
                var lastTouch = null;
                var mouseEventSimulated = function(e) {
                    var dx = Math.abs(e.pageX - lastTouch.x),
                        dy = Math.abs(e.pageY - lastTouch.y),
                        rangeDistance = 25;

                    if (dx <= rangeDistance && dy <= rangeDistance) {
                        return true;
                    }
                };

                // normalize event
                var fixEvent = function(e) {
                    var origEvent = e || window.event,
                        touchEventData = null,
                        targetEventName = eventMap[origEvent.type];

                    e = $.event.fix(origEvent);
                    e.type = eventPrefix + targetEventName;

                    if (origEvent.pointerType) {
                        switch (origEvent.pointerType) {
                            case 2: e.pointerType = 'touch'; break;
                            case 3: e.pointerType = 'pen'; break;
                            case 4: e.pointerType = 'mouse'; break;
                            default: e.pointerType = origEvent.pointerType;
                        }
                    } else {
                        e.pointerType = origEvent.type.substr(0, 5); // "mouse" or "touch" word length
                    }

                    if (!e.pageX && !e.pageY) {
                        touchEventData = origEvent.changedTouches ? origEvent.changedTouches[0] : origEvent;
                        e.pageX = touchEventData.pageX;
                        e.pageY = touchEventData.pageY;
                    }

                    if (origEvent.type === 'touchend') {
                        lastTouch = { x: e.pageX, y: e.pageY };
                    }
                    if (e.pointerType === 'mouse' && lastTouch && mouseEventSimulated(e)) {
                        return;
                    } else {
                        return ($.event.dispatch || $.event.handle).call(this, e);
                    }
                };
            }());

            // custom mousewheel/trackpad handler
            (function() {
                var wheelEvents = ('onwheel' in document || document.documentMode >= 9 ? 'wheel' : 'mousewheel DOMMouseScroll').split(' '),
                    shimEventName = 'jcf-mousewheel';

                $.event.special[shimEventName] = {
                    setup: function() {
                        var self = this;
                        $.each(wheelEvents, function(index, fallbackEvent) {
                            if (self.addEventListener) self.addEventListener(fallbackEvent, fixEvent, false);
                            else self['on' + fallbackEvent] = fixEvent;
                        });
                    },
                    teardown: function() {
                        var self = this;
                        $.each(wheelEvents, function(index, fallbackEvent) {
                            if (self.addEventListener) self.removeEventListener(fallbackEvent, fixEvent, false);
                            else self['on' + fallbackEvent] = null;
                        });
                    }
                };

                var fixEvent = function(e) {
                    var origEvent = e || window.event;
                    e = $.event.fix(origEvent);
                    e.type = shimEventName;

                    // old wheel events handler
                    if ('detail'      in origEvent) { e.deltaY = -origEvent.detail;      }
                    if ('wheelDelta'  in origEvent) { e.deltaY = -origEvent.wheelDelta;  }
                    if ('wheelDeltaY' in origEvent) { e.deltaY = -origEvent.wheelDeltaY; }
                    if ('wheelDeltaX' in origEvent) { e.deltaX = -origEvent.wheelDeltaX; }

                    // modern wheel event handler
                    if ('deltaY' in origEvent) {
                        e.deltaY = origEvent.deltaY;
                    }
                    if ('deltaX' in origEvent) {
                        e.deltaX = origEvent.deltaX;
                    }

                    // handle deltaMode for mouse wheel
                    e.delta = e.deltaY || e.deltaX;
                    if (origEvent.deltaMode === 1) {
                        var lineHeight = 16;
                        e.delta *= lineHeight;
                        e.deltaY *= lineHeight;
                        e.deltaX *= lineHeight;
                    }

                    return ($.event.dispatch || $.event.handle).call(this, e);
                };
            }());

            // extra module methods
            var moduleMixin = {
                // provide function for firing native events
                fireNativeEvent: function(elements, eventName) {
                    $(elements).each(function() {
                        var element = this, eventObject;
                        if (element.dispatchEvent) {
                            eventObject = document.createEvent('HTMLEvents');
                            eventObject.initEvent(eventName, true, true);
                            element.dispatchEvent(eventObject);
                        } else if (document.createEventObject) {
                            eventObject = document.createEventObject();
                            eventObject.target = element;
                            element.fireEvent('on' + eventName, eventObject);
                        }
                    });
                },
                // bind event handlers for module instance (functions beggining with "on")
                bindHandlers: function() {
                    var self = this;
                    $.each(self, function(propName, propValue) {
                        if (propName.indexOf('on') === 0 && $.isFunction(propValue)) {
                            // dont use $.proxy here because it doesn't create unique handler
                            self[propName] = function() {
                                return propValue.apply(self, arguments);
                            };
                        }
                    });
                }
            };

            // public API
            var api = {
                version: version,
                modules: {},
                getOptions: function() {
                    return $.extend({}, commonOptions);
                },
                setOptions: function(moduleName, moduleOptions) {
                    if (arguments.length > 1) {
                        // set module options
                        if (this.modules[moduleName]) {
                            $.extend(this.modules[moduleName].prototype.options, moduleOptions);
                        }
                    } else {
                        // set common options
                        $.extend(commonOptions, moduleName);
                    }
                },
                addModule: function(proto) {
                    // add module to list
                    var Module = function(options) {
                        // save instance to collection
                        if (!options.element.data(commonOptions.dataKey)) {
                            options.element.data(commonOptions.dataKey, this);
                        }
                        customInstances.push(this);

                        // save options
                        this.options = $.extend({}, commonOptions, this.options, getInlineOptions(options.element), options);

                        // bind event handlers to instance
                        this.bindHandlers();

                        // call constructor
                        this.init.apply(this, arguments);
                    };

                    // parse options from HTML attribute
                    var getInlineOptions = function(element) {
                        var dataOptions = element.data(commonOptions.optionsKey),
                            attrOptions = element.attr(commonOptions.optionsKey);

                        if (dataOptions) {
                            return dataOptions;
                        } else if (attrOptions) {
                            try {
                                return $.parseJSON(attrOptions);
                            } catch (e) {
                                // ignore invalid attributes
                            }
                        }
                    };

                    // set proto as prototype for new module
                    Module.prototype = proto;

                    // add mixin methods to module proto
                    $.extend(proto, moduleMixin);
                    if (proto.plugins) {
                        $.each(proto.plugins, function(pluginName, plugin) {
                            $.extend(plugin.prototype, moduleMixin);
                        });
                    }

                    // override destroy method
                    var originalDestroy = Module.prototype.destroy;
                    Module.prototype.destroy = function() {
                        this.options.element.removeData(this.options.dataKey);

                        for (var i = customInstances.length - 1; i >= 0; i--) {
                            if (customInstances[i] === this) {
                                customInstances.splice(i, 1);
                                break;
                            }
                        }

                        if (originalDestroy) {
                            originalDestroy.apply(this, arguments);
                        }
                    };

                    // save module to list
                    this.modules[proto.name] = Module;
                },
                getInstance: function(element) {
                    return $(element).data(commonOptions.dataKey);
                },
                replace: function(elements, moduleName, customOptions) {
                    var self = this,
                        instance;

                    if (!commonOptions.styleSheetCreated) {
                        createStyleSheet();
                    }

                    $(elements).each(function() {
                        var moduleOptions,
                            element = $(this);

                        instance = element.data(commonOptions.dataKey);
                        if (instance) {
                            instance.refresh();
                        } else {
                            if (!moduleName) {
                                $.each(self.modules, function(currentModuleName, module) {
                                    if (module.prototype.matchElement.call(module.prototype, element)) {
                                        moduleName = currentModuleName;
                                        return false;
                                    }
                                });
                            }
                            if (moduleName) {
                                moduleOptions = $.extend({ element: element }, customOptions);
                                instance = new self.modules[moduleName](moduleOptions);
                            }
                        }
                    });
                    return instance;
                },
                refresh: function(elements) {
                    $(elements).each(function() {
                        var instance = $(this).data(commonOptions.dataKey);
                        if (instance) {
                            instance.refresh();
                        }
                    });
                },
                destroy: function(elements) {
                    $(elements).each(function() {
                        var instance = $(this).data(commonOptions.dataKey);
                        if (instance) {
                            instance.destroy();
                        }
                    });
                },
                replaceAll: function(context) {
                    var self = this;
                    $.each(this.modules, function(moduleName, module) {
                        $(module.prototype.selector, context).each(function() {
                            if (this.className.indexOf('jcf-ignore') < 0) {
                                self.replace(this, moduleName);
                            }
                        });
                    });
                },
                refreshAll: function(context) {
                    if (context) {
                        $.each(this.modules, function(moduleName, module) {
                            $(module.prototype.selector, context).each(function() {
                                var instance = $(this).data(commonOptions.dataKey);
                                if (instance) {
                                    instance.refresh();
                                }
                            });
                        });
                    } else {
                        for (var i = customInstances.length - 1; i >= 0; i--) {
                            customInstances[i].refresh();
                        }
                    }
                },
                destroyAll: function(context) {
                    if (context) {
                        $.each(this.modules, function(moduleName, module) {
                            $(module.prototype.selector, context).each(function(index, element) {
                                var instance = $(element).data(commonOptions.dataKey);
                                if (instance) {
                                    instance.destroy();
                                }
                            });
                        });
                    } else {
                        while (customInstances.length) {
                            customInstances[0].destroy();
                        }
                    }
                }
            };

            // always export API to the global window object
            window.jcf = api;

            return api;
        }));

    },{"jquery":2}],28:[function(require,module,exports){
        /*!
 * JavaScript Custom Forms : Radio Module
 *
 * Copyright 2014-2015 PSD2HTML - http://psd2html.com/jcf
 * Released under the MIT license (LICENSE.txt)
 *
 * Version: 1.1.2
 */
        ;(function($) {
            'use strict';

            jcf.addModule({
                              name: 'Radio',
                              selector: 'input[type="radio"]',
                              options: {
                                  wrapNative: true,
                                  checkedClass: 'jcf-checked',
                                  uncheckedClass: 'jcf-unchecked',
                                  labelActiveClass: 'jcf-label-active',
                                  fakeStructure: '<span class="jcf-radio"><span></span></span>'
                              },
                              matchElement: function(element) {
                                  return element.is(':radio');
                              },
                              init: function() {
                                  this.initStructure();
                                  this.attachEvents();
                                  this.refresh();
                              },
                              initStructure: function() {
                                  // prepare structure
                                  this.doc = $(document);
                                  this.realElement = $(this.options.element);
                                  this.fakeElement = $(this.options.fakeStructure).insertAfter(this.realElement);
                                  this.labelElement = this.getLabelFor();

                                  if (this.options.wrapNative) {
                                      // wrap native radio inside fake block
                                      this.realElement.prependTo(this.fakeElement).css({
                                                                                           position: 'absolute',
                                                                                           opacity: 0
                                                                                       });
                                  } else {
                                      // just hide native radio
                                      this.realElement.addClass(this.options.hiddenClass);
                                  }
                              },
                              attachEvents: function() {
                                  // add event handlers
                                  this.realElement.on({
                                                          focus: this.onFocus,
                                                          click: this.onRealClick
                                                      });
                                  this.fakeElement.on('click', this.onFakeClick);
                                  this.fakeElement.on('jcf-pointerdown', this.onPress);
                              },
                              onRealClick: function(e) {
                                  // redraw current radio and its group (setTimeout handles click that might be prevented)
                                  var self = this;
                                  this.savedEventObject = e;
                                  setTimeout(function() {
                                      self.refreshRadioGroup();
                                  }, 0);
                              },
                              onFakeClick: function(e) {
                                  // skip event if clicked on real element inside wrapper
                                  if (this.options.wrapNative && this.realElement.is(e.target)) {
                                      return;
                                  }

                                  // toggle checked class
                                  if (!this.realElement.is(':disabled')) {
                                      delete this.savedEventObject;
                                      this.currentActiveRadio = this.getCurrentActiveRadio();
                                      this.stateChecked = this.realElement.prop('checked');
                                      this.realElement.prop('checked', true);
                                      this.fireNativeEvent(this.realElement, 'click');
                                      if (this.savedEventObject && this.savedEventObject.isDefaultPrevented()) {
                                          this.realElement.prop('checked', this.stateChecked);
                                          this.currentActiveRadio.prop('checked', true);
                                      } else {
                                          this.fireNativeEvent(this.realElement, 'change');
                                      }
                                      delete this.savedEventObject;
                                  }
                              },
                              onFocus: function() {
                                  if (!this.pressedFlag || !this.focusedFlag) {
                                      this.focusedFlag = true;
                                      this.fakeElement.addClass(this.options.focusClass);
                                      this.realElement.on('blur', this.onBlur);
                                  }
                              },
                              onBlur: function() {
                                  if (!this.pressedFlag) {
                                      this.focusedFlag = false;
                                      this.fakeElement.removeClass(this.options.focusClass);
                                      this.realElement.off('blur', this.onBlur);
                                  }
                              },
                              onPress: function(e) {
                                  if (!this.focusedFlag && e.pointerType === 'mouse') {
                                      this.realElement.focus();
                                  }
                                  this.pressedFlag = true;
                                  this.fakeElement.addClass(this.options.pressedClass);
                                  this.doc.on('jcf-pointerup', this.onRelease);
                              },
                              onRelease: function(e) {
                                  if (this.focusedFlag && e.pointerType === 'mouse') {
                                      this.realElement.focus();
                                  }
                                  this.pressedFlag = false;
                                  this.fakeElement.removeClass(this.options.pressedClass);
                                  this.doc.off('jcf-pointerup', this.onRelease);
                              },
                              getCurrentActiveRadio: function() {
                                  return this.getRadioGroup(this.realElement).filter(':checked');
                              },
                              getRadioGroup: function(radio) {
                                  // find radio group for specified radio button
                                  var name = radio.attr('name'),
                                      parentForm = radio.parents('form');

                                  if (name) {
                                      if (parentForm.length) {
                                          return parentForm.find('input[name="' + name + '"]');
                                      } else {
                                          return $('input[name="' + name + '"]:not(form input)');
                                      }
                                  } else {
                                      return radio;
                                  }
                              },
                              getLabelFor: function() {
                                  var parentLabel = this.realElement.closest('label'),
                                      elementId = this.realElement.prop('id');

                                  if (!parentLabel.length && elementId) {
                                      parentLabel = $('label[for="' + elementId + '"]');
                                  }
                                  return parentLabel.length ? parentLabel : null;
                              },
                              refreshRadioGroup: function() {
                                  // redraw current radio and its group
                                  this.getRadioGroup(this.realElement).each(function() {
                                      jcf.refresh(this);
                                  });
                              },
                              refresh: function() {
                                  // redraw current radio button
                                  var isChecked = this.realElement.is(':checked'),
                                      isDisabled = this.realElement.is(':disabled');

                                  this.fakeElement.toggleClass(this.options.checkedClass, isChecked)
                                      .toggleClass(this.options.uncheckedClass, !isChecked)
                                      .toggleClass(this.options.disabledClass, isDisabled);

                                  if (this.labelElement) {
                                      this.labelElement.toggleClass(this.options.labelActiveClass, isChecked);
                                  }
                              },
                              destroy: function() {
                                  // restore structure
                                  if (this.options.wrapNative) {
                                      this.realElement.insertBefore(this.fakeElement).css({
                                                                                              position: '',
                                                                                              width: '',
                                                                                              height: '',
                                                                                              opacity: '',
                                                                                              margin: ''
                                                                                          });
                                  } else {
                                      this.realElement.removeClass(this.options.hiddenClass);
                                  }

                                  // removing element will also remove its event handlers
                                  this.fakeElement.off('jcf-pointerdown', this.onPress);
                                  this.fakeElement.remove();

                                  // remove other event handlers
                                  this.doc.off('jcf-pointerup', this.onRelease);
                                  this.realElement.off({
                                                           blur: this.onBlur,
                                                           focus: this.onFocus,
                                                           click: this.onRealClick
                                                       });
                              }
                          });

        }(jQuery));

    },{}],29:[function(require,module,exports){
        /*!
 * JavaScript Custom Forms : Scrollbar Module
 *
 * Copyright 2014-2015 PSD2HTML - http://psd2html.com/jcf
 * Released under the MIT license (LICENSE.txt)
 *
 * Version: 1.1.2
 */
        ;(function($, window) {
            'use strict';

            jcf.addModule({
                              name: 'Scrollable',
                              selector: '.jcf-scrollable',
                              plugins: {
                                  ScrollBar: ScrollBar
                              },
                              options: {
                                  mouseWheelStep: 150,
                                  handleResize: true,
                                  alwaysShowScrollbars: false,
                                  alwaysPreventMouseWheel: false,
                                  scrollAreaStructure: '<div class="jcf-scrollable-wrapper"></div>'
                              },
                              matchElement: function(element) {
                                  return element.is('.jcf-scrollable');
                              },
                              init: function() {
                                  this.initStructure();
                                  this.attachEvents();
                                  this.rebuildScrollbars();
                              },
                              initStructure: function() {
                                  // prepare structure
                                  this.doc = $(document);
                                  this.win = $(window);
                                  this.realElement = $(this.options.element);
                                  this.scrollWrapper = $(this.options.scrollAreaStructure).insertAfter(this.realElement);

                                  // set initial styles
                                  this.scrollWrapper.css('position', 'relative');
                                  this.realElement.css('overflow', 'hidden');
                                  this.vBarEdge = 0;
                              },
                              attachEvents: function() {
                                  // create scrollbars
                                  var self = this;
                                  this.vBar = new ScrollBar({
                                                                holder: this.scrollWrapper,
                                                                vertical: true,
                                                                onScroll: function(scrollTop) {
                                                                    self.realElement.scrollTop(scrollTop);
                                                                }
                                                            });
                                  this.hBar = new ScrollBar({
                                                                holder: this.scrollWrapper,
                                                                vertical: false,
                                                                onScroll: function(scrollLeft) {
                                                                    self.realElement.scrollLeft(scrollLeft);
                                                                }
                                                            });

                                  // add event handlers
                                  this.realElement.on('scroll', this.onScroll);
                                  if (this.options.handleResize) {
                                      this.win.on('resize orientationchange load', this.onResize);
                                  }

                                  // add pointer/wheel event handlers
                                  this.realElement.on('jcf-mousewheel', this.onMouseWheel);
                                  this.realElement.on('jcf-pointerdown', this.onTouchBody);
                              },
                              onScroll: function() {
                                  this.redrawScrollbars();
                              },
                              onResize: function() {
                                  // do not rebuild scrollbars if form field is in focus
                                  if (!$(document.activeElement).is(':input')) {
                                      this.rebuildScrollbars();
                                  }
                              },
                              onTouchBody: function(e) {
                                  if (e.pointerType === 'touch') {
                                      this.touchData = {
                                          scrollTop: this.realElement.scrollTop(),
                                          scrollLeft: this.realElement.scrollLeft(),
                                          left: e.pageX,
                                          top: e.pageY
                                      };
                                      this.doc.on({
                                                      'jcf-pointermove': this.onMoveBody,
                                                      'jcf-pointerup': this.onReleaseBody
                                                  });
                                  }
                              },
                              onMoveBody: function(e) {
                                  var targetScrollTop,
                                      targetScrollLeft,
                                      verticalScrollAllowed = this.verticalScrollActive,
                                      horizontalScrollAllowed = this.horizontalScrollActive;

                                  if (e.pointerType === 'touch') {
                                      targetScrollTop = this.touchData.scrollTop - e.pageY + this.touchData.top;
                                      targetScrollLeft = this.touchData.scrollLeft - e.pageX + this.touchData.left;

                                      // check that scrolling is ended and release outer scrolling
                                      if (this.verticalScrollActive && (targetScrollTop < 0 || targetScrollTop > this.vBar.maxValue)) {
                                          verticalScrollAllowed = false;
                                      }
                                      if (this.horizontalScrollActive && (targetScrollLeft < 0 || targetScrollLeft > this.hBar.maxValue)) {
                                          horizontalScrollAllowed = false;
                                      }

                                      this.realElement.scrollTop(targetScrollTop);
                                      this.realElement.scrollLeft(targetScrollLeft);

                                      if (verticalScrollAllowed || horizontalScrollAllowed) {
                                          e.preventDefault();
                                      } else {
                                          this.onReleaseBody(e);
                                      }
                                  }
                              },
                              onReleaseBody: function(e) {
                                  if (e.pointerType === 'touch') {
                                      delete this.touchData;
                                      this.doc.off({
                                                       'jcf-pointermove': this.onMoveBody,
                                                       'jcf-pointerup': this.onReleaseBody
                                                   });
                                  }
                              },
                              onMouseWheel: function(e) {
                                  var currentScrollTop = this.realElement.scrollTop(),
                                      currentScrollLeft = this.realElement.scrollLeft(),
                                      maxScrollTop = this.realElement.prop('scrollHeight') - this.embeddedDimensions.innerHeight,
                                      maxScrollLeft = this.realElement.prop('scrollWidth') - this.embeddedDimensions.innerWidth,
                                      extraLeft, extraTop, preventFlag;

                                  // check edge cases
                                  if (!this.options.alwaysPreventMouseWheel) {
                                      if (this.verticalScrollActive && e.deltaY) {
                                          if (!(currentScrollTop <= 0 && e.deltaY < 0) && !(currentScrollTop >= maxScrollTop && e.deltaY > 0)) {
                                              preventFlag = true;
                                          }
                                      }
                                      if (this.horizontalScrollActive && e.deltaX) {
                                          if (!(currentScrollLeft <= 0 && e.deltaX < 0) && !(currentScrollLeft >= maxScrollLeft && e.deltaX > 0)) {
                                              preventFlag = true;
                                          }
                                      }
                                      if (!this.verticalScrollActive && !this.horizontalScrollActive) {
                                          return;
                                      }
                                  }

                                  // prevent default action and scroll item
                                  if (preventFlag || this.options.alwaysPreventMouseWheel) {
                                      e.preventDefault();
                                  } else {
                                      return;
                                  }

                                  extraLeft = e.deltaX / 100 * this.options.mouseWheelStep;
                                  extraTop = e.deltaY / 100 * this.options.mouseWheelStep;

                                  this.realElement.scrollTop(currentScrollTop + extraTop);
                                  this.realElement.scrollLeft(currentScrollLeft + extraLeft);
                              },
                              setScrollBarEdge: function(edgeSize) {
                                  this.vBarEdge = edgeSize || 0;
                                  this.redrawScrollbars();
                              },
                              saveElementDimensions: function() {
                                  this.savedDimensions = {
                                      top: this.realElement.width(),
                                      left: this.realElement.height()
                                  };
                                  return this;
                              },
                              restoreElementDimensions: function() {
                                  if (this.savedDimensions) {
                                      this.realElement.css({
                                                               width: this.savedDimensions.width,
                                                               height: this.savedDimensions.height
                                                           });
                                  }
                                  return this;
                              },
                              saveScrollOffsets: function() {
                                  this.savedOffsets = {
                                      top: this.realElement.scrollTop(),
                                      left: this.realElement.scrollLeft()
                                  };
                                  return this;
                              },
                              restoreScrollOffsets: function() {
                                  if (this.savedOffsets) {
                                      this.realElement.scrollTop(this.savedOffsets.top);
                                      this.realElement.scrollLeft(this.savedOffsets.left);
                                  }
                                  return this;
                              },
                              getContainerDimensions: function() {
                                  // save current styles
                                  var desiredDimensions,
                                      currentStyles,
                                      currentHeight,
                                      currentWidth;

                                  if (this.isModifiedStyles) {
                                      desiredDimensions = {
                                          width: this.realElement.innerWidth() + this.vBar.getThickness(),
                                          height: this.realElement.innerHeight() + this.hBar.getThickness()
                                      };
                                  } else {
                                      // unwrap real element and measure it according to CSS
                                      this.saveElementDimensions().saveScrollOffsets();
                                      this.realElement.insertAfter(this.scrollWrapper);
                                      this.scrollWrapper.detach();

                                      // measure element
                                      currentStyles = this.realElement.prop('style');
                                      currentWidth = parseFloat(currentStyles.width);
                                      currentHeight = parseFloat(currentStyles.height);

                                      // reset styles if needed
                                      if (this.embeddedDimensions && currentWidth && currentHeight) {
                                          this.isModifiedStyles |= (currentWidth !== this.embeddedDimensions.width || currentHeight !== this.embeddedDimensions.height);
                                          this.realElement.css({
                                                                   overflow: '',
                                                                   width: '',
                                                                   height: ''
                                                               });
                                      }

                                      // calculate desired dimensions for real element
                                      desiredDimensions = {
                                          width: this.realElement.outerWidth(),
                                          height: this.realElement.outerHeight()
                                      };

                                      // restore structure and original scroll offsets
                                      this.scrollWrapper.insertAfter(this.realElement);
                                      this.realElement.css('overflow', 'hidden').prependTo(this.scrollWrapper);
                                      this.restoreElementDimensions().restoreScrollOffsets();
                                  }

                                  return desiredDimensions;
                              },
                              getEmbeddedDimensions: function(dimensions) {
                                  // handle scrollbars cropping
                                  var fakeBarWidth = this.vBar.getThickness(),
                                      fakeBarHeight = this.hBar.getThickness(),
                                      paddingWidth = this.realElement.outerWidth() - this.realElement.width(),
                                      paddingHeight = this.realElement.outerHeight() - this.realElement.height(),
                                      resultDimensions;

                                  if (this.options.alwaysShowScrollbars) {
                                      // simply return dimensions without custom scrollbars
                                      this.verticalScrollActive = true;
                                      this.horizontalScrollActive = true;
                                      resultDimensions = {
                                          innerWidth: dimensions.width - fakeBarWidth,
                                          innerHeight: dimensions.height - fakeBarHeight
                                      };
                                  } else {
                                      // detect when to display each scrollbar
                                      this.saveElementDimensions();
                                      this.verticalScrollActive = false;
                                      this.horizontalScrollActive = false;

                                      // fill container with full size
                                      this.realElement.css({
                                                               width: dimensions.width - paddingWidth,
                                                               height: dimensions.height - paddingHeight
                                                           });

                                      this.horizontalScrollActive = this.realElement.prop('scrollWidth') > this.containerDimensions.width;
                                      this.verticalScrollActive = this.realElement.prop('scrollHeight') > this.containerDimensions.height;

                                      this.restoreElementDimensions();
                                      resultDimensions = {
                                          innerWidth: dimensions.width - (this.verticalScrollActive ? fakeBarWidth : 0),
                                          innerHeight: dimensions.height - (this.horizontalScrollActive ? fakeBarHeight : 0)
                                      };
                                  }
                                  $.extend(resultDimensions, {
                                      width: resultDimensions.innerWidth - paddingWidth,
                                      height: resultDimensions.innerHeight - paddingHeight
                                  });
                                  return resultDimensions;
                              },
                              rebuildScrollbars: function() {
                                  // resize wrapper according to real element styles
                                  this.containerDimensions = this.getContainerDimensions();
                                  this.embeddedDimensions = this.getEmbeddedDimensions(this.containerDimensions);

                                  // resize wrapper to desired dimensions
                                  this.scrollWrapper.css({
                                                             width: this.containerDimensions.width,
                                                             height: this.containerDimensions.height
                                                         });

                                  // resize element inside wrapper excluding scrollbar size
                                  this.realElement.css({
                                                           overflow: 'hidden',
                                                           width: this.embeddedDimensions.width,
                                                           height: this.embeddedDimensions.height
                                                       });

                                  // redraw scrollbar offset
                                  this.redrawScrollbars();
                              },
                              redrawScrollbars: function() {
                                  var viewSize, maxScrollValue;

                                  // redraw vertical scrollbar
                                  if (this.verticalScrollActive) {
                                      viewSize = this.vBarEdge ? this.containerDimensions.height - this.vBarEdge : this.embeddedDimensions.innerHeight;
                                      maxScrollValue = this.realElement.prop('scrollHeight') - this.vBarEdge;

                                      this.vBar.show().setMaxValue(maxScrollValue - viewSize).setRatio(viewSize / maxScrollValue).setSize(viewSize);
                                      this.vBar.setValue(this.realElement.scrollTop());
                                  } else {
                                      this.vBar.hide();
                                  }

                                  // redraw horizontal scrollbar
                                  if (this.horizontalScrollActive) {
                                      viewSize = this.embeddedDimensions.innerWidth;
                                      maxScrollValue = this.realElement.prop('scrollWidth');

                                      if (maxScrollValue === viewSize) {
                                          this.horizontalScrollActive = false;
                                      }
                                      this.hBar.show().setMaxValue(maxScrollValue - viewSize).setRatio(viewSize / maxScrollValue).setSize(viewSize);
                                      this.hBar.setValue(this.realElement.scrollLeft());
                                  } else {
                                      this.hBar.hide();
                                  }

                                  // set "touch-action" style rule
                                  var touchAction = '';
                                  if (this.verticalScrollActive && this.horizontalScrollActive) {
                                      touchAction = 'none';
                                  } else if (this.verticalScrollActive) {
                                      touchAction = 'pan-x';
                                  } else if (this.horizontalScrollActive) {
                                      touchAction = 'pan-y';
                                  }
                                  this.realElement.css('touchAction', touchAction);
                              },
                              refresh: function() {
                                  this.rebuildScrollbars();
                              },
                              destroy: function() {
                                  // remove event listeners
                                  this.win.off('resize orientationchange load', this.onResize);
                                  this.realElement.off({
                                                           'jcf-mousewheel': this.onMouseWheel,
                                                           'jcf-pointerdown': this.onTouchBody
                                                       });
                                  this.doc.off({
                                                   'jcf-pointermove': this.onMoveBody,
                                                   'jcf-pointerup': this.onReleaseBody
                                               });

                                  // restore structure
                                  this.saveScrollOffsets();
                                  this.vBar.destroy();
                                  this.hBar.destroy();
                                  this.realElement.insertAfter(this.scrollWrapper).css({
                                                                                           touchAction: '',
                                                                                           overflow: '',
                                                                                           width: '',
                                                                                           height: ''
                                                                                       });
                                  this.scrollWrapper.remove();
                                  this.restoreScrollOffsets();
                              }
                          });

            // custom scrollbar
            function ScrollBar(options) {
                this.options = $.extend({
                                            holder: null,
                                            vertical: true,
                                            inactiveClass: 'jcf-inactive',
                                            verticalClass: 'jcf-scrollbar-vertical',
                                            horizontalClass: 'jcf-scrollbar-horizontal',
                                            scrollbarStructure: '<div class="jcf-scrollbar"><div class="jcf-scrollbar-dec"></div><div class="jcf-scrollbar-slider"><div class="jcf-scrollbar-handle"></div></div><div class="jcf-scrollbar-inc"></div></div>',
                                            btnDecSelector: '.jcf-scrollbar-dec',
                                            btnIncSelector: '.jcf-scrollbar-inc',
                                            sliderSelector: '.jcf-scrollbar-slider',
                                            handleSelector: '.jcf-scrollbar-handle',
                                            scrollInterval: 300,
                                            scrollStep: 400 // px/sec
                                        }, options);
                this.init();
            }
            $.extend(ScrollBar.prototype, {
                init: function() {
                    this.initStructure();
                    this.attachEvents();
                },
                initStructure: function() {
                    // define proporties
                    this.doc = $(document);
                    this.isVertical = !!this.options.vertical;
                    this.sizeProperty = this.isVertical ? 'height' : 'width';
                    this.fullSizeProperty = this.isVertical ? 'outerHeight' : 'outerWidth';
                    this.invertedSizeProperty = this.isVertical ? 'width' : 'height';
                    this.thicknessMeasureMethod = 'outer' + this.invertedSizeProperty.charAt(0).toUpperCase() + this.invertedSizeProperty.substr(1);
                    this.offsetProperty = this.isVertical ? 'top' : 'left';
                    this.offsetEventProperty = this.isVertical ? 'pageY' : 'pageX';

                    // initialize variables
                    this.value = this.options.value || 0;
                    this.maxValue = this.options.maxValue || 0;
                    this.currentSliderSize = 0;
                    this.handleSize = 0;

                    // find elements
                    this.holder = $(this.options.holder);
                    this.scrollbar = $(this.options.scrollbarStructure).appendTo(this.holder);
                    this.btnDec = this.scrollbar.find(this.options.btnDecSelector);
                    this.btnInc = this.scrollbar.find(this.options.btnIncSelector);
                    this.slider = this.scrollbar.find(this.options.sliderSelector);
                    this.handle = this.slider.find(this.options.handleSelector);

                    // set initial styles
                    this.scrollbar.addClass(this.isVertical ? this.options.verticalClass : this.options.horizontalClass).css({
                                                                                                                                 touchAction: this.isVertical ? 'pan-x' : 'pan-y',
                                                                                                                                 position: 'absolute'
                                                                                                                             });
                    this.slider.css({
                                        position: 'relative'
                                    });
                    this.handle.css({
                                        touchAction: 'none',
                                        position: 'absolute'
                                    });
                },
                attachEvents: function() {
                    this.bindHandlers();
                    this.handle.on('jcf-pointerdown', this.onHandlePress);
                    this.slider.add(this.btnDec).add(this.btnInc).on('jcf-pointerdown', this.onButtonPress);
                },
                onHandlePress: function(e) {
                    if (e.pointerType === 'mouse' && e.button > 1) {
                        return;
                    } else {
                        e.preventDefault();
                        this.handleDragActive = true;
                        this.sliderOffset = this.slider.offset()[this.offsetProperty];
                        this.innerHandleOffset = e[this.offsetEventProperty] - this.handle.offset()[this.offsetProperty];

                        this.doc.on('jcf-pointermove', this.onHandleDrag);
                        this.doc.on('jcf-pointerup', this.onHandleRelease);
                    }
                },
                onHandleDrag: function(e) {
                    e.preventDefault();
                    this.calcOffset = e[this.offsetEventProperty] - this.sliderOffset - this.innerHandleOffset;
                    this.setValue(this.calcOffset / (this.currentSliderSize - this.handleSize) * this.maxValue);
                    this.triggerScrollEvent(this.value);
                },
                onHandleRelease: function() {
                    this.handleDragActive = false;
                    this.doc.off('jcf-pointermove', this.onHandleDrag);
                    this.doc.off('jcf-pointerup', this.onHandleRelease);
                },
                onButtonPress: function(e) {
                    var direction, clickOffset;
                    if (e.pointerType === 'mouse' && e.button > 1) {
                        return;
                    } else {
                        e.preventDefault();
                        if (!this.handleDragActive) {
                            if (this.slider.is(e.currentTarget)) {
                                // slider pressed
                                direction = this.handle.offset()[this.offsetProperty] > e[this.offsetEventProperty] ? -1 : 1;
                                clickOffset = e[this.offsetEventProperty] - this.slider.offset()[this.offsetProperty];
                                this.startPageScrolling(direction, clickOffset);
                            } else {
                                // scrollbar buttons pressed
                                direction = this.btnDec.is(e.currentTarget) ? -1 : 1;
                                this.startSmoothScrolling(direction);
                            }
                            this.doc.on('jcf-pointerup', this.onButtonRelease);
                        }
                    }
                },
                onButtonRelease: function() {
                    this.stopPageScrolling();
                    this.stopSmoothScrolling();
                    this.doc.off('jcf-pointerup', this.onButtonRelease);
                },
                startPageScrolling: function(direction, clickOffset) {
                    var self = this,
                        stepValue = direction * self.currentSize;

                    // limit checker
                    var isFinishedScrolling = function() {
                        var handleTop = (self.value / self.maxValue) * (self.currentSliderSize - self.handleSize);

                        if (direction > 0) {
                            return handleTop + self.handleSize >= clickOffset;
                        } else {
                            return handleTop <= clickOffset;
                        }
                    };

                    // scroll by page when track is pressed
                    var doPageScroll = function() {
                        self.value += stepValue;
                        self.setValue(self.value);
                        self.triggerScrollEvent(self.value);

                        if (isFinishedScrolling()) {
                            clearInterval(self.pageScrollTimer);
                        }
                    };

                    // start scrolling
                    this.pageScrollTimer = setInterval(doPageScroll, this.options.scrollInterval);
                    doPageScroll();
                },
                stopPageScrolling: function() {
                    clearInterval(this.pageScrollTimer);
                },
                startSmoothScrolling: function(direction) {
                    var self = this, dt;
                    this.stopSmoothScrolling();

                    // simple animation functions
                    var raf = window.requestAnimationFrame || function(func) {
                        setTimeout(func, 16);
                    };
                    var getTimestamp = function() {
                        return Date.now ? Date.now() : new Date().getTime();
                    };

                    // set animation limit
                    var isFinishedScrolling = function() {
                        if (direction > 0) {
                            return self.value >= self.maxValue;
                        } else {
                            return self.value <= 0;
                        }
                    };

                    // animation step
                    var doScrollAnimation = function() {
                        var stepValue = (getTimestamp() - dt) / 1000 * self.options.scrollStep;

                        if (self.smoothScrollActive) {
                            self.value += stepValue * direction;
                            self.setValue(self.value);
                            self.triggerScrollEvent(self.value);

                            if (!isFinishedScrolling()) {
                                dt = getTimestamp();
                                raf(doScrollAnimation);
                            }
                        }
                    };

                    // start animation
                    self.smoothScrollActive = true;
                    dt = getTimestamp();
                    raf(doScrollAnimation);
                },
                stopSmoothScrolling: function() {
                    this.smoothScrollActive = false;
                },
                triggerScrollEvent: function(scrollValue) {
                    if (this.options.onScroll) {
                        this.options.onScroll(scrollValue);
                    }
                },
                getThickness: function() {
                    return this.scrollbar[this.thicknessMeasureMethod]();
                },
                setSize: function(size) {
                    // resize scrollbar
                    var btnDecSize = this.btnDec[this.fullSizeProperty](),
                        btnIncSize = this.btnInc[this.fullSizeProperty]();

                    // resize slider
                    this.currentSize = size;
                    this.currentSliderSize = size - btnDecSize - btnIncSize;
                    this.scrollbar.css(this.sizeProperty, size);
                    this.slider.css(this.sizeProperty, this.currentSliderSize);
                    this.currentSliderSize = this.slider[this.sizeProperty]();

                    // resize handle
                    this.handleSize = Math.round(this.currentSliderSize * this.ratio);
                    this.handle.css(this.sizeProperty, this.handleSize);
                    this.handleSize = this.handle[this.fullSizeProperty]();

                    return this;
                },
                setRatio: function(ratio) {
                    this.ratio = ratio;
                    return this;
                },
                setMaxValue: function(maxValue) {
                    this.maxValue = maxValue;
                    this.setValue(Math.min(this.value, this.maxValue));
                    return this;
                },
                setValue: function(value) {
                    this.value = value;
                    if (this.value < 0) {
                        this.value = 0;
                    } else if (this.value > this.maxValue) {
                        this.value = this.maxValue;
                    }
                    this.refresh();
                },
                setPosition: function(styles) {
                    this.scrollbar.css(styles);
                    return this;
                },
                hide: function() {
                    this.scrollbar.detach();
                    return this;
                },
                show: function() {
                    this.scrollbar.appendTo(this.holder);
                    return this;
                },
                refresh: function() {
                    // recalculate handle position
                    if (this.value === 0 || this.maxValue === 0) {
                        this.calcOffset = 0;
                    } else {
                        this.calcOffset = (this.value / this.maxValue) * (this.currentSliderSize - this.handleSize);
                    }
                    this.handle.css(this.offsetProperty, this.calcOffset);

                    // toggle inactive classes
                    this.btnDec.toggleClass(this.options.inactiveClass, this.value === 0);
                    this.btnInc.toggleClass(this.options.inactiveClass, this.value === this.maxValue);
                    this.scrollbar.toggleClass(this.options.inactiveClass, this.maxValue === 0);
                },
                destroy: function() {
                    // remove event handlers and scrollbar block itself
                    this.btnDec.add(this.btnInc).off('jcf-pointerdown', this.onButtonPress);
                    this.handle.off('jcf-pointerdown', this.onHandlePress);
                    this.doc.off('jcf-pointermove', this.onHandleDrag);
                    this.doc.off('jcf-pointerup', this.onHandleRelease);
                    this.doc.off('jcf-pointerup', this.onButtonRelease);
                    this.stopSmoothScrolling();
                    this.stopPageScrolling();
                    this.scrollbar.remove();
                }
            });

        }(jQuery, this));

    },{}],30:[function(require,module,exports){
        /*!
 * JavaScript Custom Forms : Select Module
 *
 * Copyright 2014-2015 PSD2HTML - http://psd2html.com/jcf
 * Released under the MIT license (LICENSE.txt)
 *
 * Version: 1.1.2
 */
        ;(function($) {
            'use strict';

            jcf.addModule({
                              name: 'Select',
                              selector: 'select',
                              options: {
                                  element: null,
                                  multipleCompactStyle: false
                              },
                              plugins: {
                                  ListBox: ListBox,
                                  ComboBox: ComboBox,
                                  SelectList: SelectList
                              },
                              matchElement: function(element) {
                                  return element.is('select');
                              },
                              init: function() {
                                  this.element = $(this.options.element);
                                  this.createInstance();
                              },
                              isListBox: function() {
                                  return this.element.is('[size]:not([jcf-size]), [multiple]');
                              },
                              createInstance: function() {
                                  if (this.instance) {
                                      this.instance.destroy();
                                  }
                                  if (this.isListBox() && !this.options.multipleCompactStyle) {
                                      this.instance = new ListBox(this.options);
                                  } else {
                                      this.instance = new ComboBox(this.options);
                                  }
                              },
                              refresh: function() {
                                  var typeMismatch = (this.isListBox() && this.instance instanceof ComboBox) ||
                                                     (!this.isListBox() && this.instance instanceof ListBox);

                                  if (typeMismatch) {
                                      this.createInstance();
                                  } else {
                                      this.instance.refresh();
                                  }
                              },
                              destroy: function() {
                                  this.instance.destroy();
                              }
                          });

            // combobox module
            function ComboBox(options) {
                this.options = $.extend({
                                            wrapNative: true,
                                            wrapNativeOnMobile: true,
                                            fakeDropInBody: true,
                                            useCustomScroll: true,
                                            flipDropToFit: true,
                                            maxVisibleItems: 10,
                                            fakeAreaStructure: '<span class="jcf-select"><span class="jcf-select-text"></span><span class="jcf-select-opener"></span></span>',
                                            fakeDropStructure: '<div class="jcf-select-drop"><div class="jcf-select-drop-content"></div></div>',
                                            optionClassPrefix: 'jcf-option-',
                                            selectClassPrefix: 'jcf-select-',
                                            dropContentSelector: '.jcf-select-drop-content',
                                            selectTextSelector: '.jcf-select-text',
                                            dropActiveClass: 'jcf-drop-active',
                                            flipDropClass: 'jcf-drop-flipped'
                                        }, options);
                this.init();
            }
            $.extend(ComboBox.prototype, {
                init: function() {
                    this.initStructure();
                    this.bindHandlers();
                    this.attachEvents();
                    this.refresh();
                },
                initStructure: function() {
                    // prepare structure
                    this.win = $(window);
                    this.doc = $(document);
                    this.realElement = $(this.options.element);
                    this.fakeElement = $(this.options.fakeAreaStructure).insertAfter(this.realElement);
                    this.selectTextContainer = this.fakeElement.find(this.options.selectTextSelector);
                    this.selectText = $('<span></span>').appendTo(this.selectTextContainer);
                    makeUnselectable(this.fakeElement);

                    // copy classes from original select
                    this.fakeElement.addClass(getPrefixedClasses(this.realElement.prop('className'), this.options.selectClassPrefix));

                    // handle compact multiple style
                    if (this.realElement.prop('multiple')) {
                        this.fakeElement.addClass('jcf-compact-multiple');
                    }

                    // detect device type and dropdown behavior
                    if (this.options.isMobileDevice && this.options.wrapNativeOnMobile && !this.options.wrapNative) {
                        this.options.wrapNative = true;
                    }

                    if (this.options.wrapNative) {
                        // wrap native select inside fake block
                        this.realElement.prependTo(this.fakeElement).css({
                                                                             position: 'absolute',
                                                                             height: '100%',
                                                                             width: '100%'
                                                                         }).addClass(this.options.resetAppearanceClass);
                    } else {
                        // just hide native select
                        this.realElement.addClass(this.options.hiddenClass);
                        this.fakeElement.attr('title', this.realElement.attr('title'));
                        this.fakeDropTarget = this.options.fakeDropInBody ? $('body') : this.fakeElement;
                    }
                },
                attachEvents: function() {
                    // delayed refresh handler
                    var self = this;
                    this.delayedRefresh = function() {
                        setTimeout(function() {
                            self.refresh();
                            if (self.list) {
                                self.list.refresh();
                            }
                        }, 1);
                    };

                    // native dropdown event handlers
                    if (this.options.wrapNative) {
                        this.realElement.on({
                                                focus: this.onFocus,
                                                change: this.onChange,
                                                click: this.onChange,
                                                keydown: this.onChange
                                            });
                    } else {
                        // custom dropdown event handlers
                        this.realElement.on({
                                                focus: this.onFocus,
                                                change: this.onChange,
                                                keydown: this.onKeyDown
                                            });
                        this.fakeElement.on({
                                                'jcf-pointerdown': this.onSelectAreaPress
                                            });
                    }
                },
                onKeyDown: function(e) {
                    if (e.which === 13) {
                        this.toggleDropdown();
                    } else if (this.dropActive) {
                        this.delayedRefresh();
                    }
                },
                onChange: function() {
                    this.refresh();
                },
                onFocus: function() {
                    if (!this.pressedFlag || !this.focusedFlag) {
                        this.fakeElement.addClass(this.options.focusClass);
                        this.realElement.on('blur', this.onBlur);
                        this.toggleListMode(true);
                        this.focusedFlag = true;
                    }
                },
                onBlur: function() {
                    if (!this.pressedFlag) {
                        this.fakeElement.removeClass(this.options.focusClass);
                        this.realElement.off('blur', this.onBlur);
                        this.toggleListMode(false);
                        this.focusedFlag = false;
                    }
                },
                onResize: function() {
                    if (this.dropActive) {
                        this.hideDropdown();
                    }
                },
                onSelectDropPress: function() {
                    this.pressedFlag = true;
                },
                onSelectDropRelease: function(e, pointerEvent) {
                    this.pressedFlag = false;
                    if (pointerEvent.pointerType === 'mouse') {
                        this.realElement.focus();
                    }
                },
                onSelectAreaPress: function(e) {
                    // skip click if drop inside fake element or real select is disabled
                    var dropClickedInsideFakeElement = !this.options.fakeDropInBody && $(e.target).closest(this.dropdown).length;
                    if (dropClickedInsideFakeElement || e.button > 1 || this.realElement.is(':disabled')) {
                        return;
                    }

                    // toggle dropdown visibility
                    this.selectOpenedByEvent = e.pointerType;
                    this.toggleDropdown();

                    // misc handlers
                    if (!this.focusedFlag) {
                        if (e.pointerType === 'mouse') {
                            this.realElement.focus();
                        } else {
                            this.onFocus(e);
                        }
                    }
                    this.pressedFlag = true;
                    this.fakeElement.addClass(this.options.pressedClass);
                    this.doc.on('jcf-pointerup', this.onSelectAreaRelease);
                },
                onSelectAreaRelease: function(e) {
                    if (this.focusedFlag && e.pointerType === 'mouse') {
                        this.realElement.focus();
                    }
                    this.pressedFlag = false;
                    this.fakeElement.removeClass(this.options.pressedClass);
                    this.doc.off('jcf-pointerup', this.onSelectAreaRelease);
                },
                onOutsideClick: function(e) {
                    var target = $(e.target),
                        clickedInsideSelect = target.closest(this.fakeElement).length || target.closest(this.dropdown).length;

                    if (!clickedInsideSelect) {
                        this.hideDropdown();
                    }
                },
                onSelect: function() {
                    this.refresh();

                    if (this.realElement.prop('multiple')) {
                        this.repositionDropdown();
                    } else {
                        this.hideDropdown();
                    }

                    this.fireNativeEvent(this.realElement, 'change');
                },
                toggleListMode: function(state) {
                    if (!this.options.wrapNative) {
                        if (state) {
                            // temporary change select to list to avoid appearing of native dropdown
                            this.realElement.attr({
                                                      size: 4,
                                                      'jcf-size': ''
                                                  });
                        } else {
                            // restore select from list mode to dropdown select
                            if (!this.options.wrapNative) {
                                this.realElement.removeAttr('size jcf-size');
                            }
                        }
                    }
                },
                createDropdown: function() {
                    // destroy previous dropdown if needed
                    if (this.dropdown) {
                        this.list.destroy();
                        this.dropdown.remove();
                    }

                    // create new drop container
                    this.dropdown = $(this.options.fakeDropStructure).appendTo(this.fakeDropTarget);
                    this.dropdown.addClass(getPrefixedClasses(this.realElement.prop('className'), this.options.selectClassPrefix));
                    makeUnselectable(this.dropdown);

                    // handle compact multiple style
                    if (this.realElement.prop('multiple')) {
                        this.dropdown.addClass('jcf-compact-multiple');
                    }

                    // set initial styles for dropdown in body
                    if (this.options.fakeDropInBody) {
                        this.dropdown.css({
                                              position: 'absolute',
                                              top: -9999
                                          });
                    }

                    // create new select list instance
                    this.list = new SelectList({
                                                   useHoverClass: true,
                                                   handleResize: false,
                                                   alwaysPreventMouseWheel: true,
                                                   maxVisibleItems: this.options.maxVisibleItems,
                                                   useCustomScroll: this.options.useCustomScroll,
                                                   holder: this.dropdown.find(this.options.dropContentSelector),
                                                   multipleSelectWithoutKey: this.realElement.prop('multiple'),
                                                   element: this.realElement
                                               });
                    $(this.list).on({
                                        select: this.onSelect,
                                        press: this.onSelectDropPress,
                                        release: this.onSelectDropRelease
                                    });
                },
                repositionDropdown: function() {
                    var selectOffset = this.fakeElement.offset(),
                        selectWidth = this.fakeElement.outerWidth(),
                        selectHeight = this.fakeElement.outerHeight(),
                        dropHeight = this.dropdown.css('width', selectWidth).outerHeight(),
                        winScrollTop = this.win.scrollTop(),
                        winHeight = this.win.height(),
                        calcTop, calcLeft, bodyOffset, needFlipDrop = false;

                    // check flip drop position
                    if (selectOffset.top + selectHeight + dropHeight > winScrollTop + winHeight && selectOffset.top - dropHeight > winScrollTop) {
                        needFlipDrop = true;
                    }

                    if (this.options.fakeDropInBody) {
                        bodyOffset = this.fakeDropTarget.css('position') !== 'static' ? this.fakeDropTarget.offset().top : 0;
                        if (this.options.flipDropToFit && needFlipDrop) {
                            // calculate flipped dropdown position
                            calcLeft = selectOffset.left;
                            calcTop = selectOffset.top - dropHeight - bodyOffset;
                        } else {
                            // calculate default drop position
                            calcLeft = selectOffset.left;
                            calcTop = selectOffset.top + selectHeight - bodyOffset;
                        }

                        // update drop styles
                        this.dropdown.css({
                                              width: selectWidth,
                                              left: calcLeft,
                                              top: calcTop
                                          });
                    }

                    // refresh flipped class
                    this.dropdown.add(this.fakeElement).toggleClass(this.options.flipDropClass, this.options.flipDropToFit && needFlipDrop);
                },
                showDropdown: function() {
                    // do not show empty custom dropdown
                    if (!this.realElement.prop('options').length) {
                        return;
                    }

                    // create options list if not created
                    if (!this.dropdown) {
                        this.createDropdown();
                    }

                    // show dropdown
                    this.dropActive = true;
                    this.dropdown.appendTo(this.fakeDropTarget);
                    this.fakeElement.addClass(this.options.dropActiveClass);
                    this.refreshSelectedText();
                    this.repositionDropdown();
                    this.list.setScrollTop(this.savedScrollTop);
                    this.list.refresh();

                    // add temporary event handlers
                    this.win.on('resize', this.onResize);
                    this.doc.on('jcf-pointerdown', this.onOutsideClick);
                },
                hideDropdown: function() {
                    if (this.dropdown) {
                        this.savedScrollTop = this.list.getScrollTop();
                        this.fakeElement.removeClass(this.options.dropActiveClass + ' ' + this.options.flipDropClass);
                        this.dropdown.removeClass(this.options.flipDropClass).detach();
                        this.doc.off('jcf-pointerdown', this.onOutsideClick);
                        this.win.off('resize', this.onResize);
                        this.dropActive = false;
                        if (this.selectOpenedByEvent === 'touch') {
                            this.onBlur();
                        }
                    }
                },
                toggleDropdown: function() {
                    if (this.dropActive) {
                        this.hideDropdown();
                    } else {
                        this.showDropdown();
                    }
                },
                refreshSelectedText: function() {
                    // redraw selected area
                    var selectedIndex = this.realElement.prop('selectedIndex'),
                        selectedOption = this.realElement.prop('options')[selectedIndex],
                        selectedOptionImage = selectedOption ? selectedOption.getAttribute('data-image') : null,
                        selectedOptionText = '',
                        selectedOptionClasses;

                    if (this.realElement.prop('multiple')) {
                        $.each(this.realElement.prop('options'), function(index, option) {
                            if (option.selected) {
                                selectedOptionText += (selectedOptionText ? ', ' : '') + option.innerHTML;
                            }
                        });
                        this.selectText.removeAttr('class').html(selectedOptionText);
                    } else if (!selectedOption) {
                        if (this.selectImage) {
                            this.selectImage.hide();
                        }
                        this.selectText.removeAttr('class').empty();
                    } else if (this.currentSelectedText !== selectedOption.innerHTML || this.currentSelectedImage !== selectedOptionImage) {
                        selectedOptionClasses = getPrefixedClasses(selectedOption.className, this.options.optionClassPrefix);
                        this.selectText.attr('class', selectedOptionClasses).html(selectedOption.innerHTML);

                        if (selectedOptionImage) {
                            if (!this.selectImage) {
                                this.selectImage = $('<img>').prependTo(this.selectTextContainer).hide();
                            }
                            this.selectImage.attr('src', selectedOptionImage).show();
                        } else if (this.selectImage) {
                            this.selectImage.hide();
                        }

                        this.currentSelectedText = selectedOption.innerHTML;
                        this.currentSelectedImage = selectedOptionImage;
                    }
                },
                refresh: function() {
                    // refresh fake select visibility
                    if (this.realElement.prop('style').display === 'none') {
                        this.fakeElement.hide();
                    } else {
                        this.fakeElement.show();
                    }

                    // refresh selected text
                    this.refreshSelectedText();

                    // handle disabled state
                    this.fakeElement.toggleClass(this.options.disabledClass, this.realElement.is(':disabled'));
                },
                destroy: function() {
                    // restore structure
                    if (this.options.wrapNative) {
                        this.realElement.insertBefore(this.fakeElement).css({
                                                                                position: '',
                                                                                height: '',
                                                                                width: ''
                                                                            }).removeClass(this.options.resetAppearanceClass);
                    } else {
                        this.realElement.removeClass(this.options.hiddenClass);
                        if (this.realElement.is('[jcf-size]')) {
                            this.realElement.removeAttr('size jcf-size');
                        }
                    }

                    // removing element will also remove its event handlers
                    this.fakeElement.remove();

                    // remove other event handlers
                    this.doc.off('jcf-pointerup', this.onSelectAreaRelease);
                    this.realElement.off({
                                             focus: this.onFocus
                                         });
                }
            });

            // listbox module
            function ListBox(options) {
                this.options = $.extend({
                                            wrapNative: true,
                                            useCustomScroll: true,
                                            fakeStructure: '<span class="jcf-list-box"><span class="jcf-list-wrapper"></span></span>',
                                            selectClassPrefix: 'jcf-select-',
                                            listHolder: '.jcf-list-wrapper'
                                        }, options);
                this.init();
            }
            $.extend(ListBox.prototype, {
                init: function() {
                    this.bindHandlers();
                    this.initStructure();
                    this.attachEvents();
                },
                initStructure: function() {
                    this.realElement = $(this.options.element);
                    this.fakeElement = $(this.options.fakeStructure).insertAfter(this.realElement);
                    this.listHolder = this.fakeElement.find(this.options.listHolder);
                    makeUnselectable(this.fakeElement);

                    // copy classes from original select
                    this.fakeElement.addClass(getPrefixedClasses(this.realElement.prop('className'), this.options.selectClassPrefix));
                    this.realElement.addClass(this.options.hiddenClass);

                    this.list = new SelectList({
                                                   useCustomScroll: this.options.useCustomScroll,
                                                   holder: this.listHolder,
                                                   selectOnClick: false,
                                                   element: this.realElement
                                               });
                },
                attachEvents: function() {
                    // delayed refresh handler
                    var self = this;
                    this.delayedRefresh = function(e) {
                        if (e && e.which === 16) {
                            // ignore SHIFT key
                            return;
                        } else {
                            clearTimeout(self.refreshTimer);
                            self.refreshTimer = setTimeout(function() {
                                self.refresh();
                            }, 1);
                        }
                    };

                    // other event handlers
                    this.realElement.on({
                                            focus: this.onFocus,
                                            click: this.delayedRefresh,
                                            keydown: this.delayedRefresh
                                        });

                    // select list event handlers
                    $(this.list).on({
                                        select: this.onSelect,
                                        press: this.onFakeOptionsPress,
                                        release: this.onFakeOptionsRelease
                                    });
                },
                onFakeOptionsPress: function(e, pointerEvent) {
                    this.pressedFlag = true;
                    if (pointerEvent.pointerType === 'mouse') {
                        this.realElement.focus();
                    }
                },
                onFakeOptionsRelease: function(e, pointerEvent) {
                    this.pressedFlag = false;
                    if (pointerEvent.pointerType === 'mouse') {
                        this.realElement.focus();
                    }
                },
                onSelect: function() {
                    this.fireNativeEvent(this.realElement, 'change');
                    this.fireNativeEvent(this.realElement, 'click');
                },
                onFocus: function() {
                    if (!this.pressedFlag || !this.focusedFlag) {
                        this.fakeElement.addClass(this.options.focusClass);
                        this.realElement.on('blur', this.onBlur);
                        this.focusedFlag = true;
                    }
                },
                onBlur: function() {
                    if (!this.pressedFlag) {
                        this.fakeElement.removeClass(this.options.focusClass);
                        this.realElement.off('blur', this.onBlur);
                        this.focusedFlag = false;
                    }
                },
                refresh: function() {
                    this.fakeElement.toggleClass(this.options.disabledClass, this.realElement.is(':disabled'));
                    this.list.refresh();
                },
                destroy: function() {
                    this.list.destroy();
                    this.realElement.insertBefore(this.fakeElement).removeClass(this.options.hiddenClass);
                    this.fakeElement.remove();
                }
            });

            // options list module
            function SelectList(options) {
                this.options = $.extend({
                                            holder: null,
                                            maxVisibleItems: 10,
                                            selectOnClick: true,
                                            useHoverClass: false,
                                            useCustomScroll: false,
                                            handleResize: true,
                                            multipleSelectWithoutKey: false,
                                            alwaysPreventMouseWheel: false,
                                            indexAttribute: 'data-index',
                                            cloneClassPrefix: 'jcf-option-',
                                            containerStructure: '<span class="jcf-list"><span class="jcf-list-content"></span></span>',
                                            containerSelector: '.jcf-list-content',
                                            captionClass: 'jcf-optgroup-caption',
                                            disabledClass: 'jcf-disabled',
                                            optionClass: 'jcf-option',
                                            groupClass: 'jcf-optgroup',
                                            hoverClass: 'jcf-hover',
                                            selectedClass: 'jcf-selected',
                                            scrollClass: 'jcf-scroll-active'
                                        }, options);
                this.init();
            }
            $.extend(SelectList.prototype, {
                init: function() {
                    this.initStructure();
                    this.refreshSelectedClass();
                    this.attachEvents();
                },
                initStructure: function() {
                    this.element = $(this.options.element);
                    this.indexSelector = '[' + this.options.indexAttribute + ']';
                    this.container = $(this.options.containerStructure).appendTo(this.options.holder);
                    this.listHolder = this.container.find(this.options.containerSelector);
                    this.lastClickedIndex = this.element.prop('selectedIndex');
                    this.rebuildList();
                },
                attachEvents: function() {
                    this.bindHandlers();
                    this.listHolder.on('jcf-pointerdown', this.indexSelector, this.onItemPress);
                    this.listHolder.on('jcf-pointerdown', this.onPress);

                    if (this.options.useHoverClass) {
                        this.listHolder.on('jcf-pointerover', this.indexSelector, this.onHoverItem);
                    }
                },
                onPress: function(e) {
                    $(this).trigger('press', e);
                    this.listHolder.on('jcf-pointerup', this.onRelease);
                },
                onRelease: function(e) {
                    $(this).trigger('release', e);
                    this.listHolder.off('jcf-pointerup', this.onRelease);
                },
                onHoverItem: function(e) {
                    var hoverIndex = parseFloat(e.currentTarget.getAttribute(this.options.indexAttribute));
                    this.fakeOptions.removeClass(this.options.hoverClass).eq(hoverIndex).addClass(this.options.hoverClass);
                },
                onItemPress: function(e) {
                    if (e.pointerType === 'touch' || this.options.selectOnClick) {
                        // select option after "click"
                        this.tmpListOffsetTop = this.list.offset().top;
                        this.listHolder.on('jcf-pointerup', this.indexSelector, this.onItemRelease);
                    } else {
                        // select option immediately
                        this.onSelectItem(e);
                    }
                },
                onItemRelease: function(e) {
                    // remove event handlers and temporary data
                    this.listHolder.off('jcf-pointerup', this.indexSelector, this.onItemRelease);

                    // simulate item selection
                    if (this.tmpListOffsetTop === this.list.offset().top) {
                        this.listHolder.on('click', this.indexSelector, { savedPointerType: e.pointerType }, this.onSelectItem);
                    }
                    delete this.tmpListOffsetTop;
                },
                onSelectItem: function(e) {
                    var clickedIndex = parseFloat(e.currentTarget.getAttribute(this.options.indexAttribute)),
                        pointerType = e.data && e.data.savedPointerType || e.pointerType || 'mouse',
                        range;

                    // remove click event handler
                    this.listHolder.off('click', this.indexSelector, this.onSelectItem);

                    // ignore clicks on disabled options
                    if (e.button > 1 || this.realOptions[clickedIndex].disabled) {
                        return;
                    }

                    if (this.element.prop('multiple')) {
                        if (e.metaKey || e.ctrlKey || pointerType === 'touch' || this.options.multipleSelectWithoutKey) {
                            // if CTRL/CMD pressed or touch devices - toggle selected option
                            this.realOptions[clickedIndex].selected = !this.realOptions[clickedIndex].selected;
                        } else if (e.shiftKey) {
                            // if SHIFT pressed - update selection
                            range = [this.lastClickedIndex, clickedIndex].sort(function(a, b) {
                                return a - b;
                            });
                            this.realOptions.each(function(index, option) {
                                option.selected = (index >= range[0] && index <= range[1]);
                            });
                        } else {
                            // set single selected index
                            this.element.prop('selectedIndex', clickedIndex);
                        }
                    } else {
                        this.element.prop('selectedIndex', clickedIndex);
                    }

                    // save last clicked option
                    if (!e.shiftKey) {
                        this.lastClickedIndex = clickedIndex;
                    }

                    // refresh classes
                    this.refreshSelectedClass();

                    // scroll to active item in desktop browsers
                    if (pointerType === 'mouse') {
                        this.scrollToActiveOption();
                    }

                    // make callback when item selected
                    $(this).trigger('select');
                },
                rebuildList: function() {
                    // rebuild options
                    var self = this,
                        rootElement = this.element[0];

                    // recursively create fake options
                    this.storedSelectHTML = rootElement.innerHTML;
                    this.optionIndex = 0;
                    this.list = $(this.createOptionsList(rootElement));
                    this.listHolder.empty().append(this.list);
                    this.realOptions = this.element.find('option');
                    this.fakeOptions = this.list.find(this.indexSelector);
                    this.fakeListItems = this.list.find('.' + this.options.captionClass + ',' + this.indexSelector);
                    delete this.optionIndex;

                    // detect max visible items
                    var maxCount = this.options.maxVisibleItems,
                        sizeValue = this.element.prop('size');
                    if (sizeValue > 1 && !this.element.is('[jcf-size]')) {
                        maxCount = sizeValue;
                    }

                    // handle scrollbar
                    var needScrollBar = this.fakeOptions.length > maxCount;
                    this.container.toggleClass(this.options.scrollClass, needScrollBar);
                    if (needScrollBar) {
                        // change max-height
                        this.listHolder.css({
                                                maxHeight: this.getOverflowHeight(maxCount),
                                                overflow: 'auto'
                                            });

                        if (this.options.useCustomScroll && jcf.modules.Scrollable) {
                            // add custom scrollbar if specified in options
                            jcf.replace(this.listHolder, 'Scrollable', {
                                handleResize: this.options.handleResize,
                                alwaysPreventMouseWheel: this.options.alwaysPreventMouseWheel
                            });
                            return;
                        }
                    }

                    // disable edge wheel scrolling
                    if (this.options.alwaysPreventMouseWheel) {
                        this.preventWheelHandler = function(e) {
                            var currentScrollTop = self.listHolder.scrollTop(),
                                maxScrollTop = self.listHolder.prop('scrollHeight') - self.listHolder.innerHeight();

                            // check edge cases
                            if ((currentScrollTop <= 0 && e.deltaY < 0) || (currentScrollTop >= maxScrollTop && e.deltaY > 0)) {
                                e.preventDefault();
                            }
                        };
                        this.listHolder.on('jcf-mousewheel', this.preventWheelHandler);
                    }
                },
                refreshSelectedClass: function() {
                    var self = this,
                        selectedItem,
                        isMultiple = this.element.prop('multiple'),
                        selectedIndex = this.element.prop('selectedIndex');

                    if (isMultiple) {
                        this.realOptions.each(function(index, option) {
                            self.fakeOptions.eq(index).toggleClass(self.options.selectedClass, !!option.selected);
                        });
                    } else {
                        this.fakeOptions.removeClass(this.options.selectedClass + ' ' + this.options.hoverClass);
                        selectedItem = this.fakeOptions.eq(selectedIndex).addClass(this.options.selectedClass);
                        if (this.options.useHoverClass) {
                            selectedItem.addClass(this.options.hoverClass);
                        }
                    }
                },
                scrollToActiveOption: function() {
                    // scroll to target option
                    var targetOffset = this.getActiveOptionOffset();
                    this.listHolder.prop('scrollTop', targetOffset);
                },
                getSelectedIndexRange: function() {
                    var firstSelected = -1, lastSelected = -1;
                    this.realOptions.each(function(index, option) {
                        if (option.selected) {
                            if (firstSelected < 0) {
                                firstSelected = index;
                            }
                            lastSelected = index;
                        }
                    });
                    return [firstSelected, lastSelected];
                },
                getChangedSelectedIndex: function() {
                    var selectedIndex = this.element.prop('selectedIndex'),
                        targetIndex;

                    if (this.element.prop('multiple')) {
                        // multiple selects handling
                        if (!this.previousRange) {
                            this.previousRange = [selectedIndex, selectedIndex];
                        }
                        this.currentRange = this.getSelectedIndexRange();
                        targetIndex = this.currentRange[this.currentRange[0] !== this.previousRange[0] ? 0 : 1];
                        this.previousRange = this.currentRange;
                        return targetIndex;
                    } else {
                        // single choice selects handling
                        return selectedIndex;
                    }
                },
                getActiveOptionOffset: function() {
                    // calc values
                    var dropHeight = this.listHolder.height(),
                        dropScrollTop = this.listHolder.prop('scrollTop'),
                        currentIndex = this.getChangedSelectedIndex(),
                        fakeOption = this.fakeOptions.eq(currentIndex),
                        fakeOptionOffset = fakeOption.offset().top - this.list.offset().top,
                        fakeOptionHeight = fakeOption.innerHeight();

                    // scroll list
                    if (fakeOptionOffset + fakeOptionHeight >= dropScrollTop + dropHeight) {
                        // scroll down (always scroll to option)
                        return fakeOptionOffset - dropHeight + fakeOptionHeight;
                    } else if (fakeOptionOffset < dropScrollTop) {
                        // scroll up to option
                        return fakeOptionOffset;
                    }
                },
                getOverflowHeight: function(sizeValue) {
                    var item = this.fakeListItems.eq(sizeValue - 1),
                        listOffset = this.list.offset().top,
                        itemOffset = item.offset().top,
                        itemHeight = item.innerHeight();

                    return itemOffset + itemHeight - listOffset;
                },
                getScrollTop: function() {
                    return this.listHolder.scrollTop();
                },
                setScrollTop: function(value) {
                    this.listHolder.scrollTop(value);
                },
                createOption: function(option) {
                    var newOption = document.createElement('span');
                    newOption.className = this.options.optionClass;
                    newOption.innerHTML = option.innerHTML;
                    newOption.setAttribute(this.options.indexAttribute, this.optionIndex++);

                    var optionImage, optionImageSrc = option.getAttribute('data-image');
                    if (optionImageSrc) {
                        optionImage = document.createElement('img');
                        optionImage.src = optionImageSrc;
                        newOption.insertBefore(optionImage, newOption.childNodes[0]);
                    }
                    if (option.disabled) {
                        newOption.className += ' ' + this.options.disabledClass;
                    }
                    if (option.className) {
                        newOption.className += ' ' + getPrefixedClasses(option.className, this.options.cloneClassPrefix);
                    }
                    return newOption;
                },
                createOptGroup: function(optgroup) {
                    var optGroupContainer = document.createElement('span'),
                        optGroupName = optgroup.getAttribute('label'),
                        optGroupCaption, optGroupList;

                    // create caption
                    optGroupCaption = document.createElement('span');
                    optGroupCaption.className = this.options.captionClass;
                    optGroupCaption.innerHTML = optGroupName;
                    optGroupContainer.appendChild(optGroupCaption);

                    // create list of options
                    if (optgroup.children.length) {
                        optGroupList = this.createOptionsList(optgroup);
                        optGroupContainer.appendChild(optGroupList);
                    }

                    optGroupContainer.className = this.options.groupClass;
                    return optGroupContainer;
                },
                createOptionContainer: function() {
                    var optionContainer = document.createElement('li');
                    return optionContainer;
                },
                createOptionsList: function(container) {
                    var self = this,
                        list = document.createElement('ul');

                    $.each(container.children, function(index, currentNode) {
                        var item = self.createOptionContainer(currentNode),
                            newNode;

                        switch (currentNode.tagName.toLowerCase()) {
                            case 'option': newNode = self.createOption(currentNode); break;
                            case 'optgroup': newNode = self.createOptGroup(currentNode); break;
                        }
                        list.appendChild(item).appendChild(newNode);
                    });
                    return list;
                },
                refresh: function() {
                    // check for select innerHTML changes
                    if (this.storedSelectHTML !== this.element.prop('innerHTML')) {
                        this.rebuildList();
                    }

                    // refresh custom scrollbar
                    var scrollInstance = jcf.getInstance(this.listHolder);
                    if (scrollInstance) {
                        scrollInstance.refresh();
                    }

                    // refresh selectes classes
                    this.refreshSelectedClass();
                },
                destroy: function() {
                    this.listHolder.off('jcf-mousewheel', this.preventWheelHandler);
                    this.listHolder.off('jcf-pointerdown', this.indexSelector, this.onSelectItem);
                    this.listHolder.off('jcf-pointerover', this.indexSelector, this.onHoverItem);
                    this.listHolder.off('jcf-pointerdown', this.onPress);
                }
            });

            // helper functions
            var getPrefixedClasses = function(className, prefixToAdd) {
                return className ? className.replace(/[\s]*([\S]+)+[\s]*/gi, prefixToAdd + '$1 ') : '';
            };
            var makeUnselectable = (function() {
                var unselectableClass = jcf.getOptions().unselectableClass;
                function preventHandler(e) {
                    e.preventDefault();
                }
                return function(node) {
                    node.addClass(unselectableClass).on('selectstart', preventHandler);
                };
            }());

        }(jQuery, this));

    },{}],31:[function(require,module,exports){
        /*!
 * JavaScript Custom Forms : Textarea Module
 *
 * Copyright 2014-2015 PSD2HTML - http://psd2html.com/jcf
 * Released under the MIT license (LICENSE.txt)
 *
 * Version: 1.1.2
 */
        ;(function($) {
            'use strict';

            jcf.addModule({
                              name: 'Textarea',
                              selector: 'textarea',
                              options: {
                                  resize: true,
                                  resizerStructure: '<span class="jcf-resize"></span>',
                                  fakeStructure: '<span class="jcf-textarea"></span>'
                              },
                              matchElement: function(element) {
                                  return element.is('textarea');
                              },
                              init: function() {
                                  this.initStructure();
                                  this.attachEvents();
                                  this.refresh();
                              },
                              initStructure: function() {
                                  // prepare structure
                                  this.doc = $(document);
                                  this.realElement = $(this.options.element);
                                  this.fakeElement = $(this.options.fakeStructure).insertAfter(this.realElement);
                                  this.resizer = $(this.options.resizerStructure).appendTo(this.fakeElement);

                                  // add custom scrollbar
                                  if (jcf.modules.Scrollable) {
                                      this.realElement.prependTo(this.fakeElement).addClass().css({
                                                                                                      overflow: 'hidden',
                                                                                                      resize: 'none'
                                                                                                  });

                                      this.scrollable = new jcf.modules.Scrollable({
                                                                                       element: this.realElement,
                                                                                       alwaysShowScrollbars: true
                                                                                   });
                                      this.scrollable.setScrollBarEdge(this.resizer.outerHeight());
                                  }
                              },
                              attachEvents: function() {
                                  // add event handlers
                                  this.realElement.on({
                                                          focus: this.onFocus,
                                                          keyup: this.onChange,
                                                          change: this.onChange
                                                      });

                                  this.resizer.on('jcf-pointerdown', this.onResizePress);
                              },
                              onResizePress: function(e) {
                                  var resizerOffset = this.resizer.offset(),
                                      areaOffset = this.fakeElement.offset();

                                  e.preventDefault();
                                  this.dragData = {
                                      areaOffset: areaOffset,
                                      innerOffsetLeft: e.pageX - resizerOffset.left,
                                      innerOffsetTop: e.pageY - resizerOffset.top
                                  };
                                  this.doc.on({
                                                  'jcf-pointermove': this.onResizeMove,
                                                  'jcf-pointerup': this.onResizeRelease
                                              });

                                  // restore focus
                                  if (this.isFocused) {
                                      this.focusedDrag = true;
                                      this.realElement.focus();
                                  }
                              },
                              onResizeMove: function(e) {
                                  var newWidth = e.pageX + this.dragData.innerOffsetLeft - this.dragData.areaOffset.left,
                                      newHeight = e.pageY + this.dragData.innerOffsetTop - this.dragData.areaOffset.top,
                                      widthDiff = this.fakeElement.innerWidth() - this.realElement.innerWidth();

                                  // prevent text selection or page scroll on touch devices
                                  e.preventDefault();

                                  // resize textarea and refresh scrollbars
                                  this.realElement.innerWidth(newWidth - widthDiff).innerHeight(newHeight);
                                  this.scrollable.rebuildScrollbars();

                                  // restore focus
                                  if (this.focusedDrag) {
                                      this.realElement.focus();
                                  }
                              },
                              onResizeRelease: function() {
                                  this.doc.off({
                                                   'jcf-pointermove': this.onResizeMove,
                                                   'jcf-pointerup': this.onResizeRelease
                                               });

                                  delete this.focusedDrag;
                              },
                              onFocus: function() {
                                  this.isFocused = true;
                                  this.fakeElement.addClass(this.options.focusClass);
                                  this.realElement.on('blur', this.onBlur);
                              },
                              onBlur: function() {
                                  this.isFocused = false;
                                  this.fakeElement.removeClass(this.options.focusClass);
                                  this.realElement.off('blur', this.onBlur);
                              },
                              onChange: function() {
                                  this.refreshCustomScrollbars();
                              },
                              refreshCustomScrollbars: function() {
                                  if (this.isFocused) {
                                      this.scrollable.redrawScrollbars();
                                  } else {
                                      this.scrollable.rebuildScrollbars();
                                  }
                              },
                              refresh: function() {
                                  // refresh custom scroll position
                                  var isDisabled = this.realElement.is(':disabled');
                                  this.fakeElement.toggleClass(this.options.disabledClass, isDisabled);
                                  this.refreshCustomScrollbars();
                              },
                              destroy: function() {
                                  // destroy custom scrollbar
                                  this.scrollable.destroy();

                                  // restore styles and remove event listeners
                                  this.realElement.css({
                                                           overflow: '',
                                                           resize: ''
                                                       }).insertBefore(this.fakeElement).off({
                                                                                                 focus: this.onFocus,
                                                                                                 blur: this.onBlur
                                                                                             });

                                  // remove scrollbar and fake wrapper
                                  this.fakeElement.remove();
                              }
                          });

        }(jQuery));

    },{}],32:[function(require,module,exports){
        function PublicationScroll(container) {
            this.self = this;
            this.container = container;
            this.body = jQuery('body');
            this.window = jQuery(window);
            this.toggledContent = this.container.siblings('.toggled-content');
            this.containerInitialOffset = this.container.offset().top;

            this.window.on('scroll', this.scrollInfo.bind(this));
        }

        PublicationScroll.prototype.scrollInfo = function() {
            var windowWidth = jQuery(window).width();
            var bodyClasses = document.body.classList;
            var arrayBodyClasses = Array.prototype.slice.call(bodyClasses);

            if (windowWidth >= 960) {
                if (arrayBodyClasses.indexOf('ipad') === -1) {
                    this.container.stick_in_parent();
                } else if (arrayBodyClasses.indexOf('ipad') !== -1 && arrayBodyClasses.indexOf('viewport-landscape') === -1) {
                    this.container.stick_in_parent()
                }
            }
        }

        jQuery.fn.publicationScroll = function() {
            return jQuery(this).each(function() {
                new PublicationScroll(jQuery(this));
            });
        };

        module.exports = {
            PublicationScroll: PublicationScroll
        };
    },{}],33:[function(require,module,exports){
        function RelatedBox(element) {
            this.element = element;
            this.query = this.element.data('query');
            this.searchbox = jQuery('.searchbox .search');

            this.element.on('click', this.onClick.bind(this));
        }

        RelatedBox.prototype.onClick = function(event) {
            event.preventDefault();
            this.searchbox.val(this.query).trigger('keyup');
        };

        jQuery.fn.relatedSearchBox = function() {
            return jQuery(this).each(function() {
                new RelatedBox(jQuery(this));
            });
        };

        module.exports = RelatedBox;

    },{}],34:[function(require,module,exports){
        var viewport = require('../utils/viewport');

        function SearchFilters(filter) {
            this.filter = filter;
            this.filters = this.filter.find('input,select');
            this.filterList = this.filter.find('ul');
            this.searchForm = this.filter.closest('form.ajax');
            this.showFilter = true;
            if (this.filter.hasClass('hidden-at-start') == true) {
                this.filter.hide();
                this.showFilter = false;
            }

            this.filters.on('change', this.sendSearchForm.bind(this));

            this.onSpecialKeywordUsed = this.onSpecialKeywordUsed.bind(this);
            this.onSpecialKeywordRemoved = this.onSpecialKeywordRemoved.bind(this);
            this.onSendSearchFormReset = this.onSendSearchFormReset.bind(this);
            this.searchForm.on('special-keyword-used', this.onSpecialKeywordUsed);
            this.searchForm.on('special-keyword-removed', this.onSpecialKeywordRemoved);
            this.searchForm.on('send-search-form-reset', this.onSendSearchFormReset);

            this.generateMobileView();
        }

        SearchFilters.prototype.sendSearchForm = function() {
            this.searchForm.trigger('filter-send');

            var searchResult = this.searchForm.siblings('.search-result-section').first();
            if (searchResult.find('.loading-indicator').length === 0) {
                searchResult.append('<div class="loading-indicator"/>');
            }
            this.searchForm.submit();
        };

        SearchFilters.prototype.onSpecialKeywordUsed = function() {
            this.hideFilters();
        };

        SearchFilters.prototype.onSpecialKeywordRemoved = function() {
            this.showFilters();
        };

        SearchFilters.prototype.onSendSearchFormReset = function() {
            this.resetFilters();
            this.sendSearchForm();
        };


        SearchFilters.prototype.hideFilters = function() {
            if (this.showFilter) {
                this.filter.animate({
                                        'opacity': 0
                                    }, 250, function() {
                    jQuery(this).slideUp(function() {
                        jQuery(this).addClass('hidden');
                    });
                });
                this.showFilter = false;
                this.resetFilters();
            }
        };

        SearchFilters.prototype.showFilters = function() {
            if (!this.showFilter) {
                this.filter.removeClass('hidden').slideDown(function() {
                    jQuery(this).animate({
                                             'opacity': 1
                                         }, 250);
                });
                this.showFilter = true;
                this.filter.removeClass('hidden-at-start');
            }
        };

        SearchFilters.prototype.resetFilters = function() {
            this.filterList.each(function() {
                jQuery(this).find('input').each(function(key) {
                    if (key === 0) {
                        jQuery(this).prop('checked', 'checked');
                    }
                });
            });
            jQuery(this.filter).find('select').each(function() {
                jQuery(this).find('option').first().prop('selected', 'selected');
                jcf.refresh(jQuery(this));
            });
        };

        SearchFilters.prototype.generateMobileView = function() {
            var self = this;

            this.filterList.each(function() {
                var list = jQuery(this);
                var description = list.find('input:checked + label').html();

                list.before('<a href="#" class="toggle-filter jcf-select jcf-select-secondary"><span class="jcf-select-text"><span>' + description + '</span></span><span class="jcf-select-opener" /></a>');

                list.siblings('a.toggle-filter').click(function(event) {
                    event.preventDefault();
                    jQuery(this).toggleClass('active');
                    list.slideToggle();
                });
                jQuery('body').click(function(event) {
                    if (viewport <= 1024) {
                        if(!jQuery.contains(list.siblings('a.toggle-filter')[0], event.target)) {
                            list.slideUp().siblings('a.toggle-filter').removeClass('active');
                        }
                    }
                });
                list.find('input').click(function() {

                    if (viewport.width() <= 1024) {
                        var element = jQuery(this);
                        var currentList = element.closest('ul');
                        if (element.attr('value') !== undefined) {
                            list.siblings('a.toggle-filter').find('.jcf-select-text').html(element.siblings('label').html());
                        }
                        currentList.slideUp();
                        currentList.siblings('a.toggle-filter').removeClass('active');
                    }
                });
            });
        };

        jQuery.fn.searchFilters = function() {
            return jQuery(this).each(function() {
                new SearchFilters(jQuery(this));
            });
        };

        module.exports = SearchFilters;

    },{"../utils/viewport":16}],35:[function(require,module,exports){
        function Searchbox(search) {
            var self = this;
            this.search = search;
            this.searchbox = this.search.parent();
            this.searchForm = this.search.closest('form.ajax');

            this.delay = 500;
            this.keyToSend = 0;
            if (typeof this.search.attr('data-delay') !== 'undefined') {
                this.delay = this.search.data('delay');
            }
            if (typeof this.search.attr('data-max-chars') !== 'undefined') {
                this.keyToSend = this.search.data('max-chars');
            }

            this.now = new Date();
            this.send = false;
            this.lastExecution = this.now.getTime();
            this.timer = null;
            this.keyEntered = 0;
            this.hints = null;
            this.showHints = true;
            this.specialKeyword = false;
            this.specialKeywords = [];

            this.getSpecialKeywords();
            this.generateHintHTML();
            this.getHints();

            this.onSearchKeyUp = this.onSearchKeyUp.bind(this);
            this.onSearchKeyDown = this.onSearchKeyDown.bind(this);

            this.search.on('keyup', this.onSearchKeyUp);
            this.search.on('blur', function() {
                self.addMainKeyword();
                setTimeout(function() {
                    self.hideKeywords();
                }, 150);
                self.activeButton();
            });
            this.search.on('focus', function() {
                self.removeMainKeyword();
                self.showKeywords();
                self.activeButton(true);
            });

            this.searchForm.on('filter-send', function() {
                self.showHints = false;
            });
        }

        Searchbox.prototype.activeButton = function(active) {
            var searchButton = jQuery('.search.button');

            if (this.search.val() || active === true) {
                searchButton.addClass('active');
            } else {
                searchButton.removeClass('active');
            }
        };

        Searchbox.prototype.getSpecialKeywords = function() {
            var keywords = this.search.data('special-keywords');

            this.specialKeywords = keywords.split(' ');
        };

        Searchbox.prototype.generateHintHTML = function() {
            var hintInput = jQuery('<input type="text" class="search-hint" readonly>');
            this.searchbox.append(hintInput);

            this.searchHint = hintInput;
        };

        Searchbox.prototype.onSearchKeyUp = function(event) {
            if (this.keyToSend > 0) {
                clearTimeout(this.timer);
            }

            this.specialKeyword = false;
            var searchValue = this.search.val();
            var searchValueArray = [];

            // Check if special keyword used
            searchValueArray = searchValue.split(' ');
            for (var i = 0; i < this.specialKeywords.length; i++) {

                /*
        // COMMENTED OUT - SKR
        // This checks for the specialKeyword at the beginning only
        if (searchValueArray[0].toLowerCase() === this.specialKeywords[i].toLowerCase()) {
            this.specialKeyword = true;
            this.hideKeywords();
        }
        */

                // find specialKeyword anywhere in string
                if (searchValue.toLowerCase().indexOf(this.specialKeywords[i].toLowerCase()) > -1) {
                    this.specialKeyword = true;
                    this.hideKeywords();
                }
            }

            // Prevent send when used arrow keys, tab and special keywords
            if (event.which !== 37 && event.which !== 38 && event.which !== 39 && event.which !== 40 && event.which !== 13 && event.which !== 9 && !this.specialKeyword) {

                /*
        // COMMENTED OUT - SKR
        if (this.hints === null) {
            this.checkSendSearchForm(event);
        } else {
            if (!this.checkKeywordMatch(this.hints.keyword)) {
                this.checkSendSearchForm(event);
            }
        }
        */
                this.checkSendSearchForm(event);
            }

            // Fire search when entered string-length is < 1
            if (this.search.val().length < 1) {
                this.sendSearchForm();
            }

            if (this.specialKeyword) {
                this.searchForm.trigger('special-keyword-used');
            } else {
                this.searchForm.trigger('special-keyword-removed');
            }

            // Send on enter
            //if (event.which === 13 && this.specialKeyword) {
            if (event.which === 13) {
                this.search.blur();
                this.sendSearchForm();
            }
        };

        Searchbox.prototype.onSearchKeyDown = function(event) {

            if (event.which === 38 || event.which === 40 || event.which === 13 || event.which === 9) {
                event.preventDefault();

                var hightligth = this.keywordsHTMLList.find('li.highlight');

                if (event.which === 40) { // arrow down
                    if (hightligth.length > 0) {
                        if (hightligth.index() === this.keywordsHTMLList.find('li').length - 1) {
                            hightligth.removeClass('highlight');
                            this.keywordsHTMLList.find('li:first-child').addClass('highlight');
                        } else {
                            hightligth.removeClass('highlight').next().addClass('highlight');
                        }
                    } else {
                        this.keywordsHTMLList.find('li:first-child').addClass('highlight');
                    }
                } else if (event.which === 38) { // arrow up
                    if (hightligth.length > 0) {
                        if (hightligth.index() === 0) {
                            hightligth.removeClass('highlight');
                            this.keywordsHTMLList.find('li:last-child').addClass('highlight');
                        } else {
                            hightligth.removeClass('highlight').prev().addClass('highlight');
                        }
                    } else {
                        this.keywordsHTMLList.find('li:last-child').addClass('highlight');
                    }
                } else if (event.which === 13) { // enter

                    this.search.blur();
                    this.sendSearchForm();

                } else if (event.which === 9) { // tab key
                    this.activeHint(this.keywordsHTMLList.find('li:first-child a'));
                    this.search.focus();
                }
            }
        };

        Searchbox.prototype.checkSendSearchForm = function(event) {
            this.keyEntered += 1;

            if (this.keyToSend > 0) {
                if (this.lastExecution && this.now.getTime() < this.lastExecution + this.delay) {
                    if (this.keyEntered === this.keyToSend || event.which === 32) {
                        this.sendSearchForm();
                    } else {
                        this.timer = setTimeout(this.sendSearchForm.bind(this), this.delay);
                    }
                }
            } else {
                if (!this.send) {
                    this.send = true;
                    this.timer = setTimeout(this.sendSearchForm.bind(this), this.delay);
                }
            }
        };

        Searchbox.prototype.sendSearchForm = function() {
            if (this.keyToSend === 0) {
                clearTimeout(this.timer);
                this.send = false;
            }
            this.lastExecution = this.now.getTime();
            this.keyEntered = 0;

            var searchResult = this.searchForm.siblings('.search-result-section').first();
            var searchAutocomplete = jQuery('#search-autocomplete');

            if (searchResult.find('.loading-indicator').length === 0) {
                searchResult.append('<div class="loading-indicator"/>');
            }
            if (searchAutocomplete.find('.loading-indicator').length === 0) {
                searchAutocomplete.append('<div class="loading-indicator"/>');
            }

            this.searchForm.submit();
        };

        Searchbox.prototype.getHints = function() {
            var self = this;

            this.searchForm.on('ajax-data-object', function() {
                self.hints = (jQuery.data(jQuery(this)[0], 'dataObject'));

                // Check if there is some data
                if (! self.hints.keyword) {
                    self.hints = null;
                    self.keywordsHTMLList = null;
                    self.hideKeywords();
                    self.removeMainKeyword();

                } else {

                    self.generateKeywordsHTML();
                    if (self.showHints) {
                        self.hideKeywords();

                        if (self.search.is(':focus')) {
                            self.showKeywords();
                        }
                    }
                    self.showHints = true;

                    if (! self.search.is(':focus'))
                        self.addMainKeyword();
                }
            });
        };

        Searchbox.prototype.checkMainKeyword = function() {
            if (
                (this.hints !== null)
                && (this.hints.keyword !== null)
            ) {
                var mainKeyword = this.hints.keyword;
                var keywordLength = mainKeyword.length;
                var searchValue = this.search.val();
                var searchLength = searchValue.length;

                if ((searchValue.length > 0) && this.checkKeywordMatch(mainKeyword)) {
                    this.keyword = searchValue + mainKeyword.substr(searchLength, keywordLength);
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        };

        Searchbox.prototype.addMainKeyword = function() {
            if (this.checkMainKeyword()) {
                this.searchHint.val(this.keyword);
            } else {
                this.removeMainKeyword();
            }
        };

        Searchbox.prototype.removeMainKeyword = function() {
            this.searchHint.val('');
        };

        Searchbox.prototype.generateKeywordsHTML = function() {
            var keywordAlternatives = 'keyword-alternatives';

            if (this.hints[keywordAlternatives].length > 0) {
                var html = '<div id="search-autocomplete"><ul>';
                for (var i = 0; i < this.hints[keywordAlternatives].length; i++) {
                    html += '<li><a href="#">' + this.hints[keywordAlternatives][i] + '</a>';
                }
                html += '</ul></div>';

                this.keywordsHTMLList = jQuery(html);
            }
        };

        Searchbox.prototype.showKeywords = function() {
            var self = this;
            if (!this.specialKeyword) {
                if (this.keywordsHTMLList && this.search.val().length > 0) {
                    var body = jQuery('body');
                    body.find('#search-autocomplete').remove();
                    body.append(this.keywordsHTMLList);

                    var x = this.search.offset().top + this.search.outerHeight();
                    var y = this.search.offset().left;
                    var width = this.search.outerWidth();

                    this.keywordsHTMLList.css({
                                                  'position': 'absolute',
                                                  'top': x,
                                                  'left': y,
                                                  'width': width
                                              });

                    this.keywordsHTMLList.find('a').click(function(event) {
                        event.preventDefault();
                        self.activeHint(jQuery(this));
                    });

                    this.search.on('keydown', this.onSearchKeyDown);
                }
            }
        };

        Searchbox.prototype.hideKeywords = function() {
            jQuery('body').find('#search-autocomplete').remove();
            this.search.off('keydown', this.onSearchKeyDown);
        };

        Searchbox.prototype.activeHint = function(link) {
            var keyword = link.text();

            this.showHints = false;
            this.search.val(keyword);
            this.sendSearchForm();
            this.addMainKeyword();
        };

        Searchbox.prototype.checkKeywordMatch = function(keyword) {
            var searchValue = this.search.val();
            var searchLength = searchValue.length;
            var keywordStartString = keyword.substr(0, searchLength);

            if (searchValue.toLowerCase() === keywordStartString.toLowerCase()) {
                return true;
            } else {
                return false;
            }
        };

        jQuery.fn.searchbox = function() {
            return jQuery(this).each(function() {
                new Searchbox(jQuery(this));
            });
        };

        module.exports = Searchbox;

    },{}],36:[function(require,module,exports){
        var jQuery = require('jquery');
        var numbers = require('../utils/numbers');
        var settings = require('../utils/settings');
        var gestures = require('../utils/gestures');
        var Signal = require('../utils/signal');
        gestures.enable();

// Check for transform support;
        var cssTransform;
        var prefixes = ['transform', '-webkit-transform', '-ms-transform'];

        for (var i = 0; i < prefixes.length; i++)
            if (typeof document.body.style[prefixes[i]] != 'undefined')
                cssTransform = prefixes[i];


        function Slider(element, options) {
            jQuery.extend(true, this, Slider.DEFAULT_SETTINGS, options);

            this.element = element;
            this.items = this.element.find('>.slide'); // Items in the slider.
            this.count = this.items.length; // Count of items in the slider.
            this.destination = this.position;
            this.tempAuto = this.auto;

            this.itemState = [];
            for (var i = 0; i < this.count; i++)
                this.itemState.push(i);

            this.animated = false;

            this.items.wrapAll('<div class="slider-container"></div>');
            this.container = this.element.children('.slider-container');

            if (this.auto)
                this.enableAuto();

            this.sliderTouch();

            if (this.arrows)
                this.createArrows();

            if (this.dots)
                this.createDots();

            this.onChangeSlide = new Signal();

        }

        Slider.MODE_DEFAULT = 'default';
        Slider.MODE_CAROUSEL = 'carousel';

        Slider.DEFAULT_SETTINGS = {
            'itemIndex': 0,
            'itemSize': 100,  // Usually width of one slide (or height in case of vertical slider).
            'perPage': 1, // Number of slides per page. Can be 1 to N, where N <= this.count.
            'step': 1,
            'ease': 0.2, // Speed of animation, smaller value is faster.
            'unit': '%', // 'px'
            'arrows': true,
            'dots': true,
            'auto': true,
            'autoInterval': 8000,
            'animatedProperty': 'left',
            'minCount': 1,
            'mode': Slider.MODE_DEFAULT,
            'position': 0,
            'takeShortcuts': true,
            'touchEnabled': true
        };

        Slider.prototype.render = function() {
            var x = 0;
            var y = 0;
            var css = {};
            var list = this.container;

            if (this.animatedProperty == 'left' || this.animatedProperty == 'top') {
                if (this.animatedProperty == 'left')
                    x = this.position;

                if (this.animatedProperty == 'top')
                    y = this.position;

                css[cssTransform] = 'translate(' + x + this.unit + ', ' + y + this.unit + ')';
            } else
                css[this.animatedProperty] = Math.round(this.position) + this.unit;

            list.css(css);
        };

        Slider.prototype.animate = function(instant) {
            var newItemIndex;

            this.animated = true;

            if (this.position == this.destination) {
                this.animated = false;
                return;
            }

            if (instant)
                this.position = this.destination;

            var distance = this.destination - this.position;

            if (Math.abs(distance) < (this.unit == '%' ? 0.1 : 1)) {
                this.position = this.destination;
            } else {
                this.position += Math.abs(distance) * this.ease * Math.sign(distance);
                //alert(this.position + ' ' + this.destination)
            }

            //Carousel mode required moving slider elements from beginning to the end and vice versa.
            if (this.mode == Slider.MODE_CAROUSEL) {
                if (distance < 0 && this.position <= -this.itemSize)
                    this.append();

                if (distance > 0 && this.position > 0)
                    this.prepend();

                newItemIndex = numbers.mod(this.itemState[0] + Math.round(-this.position / this.itemSize), this.count);
            } else
                newItemIndex = Math.round(-this.position / this.itemSize);

            if (typeof newItemIndex != 'undefined' && newItemIndex != this.itemIndex) {
                this.itemIndex = newItemIndex;
                this.onChangeSlide.send(this.itemIndex);
                this.update();
            }

            // Actually move the slider elements.
            this.render();

            if (this._timer)
                clearTimeout(this._timer);
            this._timer = setTimeout(this.animate.bind(this), 33);


        };

        Slider.prototype.append = function() {
            this.position += this.itemSize;
            this.destination += this.itemSize;

            this.itemState.push(this.itemState.shift());

            var elements = this.element.find('.slide');
            elements.first().insertAfter(elements.last());
        };

        Slider.prototype.prepend = function() {
            this.position -= this.itemSize;
            this.destination -= this.itemSize;

            this.itemState.unshift(this.itemState.pop());

            var elements = this.element.find('.slide');
            elements.last().insertBefore(elements.first());
        };

        Slider.prototype.next = function() {
            var newItemIndex, position;

            if (this.mode == Slider.MODE_DEFAULT) {
                newItemIndex = Math.min(this.itemIndex + this.step, this.count);

                if ((newItemIndex == this.itemIndex) || (newItemIndex == this.count))
                    return;

                position = this.destination - (newItemIndex - this.itemIndex) * this.itemSize;
            } else
                position = this.destination + this.step * this.itemSize;

            this.slideTo(position);
        };

        Slider.prototype.previous = function() {
            var newItemIndex, position;

            if (this.mode == Slider.MODE_DEFAULT) {
                newItemIndex = Math.max(0, this.itemIndex - this.step);

                if (newItemIndex == this.itemIndex)
                    return;

                position = this.destination + (this.itemIndex - newItemIndex) * this.itemSize;
            } else
                position = this.destination - this.step * this.itemSize;

            this.slideTo(position);
        };

        Slider.prototype.slideTo = function(position) {
            if (this.tempAuto && this.auto)
                this.disableAuto();

            this.destination = position;
            this.animate();

            if (!(this.tempAuto) && this.auto)
                this.enableAuto();

        };

        Slider.prototype.slideToIndex = function(index) {
            var position;
            var half = this.itemState.length / 2;

            if (this.mode == Slider.MODE_DEFAULT)
                position = -index * this.itemSize;
            else {
                for (var i = 0; i < this.itemState.length; i++) {
                    if (index == this.itemState[i]) {
                        if ((this.takeShortcuts && i < half) || index > this.itemIndex)
                            position = -i * this.itemSize;
                        else if ((this.takeShortcuts && i > half) || index <= this.itemIndex)
                            position = (this.itemState.length-i) * this.itemSize;
                        break;
                    }
                }
            }

            this.slideTo(position);
        };

        Slider.prototype.createArrows = function() {
            var self = this;
            if (this.itemState.length > 1) {
                var navigation = '<button href="#" class="icon-arrow-left slider-navigation previous"></button><button href="#" class="icon-arrow-right slider-navigation next"></button>';
                this.element.append(navigation);
                this.element.addClass('navigations');
            }

            this.element.find('.slider-navigation').each(function() {
                jQuery(this).click(function(event) {
                    event.preventDefault();

                    var navigationLink = jQuery(this);
                    if (navigationLink.hasClass('previous')) {
                        if (self.mode === Slider.MODE_DEFAULT) {
                            self.previous();
                        } else {
                            self.next();
                        }
                    } else if (navigationLink.hasClass('next')) {
                        if (self.mode === Slider.MODE_DEFAULT) {
                            self.next();
                        } else {
                            self.previous();
                        }
                    }
                });
            });
        };

        Slider.prototype.createDots = function() {
            var self = this;
            if (this.itemState.length > 1) {
                var navigation = '<ul class="navigation-list" role="listbox">';
                for (var i = 0; i < this.itemState.length; i++) {
                    if (i == 0)
                        navigation += '<li class="active" role="option" aria-selected="false"><a href="#" data-slide="'+i+'" tabindex="1" aria-selected="1" title="Zeige Beitrag '+(i+1)+'"/></li>';
                    else
                        navigation += '<li role="option" aria-selected="false"><a href="#" data-slide="'+i+'" tabindex="-1" title="Zeige Beitrag '+(i+1)+'" /></li>';
                }
                navigation += '</ul>';
                this.element.append(navigation);
                this.element.addClass('navigations');

                this.element.find('.navigation-list a').click(function(event) {
                    event.preventDefault();
                    var element = jQuery(this);
                    var slideIndex = element.data('slide');

                    self.slideToIndex(slideIndex);
                });
            }
        };

        Slider.prototype.enableAuto = function() {
            this.tempAuto = true;

            if (this.count <= this.perPage)
                return false;

            if (this._autoTimer)
                clearInterval(this._autoTimer);

            this._autoTimer = setInterval(this.previous.bind(this), this.autoInterval);
        };

        Slider.prototype.update = function() {
            var self = this;
            if (this.dots) {
                var dots = this.element.find('.navigation-list li');
                dots.removeClass('active');
                dots.find('a').removeAttr('aria-selected');
                dots.find('a').attr('tabindex', -1);
                dots.eq(self.itemIndex).addClass('active');
                dots.eq(self.itemIndex).find('a').attr('aria-selected', true);
                dots.eq(self.itemIndex).find('a').attr('tabindex', 1);
            }
        };

        Slider.prototype.disableAuto = function() {
            this.tempAuto = false;

            if (this._autoTimer) {
                clearInterval(this._autoTimer);
                delete this._autoTimer;
            }
        };

        Slider.prototype.sliderTouch = function() {
            var self = this;

            if (this.touchEnabled) {
                gestures.onTouchMove(function(target, touch, event) {
                    var sliderChild = jQuery.contains(self.element[0], target);

                    if (sliderChild)
                        if (Math.abs(touch.dx) > Math.abs(touch.dy))
                            event.preventDefault();
                });

                gestures.onTouchEnd(function(target, touch, event) {
                    var sliderChild = jQuery.contains(self.element[0], target);

                    if (sliderChild) {
                        if (touch.dx > 0 && touch.dx > 100)
                            self.next();
                        else if (touch.dx < 0 && touch.dx < -100)
                            self.previous();

                        event.stopPropagation();
                    }
                });
            }
        };

        jQuery.fn.slider = function(options) {
            return this.each(function() {
                new Slider(jQuery(this), options);
            });
        };

        module.exports = Slider;

    },{"../utils/gestures":9,"../utils/numbers":10,"../utils/settings":11,"../utils/signal":12,"jquery":2}],37:[function(require,module,exports){
        var jQuery = require('jquery');
        function throttle (scope, delay, callback) {
            var delay = delay || 250;
            var lastExecution, timer;

            return function () {
                clearTimeout(timer);

                var context = scope || this;

                var now = new Date,
                    args = arguments;

                var fn = function () {
                    lastExecution = now.getTime();
                    callback.apply(context, args);
                };

                if (lastExecution && now.getTime() < lastExecution + delay)
                    timer = setTimeout(fn, delay);
                else
                    fn();
            };
        }

        module.exports = throttle;

    },{"jquery":2}],38:[function(require,module,exports){
        var Debounce = require('../utils/debounce.js');
        var Throttle = require('../utils/throttle.js')

        function TopMenu(topMenu) {
            var self = this;
            this.topMenu = topMenu;

            this.body = jQuery('body');
            this.window = jQuery(window);
            this.pageWrapper = this.body.find('.page-wrap');
            this.pageContainer = this.pageWrapper.find('.container');

            this.listItem = this.topMenu.find('.top-menu__list-item');
            this.listItemDisplayed = this.topMenu.find('.top-menu__list-item--displayed');
            this.listLink = this.listItemDisplayed.find('.top-menu__list-link');
            this.secondLevelMenu = this.topMenu.find('.top-menu__level2');
            this.thirdLevelMenu = this.listItemDisplayed.find('.top-menu__level3');
            this.thirdLevelItems = this.listItemDisplayed.find('.top-menu__level3-item');
            this.secondLevelLink = this.listItemDisplayed.find('.top-menu__level2-link');
            this.thirdLevelLink = this.listItemDisplayed.find('.top-menu__list-link');
            this.offsetMenu = this.listItemDisplayed.find('.top-menu__offset-menu');
            this.fourthLevelMenu = this.offsetMenu.find('.top-menu__level4');
            this.expandedSubmenu = this.topMenu.find('.top-menu__submenu');
            this.closeSubmenuButton = this.topMenu.find('.top-menu__close-icon');
            this.levelSubmenu = this.offsetMenu.find('.top-menu__sublist');
            this.deeperLevelMenu = this.offsetMenu.find('.top-menu__deeper-level');
            this.deeperLevelItem = this.offsetMenu.find('.top-menu__sublist-item');
            this.deeperLevelLink = this.offsetMenu.find('.top-menu__sublist-link');
            this.menuButton = this.offsetMenu.find('.top-menu__button');
            this.leftMenuButton = this.offsetMenu.find('.top-menu__button--left');
            this.rightMenuButton = this.offsetMenu.find('.top-menu__button--right');
            this.listLength = this.thirdLevelItems.size();
            this.lastItem = $(this.thirdLevelItems[this.listLength-1]);
            this.lastItemWidth = this.lastItem.width();
            this.firstItem = $(this.thirdLevelItems[0]);
            this.firstWidth = this.firstItem.width();
            this.currentPage = this.deeperLevelLink.filter('.top-menu__sublist-link--current-page');


            if (this.offsetMenu.length !== 0) {
                this.deeperLevelMenu.css('left', this.pageContainer.width()/2);

                this.setSubmenuSize();
                this.showCurrentItem();
                this.setOffsetPosition();
                this.checkFourthLevelSubmenuExistance();
                this.checkDeeperLevelSubmenuExistance();

                this.window.on('resize', this.updateOnResize.bind(this));
                this.window.on('font-reload', this.updateOnResize.bind(this));
                this.deeperLevelLink.on('click', this.showDeeperMenuLevel.bind(this));
                this.closeSubmenuButton.on('click', this.closeMenu.bind(this));
                $(document).on('mouseup', this.closeMenuWithRandomClick.bind(this));
                this.rightMenuButton.on('click', this.preventDefaultBehavior.bind(this));
                this.leftMenuButton.on('click', this.preventDefaultBehavior.bind(this));
                this.rightMenuButton.one('click', this.slideRight.bind(this));
                this.leftMenuButton.one('click', this.slideLeft.bind(this));

                this.thirdLevelLink.on('click', jQuery.debounce(500, true, this.showMenu.bind(this)));
            }
        }

        TopMenu.prototype.preventDefaultBehavior = function(e) {
            e.preventDefault();
        }

        TopMenu.prototype.setOffsetPosition = function() {
            var leftPosition = this.secondLevelMenu.offset().left;
            this.offsetMenu.offset({left: leftPosition});
        }

        TopMenu.prototype.showCurrentItem = function() {
            this.currentPage.parents('.top-menu__level3-item').addClass('top-menu__list-item--displayed');

            var currentPageItem = this.thirdLevelItems.filter('.top-menu__list-item--displayed');
            var itemPosition = currentPageItem.offset().left;
            var menuWidth = this.thirdLevelMenu.width();
            var newPosition = itemPosition - menuWidth/2;

            if (itemPosition > menuWidth && menuWidth > this.body.width()) {
                this.thirdLevelItems.animate({left: '-=' + newPosition}, 500);
                currentPageItem.children('.top-menu__list-link').addClass('top-menu__list-link--active');
            }

            setTimeout(this.checkMenuLength.bind(this), 1000);
        }

        TopMenu.prototype.updateOnResize = function() {
            this.setOffsetPosition();
            this.setSubmenuSize();
            this.checkMenuLength();
            this.checkFourthLevelSubmenuExistance();
            this.checkDeeperLevelSubmenuExistance();
            this.showCurrentItem();
        }

        TopMenu.prototype.setSubmenuSize = function(currentHeight) {
            var currentWidth = this.pageContainer.width();

            if (!currentHeight) {
                var currentHeight = this.levelSubmenu.height();
            }

            this.expandedSubmenu.css({
                                         width: currentWidth,
                                         height: currentHeight + 40
                                     });

            this.offsetMenu.css({
                                    width: currentWidth - 16,
                                    height: currentHeight + 80
                                });

            this.expandedSubmenu.height(currentHeight + 40);
        }

        TopMenu.prototype.checkFourthLevelSubmenuExistance = function() {
            this.thirdLevelItems.each(function(i, e){
                if($(e).has('.top-menu__level4').length !== 0) {
                    $(e).find('.top-menu__list-link').addClass('icon-arrow-down');
                }
            });
        }

        TopMenu.prototype.checkDeeperLevelSubmenuExistance = function() {
            this.deeperLevelItem.each(function(i, e){
                if($(e).has('.top-menu__sublist').length !== 0) {
                    $(e).children('.top-menu__sublist-link').addClass('top-menu__sublist-link--arrow-right');
                }
            });
        }

        TopMenu.prototype.showDeeperMenuLevel = function(el) {
            var clickedLink = $(el.target);
            var sublist = clickedLink.siblings('.top-menu__deeper-level');
            var clickedLinkParent = clickedLink.parent();
            var clickedLinkParentSiblings = clickedLinkParent.siblings();
            var currentHeight = 0;

            if ((clickedLink.siblings('.top-menu__deeper-level').length !== 0) && !(clickedLink.hasClass('top-menu__sublist-link--back'))) {
                el.preventDefault();

                clickedLink.hide();

                clickedLinkParentSiblings.addClass('top-menu__sublist-item--hidden');
                sublist.addClass('top-menu__deeper-level--visible').css('left', 0);

                currentHeight = clickedLink.siblings('.top-menu__sublist').height();

                this.setSubmenuSize(currentHeight);
            } else if (clickedLink.hasClass('top-menu__sublist-link--back')){
                el.preventDefault();
                var sublistParent = clickedLink.closest('.top-menu__sublist');

                sublistParent.removeClass('top-menu__deeper-level--visible').css('left', this.pageContainer.width()/2);
                setTimeout(function(){
                    sublistParent.siblings('.top-menu__sublist-link').show();
                    sublistParent.closest('.top-menu__sublist-item').siblings().removeClass('top-menu__sublist-item--hidden');
                    currentHeight = sublistParent.closest('.top-menu__sublist-item').parent().height();

                    this.setSubmenuSize(currentHeight);
                }.bind(this), 200);
            }

        }

        TopMenu.prototype.showMenu = function(el) {
            var clickedTopLink = $(el.target);
            var submenuWidth = clickedTopLink.siblings('.top-menu__level4').width();
            var clickedLinkSiblings = clickedTopLink.siblings(this.levelSubmenu);
            var deeperLinks = clickedLinkSiblings.find('.top-menu__sublist-link');

            var height = clickedTopLink.siblings(this.fourthLevelMenu).height();
            this.setSubmenuSize(height);

            if (clickedTopLink.siblings('.top-menu__level4').length !== 0) {
                el.preventDefault();
                var position = this.thirdLevelMenu.width() - clickedTopLink.offset().left;
                if (position < submenuWidth) {
                    var newPosition = submenuWidth - position;
                    this.thirdLevelItems.animate({left: '-=' + newPosition}, 500);
                }
            }

            if (clickedLinkSiblings.length !== 0 && clickedLinkSiblings.css('display') === 'block') {
                clickedLinkSiblings.stop().slideUp();
                this.expandedSubmenu.stop().slideUp();

                this.setSubmenuInitialValues();
            } else if (clickedLinkSiblings.length !== 0 && clickedLinkSiblings.is(':hidden')) {
                this.fourthLevelMenu.not(clickedLinkSiblings).slideUp();
                clickedLinkSiblings.stop().slideDown();
                this.expandedSubmenu.stop().slideDown();

                if (deeperLinks.hasClass('top-menu__sublist-link--current-page')) {
                    var currentPageLink = deeperLinks.filter('.top-menu__sublist-link--current-page');
                    var closestSublist = currentPageLink.closest('.top-menu__sublist');
                    var currentPageParentSublists =  currentPageLink.parents('.top-menu__sublist');
                    var items = closestSublist.parents('.top-menu__sublist-item').siblings();
                    var displayedItem = currentPageLink.parents('.top-menu__list-item').addClass('top-menu__list-item--displayed');

                    currentPageLink.addClass('top-menu__sublist-link--current');
                    closestSublist.siblings().show();
                    currentPageParentSublists.siblings('.top-menu__sublist-link').addClass('top-menu__sublist-link--current').hide();
                    currentPageParentSublists.addClass('top-menu__deeper-level--visible').css('left', 0);
                    items.addClass('top-menu__sublist-item--hidden');

                    setTimeout(function() {
                        var height = currentPageLink.parent().height();
                        currentPageLink.parent().siblings().each(function(i, el) {
                            height += $(el).height();
                        });
                        this.setSubmenuSize(height);
                    }.bind(this), 500)
                } else {

                    this.secondLevelLink.removeClass('top-menu__list-link--active');
                    clickedTopLink.addClass('top-menu__list-link--active');
                    this.thirdLevelLink.not(clickedTopLink).removeClass('top-menu__list-link--active');

                    setTimeout(function() {
                        var height = clickedTopLink.siblings(this.fourthLevelMenu).height();
                        this.setSubmenuSize(height);

                    }.bind(this), 400)
                }
            } else {
                clickedTopLink.addClass('top-menu__list-link--active');
                this.thirdLevelLink.not(clickedTopLink).removeClass('top-menu__list-link--active');
            }

            setTimeout(this.checkMenuLength.bind(this), 250);

        }

        TopMenu.prototype.closeMenu = function(e) {
            e.preventDefault();
            if (this.levelSubmenu.is(':visible')) {
                this.fourthLevelMenu.slideUp();
                this.expandedSubmenu.slideUp();
                this.checkMenuLength();
                this.setSubmenuInitialValues();
            }
        }

        TopMenu.prototype.setSubmenuInitialValues = function(e) {
            var currentHeight = this.levelSubmenu.height() + 70;
            this.fourthLevelMenu.children().removeClass('top-menu__sublist-item--hidden');
            this.deeperLevelItem.removeClass('top-menu__sublist-item--hidden');
            this.deeperLevelLink.removeClass('top-menu__sublist-link--hidden');
            this.deeperLevelMenu.removeClass('top-menu__deeper-level--visible');
            this.deeperLevelLink.show();

            this.currentPage.parents('.top-menu__level3-item').addClass('top-menu__level3-item--displayed');

            this.listItem.filter('.top-menu__list-item--displayed')
                .children('.top-menu__list-link').addClass('top-menu__list-link--active');
            this.thirdLevelItems.not('.top-menu__list-item--displayed').removeClass('top-menu__list-link--active');
            this.thirdLevelItems.filter('.top-menu__list-item--displayed')
                .children('.top-menu__list-link').addClass('top-menu__list-link--active');

            this.deeperLevelItem.filter('.top-menu__sublist-item--current')
                .removeClass('top-menu__sublist-item--current')
                .children('.top-menu__sublist-link').addClass('top-menu__sublist-link--current');

            this.checkDeeperLevelSubmenuExistance();
            this.deeperLevelMenu.css('left', this.pageContainer.width()/2);
            this.offsetMenu.css('height', currentHeight);
        }

        TopMenu.prototype.closeMenuWithRandomClick = function(e) {
            if (!this.levelSubmenu.is(e.target) && !this.listLink.is(e.target) && this.levelSubmenu.has(e.target).length === 0) {
                this.fourthLevelMenu.slideUp();
                this.expandedSubmenu.slideUp();
                this.checkMenuLength();
                this.setSubmenuInitialValues();
            }
        }

        TopMenu.prototype.checkMenuLength = function() {
            var lastItemOffsetLeft = this.lastItem.offset().left;
            var lastItemOffsetRight = lastItemOffsetLeft + this.lastItemWidth;
            var firstItemOffsetLeft = this.firstItem.offset().left;
            var thirdLevelMenuWidth = this.thirdLevelMenu.width();
            var menuWidth = 0;

            this.thirdLevelItems.each(function(i, el){
                menuWidth += $(el).outerWidth();
            });

            if ($('main').width() < menuWidth && this.window.width() > 1824) {
                if (lastItemOffsetRight > menuWidth +  this.firstItem.width()) {
                    this.rightMenuButton.addClass('top-menu__button--active');
                } else {
                    this.rightMenuButton.removeClass('top-menu__button--active');
                }

                if (firstItemOffsetLeft < 150 ) {
                    this.leftMenuButton.addClass('top-menu__button--active');
                } else {
                    this.leftMenuButton.removeClass('top-menu__button--active');
                }
            } else if ($('main').width() < menuWidth) {
                if (lastItemOffsetRight > thirdLevelMenuWidth + 100) {
                    this.rightMenuButton.addClass('top-menu__button--active');
                } else {
                    this.rightMenuButton.removeClass('top-menu__button--active');
                }

                if (firstItemOffsetLeft < 80 ) {
                    this.leftMenuButton.addClass('top-menu__button--active');
                } else {
                    this.leftMenuButton.removeClass('top-menu__button--active');
                }
            } else {
                if (firstItemOffsetLeft < 80 ) {
                    this.leftMenuButton.addClass('top-menu__button--active');
                } else {
                    this.leftMenuButton.removeClass('top-menu__button--active');
                }
            }
        }

        TopMenu.prototype.slideRight = function() {
            var lastItemOffsetLeft = this.lastItem.offset().left;
            var lastItemOffsetRight = lastItemOffsetLeft + this.lastItemWidth;
            var thirdLevelMenuWidth = this.thirdLevelMenu.width();
            var menuWidth = 0;

            this.thirdLevelItems.each(function(i, el){
                menuWidth += $(el).outerWidth();
            });

            var slideDistance = menuWidth - thirdLevelMenuWidth;

            if (this.expandedSubmenu.is(':visible')) {
                this.rightMenuButton.off('click', this.slideRight.bind(this));
                this.leftMenuButton.off('click', this.slideLeft.bind(this));
            }

            if (menuWidth/thirdLevelMenuWidth >= 2 && lastItemOffsetRight > menuWidth) {
                this.thirdLevelItems.animate({left: '-=' + (thirdLevelMenuWidth - 100)});
            } else {
                if (menuWidth/thirdLevelMenuWidth >= 2) {
                    var scroll = 2*(menuWidth - thirdLevelMenuWidth*(parseInt(menuWidth/thirdLevelMenuWidth)));
                } else {
                    var scroll = menuWidth - thirdLevelMenuWidth + 45;
                }
                this.thirdLevelItems.animate({left: '-=' + scroll});
            }

            setTimeout(function() {
                this.rightMenuButton.one('click', this.slideRight.bind(this));
                this.checkMenuLength();
            }.bind(this), 500);
        }

        TopMenu.prototype.slideLeft = function(e) {
            e.preventDefault();
            var firstItemOffsetLeft = this.firstItem.offset().left;
            var thirdLevelMenuWidth = this.thirdLevelMenu.width();
            var menuWidth = 0;

            this.thirdLevelItems.each(function(i, el){
                menuWidth += $(el).outerWidth();
            });

            if (this.expandedSubmenu.is(':visible')) {
                this.rightMenuButton.off('click', this.slideRight.bind(this));
                this.leftMenuButton.off('click', this.slideLeft.bind(this));
            }

            if (menuWidth/thirdLevelMenuWidth >= 2 && -firstItemOffsetLeft > thirdLevelMenuWidth) {
                this.thirdLevelItems.animate({left: '+=' + thirdLevelMenuWidth});
            } else {
                this.thirdLevelItems.animate({left: 0});
            }

            setTimeout(function() {
                this.leftMenuButton.one('click', this.slideLeft.bind(this));
                this.checkMenuLength();
            }.bind(this), 500);

        }

        jQuery.fn.topMenu = function() {
            return jQuery(this).each(function() {
                new TopMenu(jQuery(this));
            });
        };

        module.exports = {
            TopMenu: TopMenu
        };
    },{"../utils/debounce.js":7,"../utils/throttle.js":14}],39:[function(require,module,exports){
        /* ===================
* Validation Script
* Marcin Majewski, Marcin Wasilewski - Merix Studio
*
* Avaible rules: required, email, phone, letters-only, postcode, equalto, number, min-length
*/

        var jQuery = require('jquery');
        var translate = require('../utils/translate')
        function Validate(form) {
            var self = this;
            this.form = form;
            this.formValid = new Array();

            this.checkFields();
        }

        Validate.prototype.checkFields = function() {
            var self = this;
            this.form.find('[data-validate]').each(function() {
                var field = jQuery(this);
                var validateData = JSON.parse(field.data('validate').replace(/\'/g, '"'));
                self.isRequired(field, validateData);
                self.isMail(field, validateData);
                self.isPhone(field, validateData);
                self.hasLettersOnly(field, validateData);
                self.isPostcode(field, validateData);
                self.isEqualTo(field, validateData);
                self.isNumber(field, validateData);
                self.isMinLength(field, validateData);
            });
        };

        Validate.prototype.isRequired = function(field, validateData) {
            if (field.prop('tagName') != 'SPAN') {
                if (validateData['required'] && field.is('[type="checkbox"]')) {
                    if (field.is(':checked')) {
                        this.removeError(field);
                        this.formValid.push([true, field]);
                    } else {
                        this.showError(field, 'required');
                        this.formValid.push([false, field]);
                    }
                } else if (validateData['required'] && field.is('[type="radio"]')) {
                    var i = 0;
                    jQuery('[name="'+field.attr('name')+'"]').each(function() {
                        if (jQuery(this).is(':checked'))
                            i += 1;
                    });

                    if (i > 0) {
                        this.removeError(field);
                        this.formValid.push([true, field]);
                    }
                    else {
                        this.showError(field, 'required');
                        this.formValid.push([false, field]);
                    }
                } else if (validateData['required'] && field.val() == '') {
                    this.showError(field, 'required');
                    this.formValid.push([false, field]);
                }
                else {
                    this.removeError(field, 'required');
                    this.formValid.push([true, field]);
                }
            }
        };

        Validate.prototype.isMail = function(field, validateData) {
            if (field.prop('tagName') != 'SPAN') {
                if (validateData['email']) {
                    var regex = /^[-!#$%&'*+/0-9=?A-Z^_a-z{|}~](\.?[-!#$%&'*+/0-9=?A-Z^_a-z{|}~])*@[a-zA-Z](-?[a-zA-Z0-9])*(\.[a-zA-Z](-?[a-zA-Z0-9])*)+$/; // regex '
                    var email = field.val();
                    if (regex.test(email)) {
                        this.removeError(field);
                        this.formValid.push([true, field]);
                    } else {
                        this.showError(field, 'email');
                        this.formValid.push([false, field]);
                    }
                }
            }
        };

        Validate.prototype.isPhone = function(field, validateData) {
            if (field.prop('tagName') != 'SPAN') {
                if (validateData['phone'] && field.val() != '') {
                    var regex = /\(?([0-9.\+\-\s()]+)/;
                    var phone = field.val();
                    if (regex.test(phone)) {
                        this.removeError(field);
                        this.formValid.push([true, field]);
                    } else {
                        this.showError(field, 'phone');
                        this.formValid.push([false, field]);
                    }
                }
            }
        };

        Validate.prototype.hasLettersOnly = function(field, validateData) {
            if (field.prop('tagName') != 'SPAN') {
                if (validateData['letters-only'] && field.val() != '') {
                    var regex = /^[^!@#\$%\^&\*\(\)\[\]:;'",\.\d+-]+$/;
                    var name = field.val();
                    if (regex.test(name)) {
                        this.removeError(field);
                        this.formValid.push([true, field]);
                    } else {
                        this.showError(field, 'letters-only');
                        this.formValid.push([false, field]);
                    }
                }
            }
        };

        Validate.prototype.isEqualTo = function(field, validateData) {
            if (field.prop('tagName') != 'SPAN') {
                if (validateData['equal-to'] && field.val() != '') {
                    var equalTo = this.form.find('#'+ validateData['equal-to']);
                    if (field.val() === equalTo.val()) {
                        this.removeError(field);
                        this.formValid.push([true, field]);
                        this.removeError(equalTo);
                    } else {
                        this.showError(field, 'equal');
                        this.formValid.push([false, field]);
                        this.showError(equalTo, 'equal');
                    }
                }
            }
        };

        Validate.prototype.isPostcode = function(field, validateData) {
            if (field.prop('tagName') != 'SPAN') {
                if (validateData['postcode'] && field.val() != '') {
                    var regex = /^[0-9]{2}-[0-9]{3}$/;
                    var postcode = field.val();
                    if (regex.test(postcode)) {
                        this.removeError(field);
                        this.formValid.push([true, field]);
                    } else {
                        this.showError(field, 'postcode');
                        this.formValid.push([false, field]);
                    }
                }
            }
        };

        Validate.prototype.isNumber = function(field, validateData) {
            if (field.prop('tagName') != 'SPAN') {
                if (validateData['number'] && field.val() != '') {
                    var regex = /^[0-9]*$/;
                    var name = field.val();
                    if (regex.test(name)) {
                        this.removeError(field);
                        this.formValid.push([true, field]);
                    } else {
                        this.showError(field, 'number');
                        this.formValid.push([false, field]);
                    }
                }
            }
        };

        Validate.prototype.isMinLength = function(field, validateData) {
            if (field.prop('tagName') != 'SPAN') {
                if (validateData['min-length'] && field.val() != '') {
                    var name = field.val();
                    if (name.length >= validateData['min-length']) {
                        this.removeError(field);
                        this.formValid.push([true, field]);
                    } else {
                        this.showError(field, 'minlength', {0: validateData['min-length']});
                        this.formValid.push([false, field]);
                    }
                }
            }
        };

        Validate.prototype.showError = function(element, type, errorVariables) {
            var multiple = false;
            var errorPlace = element.parent();
            errorVariables = errorVariables || null;

            if (element.is('[type="checkbox"]') || element.is('[type="radio"]')) {
                var elements = jQuery('[type="radio"][name="' + element.attr('name') + '"]');
                if (elements.length > 1) {
                    multiple = true;
                    if (!elements.last().closest('label').hasClass('error'))
                        elements.last().closest('label').addClass('error');

                    errorPlace = elements.last().closest('label');
                } else {
                    element.closest('label').addClass('error');
                    errorPlace = element.closest('label');
                }
            }

            else if (element.prop('tagName') == 'TEXTAREA') {
                element.closest('.textarea-wrapper').addClass('error');
                errorPlace = element.closest('.textarea-wrapper').parent();
            }

            else if (element.prop('tagName') == 'SELECT') {
                    element.closest('.fake-select').addClass('error');
                    errorPlace = element.closest('.fake-select').parent();
                }

                else
                    element.parent().addClass('error');

            if (element.parent().children('.error-message').length == 0 && element.closest('.set').children('.error-message').length == 0) {
                if (multiple == false || (multiple == true && element.closest('label').hasClass('error'))) {
                    var validate = JSON.parse(element.data('validate').replace(/\'/g, '"'));
                    var label = (typeof validate[type] == 'string' ? validate[type] : translate('validation_' + type, errorVariables));

                    if (element.prop('tagName') == 'SELECT') {
                        if (element.parent().nextAll('.error-message').length == 0)
                            errorPlace.append('<span class="error-message">' + label + '</span>');
                    } else if (element.prop('tagName') == 'TEXTAREA') {
                        if (element.parents('.textarea-wrapper').nextAll('.error-message').length == 0)
                            errorPlace.append('<span class="error-message">' + label + '</span>');
                    } else if (element.is('[type="checkbox"]') || element.is('[type="radio"]')) {
                        if (errorPlace.find('.error-message').length == 0) {
                            errorPlace.append('<span class="error-message">' + label + '</span>');
                        }
                    } else {
                        errorPlace.append('<span class="error-message">' + label + '</span>');
                    }
                }
            }
        };

        Validate.prototype.removeError = function(element) {
            if (element.is('[type="checkbox"]') || element.is('[type="radio"]'))
                element.closest('label').removeClass('error');

            else if (element.prop('tagName') == 'TEXTAREA') {
                element.parents('.textarea-wrapper').removeClass('error').nextAll('.error-message').remove();
            }

            else if (element.hasClass('scrollable'))
                    element.closest('.scrollbar-wrapper').removeClass('error');

                else if (element.prop('tagName') == 'SELECT') {
                        element.closest('.fake-select').removeClass('error');
                        element.closest('.fake-select').nextAll('.error-message').remove();
                    }

                    else
                        element.parent().removeClass('error');

            if (element.is('[type="checkbox"]') || element.is('[type="radio"]')) {
                element.closest('label').find('.error-message').remove();
            } else {
                element.nextAll('.error-message').remove();
            }
        };

        Validate.prototype.isValid = function() {
            for(var i = 0; i < this.formValid.length; i++) {
                if (this.formValid[i][0] == false) {
                    this.scrollToError(this.formValid[i][1]);
                    return false;
                    break;
                }
            }

            return true;
        };

        Validate.prototype.scrollToError = function(field) {
            var sectionOffset = Math.ceil(field.offset().top);
            var scrollTo = sectionOffset - 50;

            jQuery('body, html').stop().animate({'scrollTop': scrollTo}, 500);

            field.focus();
        };

        jQuery.fn.validate = function(){
            jQuery(this).each(function() {
                var form = jQuery(this);
                var button = form.find('button');
                var body = form.closest('.page-wrap');
                form.attr('novalidate', 'novalidate');
                form.on('submit', function(event) {
                    event.preventDefault(); ///DELETE
                    var valid = new Validate(form);

                    if (valid.isValid() != true)
                        event.preventDefault();
                });
            });

            return this;
        };

        module.exports = Validate;

    },{"../utils/translate":15,"jquery":2}],40:[function(require,module,exports){
        function VerticalMenu(container) {
            var self = this;
            this.container = container;
            this.body = jQuery('body');
            this.pageHeader = this.body.find('.page-header');
            this.pageWrap = this.body.find('.page-wrap');
            this.mainMenuContainer = this.pageHeader.find('.page-header__container');
            this.closeMobileButton = this.pageHeader.find('.page-header__close-mobile-button');
            this.mainMenuButton = this.container.find('.main-menu__item-link');
            this.secondLevelList = this.container.find('.main-menu__sublist');
            this.pageContent = this.body.find('.page-content-wrapper');
            this.mobileMenuButton = this.pageHeader.find('.page-header__mobile-button');
            this.logoContainer = this.pageHeader.find('.page-header__logo-container');
            this.pageHeaderCloseButton = this.pageHeader.find('.page-header__close-button');
            this.secondLevelItems = this.pageHeader.find('.main-menu__sublist-item');
            this.secondLevelLinks = this.pageHeader.find('.main-menu__deeper-list-link');
            this.deeperLevelList = this.pageHeader.find('.main-menu__deeper-level-list');
            this.deeperLevelItems = this.pageHeader.find('.main-menu__deeper-list-item');
            this.deeperLevelLinks = this.pageHeader.find('.main-menu__deeper-list-link');
            this.micrositeNavigation = this.pageHeader.find('.page-header__microsite-navigation');
            this.micrositeVerticalText = this.pageHeader.find('.page-header__vertical-text');
            this.micrositeButton = this.pageHeader.find('.page-header__microsite-button');

            this.addClassToBody();
            this.checkDeeperLevelSubmenuExistance();

            this.mainMenuButton.on('click', this.openMenu.bind(this));
            this.mobileMenuButton.on('click', this.openMenuOnMobile.bind(this));
            this.closeMobileButton.on('click', this.closeMenu.bind(this));
            this.pageContent.on('click', this.closeMenu.bind(this));
            this.pageHeaderCloseButton.on('click', this.closeMenu.bind(this));
            this.deeperLevelLinks.on('click', this.showDeeperMenuLevel.bind(this));
        }

        VerticalMenu.prototype.addClassToBody = function() {
            if (this.container.hasClass('main-menu--opened')) {
                this.body.addClass('opened');
            } else {
                this.body.removeClass('opened');
            }
        };

        VerticalMenu.prototype.closeMenu = function(e) {
            e.preventDefault();

            this.mainMenuContainer.removeClass('page-header__container--opened');
            this.container.removeClass('main-menu--opened');
            this.secondLevelList.removeClass('main-menu__sublist--active');
            this.body.removeClass('opened');

            if (this.container.hasClass('main-menu--microsite')) {
                this.micrositeNavigation.removeClass('page-header__microsite-navigation--hidden');
            } else {
                this.mainMenuButton.removeClass('main-menu__item-link--active');
            }
            if ($(window).width() <= 959) {
                this.mainMenuContainer.removeClass('page-header__container--visible')
                this.mobileMenuButton.removeClass('page-header__mobile-button--hidden');
            }

            this.pageHeader.removeClass('page-header--opened');
            this.body.removeClass('no-scroll');
            this.pageWrap.removeClass('fixed');

            this.togglePageScrolling();
            this.addClassToBody();
            this.setSubmenuInitialValues();
        };

        VerticalMenu.prototype.openMenu = function(e) {
            var clickedButton = $(e.currentTarget);
            var secondLevelList = clickedButton.siblings('.main-menu__sublist');

            if (secondLevelList.length !== 0) {
                e.preventDefault();
                clickedButton.addClass('main-menu__item-link--active');
                secondLevelList.addClass('main-menu__sublist--active');

                this.mainMenuButton.not(clickedButton).removeClass('main-menu__item-link--active');
                this.secondLevelList.not(secondLevelList).removeClass('main-menu__sublist--active');

                this.mainMenuContainer.addClass('page-header__container--opened');
                this.container.addClass('main-menu--opened');

                this.pageHeader.addClass('page-header--opened');
                this.body.addClass('no-scroll');
                this.pageWrap.addClass('fixed');

                this.addClassToBody();
                this.setSubmenuInitialValues();

            }
        }

        VerticalMenu.prototype.openMenuOnMobile = function(e) {
            e.preventDefault();

            this.mobileMenuButton.addClass('page-header__mobile-button--hidden');
            this.mainMenuContainer.addClass('page-header__container--visible page-header__container--opened');
            this.container.addClass('main-menu--opened');
            this.pageHeader.addClass('page-header--opened');
            this.body.addClass('opened');

            if (this.mobileMenuButton.hasClass('page-header__mobile-button--microsite')) {
                this.secondLevelList.addClass('main-menu__sublist--active');
            }

            this.addClassToBody();
            this.togglePageScrolling();

            if ($(window).width() < 960) {
                if (this.deeperLevelLinks.hasClass('main-menu__deeper-list-link--current-page')) {
                    var currentPageLink = this.deeperLevelLinks.filter('.main-menu__deeper-list-link--current-page');
                    var closestSublist = currentPageLink.closest('.main-menu__deeper-level-list');
                    var currentPageParentSublists =  currentPageLink.parents('.main-menu__deeper-level-list');
                    var items = closestSublist.parents('.main-menu__deeper-list-item').siblings();
                    var topSublist = currentPageLink.parents('.main-menu__sublist');
                    var topItemLink = topSublist.siblings('.main-menu__item-link');
                    var topItem = topSublist.parents('.main-menu__item');

                    topSublist.addClass('main-menu__sublist--active');
                    topItemLink.addClass('main-menu__item-link--active');
                    this.mainMenuButton.not(topItemLink).removeClass('main-menu__item-link--active');
                    this.secondLevelList.not(topSublist).removeClass('main-menu__sublist--active');

                    currentPageLink.addClass('main-menu__deeper-list-link--current');
                    closestSublist.addClass('main-menu__deeper-level-list--visible');
                    currentPageParentSublists.addClass('main-menu__deeper-level-list--visible');
                    currentPageParentSublists.siblings().addClass('main-menu__deeper-list-link--current').hide();
                    items.addClass('main-menu__deeper-list-item--hidden');
                }
            }

            if (this.body.hasClass('ipad')) {
                this.pageHeader.addClass('page-header--opened');
                this.body.addClass('no-scroll');
                this.pageWrap.addClass('fixed');
            }
        }

        VerticalMenu.prototype.checkDeeperLevelSubmenuExistance = function() {
            if ($(window).width() <= 959){
                this.deeperLevelItems.each(function(i, e){
                    if($(e).has('.main-menu__deeper-level-list').length !== 0) {
                        $(e).children('.main-menu__deeper-list-link').addClass('main-menu__deeper-list-link--arrow-right');
                    }
                });
            }
        };

        VerticalMenu.prototype.showDeeperMenuLevel = function(el) {
            var clickedLink = $(el.target);
            var sublist = clickedLink.siblings('.main-menu__deeper-level-list');
            var clickedLinkParent = clickedLink.parent();
            var clickedLinkParentSiblings = clickedLinkParent.siblings();
            var clickedLinkGrandfather = clickedLinkParent.parent();

            if ($(window).width() <= 959) {
                if ((clickedLink.siblings('.main-menu__deeper-level-list').length !== 0) && !(clickedLink.hasClass('main-menu__deeper-list-link--back'))) {
                    el.preventDefault();
                    clickedLink.hide();

                    clickedLinkParentSiblings.addClass('main-menu__deeper-list-item--hidden');
                    sublist.addClass('main-menu__deeper-level-list--visible');
                } else if (clickedLink.hasClass('main-menu__deeper-list-link--back')){
                    el.preventDefault();
                    var sublistParent = clickedLink.closest('.main-menu__deeper-level-list');

                    sublistParent.removeClass('main-menu__deeper-level-list--visible');
                    setTimeout(function(){
                        sublistParent.siblings('.main-menu__deeper-list-link').show();
                        sublistParent.closest('.main-menu__deeper-list-item').siblings().removeClass('main-menu__deeper-list-item--hidden');
                    }.bind(this), 200);
                }
            }
        };

        VerticalMenu.prototype.setSubmenuInitialValues = function(e) {
            this.secondLevelLinks.show();
            this.deeperLevelLinks.show();
            this.deeperLevelList.children().removeClass('main-menu__deeper-list-item--hidden');
            this.deeperLevelItems.removeClass('main-menu__deeper-list-item--hidden');
            this.deeperLevelList.removeClass('main-menu__deeper-level-list--visible').removeAttr('style');

            this.deeperLevelItems.filter('.main-menu__deeper-list-item--current')
                .children('.main-menu__deeper-list-link').addClass('main-menu__deeper-list-link--current');

            this.checkDeeperLevelSubmenuExistance();
        }

        VerticalMenu.prototype.togglePageScrolling = function(e) {
            if ($(window).width() < 1025 && this.container.hasClass('main-menu--opened')) {
                $('html, body').addClass('no-scroll');
            } else {
                $('html, body').removeClass('no-scroll');
            }
        }

        jQuery.fn.verticalMenu = function() {
            return jQuery(this).each(function() {
                new VerticalMenu(jQuery(this));
            });
        };

        module.exports = {
            VerticalMenu: VerticalMenu
        };
    },{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzY3JpcHRzL3NpdGUuanMiLCJub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzIiwic2NyaXB0cy9saWJzL2ltYWdlZmlsbC5qcyIsInNjcmlwdHMvbGlicy9pbWFnZXNsb2FkZWQuanMiLCJzY3JpcHRzL2xpYnMvb2JqZWN0X2ZpdC5qcyIsInNjcmlwdHMvbGlicy9zdGlja3kuanMiLCJzY3JpcHRzL3V0aWxzL2RlYm91bmNlLmpzIiwic2NyaXB0cy91dGlscy9kZXRlY3QuanMiLCJzY3JpcHRzL3V0aWxzL2dlc3R1cmVzLmpzIiwic2NyaXB0cy91dGlscy9udW1iZXJzLmpzIiwic2NyaXB0cy91dGlscy9zZXR0aW5ncy5qcyIsInNjcmlwdHMvdXRpbHMvc2lnbmFsLmpzIiwic2NyaXB0cy91dGlscy9zbWFydF9ibG9ja3MuanMiLCJzY3JpcHRzL3V0aWxzL3Rocm90dGxlLmpzIiwic2NyaXB0cy91dGlscy90cmFuc2xhdGUuanMiLCJzY3JpcHRzL3V0aWxzL3ZpZXdwb3J0LmpzIiwic2NyaXB0cy92ZW5kb3JzL293bC5hdXRvcGxheS5qcyIsInNjcmlwdHMvdmVuZG9ycy9vd2wuY2Fyb3VzZWwuanMiLCJzY3JpcHRzL3ZlbmRvcnMvc3RhY2tibHVyLmpzIiwic2NyaXB0cy92ZW5kb3JzL3N0aWNreS1raXQuanMiLCJzY3JpcHRzL3dpZGdldHMvYWpheC1hcGkuanMiLCJzY3JpcHRzL3dpZGdldHMvY29sbGFwc2UuanMiLCJzY3JpcHRzL3dpZGdldHMvZXF1YWxfd2lkdGguanMiLCJzY3JpcHRzL3dpZGdldHMvaG9tZS5qcyIsInNjcmlwdHMvd2lkZ2V0cy9qY2YuY2hlY2tib3guanMiLCJzY3JpcHRzL3dpZGdldHMvamNmLmZpbGUuanMiLCJzY3JpcHRzL3dpZGdldHMvamNmLmpzIiwic2NyaXB0cy93aWRnZXRzL2pjZi5yYWRpby5qcyIsInNjcmlwdHMvd2lkZ2V0cy9qY2Yuc2Nyb2xsYWJsZS5qcyIsInNjcmlwdHMvd2lkZ2V0cy9qY2Yuc2VsZWN0LmpzIiwic2NyaXB0cy93aWRnZXRzL2pjZi50ZXh0YXJlYS5qcyIsInNjcmlwdHMvd2lkZ2V0cy9wdWJsaWNhdGlvbi1zY3JvbGwuanMiLCJzY3JpcHRzL3dpZGdldHMvcmVsYXRlZF9zZWFyY2hfYm94LmpzIiwic2NyaXB0cy93aWRnZXRzL3NlYXJjaC1maWx0ZXJzLmpzIiwic2NyaXB0cy93aWRnZXRzL3NlYXJjaGJveC5qcyIsInNjcmlwdHMvd2lkZ2V0cy9zbGlkZXIuanMiLCJzY3JpcHRzL3dpZGdldHMvdGhyb3R0bGUuanMiLCJzY3JpcHRzL3dpZGdldHMvdG9wLW1lbnUuanMiLCJzY3JpcHRzL3dpZGdldHMvdmFsaWRhdGUuanMiLCJzY3JpcHRzL3dpZGdldHMvdmVydGljYWwtbWVudS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGxUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2c0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNybUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0cEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDellBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCI7KGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB3aW5kb3cuJCA9IHdpbmRvdy5qUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcbiAgICByZXF1aXJlKCcuL3dpZGdldHMvamNmJyk7XG4gICAgcmVxdWlyZSgnLi93aWRnZXRzL2pjZi5zZWxlY3QnKTtcbiAgICByZXF1aXJlKCcuL3dpZGdldHMvamNmLnJhZGlvJyk7XG4gICAgcmVxdWlyZSgnLi93aWRnZXRzL2pjZi5jaGVja2JveCcpO1xuICAgIHJlcXVpcmUoJy4vd2lkZ2V0cy9qY2YuZmlsZScpO1xuICAgIHJlcXVpcmUoJy4vd2lkZ2V0cy9qY2YudGV4dGFyZWEnKTtcbiAgICByZXF1aXJlKCcuL3dpZGdldHMvamNmLnNjcm9sbGFibGUnKTtcbiAgICByZXF1aXJlKCcuL3dpZGdldHMvY29sbGFwc2UnKTtcbiAgICByZXF1aXJlKCcuL2xpYnMvc3RpY2t5LmpzJyk7XG4gICAgcmVxdWlyZSgnLi9saWJzL2ltYWdlZmlsbC5qcycpO1xuICAgIHJlcXVpcmUoJy4vbGlicy9pbWFnZXNsb2FkZWQuanMnKTtcbiAgICByZXF1aXJlKCcuL3V0aWxzL2RlYm91bmNlLmpzJyk7XG4gICAgcmVxdWlyZSgnLi91dGlscy90aHJvdHRsZS5qcycpO1xuICAgIC8vIHJlcXVpcmUoJ2dzYXAnKTtcbiAgICByZXF1aXJlICgnLi92ZW5kb3JzL3N0aWNreS1raXQnKTtcbiAgICByZXF1aXJlKCcuL3ZlbmRvcnMvb3dsLmNhcm91c2VsLmpzJyk7XG4gICAgcmVxdWlyZSgnLi92ZW5kb3JzL293bC5hdXRvcGxheS5qcycpO1xuICAgIHZhciB2aWV3cG9ydCA9IHJlcXVpcmUoJy4vdXRpbHMvdmlld3BvcnQnKTtcbiAgICB2YXIgc21hcnRCbG9ja3MgPSByZXF1aXJlKCcuL3V0aWxzL3NtYXJ0X2Jsb2NrcycpO1xuICAgIHZhciBkZXRlY3QgPSByZXF1aXJlKCcuL3V0aWxzL2RldGVjdCcpO1xuICAgIHZhciB0cmFuc2xhdGUgPSByZXF1aXJlKCcuL3V0aWxzL3RyYW5zbGF0ZScpO1xuICAgIHZhciBTbGlkZXIgPSByZXF1aXJlKCcuL3dpZGdldHMvc2xpZGVyJyk7XG4gICAgdmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi93aWRnZXRzL3ZhbGlkYXRlJyk7XG4gICAgdmFyIHRocm90dGxlID0gcmVxdWlyZSgnLi93aWRnZXRzL3Rocm90dGxlJyk7XG4gICAgdmFyIGFqYXhBcGkgPSByZXF1aXJlKCcuL3dpZGdldHMvYWpheC1hcGknKTtcbiAgICAvL3ZhciBtZW51ID0gcmVxdWlyZSgnLi93aWRnZXRzL21lbnUnKTtcbiAgICB2YXIgdmVydGljYWxNZW51ID0gcmVxdWlyZSgnLi93aWRnZXRzL3ZlcnRpY2FsLW1lbnUnKTtcbiAgICB2YXIgdG9wTWVudSA9IHJlcXVpcmUoJy4vd2lkZ2V0cy90b3AtbWVudScpO1xuICAgIHZhciBzZWFyY2hib3ggPSByZXF1aXJlKCcuL3dpZGdldHMvc2VhcmNoYm94Jyk7XG4gICAgdmFyIHNlYXJjaEZpbHRlcnMgPSByZXF1aXJlKCcuL3dpZGdldHMvc2VhcmNoLWZpbHRlcnMnKTtcbiAgICB2YXIgcmVsYXRlZEJveCA9IHJlcXVpcmUoJy4vd2lkZ2V0cy9yZWxhdGVkX3NlYXJjaF9ib3gnKTtcbiAgICB2YXIgb2JqZWN0Rml0ID0gcmVxdWlyZSgnLi9saWJzL29iamVjdF9maXQuanMnKTtcbiAgICB2YXIgZXF1YWxXaWR0aCA9IHJlcXVpcmUoJy4vd2lkZ2V0cy9lcXVhbF93aWR0aCcpO1xuICAgIHZhciBwdWJsaWNhdGlvblNjcm9sbCA9IHJlcXVpcmUoJy4vd2lkZ2V0cy9wdWJsaWNhdGlvbi1zY3JvbGwnKTtcbiAgICB2YXIgSG9tZSA9IHJlcXVpcmUoJy4vd2lkZ2V0cy9ob21lJyk7XG4gICAgdmFyIFN0YWNrQmx1ciA9IHJlcXVpcmUoXCIuL3ZlbmRvcnMvc3RhY2tibHVyXCIpO1xuXG4gICAgZnVuY3Rpb24gU2l0ZSgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHZpZXdwb3J0LmVuYWJsZSgpO1xuICAgICAgICBzbWFydEJsb2Nrcy5lbmFibGUoKTtcblxuICAgICAgICB2aWV3cG9ydC5vbkNoYW5nZS5jb25uZWN0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUHV0IHRoZXJlIGNvZGUgdG8gYmUgZXhlY3V0ZWQgd2hlbiB2aWV3cG9ydCBpcyBjaGFuZ2VkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGpRdWVyeSh3aW5kb3cpLm9uKCdya3ctYWpheC1hcGktY29udGVudC1jaGFuZ2VkJywgdGhpcy5vbkFqYXhDb250ZW50Q2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgalF1ZXJ5KHdpbmRvdykub24oJ3Jrdy1hamF4LWFwaS1wdXNoLXN0YXRlJywgdGhpcy5vbkFqYXhBcGlQdXNoU3RhdGUuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgdGhpcy5wYXJzZUNvbnRlbnQoZG9jdW1lbnQuYm9keSk7XG5cbiAgICAgICAgalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5oaXN0b3J5LnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGpzb24gPSBqUXVlcnkucGFyc2VKU09OKHdpbmRvdy5oaXN0b3J5LnN0YXRlKTtcblxuICAgICAgICAgICAgICAgIGpRdWVyeSgnIycgKyBqc29uLnBhcmVudCkuZW1wdHkoKS5hcHBlbmQoanNvbi5kYXRhKTtcbiAgICAgICAgICAgICAgICBzZWxmLnBhcnNlQ29udGVudChqUXVlcnkoJyMnICsganNvbi5wYXJlbnQpWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBUeXBla2l0LmxvYWQoe1xuICAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgYWN0aXZlOiBmdW5jdGlvbigpIHsgc2V0VGltZW91dChcImpRdWVyeSh3aW5kb3cpLnRyaWdnZXIoJ2ZvbnQtcmVsb2FkJyk7IGpRdWVyeSgnLnRvcC1tZW51JykuYWRkQ2xhc3MoJ3RvcC1tZW51LS1mb250LXJlbG9hZC1zaG93Jyk7XCIsIDUwMCk7IH0sXG4gICAgICAgICAgICAgICAgIGluYWN0aXZlOiBmdW5jdGlvbigpIHsgalF1ZXJ5KCcudG9wLW1lbnUnKS5hZGRDbGFzcygndG9wLW1lbnUtLWZvbnQtcmVsb2FkLXNob3cnKTt9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICBqUXVlcnkoJy50b3AtbWVudScpLmFkZENsYXNzKCd0b3AtbWVudS0tZm9udC1yZWxvYWQtc2hvdycpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBTaXRlLnByb3RvdHlwZS5wYXJzZUNvbnRlbnQgPSBmdW5jdGlvbihyb290KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZpbmQoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkocm9vdCkuaXMoc2VsZWN0b3IpID8galF1ZXJ5KHJvb3QpIDogalF1ZXJ5KHJvb3QpLmZpbmQoJyonKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIC8qIEZvcm1zICovXG4gICAgICAgIGZpbmQoJ3NlbGVjdDpub3QoLm5vLWpjZiknKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgamNmLnJlcGxhY2UoalF1ZXJ5KHRoaXMpLCAnU2VsZWN0Jywge1xuICAgICAgICAgICAgICAgIHdyYXBOYXRpdmU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbmQoJ2lucHV0OmNoZWNrYm94Om5vdCgubm8tamNmKScpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBqY2YucmVwbGFjZShqUXVlcnkodGhpcyksICdDaGVja2JveCcsIHsnd3JhcE5hdGl2ZSc6IHRydWV9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbmQoJ2lucHV0OnJhZGlvOm5vdCgubm8tamNmKScpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoalF1ZXJ5KHRoaXMpLmNsb3Nlc3QoJy5maWx0ZXInKS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgamNmLnJlcGxhY2UoalF1ZXJ5KHRoaXMpLCAnUmFkaW8nLCB7J3dyYXBOYXRpdmUnOiB0cnVlfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBmaW5kKCdpbnB1dFt0eXBlPVwiZmlsZVwiXTpub3QoLm5vLWpjZiknKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGpRdWVyeSh0aGlzKS5jbG9zZXN0KCcuZmlsdGVyJykubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIGpjZi5yZXBsYWNlKGpRdWVyeSh0aGlzKSwgJ0ZpbGUnLCB7XG4gICAgICAgICAgICAgICAgICAgICd3cmFwTmF0aXZlJzogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbmQoJ2Zvcm0udmFsaWRhdGUnKS52YWxpZGF0ZSgpO1xuXG4gICAgICAgIC8qIFNsaWRlciAqL1xuICAgICAgICBmaW5kKCcuc2xpZGVyJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG5ldyBTbGlkZXIoalF1ZXJ5KHRoaXMpLCB7XG4gICAgICAgICAgICAgICAgJ21vZGUnOiBTbGlkZXIuTU9ERV9DQVJPVVNFTCxcbiAgICAgICAgICAgICAgICAnYXJyb3dzJzogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvKiBBY2NvcmRpb24gKi9cbiAgICAgICAgalF1ZXJ5KCcuYWNjb3JkaW9uLXRyaWdnZXInKS5jbGljayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgYWNjb3JkaW9uID0galF1ZXJ5KHRoaXMpLnBhcmVudCgnLmFjY29yZGlvbl9faXRlbScpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBqUXVlcnkodGhpcykubmV4dCgnLmFjY29yZGlvbi1jbnQnKTtcbiAgICAgICAgICAgIGNvbnRlbnQuc3RvcCh0cnVlKS5zbGlkZVRvZ2dsZSgpO1xuXG4gICAgICAgICAgICBpZiAoYWNjb3JkaW9uLmhhc0NsYXNzKCdhY2NvcmRpb25fX2l0ZW0tLW9wZW4nKSlcbiAgICAgICAgICAgICAgICBhY2NvcmRpb24ucmVtb3ZlQ2xhc3MoJ2FjY29yZGlvbl9faXRlbS0tb3BlbicpXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgb3BlbkFjY29yZGlvbiA9IGpRdWVyeSgnLmFjY29yZGlvbl9faXRlbS0tb3BlbicpO1xuICAgICAgICAgICAgICAgIG9wZW5BY2NvcmRpb24ucmVtb3ZlQ2xhc3MoJ2FjY29yZGlvbl9faXRlbS0tb3BlbicpO1xuICAgICAgICAgICAgICAgIG9wZW5BY2NvcmRpb24uZmluZCgnLmFjY29yZGlvbi1jbnQnKS5zdG9wKHRydWUpLnNsaWRlVXAoKVxuICAgICAgICAgICAgICAgIGFjY29yZGlvbi5hZGRDbGFzcygnYWNjb3JkaW9uX19pdGVtLS1vcGVuJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyogQ29sbGFwc2VkIHRleHQgKi9cbiAgICAgICAgalF1ZXJ5KCcuY29sbGFwc2VkLXRleHQnKS5jb2xsYXBzZSgpO1xuXG5cbiAgICAgICAgLy8gcmVtb3ZlIGF0dHJpYnMgc2luY2UgdGhleSBhcmUgYnJlYWtpbmcgdGhlIHpvb21pbmdcbiAgICAgICAgalF1ZXJ5KCcuYm94IGZpZ3VyZSBpbWcnKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLnJlbW92ZUF0dHIoJ3dpZHRoJykucmVtb3ZlQXR0cignaGVpZ2h0Jyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGpRdWVyeSgnLmJveCAuYm94LWNvbnRlbnQgZmlndXJlJykuZWFjaChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgLy8gd2UgZG8gdGhpcyB2aWEgY3NzIG9iamVjdC1maXQgbm93IVxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIGpRdWVyeSh0aGlzKS5maW5kKCdpbWcnKS5sb2FkKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLnBhcmVudCgpLnBhcmVudCgpLmltYWdlZmlsbCgpO1xuICAgICAgICAgICAgfSkuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLnRyaWdnZXIoJ2xvYWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBqUXVlcnkodGhpcykuZmluZCgnaW1nJykub25lKFwibG9hZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkodGhpcykucGFyZW50KCkucGFyZW50KCkuaW1hZ2VmaWxsKCk7XG5cbiAgICAgICAgICAgIH0pLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYoalF1ZXJ5KHRoaXMpLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSh0aGlzKS5sb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGpRdWVyeSh0aGlzKS5hdHRyKCdzcmMnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7Ki9cblxuICAgICAgICB9KTtcblxuICAgICAgICBmaW5kKCcuYWpheCwgLmFqYXgtZmVlZGJhY2ssIC5hamF4IC5hamF4LW92ZXJyaWRlLCAuYWpheCAuYWpheC1zZW5kLCAuYWpheCAuYWpheC1vdmVycmlkZS1zdWJtaXQsIC5hamF4IGlucHV0LCAuYWpheCB0ZXh0YXJlYSwgLmFqYXggc2VsZWN0JykuYWpheEFwaSgpO1xuXG4gICAgICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICAgICAgLyogUHV0IG93biBzY3JpcHRzIGhlcmUgKi9cblxuICAgICAgICBmaW5kKCcudG9nZ2xlLXByb2plY3QnKS5jbGljayhmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgdmFyIGxpbmsgPSBqUXVlcnkodGhpcyk7XG4gICAgICAgICAgICB2YXIgdGFiTmFtZSA9IGxpbmsuZGF0YSgndG9nZ2xlJyk7XG4gICAgICAgICAgICB2YXIgdG9nZ2xlZENvbnRlbnQgPSBqUXVlcnkoJ1tkYXRhLXRhYj1cIicgKyB0YWJOYW1lICsgJ1wiXScpO1xuICAgICAgICAgICAgdmFyIGJvZHlDbGFzc2VzID0gZG9jdW1lbnQuYm9keS5jbGFzc0xpc3Q7XG4gICAgICAgICAgICB2YXIgYXJyYXlCb2R5Q2xhc3NlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJvZHlDbGFzc2VzKTtcbiAgICAgICAgICAgIHZhciBwdWJsaWNhdGlvbkRldGFpbHMgPSBqUXVlcnkoJy5wdWJsaWNhdGlvbi1kZXRhaWxzLS1jaGFwdGVyJyk7XG5cbiAgICAgICAgICAgIGlmICghalF1ZXJ5KCdib2R5JykuZmluZCgnLnB1YmxpY2F0aW9uLWRldGFpbHMnKS5oYXNDbGFzcygncHVibGljYXRpb24tZGV0YWlscy0tY2hhcHRlcicpICYmIHRvZ2dsZWRDb250ZW50LmNzcygnZGlzcGxheScpID09PSAnbm9uZScgJiYgd2luZG93LnNjcm9sbFkgPCAyNTApIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgd2luZG93LnNjcm9sbFkgKyAyMDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHVibGljYXRpb25EZXRhaWxzLmhhc0NsYXNzKCdpc19zdHVjaycpKSB7XG4gICAgICAgICAgICAgICAgdG9nZ2xlZENvbnRlbnQuY3NzKCd0b3AnLCBwdWJsaWNhdGlvbkRldGFpbHMub2Zmc2V0KCkudG9wIC0gcHVibGljYXRpb25EZXRhaWxzLmhlaWdodCgpICsgMzIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2dnbGVkQ29udGVudC5jc3MoJ3RvcCcsICdpbml0aWFsJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChqUXVlcnkoJ2JvZHknKS5maW5kKCcucHJvamVjdC1kZXRhaWxzJykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnREZXRhaWxzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgncHVibGljYXRpb24tZGV0YWlscycpO1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50VGFibGUgPSBqUXVlcnkoJ2JvZHknKS5maW5kKCcucHVibGljYXRpb25zLWNvbnRlbnRzLXRhYmxlJyk7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9ICQod2luZG93KS5oZWlnaHQoKSAtIGNvbnRlbnREZXRhaWxzWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtIGNvbnRlbnREZXRhaWxzWzBdLm9mZnNldEhlaWdodCAtIDUwO1xuXG4gICAgICAgICAgICAgICAgY29udGVudFRhYmxlLmhlaWdodChoZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgalF1ZXJ5KCdodG1sJykudG9nZ2xlQ2xhc3MoJ25vLXNjcm9sbCcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFycmF5Qm9keUNsYXNzZXMuaW5kZXhPZignaXBhZCcpICE9PSAtMSB8fCBhcnJheUJvZHlDbGFzc2VzLmluZGV4T2YoJ2lwaG9uZScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5KCdodG1sJykuaGFzQ2xhc3MoJ25vLXNjcm9sbCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkoJy5wYWdlLXdyYXAnKS5hZGRDbGFzcygnZml4ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeSgnLnBhZ2Utd3JhcCcpLmNzcygndG9wJywgLXBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gLXBhcnNlSW50KGpRdWVyeSgnLnBhZ2Utd3JhcCcpLmNzcygndG9wJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCcucGFnZS13cmFwJykucmVtb3ZlQ2xhc3MoJ2ZpeGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkoJy5wYWdlLXdyYXAnKS5yZW1vdmVBdHRyKCdzdHlsZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluay5maW5kKCc+c3BhbicpLnRvZ2dsZUNsYXNzKCdpY29uLWFycm93LXJpZ2h0JykudG9nZ2xlQ2xhc3MoJ2ljb24tYXJyb3ctZG93bicpO1xuICAgICAgICAgICAgdG9nZ2xlZENvbnRlbnQuc2xpZGVUb2dnbGUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZmluZCgnLnByZS1xdWVyaWVzLWl0ZW0nKS5jbGljayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBqUXVlcnkoJy5zZWFyY2hib3ggLnNlYXJjaCcpLnZhbChqUXVlcnkodGhpcykuZGF0YSgncXVlcnknKSk7XG4gICAgICAgICAgICBpZiAoalF1ZXJ5KHRoaXMpLmRhdGEoJ2ZpbHRlci1pZCcpKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KCcjJyArIGpRdWVyeSh0aGlzKS5kYXRhKCdmaWx0ZXItaWQnKSkuY2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmb3JtID0galF1ZXJ5KCcuc2VhcmNoYm94JykuY2xvc2VzdCgnZm9ybScpO1xuICAgICAgICAgICAgZm9ybS5zdWJtaXQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZmluZCgnLmNvbnRhY3QtaW5mbyAucGhvbmUnKS5jbGljayhmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgdmFyIHBob25lID0galF1ZXJ5KHRoaXMpO1xuICAgICAgICAgICAgdmFyIG1haWwgPSBwaG9uZS5wYXJlbnQoKS5uZXh0KCk7XG5cbiAgICAgICAgICAgIHBob25lLnBhcmVudCgpLnRvZ2dsZUNsYXNzKCdzaG93Jyk7XG4gICAgICAgICAgICBwaG9uZS50b2dnbGVDbGFzcygndGV4dC1oaWRlJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZpbmQoJy50b3AtbWVudScpLnRvcE1lbnUoKTtcblxuICAgICAgICBmaW5kKCcubWFpbi1tZW51JykudmVydGljYWxNZW51KCk7XG5cbiAgICAgICAgZmluZCgnLnB1YmxpY2F0aW9uLWRldGFpbHMtLWNoYXB0ZXInKS5wdWJsaWNhdGlvblNjcm9sbCgpO1xuXG4gICAgICAgIC8vIGZpbmQoJy5hcnRpY2xlLW1lbnUnKS5hcnRpY2xlTWVudSgpO1xuXG4gICAgICAgIC8vIGZpbmQoJy5jb250ZW50LW1lbnU6bm90KC5zdGlja3kpJykuY29udGVudE1lbnUoKTtcblxuICAgICAgICBmaW5kKCcuc3VibWVudS1jb250YWluZXInKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBqUXVlcnkodGhpcyk7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsYWJsZUNvbnRhaW5lciA9IGVsZW1lbnQuZmluZCgnPionKTtcbiAgICAgICAgICAgIHZhciBhZGRpdGlvbmFsSGVpZ2h0ID0gMDtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2xvc2VzdCgnLmNvbnRlbnQtbWVudS5zdGlja3knKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsSGVpZ2h0ID0gZWxlbWVudC5jbG9zZXN0KCcuY29udGVudC1tZW51LnN0aWNreScpLm91dGVySGVpZ2h0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2V0TWF4SGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zaG93KCk7XG4gICAgICAgICAgICAgICAgc2Nyb2xsYWJsZUNvbnRhaW5lci5jc3MoJ21heC1oZWlnaHQnLCBlbGVtZW50LmhlaWdodCgpKTtcbiAgICAgICAgICAgICAgICBqY2YucmVwbGFjZShzY3JvbGxhYmxlQ29udGFpbmVyLCAnU2Nyb2xsYWJsZScsIHtcbiAgICAgICAgICAgICAgICAgICAgYWx3YXlzUHJldmVudE1vdXNlV2hlZWw6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmhpZGUoKTtcbiAgICAgICAgICAgIH0sIDI1MCk7XG5cbiAgICAgICAgICAgIGpRdWVyeShkb2N1bWVudCkub24oJ3N1Ym1lbnVVcGRhdGVkJywgdXBkYXRlU2Nyb2xsKTtcbiAgICAgICAgICAgIGpRdWVyeSh3aW5kb3cpLnJlc2l6ZShqUXVlcnkuZGVib3VuY2UoMjUwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZXRNYXhIZWlnaHQoKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVTY3JvbGwoKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGVsZW1lbnQub24oJ3VwZGF0ZVNjcm9sbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNldE1heEhlaWdodCgpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVNjcm9sbCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNldE1heEhlaWdodCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2luZG93SGVpZ2h0ID0gdmlld3BvcnQuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlckhlaWdodCA9IGpRdWVyeSgnaGVhZGVyJykub3V0ZXJIZWlnaHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudEhlaWdodCA9IHdpbmRvd0hlaWdodCAtIGhlYWRlckhlaWdodCAtIGFkZGl0aW9uYWxIZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5hdHRyKCdkYXRhLW1heC1oZWlnaHQnKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRIZWlnaHQgPSBwYXJzZUludChlbGVtZW50LmF0dHIoJ2RhdGEtbWF4LWhlaWdodCcpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbGVtZW50LnNob3coKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNzcygnbWF4LWhlaWdodCcsIGVsZW1lbnRIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuaGlkZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVTY3JvbGwoKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jc3MoJ29wYWNpdHknLCAwKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgc2Nyb2xsYWJsZUNvbnRhaW5lci5wYXJlbnQoKS5jc3Moe1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogJycsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogJycsXG4gICAgICAgICAgICAgICAgICAgICdtYXgtaGVpZ2h0JzogJydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzY3JvbGxhYmxlQ29udGFpbmVyLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgJ21heC1oZWlnaHQnOiAnJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNjcm9sbGFibGVDb250YWluZXIuY3NzKCdtYXgtaGVpZ2h0JywgZWxlbWVudC5oZWlnaHQoKSk7XG4gICAgICAgICAgICAgICAgamNmLnJlZnJlc2goc2Nyb2xsYWJsZUNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5oaWRlKCkuY3NzKCdvcGFjaXR5JywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBmaW5kKCcuc2VhcmNoYm94IC5zZWFyY2gnKS5zZWFyY2hib3goKTtcbiAgICAgICAgZmluZCgnLnNlYXJjaC1maWx0ZXInKS5zZWFyY2hGaWx0ZXJzKCk7XG5cbiAgICAgICAgZmluZCgnLm5leHQtcGFnZVtocmVmXScpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbGluayA9IGpRdWVyeSh0aGlzKTtcbiAgICAgICAgICAgIHZhciBib3hlc0NvbnRhaW5lciA9IGxpbmsucGFyZW50KCkucGFyZW50KCk7XG4gICAgICAgICAgICBib3hlc0NvbnRhaW5lci5maW5kKCcuYm94LWxvYWRpbmcnKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgaWYgKGxpbmsuaGFzQ2xhc3MoJ2F1dG9sb2FkJykpXG4gICAgICAgICAgICAgICAgalF1ZXJ5KHdpbmRvdykuc2Nyb2xsKGNoZWNrQm90dG9tKTtcblxuICAgICAgICAgICAgbGluay5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWpRdWVyeSh0aGlzKS5oYXNDbGFzcygnZGlzYWJsZWQnKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGxpbmsucmVtb3ZlQXR0cignaHJlZicpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgICAgICAgICBib3hlc0NvbnRhaW5lci5hcHBlbmQoJzxkaXYgY2xhc3M9XCJib3gtbG9hZGluZ1wiLz4nKTtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHdpbmRvdykuc2Nyb2xsVG9wKGpRdWVyeSh3aW5kb3cpLnNjcm9sbFRvcCgpIC0gMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrQm90dG9tKCkge1xuICAgICAgICAgICAgICAgIGlmIChqUXVlcnkod2luZG93KS5zY3JvbGxUb3AoKSArIGpRdWVyeSh3aW5kb3cpLmhlaWdodCgpID49IGpRdWVyeShkb2N1bWVudCkuaGVpZ2h0KCkgLSAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsaW5rLmhhc0NsYXNzKCdkaXNhYmxlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGRlbGV0ZSBkaXNhYmxlZCBtb3JlIGJveCBpZiB0aGlzIGlzIHRoZSBvbmx5IGVudHJ5IGluIHRoZSBib3ggbGlzdFxuICAgICAgICBmaW5kKCdkaXYuYm94LXdyYXBwZXIgLmJveC5kaXNhYmxlZDpmaXJzdC1jaGlsZCcpLnBhcmVudCgpLnJlbW92ZSgpO1xuICAgICAgICBmaW5kKCdkaXYgLmJveC5wdWJsaWNhdGlvbi5kaXNhYmxlZDpmaXJzdC1jaGlsZCcpLnBhcmVudCgpLnJlbW92ZSgpO1xuXG4gICAgICAgIC8vIHNjcm9sbCB0byBmaXJzdCBUWVBPMy1tZXNzYWdlIChpZiB0aGVyZSBpcyBvbmUpXG4gICAgICAgIGlmIChmaW5kKCcudHlwbzMtbWVzc2FnZXMnKS5maXJzdCgpLmxlbmd0aCA+IDApe1xuXG4gICAgICAgICAgICBqUXVlcnkoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlRGl2ID0gZmluZCgnLnR5cG8zLW1lc3NhZ2VzJykuZmlyc3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gbWVzc2FnZURpdi5vZmZzZXQoKS50b3A7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KCdodG1sLCBib2R5JykuYW5pbWF0ZSh7J3Njcm9sbFRvcCc6IG9mZnNldCAtIDEwMH0sIDEwMDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmaW5kKCcucHVibGljYXRpb25zLWNvbnRlbnRzLXRhYmxlX19jbG9zZS1pY29uJykub24oJ2NsaWNrJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgbGluayA9IGpRdWVyeSgnYm9keScpLmZpbmQoJy50b2dnbGUtcHJvamVjdCA+IHNwYW4nKTtcbiAgICAgICAgICAgIHZhciB0b2dnbGVkQ29udGVudCA9IGpRdWVyeSgnYm9keScpLmZpbmQoJy50b2dnbGVkLWNvbnRlbnQnKTtcbiAgICAgICAgICAgIHZhciBib2R5Q2xhc3NlcyA9IGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0O1xuICAgICAgICAgICAgdmFyIGFycmF5Qm9keUNsYXNzZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChib2R5Q2xhc3Nlcyk7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG5cbiAgICAgICAgICAgIGxpbmsucmVtb3ZlQ2xhc3MoJ2ljb24tYXJyb3ctZG93bicpLmFkZENsYXNzKCdpY29uLWFycm93LXJpZ2h0Jyk7XG4gICAgICAgICAgICB0b2dnbGVkQ29udGVudC5zbGlkZVVwKCk7XG4gICAgICAgICAgICBqUXVlcnkoJ2h0bWwnKS5yZW1vdmVDbGFzcygnbm8tc2Nyb2xsJyk7XG5cbiAgICAgICAgICAgIGlmIChhcnJheUJvZHlDbGFzc2VzLmluZGV4T2YoJ2lwYWQnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkoJy5wYWdlLXdyYXAnKS5yZW1vdmVDbGFzcygnZml4ZWQnKTtcbiAgICAgICAgICAgICAgICBqUXVlcnkoJy5wYWdlLXdyYXAnKS5yZW1vdmVBdHRyKCdzdHlsZScpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUb3AgPSBwb3NpdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICBmaW5kKCcucmVsYXRlZCcpLnJlbGF0ZWRTZWFyY2hCb3goKTtcblxuICAgICAgICBmaW5kKCcubWVzc2FnZS1ib3gnKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGJveCA9IGpRdWVyeSh0aGlzKTtcbiAgICAgICAgICAgIHZhciBib3hIZWlnaHQgPSBib3guaGVpZ2h0KCk7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0galF1ZXJ5KGJveC5kYXRhKCdmb3InKSk7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnQuY3NzKCdwb3NpdGlvbicpICE9PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmNzcygncG9zaXRpb24nLCAncmVsYXRpdmUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYm94LmNzcyh7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgdG9wOiAtKGJveEhlaWdodCArIDEwKSxcbiAgICAgICAgICAgICAgICBsZWZ0OiAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZmluZCgnLmJveGVzLWV4cGVydHMnKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGxhc3RMZXR0ZXIgPSAnJztcbiAgICAgICAgICAgIHZhciBncmlkID0galF1ZXJ5KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGJveGVzID0gZ3JpZC5maW5kKCcuYm94LmV4cGVydCcpO1xuXG4gICAgICAgICAgICBqUXVlcnkoJ2JvZHknKS5jbGljayhmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhY3RzQm94ID0gYm94ZXMuZmluZCgnLmNvbnRhY3QtaW5mby1ib3gnKTtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFjdHNPcGVuZXIgPSBib3hlcy5maW5kKCcuY29udGFjdC1ib3gtdG9nZ2xlJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWpRdWVyeSh0YXJnZXQpLmhhc0NsYXNzKCdjb250YWN0LWJveC10b2dnbGUnKSAmJiAhalF1ZXJ5KHRhcmdldCkuaGFzQ2xhc3MoJ2NvbnRhY3QtaW5mby1ib3gnKSAmJiBqUXVlcnkodGFyZ2V0KS5jbG9zZXN0KCcuY29udGFjdC1pbmZvLWJveCcpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250YWN0c0JveC5zbGlkZVVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3RzT3BlbmVyLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYm94ZXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm94ID0galF1ZXJ5KHRoaXMpO1xuICAgICAgICAgICAgICAgIHZhciBsZXR0ZXIgPSBib3guZmluZCgnLmxldHRlcicpLnRleHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFjdEJ1dHRvbiA9IGJveC5maW5kKCcuY29udGFjdC1ib3gtdG9nZ2xlJyk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhY3RCb3ggPSBib3guZmluZCgnLmNvbnRhY3QtaW5mby1ib3gnKTtcblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQodXBkYXRlQ29udGFjdEJveCwgMjUwKTtcbiAgICAgICAgICAgICAgICBqUXVlcnkod2luZG93KS5yZXNpemUoalF1ZXJ5LmRlYm91bmNlKDI1MCwgdXBkYXRlQ29udGFjdEJveCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RMZXR0ZXIgIT09IGxldHRlcikge1xuICAgICAgICAgICAgICAgICAgICBib3guYWRkQ2xhc3MoJ3Nob3ctbGV0dGVyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RMZXR0ZXIgPSBsZXR0ZXI7XG5cbiAgICAgICAgICAgICAgICBjb250YWN0QnV0dG9uLmNsaWNrKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLnRvZ2dsZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdEJveC5zbGlkZVRvZ2dsZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ29udGFjdEJveCgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdEJveC5zaG93KCkuY3NzKCdib3R0b20nLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlck9mZnNldCA9IGJveC5maW5kKCdoZWFkZXInKS5vZmZzZXQoKS50b3A7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXJQYWRkaW5nID0gcGFyc2VJbnQoYm94LmZpbmQoJ2hlYWRlcicpLmNzcygncGFkZGluZy10b3AnKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWN0T2Zmc2V0ID0gY29udGFjdEJveC5vZmZzZXQoKS50b3A7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWN0SGVpZ2h0ID0gY29udGFjdEJveC5oZWlnaHQoKTtcblxuICAgICAgICAgICAgICAgICAgICBjb250YWN0Qm94LmNzcygnYm90dG9tJywgY29udGFjdE9mZnNldCAtIGhlYWRlck9mZnNldCArIGNvbnRhY3RIZWlnaHQgKyBoZWFkZXJQYWRkaW5nICsgMTMpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdEJ1dHRvbi5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZpbmQoJy5ob21lYm94JykuSG9tZSgpO1xuXG4gICAgICAgIGZpbmQoJy5tYXAnKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG1hcCA9IGpRdWVyeSh0aGlzKTtcbiAgICAgICAgICAgIHZhciByZWdpb25zID0gbWFwLmZpbmQoJy5tYXBfX3JlZ2lvbicpO1xuICAgICAgICAgICAgdmFyIGJhZGdlID0galF1ZXJ5KCcubWFwX19tb3VzZW92ZXInKTtcblxuICAgICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgdmFyIGhvdXIgPSBkYXRlLmdldEhvdXJzKCk7XG5cbiAgICAgICAgICAgIGlmIChob3VyID49IDIwIHx8IGhvdXIgPD0gNykge1xuICAgICAgICAgICAgICAgIG1hcC5hZGRDbGFzcygnbWFwLS1uaWdodCcpO1xuICAgICAgICAgICAgICAgIGpRdWVyeSgnLnJlZ2lvbnMtbW9iaWxlJykuYWRkQ2xhc3MoJ3JlZ2lvbnMtbW9iaWxlLS1uaWdodCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGV0ZWN0LnRvdWNoKSB7XG4gICAgICAgICAgICAgICAgcmVnaW9ucy5vbigndG91Y2hzdGFydCcsIHNob3dCYWRnZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZ2lvbnMub24oJ21vdXNlZW50ZXInLCBzaG93QmFkZ2UpO1xuICAgICAgICAgICAgICAgIHJlZ2lvbnMub24oJ21vdXNlbGVhdmUnLCBoaWRlQmFkZ2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBzaG93QmFkZ2UoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZ2lvbiA9IGpRdWVyeSh0aGlzKTtcbiAgICAgICAgICAgICAgICBiYWRnZS5zaG93KCk7XG4gICAgICAgICAgICAgICAgYmFkZ2UuY3NzKHtsZWZ0OiByZWdpb24uZGF0YSgncG9zaXRpb24teCcpLCB0b3A6IHJlZ2lvbi5kYXRhKCdwb3NpdGlvbi15Jyl9KVxuICAgICAgICAgICAgICAgIGJhZGdlLmh0bWwoJzxzcGFuPicgKyByZWdpb24uZGF0YSgndGV4dCcpICsgJzwvc3Bhbj4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGhpZGVCYWRnZShldmVudCkge1xuICAgICAgICAgICAgICAgIGJhZGdlLmhpZGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWFwLmZpbmQoJ2EnKS5vbigndG91Y2hlbmQsIGNsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gJCh0aGlzKS5hdHRyKCdocmVmJyk7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uID0gdXJsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZpbmQoJ1tkYXRhLXNjcm9sbC10b10nKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGFuY2hvciA9ICQodGhpcyk7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gJChhbmNob3IuZGF0YSgnc2Nyb2xsLXRvJykpO1xuXG4gICAgICAgICAgICBhbmNob3IuY2xpY2soZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoJ2JvZHksIGh0bWwnKS5zdG9wKCkuYW5pbWF0ZSh7c2Nyb2xsVG9wOiB0YXJnZXQub2Zmc2V0KCkudG9wfSwgMjAwLCAnc3dpbmcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgICAgICAgZmluZCgnW2RhdGEtZXF1YWwtd2lkdGgtZ3JvdXBdJykuZWFjaChlcXVhbFdpZHRoLmhhbmRsZXIpO1xuXG4gICAgICAgIGlmICgoLypAY2Nfb24hQCovZmFsc2UgfHwgISFkb2N1bWVudC5kb2N1bWVudE1vZGUpIHx8ICghKC8qQGNjX29uIUAqL2ZhbHNlIHx8ICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSAmJiAhIXdpbmRvdy5TdHlsZU1lZGlhKSl7XG4gICAgICAgICAgICBmaW5kKCcucHVibGljYXRpb25zLWFydGljbGVfX3BpY3R1cmUnKS5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgdmFyIHBpY3R1cmUgPSBqUXVlcnkodGhpcyk7XG4gICAgICAgICAgICAgICAgdmFyIGltYWdlID0gcGljdHVyZS5maW5kKCcucHVibGljYXRpb25zLWFydGljbGVfX2ltYWdlJyk7XG4gICAgICAgICAgICAgICAgdmFyIGNhbnZhcyA9IHBpY3R1cmUuZmluZCgnLnB1YmxpY2F0aW9ucy1hcnRpY2xlX19jYW52YXMnKTtcbiAgICAgICAgICAgICAgICBjYW52YXMuc2hvdygpO1xuICAgICAgICAgICAgICAgIGpRdWVyeShpbWFnZSkucmVtb3ZlQ2xhc3MoJ3B1YmxpY2F0aW9ucy1hcnRpY2xlX19pbWFnZS0taGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgU3RhY2tCbHVyLmltYWdlKCdpbWFnZScsICdjYW52YXMnLCAxNiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGpRdWVyeShpbWFnZSkuYWRkQ2xhc3MoJ3B1YmxpY2F0aW9ucy1hcnRpY2xlX19pbWFnZS0taGlkZGVuJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVxdWFsV2lkdGgudXBkYXRlQWxsKCk7XG4gICAgICAgIHNtYXJ0QmxvY2tzLnVwZGF0ZVRyZWUocm9vdCk7XG4gICAgfTtcblxuXG4gICAgLy8gQ2FsbCBpdCBsaWtlIHRoaXM6XG4gICAgLy8galF1ZXJ5KGRvY3VtZW50KS50cmlnZ2VyKCdya3ctYWpheC1hcGktcHVzaC1zdGF0ZScsIFtqUXVlcnkoZG9jdW1lbnQpLmZpbmQoJy5zZWFyY2gtcmVzdWx0LXNlY3Rpb24nKSwgJ2h0dHA6Ly93d3cuZ29vZ2xlLmRlJywgJ1RpdGxlJ10pO1xuICAgIFNpdGUucHJvdG90eXBlLnB1c2hTdGF0ZSA9IGZ1bmN0aW9uKHJvb3QsIHVybCwgdGl0bGUpIHtcbiAgICAgICAgZnVuY3Rpb24gZmluZChzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeShyb290KS5pcyhzZWxlY3RvcikgPyBqUXVlcnkocm9vdCkgOiBqUXVlcnkocm9vdCkuZmluZCgnKicpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIC8qXG4gICAgICAgIHZhciBmb3JtID0gZmluZCgnZm9ybS5hamF4Jyk7XG4gICAgICAgIHZhciBzdGF0ZVVybCA9IGZvcm0uYXR0cignYWN0aW9uJyk7XG4gICAgICAgIHZhciBzdGF0ZURhdGEgPSBmb3JtLnNlcmlhbGl6ZUFycmF5KCk7XG4gICAgICAgIHZhciBzdGF0ZVRpdGxlID0gZm9ybS5hdHRyKCd0aXRsZScpID8gZm9ybS5hdHRyKCd0aXRsZScpIDogJ1NlYXJjaCc7XG4gICAgICAgICovXG5cbiAgICAgICAgLy8gY2xvbmUgZGF0YVxuICAgICAgICB2YXIgc3RhdGVSb290ID0galF1ZXJ5KHJvb3QpLmNsb25lKCk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGxvYWRpbmctaW5kaWNhdG9yIGFuZCBkZWFjdGl2YXRlIG1vcmUtbGlua3MgaW4gdGhpcyBjbG9uZVxuICAgICAgICBzdGF0ZVJvb3QuZmluZCgnLmJveC1sb2FkaW5nJykucmVtb3ZlKCk7XG4gICAgICAgIHN0YXRlUm9vdC5maW5kKCcubmV4dC1wYWdlW2hyZWZdJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBsaW5rID0galF1ZXJ5KHRoaXMpO1xuICAgICAgICAgICAgaWYgKGxpbmsuaGFzQ2xhc3MoJ2F1dG9sb2FkJykpXG4gICAgICAgICAgICAgICAgbGluay5yZW1vdmVBdHRyKCdocmVmJykuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBzdGF0ZVVybCA9IHVybDtcbiAgICAgICAgdmFyIHN0YXRlVGl0bGUgPSB0aXRsZSA/IHRpdGxlIDogJ1JLVyBLb21wZXRlbnp6ZW50cnVtJztcbiAgICAgICAgdmFyIHN0YXRlT2JqID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgJ3BhcmVudCc6IHN0YXRlUm9vdC5hdHRyKCdpZCcpLFxuICAgICAgICAgICAgJ2RhdGEnOiBzdGF0ZVJvb3QuaHRtbCgpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGhpc3RvcnkucHVzaFN0YXRlKHN0YXRlT2JqLCBzdGF0ZVRpdGxlLCBzdGF0ZVVybCArICcmJyArIGpRdWVyeS5wYXJhbShzdGF0ZURhdGEpKTtcbiAgICAgICAgaGlzdG9yeS5wdXNoU3RhdGUoc3RhdGVPYmosIHN0YXRlVGl0bGUsIHN0YXRlVXJsKTtcblxuICAgIH07XG5cbiAgICBTaXRlLnByb3RvdHlwZS5vbkFqYXhDb250ZW50Q2hhbmdlZCA9IGZ1bmN0aW9uKGV2ZW50LCBjb250ZW50KSB7XG4gICAgICAgIHRoaXMucGFyc2VDb250ZW50KGNvbnRlbnQpO1xuICAgIH07XG5cbiAgICBTaXRlLnByb3RvdHlwZS5vbkFqYXhBcGlQdXNoU3RhdGUgPSBmdW5jdGlvbihldmVudCwgY29udGVudCwgdXJsLCB0aXRsZSkge1xuICAgICAgICB0aGlzLnB1c2hTdGF0ZShjb250ZW50LCB1cmwsIHRpdGxlKTtcbiAgICB9O1xuXG4gICAgbmV3IFNpdGUoKTtcblxuXG59KCkpO1xuIiwiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYyLjIuNFxuICogaHR0cDovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE2LTA1LTIwVDE3OjIzWlxuICovXG5cbihmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuXHRcdC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcblx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggMTgrXG4vLyBDYW4ndCBiZSBpbiBzdHJpY3QgbW9kZSwgc2V2ZXJhbCBsaWJzIGluY2x1ZGluZyBBU1AuTkVUIHRyYWNlXG4vLyB0aGUgc3RhY2sgdmlhIGFyZ3VtZW50cy5jYWxsZXIuY2FsbGVlIGFuZCBGaXJlZm94IGRpZXMgaWZcbi8vIHlvdSB0cnkgdG8gdHJhY2UgdGhyb3VnaCBcInVzZSBzdHJpY3RcIiBjYWxsIGNoYWlucy4gKCMxMzMzNSlcbi8vXCJ1c2Ugc3RyaWN0XCI7XG52YXIgYXJyID0gW107XG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgY29uY2F0ID0gYXJyLmNvbmNhdDtcblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMi4yLjRcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjFcblx0Ly8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG5cdHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLFxuXG5cdC8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xuXHRybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW1xcZGEtel0pL2dpLFxuXG5cdC8vIFVzZWQgYnkgalF1ZXJ5LmNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcblx0ZmNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBhbGwsIGxldHRlciApIHtcblx0XHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG5cdH07XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBTdGFydCB3aXRoIGFuIGVtcHR5IHNlbGVjdG9yXG5cdHNlbGVjdG9yOiBcIlwiLFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblx0XHRyZXR1cm4gbnVtICE9IG51bGwgP1xuXG5cdFx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0XHQoIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF0gKSA6XG5cblx0XHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRcdHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cdFx0cmV0LmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0galF1ZXJ5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICkge1xuXHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KCBzcmMgKSA/IHNyYyA6IFtdO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzRnVuY3Rpb246IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJmdW5jdGlvblwiO1xuXHR9LFxuXG5cdGlzQXJyYXk6IEFycmF5LmlzQXJyYXksXG5cblx0aXNXaW5kb3c6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fSxcblxuXHRpc051bWVyaWM6IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAobnVsbHx0cnVlfGZhbHNlfFwiXCIpXG5cdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdC8vIGFkZGluZyAxIGNvcnJlY3RzIGxvc3Mgb2YgcHJlY2lzaW9uIGZyb20gcGFyc2VGbG9hdCAoIzE1MTAwKVxuXHRcdHZhciByZWFsU3RyaW5nT2JqID0gb2JqICYmIG9iai50b1N0cmluZygpO1xuXHRcdHJldHVybiAhalF1ZXJ5LmlzQXJyYXkoIG9iaiApICYmICggcmVhbFN0cmluZ09iaiAtIHBhcnNlRmxvYXQoIHJlYWxTdHJpbmdPYmogKSArIDEgKSA+PSAwO1xuXHR9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIGtleTtcblxuXHRcdC8vIE5vdCBwbGFpbiBvYmplY3RzOlxuXHRcdC8vIC0gQW55IG9iamVjdCBvciB2YWx1ZSB3aG9zZSBpbnRlcm5hbCBbW0NsYXNzXV0gcHJvcGVydHkgaXMgbm90IFwiW29iamVjdCBPYmplY3RdXCJcblx0XHQvLyAtIERPTSBub2Rlc1xuXHRcdC8vIC0gd2luZG93XG5cdFx0aWYgKCBqUXVlcnkudHlwZSggb2JqICkgIT09IFwib2JqZWN0XCIgfHwgb2JqLm5vZGVUeXBlIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gTm90IG93biBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBtdXN0IGJlIE9iamVjdFxuXHRcdGlmICggb2JqLmNvbnN0cnVjdG9yICYmXG5cdFx0XHRcdCFoYXNPd24uY2FsbCggb2JqLCBcImNvbnN0cnVjdG9yXCIgKSAmJlxuXHRcdFx0XHQhaGFzT3duLmNhbGwoIG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgfHwge30sIFwiaXNQcm90b3R5cGVPZlwiICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gT3duIHByb3BlcnRpZXMgYXJlIGVudW1lcmF0ZWQgZmlyc3RseSwgc28gdG8gc3BlZWQgdXAsXG5cdFx0Ly8gaWYgbGFzdCBvbmUgaXMgb3duLCB0aGVuIGFsbCBwcm9wZXJ0aWVzIGFyZSBvd25cblx0XHRmb3IgKCBrZXkgaW4gb2JqICkge31cblxuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCB8fCBoYXNPd24uY2FsbCggb2JqLCBrZXkgKTtcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHR0eXBlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMCwgaU9TPDYgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHRcdHR5cGVvZiBvYmo7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUgKSB7XG5cdFx0dmFyIHNjcmlwdCxcblx0XHRcdGluZGlyZWN0ID0gZXZhbDtcblxuXHRcdGNvZGUgPSBqUXVlcnkudHJpbSggY29kZSApO1xuXG5cdFx0aWYgKCBjb2RlICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgY29kZSBpbmNsdWRlcyBhIHZhbGlkLCBwcm9sb2d1ZSBwb3NpdGlvblxuXHRcdFx0Ly8gc3RyaWN0IG1vZGUgcHJhZ21hLCBleGVjdXRlIGNvZGUgYnkgaW5qZWN0aW5nIGFcblx0XHRcdC8vIHNjcmlwdCB0YWcgaW50byB0aGUgZG9jdW1lbnQuXG5cdFx0XHRpZiAoIGNvZGUuaW5kZXhPZiggXCJ1c2Ugc3RyaWN0XCIgKSA9PT0gMSApIHtcblx0XHRcdFx0c2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXHRcdFx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGF2b2lkIHRoZSBET00gbm9kZSBjcmVhdGlvbiwgaW5zZXJ0aW9uXG5cdFx0XHRcdC8vIGFuZCByZW1vdmFsIGJ5IHVzaW5nIGFuIGluZGlyZWN0IGdsb2JhbCBldmFsXG5cblx0XHRcdFx0aW5kaXJlY3QoIGNvZGUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuXHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3Milcblx0Y2FtZWxDYXNlOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuXHR9LFxuXG5cdG5vZGVOYW1lOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xXG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGNvbmNhdC5hcHBseSggW10sIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuXHQvLyBhcmd1bWVudHMuXG5cdHByb3h5OiBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdFx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRcdGNvbnRleHQgPSBmbjtcblx0XHRcdGZuID0gdG1wO1xuXHRcdH1cblxuXHRcdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdFx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdFx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHRcdH07XG5cblx0XHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0XHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRcdHJldHVybiBwcm94eTtcblx0fSxcblxuXHRub3c6IERhdGUubm93LFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbi8vIEpTSGludCB3b3VsZCBlcnJvciBvbiB0aGlzIGNvZGUgZHVlIHRvIHRoZSBTeW1ib2wgbm90IGJlaW5nIGRlZmluZWQgaW4gRVM1LlxuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmpzaGludHJjIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8ganVzdCBkaXNhYmxlIEpTSGludCBmb3IgdGhlc2Vcbi8vIHRocmVlIGxpbmVzLlxuLyoganNoaW50IGlnbm9yZTogc3RhcnQgKi9cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cbi8qIGpzaGludCBpZ25vcmU6IGVuZCAqL1xuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogaU9TIDguMiAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblxuXHRpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4yLjFcbiAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTUtMTAtMTdcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEdlbmVyYWwtcHVycG9zZSBjb25zdGFudHNcblx0TUFYX05FR0FUSVZFID0gMSA8PCAzMSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cDovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFxcXHgwMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cblx0cmF0dHJpYnV0ZVF1b3RlcyA9IG5ldyBSZWdFeHAoIFwiPVwiICsgd2hpdGVzcGFjZSArIFwiKihbXlxcXFxdJ1xcXCJdKj8pXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIiwgXCJnXCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXHRyZXNjYXBlID0gLyd8XFxcXC9nLFxuXG5cdC8vIENTUyBlc2NhcGVzIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XG5cdFx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI0XG5cdFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG5cdFx0cmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuXHRcdFx0ZXNjYXBlZCA6XG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdC8vIEJNUCBjb2RlcG9pbnRcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBuaWRzZWxlY3QsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0aWYgKCAhc2VlZCApIHtcblxuXHRcdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdH1cblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmIChlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSAmJlxuXHRcdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcblx0XHRcdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggc3VwcG9ydC5xc2EgJiZcblx0XHRcdFx0IWNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuXHRcdFx0XHQvLyBxU0EgbG9va3Mgb3V0c2lkZSBFbGVtZW50IGNvbnRleHQsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnRcblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgd29ya2Fyb3VuZCB0ZWNobmlxdWVcblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0aWYgKCAobmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApKSApIHtcblx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByZXNjYXBlLCBcIlxcXFwkJlwiICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIChuaWQgPSBleHBhbmRvKSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdG5pZHNlbGVjdCA9IHJpZGVudGlmaWVyLnRlc3QoIG5pZCApID8gXCIjXCIgKyBuaWQgOiBcIltpZD0nXCIgKyBuaWQgKyBcIiddXCI7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbaV0gPSBuaWRzZWxlY3QgKyBcIiBcIiArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBuZXdTZWxlY3RvciApIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGRpdiBhbmQgZXhwZWN0cyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGRpdiApO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZGl2LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZGl2ICk7XG5cdFx0fVxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdCggfmIuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFICkgLVxuXHRcdFx0KCB+YS5zb3VyY2VJbmRleCB8fCBNQVhfTkVHQVRJVkUgKTtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgcGFyZW50LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0aWYgKCAocGFyZW50ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHBhcmVudC50b3AgIT09IHBhcmVudCApIHtcblx0XHQvLyBTdXBwb3J0OiBJRSAxMVxuXHRcdGlmICggcGFyZW50LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRwYXJlbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggcGFyZW50LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0cGFyZW50LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZGl2LmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZGl2LmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0fSk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZGl2LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gSUQgZmluZCBhbmQgZmlsdGVyXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gbSA/IFsgbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0Ly8gU3VwcG9ydDogSUU2Lzdcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0ZGVsZXRlIEV4cHIuZmluZFtcIklEXCJdO1xuXG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2liaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcblx0XHRcdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBkaXYucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRkaXYucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGRpdiwgXCJkaXZcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGRpdiwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcblx0ZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhY29tcGlsZXJDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge31cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoIChub2RlID0gZWxlbVtpKytdKSApIHtcblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWzNdID0gKCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFszXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiICk7XG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlO1xuXHRcdH0sXG5cblx0XHRcImRpc2FibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9KSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9KSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYgZGlyID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGRpciBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgZGlyIF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0c3VwcG9ydC5nZXRCeUlkICYmIGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHRcdFx0RXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkpICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXCJcIikgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYxICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGRpdjEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIiA7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRkaXYuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRyZXR1cm4gZGl2LmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG59KSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9KTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSkoIHdpbmRvdyApO1xuXG5cblxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG52YXIgcnNpbmdsZVRhZyA9ICggL148KFtcXHctXSspXFxzKlxcLz8+KD86PFxcL1xcMT58KSQvICk7XG5cblxuXG52YXIgcmlzU2ltcGxlID0gL14uW146I1xcW1xcLixdKiQvO1xuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXG5cdH1cblxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXG5cdH1cblxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0aWYgKCByaXNTaW1wbGUudGVzdCggcXVhbGlmaWVyICkgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG5cdFx0fVxuXG5cdFx0cXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cyApO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdDtcblx0fSApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0cmV0dXJuIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxID9cblx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW10gOlxuXHRcdGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0XHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHQvLyBOZWVkZWQgYmVjYXVzZSAkKCBzZWxlY3RvciwgY29udGV4dCApIGJlY29tZXMgJCggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yIClcblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggbGVuID4gMSA/IGpRdWVyeS51bmlxdWUoIHJldCApIDogcmV0ICk7XG5cdFx0cmV0LnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciA/IHRoaXMuc2VsZWN0b3IgKyBcIiBcIiArIHNlbGVjdG9yIDogc2VsZWN0b3I7XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKikpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQmxhY2tiZXJyeSA0LjZcblx0XHRcdFx0XHQvLyBnRUJJRCByZXR1cm5zIG5vZGVzIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgKCM2OTYzKVxuXHRcdFx0XHRcdGlmICggZWxlbSAmJiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuY29udGV4dCA9IGRvY3VtZW50O1xuXHRcdFx0XHRcdHRoaXMuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXMuY29udGV4dCA9IHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3Rvci5zZWxlY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yLnNlbGVjdG9yO1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gc2VsZWN0b3IuY29udGV4dDtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHBvcyA9IHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgfHwgdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3JzLCBjb250ZXh0IHx8IHRoaXMuY29udGV4dCApIDpcblx0XHRcdFx0MDtcblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCBwb3MgP1xuXHRcdFx0XHRcdHBvcy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50IHx8IGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3R3aGl0ZSA9ICggL1xcUysvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiBqUXVlcnkudHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGxpc3RlbmVyIGxpc3QsIGZpbmFsIHN0YXRlXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCBcInJlamVjdGVkXCIgXSxcblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0galF1ZXJ5LmlzRnVuY3Rpb24oIGZuc1sgaSBdICkgJiYgZm5zWyBpIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWRbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSBmb3IgZm9yd2FyZGluZyBhY3Rpb25zIHRvIG5ld0RlZmVyXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzID09PSBwcm9taXNlID8gbmV3RGVmZXIucHJvbWlzZSgpIDogdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRwcm9taXNlLnBpcGUgPSBwcm9taXNlLnRoZW47XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyAzIF07XG5cblx0XHRcdC8vIHByb21pc2VbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHQvLyBzdGF0ZSA9IFsgcmVzb2x2ZWQgfCByZWplY3RlZCBdXG5cdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblxuXHRcdFx0XHQvLyBbIHJlamVjdF9saXN0IHwgcmVzb2x2ZV9saXN0IF0uZGlzYWJsZTsgcHJvZ3Jlc3NfbGlzdC5sb2NrXG5cdFx0XHRcdH0sIHR1cGxlc1sgaSBeIDEgXVsgMiBdLmRpc2FibGUsIHR1cGxlc1sgMiBdWyAyIF0ubG9jayApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBkZWZlcnJlZFsgcmVzb2x2ZSB8IHJlamVjdCB8IG5vdGlmeSBdXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyBwcm9taXNlIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc3Vib3JkaW5hdGUgLyogLCAuLi4sIHN1Ym9yZGluYXRlTiAqLyApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cdFx0XHRsZW5ndGggPSByZXNvbHZlVmFsdWVzLmxlbmd0aCxcblxuXHRcdFx0Ly8gdGhlIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gbGVuZ3RoICE9PSAxIHx8XG5cdFx0XHRcdCggc3Vib3JkaW5hdGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHN1Ym9yZGluYXRlLnByb21pc2UgKSApID8gbGVuZ3RoIDogMCxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZC5cblx0XHRcdC8vIElmIHJlc29sdmVWYWx1ZXMgY29uc2lzdCBvZiBvbmx5IGEgc2luZ2xlIERlZmVycmVkLCBqdXN0IHVzZSB0aGF0LlxuXHRcdFx0ZGVmZXJyZWQgPSByZW1haW5pbmcgPT09IDEgPyBzdWJvcmRpbmF0ZSA6IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBVcGRhdGUgZnVuY3Rpb24gZm9yIGJvdGggcmVzb2x2ZSBhbmQgcHJvZ3Jlc3MgdmFsdWVzXG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGksIGNvbnRleHRzLCB2YWx1ZXMgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0Y29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0dmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCB2YWx1ZXMgPT09IHByb2dyZXNzVmFsdWVzICkge1xuXHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggY29udGV4dHMsIHZhbHVlcyApO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY29udGV4dHMsIHZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cblx0XHRcdHByb2dyZXNzVmFsdWVzLCBwcm9ncmVzc0NvbnRleHRzLCByZXNvbHZlQ29udGV4dHM7XG5cblx0XHQvLyBBZGQgbGlzdGVuZXJzIHRvIERlZmVycmVkIHN1Ym9yZGluYXRlczsgdHJlYXQgb3RoZXJzIGFzIHJlc29sdmVkXG5cdFx0aWYgKCBsZW5ndGggPiAxICkge1xuXHRcdFx0cHJvZ3Jlc3NWYWx1ZXMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0cHJvZ3Jlc3NDb250ZXh0cyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0ucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXS5wcm9taXNlKClcblx0XHRcdFx0XHRcdC5wcm9ncmVzcyggdXBkYXRlRnVuYyggaSwgcHJvZ3Jlc3NDb250ZXh0cywgcHJvZ3Jlc3NWYWx1ZXMgKSApXG5cdFx0XHRcdFx0XHQuZG9uZSggdXBkYXRlRnVuYyggaSwgcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICkgKVxuXHRcdFx0XHRcdFx0LmZhaWwoIGRlZmVycmVkLnJlamVjdCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC0tcmVtYWluaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UncmUgbm90IHdhaXRpbmcgb24gYW55dGhpbmcsIHJlc29sdmUgdGhlIG1hc3RlclxuXHRcdGlmICggIXJlbWFpbmluZyApIHtcblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0O1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0Ly8gQWRkIHRoZSBjYWxsYmFja1xuXHRqUXVlcnkucmVhZHkucHJvbWlzZSgpLmRvbmUoIGZuICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSG9sZCAob3IgcmVsZWFzZSkgdGhlIHJlYWR5IGV2ZW50XG5cdGhvbGRSZWFkeTogZnVuY3Rpb24oIGhvbGQgKSB7XG5cdFx0aWYgKCBob2xkICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXG5cdFx0Ly8gVHJpZ2dlciBhbnkgYm91bmQgcmVhZHkgZXZlbnRzXG5cdFx0aWYgKCBqUXVlcnkuZm4udHJpZ2dlckhhbmRsZXIgKSB7XG5cdFx0XHRqUXVlcnkoIGRvY3VtZW50ICkudHJpZ2dlckhhbmRsZXIoIFwicmVhZHlcIiApO1xuXHRcdFx0alF1ZXJ5KCBkb2N1bWVudCApLm9mZiggXCJyZWFkeVwiICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8qKlxuICogVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbiAqL1xuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG5qUXVlcnkucmVhZHkucHJvbWlzZSA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cdGlmICggIXJlYWR5TGlzdCApIHtcblxuXHRcdHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5cdFx0Ly8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcblx0XHQvLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cblx0XHQvLyBTdXBwb3J0OiBJRTktMTAgb25seVxuXHRcdC8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuXHRcdGlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdFx0XHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHRcdFx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0XHRcdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVhZHlMaXN0LnByb21pc2UoIG9iaiApO1xufTtcblxuLy8gS2ljayBvZmYgdGhlIERPTSByZWFkeSBjaGVjayBldmVuIGlmIHRoZSB1c2VyIGRvZXMgbm90XG5qUXVlcnkucmVhZHkucHJvbWlzZSgpO1xuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIGpRdWVyeS50eXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY2hhaW5hYmxlID9cblx0XHRlbGVtcyA6XG5cblx0XHQvLyBHZXRzXG5cdFx0YnVsayA/XG5cdFx0XHRmbi5jYWxsKCBlbGVtcyApIDpcblx0XHRcdGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHQvKiBqc2hpbnQgLVcwMTggKi9cblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdHJlZ2lzdGVyOiBmdW5jdGlvbiggb3duZXIsIGluaXRpYWwgKSB7XG5cdFx0dmFyIHZhbHVlID0gaW5pdGlhbCB8fCB7fTtcblxuXHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSwgbm9uLXdyaXRhYmxlIHByb3BlcnR5XG5cdFx0Ly8gY29uZmlndXJhYmlsaXR5IG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHQvLyBkZWxldGVkIHdpdGggdGhlIGRlbGV0ZSBvcGVyYXRvclxuXHRcdH0gZWxzZSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdH0sXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdGlmICggIWFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cdFx0XHRyZXR1cm4ge307XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgZGF0YSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBwcm9wIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBrZXkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIHN0b3JlZDtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0c3RvcmVkID0gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblxuXHRcdFx0cmV0dXJuIHN0b3JlZCAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0c3RvcmVkIDogdGhpcy5nZXQoIG93bmVyLCBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKSApO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSwgbmFtZSwgY2FtZWwsXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5yZWdpc3Rlciggb3duZXIgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBcIm5hbWVcIiBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdoZW4gZGF0YSBpcyBpbml0aWFsbHkgY3JlYXRlZCwgdmlhIChcImtleVwiLCBcInZhbFwiKSBzaWduYXR1cmUsXG5cdFx0XHRcdC8vIGtleXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlLlxuXHRcdFx0XHQvLyBTaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gdGVsbCBfaG93XyBhIGtleSB3YXMgYWRkZWQsIHJlbW92ZVxuXHRcdFx0XHQvLyBib3RoIHBsYWluIGtleSBhbmQgY2FtZWxDYXNlIGtleS4gIzEyNzg2XG5cdFx0XHRcdC8vIFRoaXMgd2lsbCBvbmx5IHBlbmFsaXplIHRoZSBhcnJheSBhcmd1bWVudCBwYXRoLlxuXHRcdFx0XHRuYW1lID0ga2V5LmNvbmNhdCgga2V5Lm1hcCggalF1ZXJ5LmNhbWVsQ2FzZSApICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYW1lbCA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIFRyeSB0aGUgc3RyaW5nIGFzIGEga2V5IGJlZm9yZSBhbnkgbWFuaXB1bGF0aW9uXG5cdFx0XHRcdGlmICgga2V5IGluIGNhY2hlICkge1xuXHRcdFx0XHRcdG5hbWUgPSBbIGtleSwgY2FtZWwgXTtcblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRcdG5hbWUgPSBjYW1lbDtcblx0XHRcdFx0XHRuYW1lID0gbmFtZSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0XHRbIG5hbWUgXSA6ICggbmFtZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIG5hbWVbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PSAzNS00NStcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3XG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZGF0YSA9PT0gXCJ0cnVlXCIgPyB0cnVlIDpcblx0XHRcdFx0XHRkYXRhID09PSBcImZhbHNlXCIgPyBmYWxzZSA6XG5cdFx0XHRcdFx0ZGF0YSA9PT0gXCJudWxsXCIgPyBudWxsIDpcblxuXHRcdFx0XHRcdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdFx0XHRcdFx0K2RhdGEgKyBcIlwiID09PSBkYXRhID8gK2RhdGEgOlxuXHRcdFx0XHRcdHJicmFjZS50ZXN0KCBkYXRhICkgPyBqUXVlcnkucGFyc2VKU09OKCBkYXRhICkgOlxuXHRcdFx0XHRcdGRhdGE7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUxMStcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhLCBjYW1lbEtleTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gd2l0aCB0aGUga2V5IGFzLWlzXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApIHx8XG5cblx0XHRcdFx0XHQvLyBUcnkgdG8gZmluZCBkYXNoZWQga2V5IGlmIGl0IGV4aXN0cyAoZ2gtMjc3OSlcblx0XHRcdFx0XHQvLyBUaGlzIGlzIGZvciAyLjIueCBvbmx5XG5cdFx0XHRcdFx0ZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCkgKTtcblxuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbWVsS2V5ID0galF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyB3aXRoIHRoZSBrZXkgY2FtZWxpemVkXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGNhbWVsS2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGNhbWVsS2V5LCB1bmRlZmluZWQgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHRjYW1lbEtleSA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBGaXJzdCwgYXR0ZW1wdCB0byBzdG9yZSBhIGNvcHkgb3IgcmVmZXJlbmNlIG9mIGFueVxuXHRcdFx0XHQvLyBkYXRhIHRoYXQgbWlnaHQndmUgYmVlbiBzdG9yZSB3aXRoIGEgY2FtZWxDYXNlZCBrZXkuXG5cdFx0XHRcdHZhciBkYXRhID0gZGF0YVVzZXIuZ2V0KCB0aGlzLCBjYW1lbEtleSApO1xuXG5cdFx0XHRcdC8vIEZvciBIVE1MNSBkYXRhLSogYXR0cmlidXRlIGludGVyb3AsIHdlIGhhdmUgdG9cblx0XHRcdFx0Ly8gc3RvcmUgcHJvcGVydHkgbmFtZXMgd2l0aCBkYXNoZXMgaW4gYSBjYW1lbENhc2UgZm9ybS5cblx0XHRcdFx0Ly8gVGhpcyBtaWdodCBub3QgYXBwbHkgdG8gYWxsIHByb3BlcnRpZXMuLi4qXG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywgY2FtZWxLZXksIHZhbHVlICk7XG5cblx0XHRcdFx0Ly8gKi4uLiBJbiB0aGUgY2FzZSBvZiBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgX2FjdHVhbGx5X1xuXHRcdFx0XHQvLyBoYXZlIGRhc2hlcywgd2UgbmVlZCB0byBhbHNvIHN0b3JlIGEgY29weSBvZiB0aGF0XG5cdFx0XHRcdC8vIHVuY2hhbmdlZCBwcm9wZXJ0eS5cblx0XHRcdFx0aWYgKCBrZXkuaW5kZXhPZiggXCItXCIgKSA+IC0xICYmIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IGpRdWVyeS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBpc0hpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHQhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblx0fTtcblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCxcblx0XHRzY2FsZSA9IDEsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHdlZW4uY3VyKCk7IH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7IH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdGRvIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgaXRlcmF0aW9uIHplcm9lZCBvdXQsIGRvdWJsZSB1bnRpbCB3ZSBnZXQgKnNvbWV0aGluZyouXG5cdFx0XHQvLyBVc2Ugc3RyaW5nIGZvciBkb3VibGluZyBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgc2VlIHNjYWxlIGFzIHVuY2hhbmdlZCBiZWxvd1xuXHRcdFx0c2NhbGUgPSBzY2FsZSB8fCBcIi41XCI7XG5cblx0XHRcdC8vIEFkanVzdCBhbmQgYXBwbHlcblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBVcGRhdGUgc2NhbGUsIHRvbGVyYXRpbmcgemVybyBvciBOYU4gZnJvbSB0d2Vlbi5jdXIoKVxuXHRcdC8vIEJyZWFrIHRoZSBsb29wIGlmIHNjYWxlIGlzIHVuY2hhbmdlZCBvciBwZXJmZWN0LCBvciBpZiB3ZSd2ZSBqdXN0IGhhZCBlbm91Z2guXG5cdFx0fSB3aGlsZSAoXG5cdFx0XHRzY2FsZSAhPT0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCApICYmIHNjYWxlICE9PSAxICYmIC0tbWF4SXRlcmF0aW9uc1xuXHRcdCk7XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFtcXHc6LV0rKS8gKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gU3VwcG9ydDogSUU5XG5cdG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdLFxuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxuLy8gU3VwcG9ydDogSUU5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldCA9IHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiID9cblx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApIDpcblx0XHRcdHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgP1xuXHRcdFx0XHRjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApIDpcblx0XHRcdFtdO1xuXG5cdHJldHVybiB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSA/XG5cdFx0alF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICkgOlxuXHRcdHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggalF1ZXJ5LnR5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMSwgUGhhbnRvbUpTPDJcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xLCBQaGFudG9tSlM8MlxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggY29udGFpbnMgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMC00LjMsIFNhZmFyaTw9NS4xXG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBTYWZhcmk8PTUuMSwgQW5kcm9pZDw0LjJcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRTw9MTErXG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59ICkoKTtcblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUU5XG4vLyBTZWUgIzEzMzkzIGZvciBtb3JlIGluZm9cbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcblx0XHRpZiAoICFlbGVtRGF0YSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaixcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcblx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxuXHRcdFx0XHQvLyBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgbWF0Y2hlcywgc2VsLCBoYW5kbGVPYmosXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gU3VwcG9ydCAoYXQgbGVhc3QpOiBDaHJvbWUsIElFOVxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAoIzEzMTgwKVxuXHRcdC8vXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDw9NDIrXG5cdFx0Ly8gQXZvaWQgbm9uLWxlZnQtY2xpY2sgaW4gRkYgYnV0IGRvbid0IGJsb2NrIElFIHJhZGlvIGV2ZW50cyAoIzM4NjEsIGdoLTIzNDMpXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmIGN1ci5ub2RlVHlwZSAmJlxuXHRcdFx0KCBldmVudC50eXBlICE9PSBcImNsaWNrXCIgfHwgaXNOYU4oIGV2ZW50LmJ1dHRvbiApIHx8IGV2ZW50LmJ1dHRvbiA8IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAoIGN1ci5kaXNhYmxlZCAhPT0gdHJ1ZSB8fCBldmVudC50eXBlICE9PSBcImNsaWNrXCIgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVzID0gW107XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZXMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiB0aGlzLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHQvLyBJbmNsdWRlcyBzb21lIGV2ZW50IHByb3BzIHNoYXJlZCBieSBLZXlFdmVudCBhbmQgTW91c2VFdmVudFxuXHRwcm9wczogKCBcImFsdEtleSBidWJibGVzIGNhbmNlbGFibGUgY3RybEtleSBjdXJyZW50VGFyZ2V0IGRldGFpbCBldmVudFBoYXNlIFwiICtcblx0XHRcIm1ldGFLZXkgcmVsYXRlZFRhcmdldCBzaGlmdEtleSB0YXJnZXQgdGltZVN0YW1wIHZpZXcgd2hpY2hcIiApLnNwbGl0KCBcIiBcIiApLFxuXG5cdGZpeEhvb2tzOiB7fSxcblxuXHRrZXlIb29rczoge1xuXHRcdHByb3BzOiBcImNoYXIgY2hhckNvZGUga2V5IGtleUNvZGVcIi5zcGxpdCggXCIgXCIgKSxcblx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBldmVudCwgb3JpZ2luYWwgKSB7XG5cblx0XHRcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xuXHRcdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICkge1xuXHRcdFx0XHRldmVudC53aGljaCA9IG9yaWdpbmFsLmNoYXJDb2RlICE9IG51bGwgPyBvcmlnaW5hbC5jaGFyQ29kZSA6IG9yaWdpbmFsLmtleUNvZGU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cdH0sXG5cblx0bW91c2VIb29rczoge1xuXHRcdHByb3BzOiAoIFwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIG9mZnNldFggb2Zmc2V0WSBwYWdlWCBwYWdlWSBcIiArXG5cdFx0XHRcInNjcmVlblggc2NyZWVuWSB0b0VsZW1lbnRcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRcdGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcblx0XHRcdHZhciBldmVudERvYywgZG9jLCBib2R5LFxuXHRcdFx0XHRidXR0b24gPSBvcmlnaW5hbC5idXR0b247XG5cblx0XHRcdC8vIENhbGN1bGF0ZSBwYWdlWC9ZIGlmIG1pc3NpbmcgYW5kIGNsaWVudFgvWSBhdmFpbGFibGVcblx0XHRcdGlmICggZXZlbnQucGFnZVggPT0gbnVsbCAmJiBvcmlnaW5hbC5jbGllbnRYICE9IG51bGwgKSB7XG5cdFx0XHRcdGV2ZW50RG9jID0gZXZlbnQudGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG5cdFx0XHRcdGRvYyA9IGV2ZW50RG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdFx0Ym9keSA9IGV2ZW50RG9jLmJvZHk7XG5cblx0XHRcdFx0ZXZlbnQucGFnZVggPSBvcmlnaW5hbC5jbGllbnRYICtcblx0XHRcdFx0XHQoIGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwICkgLVxuXHRcdFx0XHRcdCggZG9jICYmIGRvYy5jbGllbnRMZWZ0IHx8IGJvZHkgJiYgYm9keS5jbGllbnRMZWZ0IHx8IDAgKTtcblx0XHRcdFx0ZXZlbnQucGFnZVkgPSBvcmlnaW5hbC5jbGllbnRZICtcblx0XHRcdFx0XHQoIGRvYyAmJiBkb2Muc2Nyb2xsVG9wICB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsVG9wICB8fCAwICkgLVxuXHRcdFx0XHRcdCggZG9jICYmIGRvYy5jbGllbnRUb3AgIHx8IGJvZHkgJiYgYm9keS5jbGllbnRUb3AgIHx8IDAgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdFx0Ly8gTm90ZTogYnV0dG9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyBkb24ndCB1c2UgaXRcblx0XHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRldmVudC53aGljaCA9ICggYnV0dG9uICYgMSA/IDEgOiAoIGJ1dHRvbiAmIDIgPyAzIDogKCBidXR0b24gJiA0ID8gMiA6IDAgKSApICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSApIHtcblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgYSB3cml0YWJsZSBjb3B5IG9mIHRoZSBldmVudCBvYmplY3QgYW5kIG5vcm1hbGl6ZSBzb21lIHByb3BlcnRpZXNcblx0XHR2YXIgaSwgcHJvcCwgY29weSxcblx0XHRcdHR5cGUgPSBldmVudC50eXBlLFxuXHRcdFx0b3JpZ2luYWxFdmVudCA9IGV2ZW50LFxuXHRcdFx0Zml4SG9vayA9IHRoaXMuZml4SG9va3NbIHR5cGUgXTtcblxuXHRcdGlmICggIWZpeEhvb2sgKSB7XG5cdFx0XHR0aGlzLmZpeEhvb2tzWyB0eXBlIF0gPSBmaXhIb29rID1cblx0XHRcdFx0cm1vdXNlRXZlbnQudGVzdCggdHlwZSApID8gdGhpcy5tb3VzZUhvb2tzIDpcblx0XHRcdFx0cmtleUV2ZW50LnRlc3QoIHR5cGUgKSA/IHRoaXMua2V5SG9va3MgOlxuXHRcdFx0XHR7fTtcblx0XHR9XG5cdFx0Y29weSA9IGZpeEhvb2sucHJvcHMgPyB0aGlzLnByb3BzLmNvbmNhdCggZml4SG9vay5wcm9wcyApIDogdGhpcy5wcm9wcztcblxuXHRcdGV2ZW50ID0gbmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXG5cdFx0aSA9IGNvcHkubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0cHJvcCA9IGNvcHlbIGkgXTtcblx0XHRcdGV2ZW50WyBwcm9wIF0gPSBvcmlnaW5hbEV2ZW50WyBwcm9wIF07XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQ29yZG92YSAyLjUgKFdlYktpdCkgKCMxMzI1NSlcblx0XHQvLyBBbGwgZXZlbnRzIHNob3VsZCBoYXZlIGEgdGFyZ2V0OyBDb3Jkb3ZhIGRldmljZXJlYWR5IGRvZXNuJ3Rcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBkb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgNi4wKywgQ2hyb21lPDI4XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHRpZiAoIGV2ZW50LnRhcmdldC5ub2RlVHlwZSA9PT0gMyApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGV2ZW50LnRhcmdldC5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmaXhIb29rLmZpbHRlciA/IGZpeEhvb2suZmlsdGVyKCBldmVudCwgb3JpZ2luYWxFdmVudCApIDogZXZlbnQ7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGZvY3VzOiB7XG5cblx0XHRcdC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyAhPT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmZvY3VzICkge1xuXHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcblx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgJiYgalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR0aGlzLmNsaWNrKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubm9kZU5hbWUoIGV2ZW50LnRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXG5cdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBqUXVlcnkubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcdzotXSspW14+XSopXFwvPi9naSxcblxuXHQvLyBTdXBwb3J0OiBJRSAxMC0xMSwgRWRnZSAxMDI0MCtcblx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cblx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cnNjcmlwdFR5cGVNYXNrZWQgPSAvXnRydWVcXC8oLiopLyxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG4vLyBNYW5pcHVsYXRpbmcgdGFibGVzIHJlcXVpcmVzIGEgdGJvZHlcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRqUXVlcnkubm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgP1xuXG5cdFx0ZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJ0Ym9keVwiIClbIDAgXSB8fFxuXHRcdFx0ZWxlbS5hcHBlbmRDaGlsZCggZWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwidGJvZHlcIiApICkgOlxuXHRcdGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdHZhciBtYXRjaCA9IHJzY3JpcHRUeXBlTWFza2VkLmV4ZWMoIGVsZW0udHlwZSApO1xuXG5cdGlmICggbWF0Y2ggKSB7XG5cdFx0ZWxlbS50eXBlID0gbWF0Y2hbIDEgXTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0cGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xuXHRcdFx0cGRhdGFDdXIuZXZlbnRzID0ge307XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCBpc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xLCBQaGFudG9tSlM8MlxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIG5vZGUub3duZXJEb2N1bWVudCwgbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWwucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0gMzUtNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9IDM1LTQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0Ly8gS2VlcCBkb21NYW5pcCBleHBvc2VkIHVudGlsIDMuMCAoZ2gtMjIyNSlcblx0ZG9tTWFuaXA6IGRvbU1hbmlwLFxuXG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzXG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcblxuXG52YXIgaWZyYW1lLFxuXHRlbGVtZGlzcGxheSA9IHtcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3hcblx0XHQvLyBXZSBoYXZlIHRvIHByZS1kZWZpbmUgdGhlc2UgdmFsdWVzIGZvciBGRiAoIzEwMjI3KVxuXHRcdEhUTUw6IFwiYmxvY2tcIixcblx0XHRCT0RZOiBcImJsb2NrXCJcblx0fTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgYWN0dWFsIGRpc3BsYXkgb2YgYSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBub2RlTmFtZSBvZiB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IGRvYyBEb2N1bWVudCBvYmplY3RcbiAqL1xuXG4vLyBDYWxsZWQgb25seSBmcm9tIHdpdGhpbiBkZWZhdWx0RGlzcGxheVxuZnVuY3Rpb24gYWN0dWFsRGlzcGxheSggbmFtZSwgZG9jICkge1xuXHR2YXIgZWxlbSA9IGpRdWVyeSggZG9jLmNyZWF0ZUVsZW1lbnQoIG5hbWUgKSApLmFwcGVuZFRvKCBkb2MuYm9keSApLFxuXG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW1bIDAgXSwgXCJkaXNwbGF5XCIgKTtcblxuXHQvLyBXZSBkb24ndCBoYXZlIGFueSBkYXRhIHN0b3JlZCBvbiB0aGUgZWxlbWVudCxcblx0Ly8gc28gdXNlIFwiZGV0YWNoXCIgbWV0aG9kIGFzIGZhc3Qgd2F5IHRvIGdldCByaWQgb2YgdGhlIGVsZW1lbnRcblx0ZWxlbS5kZXRhY2goKTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuLyoqXG4gKiBUcnkgdG8gZGV0ZXJtaW5lIHRoZSBkZWZhdWx0IGRpc3BsYXkgdmFsdWUgb2YgYW4gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IG5vZGVOYW1lXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHREaXNwbGF5KCBub2RlTmFtZSApIHtcblx0dmFyIGRvYyA9IGRvY3VtZW50LFxuXHRcdGRpc3BsYXkgPSBlbGVtZGlzcGxheVsgbm9kZU5hbWUgXTtcblxuXHRpZiAoICFkaXNwbGF5ICkge1xuXHRcdGRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KCBub2RlTmFtZSwgZG9jICk7XG5cblx0XHQvLyBJZiB0aGUgc2ltcGxlIHdheSBmYWlscywgcmVhZCBmcm9tIGluc2lkZSBhbiBpZnJhbWVcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiIHx8ICFkaXNwbGF5ICkge1xuXG5cdFx0XHQvLyBVc2UgdGhlIGFscmVhZHktY3JlYXRlZCBpZnJhbWUgaWYgcG9zc2libGVcblx0XHRcdGlmcmFtZSA9ICggaWZyYW1lIHx8IGpRdWVyeSggXCI8aWZyYW1lIGZyYW1lYm9yZGVyPScwJyB3aWR0aD0nMCcgaGVpZ2h0PScwJy8+XCIgKSApXG5cdFx0XHRcdC5hcHBlbmRUbyggZG9jLmRvY3VtZW50RWxlbWVudCApO1xuXG5cdFx0XHQvLyBBbHdheXMgd3JpdGUgYSBuZXcgSFRNTCBza2VsZXRvbiBzbyBXZWJraXQgYW5kIEZpcmVmb3ggZG9uJ3QgY2hva2Ugb24gcmV1c2Vcblx0XHRcdGRvYyA9IGlmcmFtZVsgMCBdLmNvbnRlbnREb2N1bWVudDtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUVcblx0XHRcdGRvYy53cml0ZSgpO1xuXHRcdFx0ZG9jLmNsb3NlKCk7XG5cblx0XHRcdGRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KCBub2RlTmFtZSwgZG9jICk7XG5cdFx0XHRpZnJhbWUuZGV0YWNoKCk7XG5cdFx0fVxuXG5cdFx0Ly8gU3RvcmUgdGhlIGNvcnJlY3QgZGVmYXVsdCBkaXNwbGF5XG5cdFx0ZWxlbWRpc3BsYXlbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXHR9XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG52YXIgcm1hcmdpbiA9ICggL15tYXJnaW4vICk7XG5cbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUU8PTExKywgRmlyZWZveDw9MzArICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgcGl4ZWxNYXJnaW5SaWdodFZhbCwgcmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjowO3dpZHRoOjhweDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHg7XCIgK1xuXHRcdFwicGFkZGluZzowO21hcmdpbi10b3A6MXB4O3Bvc2l0aW9uOmFic29sdXRlXCI7XG5cdGNvbnRhaW5lci5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyOSwgQW5kcm9pZCAyLjNcblx0XHRcdC8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZ1xuXHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7XCIgK1xuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcInRvcDoxJTt3aWR0aDo1MCVcIjtcblx0XHRkaXYuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSBkaXZTdHlsZS5tYXJnaW5MZWZ0ID09PSBcIjJweFwiO1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gZGl2U3R5bGUud2lkdGggPT09IFwiNHB4XCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gXCI1MCVcIjtcblx0XHRwaXhlbE1hcmdpblJpZ2h0VmFsID0gZGl2U3R5bGUubWFyZ2luUmlnaHQgPT09IFwiNHB4XCI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXHR9XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBUaGlzIHRlc3QgaXMgZXhlY3V0ZWQgb25seSBvbmNlIGJ1dCB3ZSBzdGlsbCBkbyBtZW1vaXppbmdcblx0XHRcdC8vIHNpbmNlIHdlIGNhbiB1c2UgdGhlIGJveFNpemluZ1JlbGlhYmxlIHByZS1jb21wdXRpbmcuXG5cdFx0XHQvLyBObyBuZWVkIHRvIGNoZWNrIGlmIHRoZSB0ZXN0IHdhcyBhbHJlYWR5IHBlcmZvcm1lZCwgdGhvdWdoLlxuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBib3hTaXppbmdSZWxpYWJsZVZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wLTQuM1xuXHRcdFx0Ly8gV2UncmUgY2hlY2tpbmcgZm9yIGJveFNpemluZ1JlbGlhYmxlVmFsIGhlcmUgaW5zdGVhZCBvZiBwaXhlbE1hcmdpblJpZ2h0VmFsXG5cdFx0XHQvLyBzaW5jZSB0aGF0IGNvbXByZXNzZXMgYmV0dGVyIGFuZCB0aGV5J3JlIGNvbXB1dGVkIHRvZ2V0aGVyIGFueXdheS5cblx0XHRcdGlmICggYm94U2l6aW5nUmVsaWFibGVWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwaXhlbE1hcmdpblJpZ2h0VmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IG9ubHksIEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gMzdcblx0XHRcdGlmICggYm94U2l6aW5nUmVsaWFibGVWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpblJpZ2h0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjNcblx0XHRcdC8vIENoZWNrIGlmIGRpdiB3aXRoIGV4cGxpY2l0IHdpZHRoIGFuZCBubyBtYXJnaW4tcmlnaHQgaW5jb3JyZWN0bHlcblx0XHRcdC8vIGdldHMgY29tcHV0ZWQgbWFyZ2luLXJpZ2h0IGJhc2VkIG9uIHdpZHRoIG9mIGNvbnRhaW5lci4gKCMzMzMzKVxuXHRcdFx0Ly8gV2ViS2l0IEJ1ZyAxMzM0MyAtIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyB3cm9uZyB2YWx1ZSBmb3IgbWFyZ2luLXJpZ2h0XG5cdFx0XHQvLyBUaGlzIHN1cHBvcnQgZnVuY3Rpb24gaXMgb25seSBleGVjdXRlZCBvbmNlIHNvIG5vIG1lbW9pemluZyBpcyBuZWVkZWQuXG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHRtYXJnaW5EaXYgPSBkaXYuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHQvLyBSZXNldCBDU1M6IGJveC1zaXppbmc7IGRpc3BsYXk7IG1hcmdpbjsgYm9yZGVyOyBwYWRkaW5nXG5cdFx0XHRtYXJnaW5EaXYuc3R5bGUuY3NzVGV4dCA9IGRpdi5zdHlsZS5jc3NUZXh0ID1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdFx0XHQvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcblx0XHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveDtcIiArXG5cdFx0XHRcdFwiZGlzcGxheTpibG9jazttYXJnaW46MDtib3JkZXI6MDtwYWRkaW5nOjBcIjtcblx0XHRcdG1hcmdpbkRpdi5zdHlsZS5tYXJnaW5SaWdodCA9IG1hcmdpbkRpdi5zdHlsZS53aWR0aCA9IFwiMFwiO1xuXHRcdFx0ZGl2LnN0eWxlLndpZHRoID0gXCIxcHhcIjtcblx0XHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHRcdHJldCA9ICFwYXJzZUZsb2F0KCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggbWFyZ2luRGl2ICkubWFyZ2luUmlnaHQgKTtcblxuXHRcdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblx0XHRcdGRpdi5yZW1vdmVDaGlsZCggbWFyZ2luRGl2ICk7XG5cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXHRyZXQgPSBjb21wdXRlZCA/IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdIDogdW5kZWZpbmVkO1xuXG5cdC8vIFN1cHBvcnQ6IE9wZXJhIDEyLjF4IG9ubHlcblx0Ly8gRmFsbCBiYWNrIHRvIHN0eWxlIGV2ZW4gd2l0aG91dCBjb21wdXRlZFxuXHQvLyBjb21wdXRlZCBpcyB1bmRlZmluZWQgZm9yIGVsZW1zIG9uIGRvY3VtZW50IGZyYWdtZW50c1xuXHRpZiAoICggcmV0ID09PSBcIlwiIHx8IHJldCA9PT0gdW5kZWZpbmVkICkgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRTlcblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBvbmx5IG5lZWRlZCBmb3IgLmNzcygnZmlsdGVyJykgKCMxMjUzNylcblx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbE1hcmdpblJpZ2h0KCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJtYXJnaW4udGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXJcblxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9LFxuXG5cdGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk9cIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGU7XG5cbi8vIFJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdC8vIFNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXG5cdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSwgaXNCb3JkZXJCb3gsIHN0eWxlcyApIHtcblx0dmFyIGkgPSBleHRyYSA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApID9cblxuXHRcdC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuXHRcdDQgOlxuXG5cdFx0Ly8gT3RoZXJ3aXNlIGluaXRpYWxpemUgZm9yIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydGllc1xuXHRcdG5hbWUgPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXG5cdFx0dmFsID0gMDtcblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW4sIHNvIGFkZCBpdCBpZiB3ZSB3YW50IGl0XG5cdFx0aWYgKCBleHRyYSA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBleHRyYSArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGlzQm9yZGVyQm94ICkge1xuXG5cdFx0XHQvLyBib3JkZXItYm94IGluY2x1ZGVzIHBhZGRpbmcsIHNvIHJlbW92ZSBpdCBpZiB3ZSB3YW50IGNvbnRlbnRcblx0XHRcdGlmICggZXh0cmEgPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGJvcmRlciBub3IgbWFyZ2luLCBzbyByZW1vdmUgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50LCBzbyBhZGQgcGFkZGluZ1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50IG5vciBwYWRkaW5nLCBzbyBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBvZmZzZXQgcHJvcGVydHksIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGJvcmRlci1ib3ggdmFsdWVcblx0dmFyIHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlLFxuXHRcdHZhbCA9IG5hbWUgPT09IFwid2lkdGhcIiA/IGVsZW0ub2Zmc2V0V2lkdGggOiBlbGVtLm9mZnNldEhlaWdodCxcblx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0Ly8gU29tZSBub24taHRtbCBlbGVtZW50cyByZXR1cm4gdW5kZWZpbmVkIGZvciBvZmZzZXRXaWR0aCwgc28gY2hlY2sgZm9yIG51bGwvdW5kZWZpbmVkXG5cdC8vIHN2ZyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY0OTI4NVxuXHQvLyBNYXRoTUwgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD00OTE2Njhcblx0aWYgKCB2YWwgPD0gMCB8fCB2YWwgPT0gbnVsbCApIHtcblxuXHRcdC8vIEZhbGwgYmFjayB0byBjb21wdXRlZCB0aGVuIHVuY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeVxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0aWYgKCB2YWwgPCAwIHx8IHZhbCA9PSBudWxsICkge1xuXHRcdFx0dmFsID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIENvbXB1dGVkIHVuaXQgaXMgbm90IHBpeGVscy4gU3RvcCBoZXJlIGFuZCByZXR1cm4uXG5cdFx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG5cdFx0Ly8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJlxuXHRcdFx0KCBzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlWyBuYW1lIF0gKTtcblxuXHRcdC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcblx0XHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXHR9XG5cblx0Ly8gVXNlIHRoZSBhY3RpdmUgYm94LXNpemluZyBtb2RlbCB0byBhZGQvc3VidHJhY3QgaXJyZWxldmFudCBzdHlsZXNcblx0cmV0dXJuICggdmFsICtcblx0XHRhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdGVsZW0sXG5cdFx0XHRuYW1lLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlc1xuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSwgaGlkZGVuLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKTtcblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gUmVzZXQgdGhlIGlubGluZSBkaXNwbGF5IG9mIHRoaXMgZWxlbWVudCB0byBsZWFybiBpZiBpdCBpc1xuXHRcdFx0Ly8gYmVpbmcgaGlkZGVuIGJ5IGNhc2NhZGVkIHJ1bGVzIG9yIG5vdFxuXHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICYmIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZWxlbWVudHMgd2hpY2ggaGF2ZSBiZWVuIG92ZXJyaWRkZW4gd2l0aCBkaXNwbGF5OiBub25lXG5cdFx0XHQvLyBpbiBhIHN0eWxlc2hlZXQgdG8gd2hhdGV2ZXIgdGhlIGRlZmF1bHQgYnJvd3NlciBzdHlsZSBpc1xuXHRcdFx0Ly8gZm9yIHN1Y2ggYW4gZWxlbWVudFxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW4oIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuYWNjZXNzKFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0XCJvbGRkaXNwbGF5XCIsXG5cdFx0XHRcdFx0ZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRoaWRkZW4gPSBpc0hpZGRlbiggZWxlbSApO1xuXG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiIHx8ICFoaWRkZW4gKSB7XG5cdFx0XHRcdGRhdGFQcml2LnNldChcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdFwib2xkZGlzcGxheVwiLFxuXHRcdFx0XHRcdGhpZGRlbiA/IGRpc3BsYXkgOiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIG1vc3Qgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3Bcblx0Ly8gdG8gYXZvaWQgdGhlIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdGlmICggIXNob3cgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBzaG93ID8gdmFsdWVzWyBpbmRleCBdIHx8IFwiXCIgOiBcIm5vbmVcIjtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7XG5cdFx0XCJmbG9hdFwiOiBcImNzc0Zsb2F0XCJcblx0fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8XG5cdFx0XHQoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBvcmlnTmFtZSApIHx8IG9yaWdOYW1lICk7XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHxcblx0XHRcdCggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG9yaWdOYW1lICkgfHwgb3JpZ05hbWUgKTtcblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXHRcdFx0XHRcdGVsZW0ub2Zmc2V0V2lkdGggPT09IDAgP1xuXHRcdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBleHRyYSAmJiBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSAmJiBhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0KTtcblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gU3VwcG9ydDogQW5kcm9pZCAyLjNcbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5SaWdodCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpblJpZ2h0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiBzd2FwKCBlbGVtLCB7IFwiZGlzcGxheVwiOiBcImlubGluZS1ibG9ja1wiIH0sXG5cdFx0XHRcdGN1ckNTUywgWyBlbGVtLCBcIm1hcmdpblJpZ2h0XCIgXSApO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCAhcm1hcmdpbi50ZXN0KCBwcmVmaXggKSApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUU5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBDb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgdGltZXJJZCxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0galF1ZXJ5Lm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQgOyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0LyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgdHdlZW4sIGhvb2tzLCBvbGRmaXJlLCBkaXNwbGF5LCBjaGVja0Rpc3BsYXksXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBIYW5kbGUgcXVldWU6IGZhbHNlIHByb21pc2VzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEhlaWdodC93aWR0aCBvdmVyZmxvdyBwYXNzXG5cdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiaGVpZ2h0XCIgaW4gcHJvcHMgfHwgXCJ3aWR0aFwiIGluIHByb3BzICkgKSB7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBub3RoaW5nIHNuZWFrcyBvdXRcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFOS0xMCBkbyBub3Rcblx0XHQvLyBjaGFuZ2UgdGhlIG92ZXJmbG93IGF0dHJpYnV0ZSB3aGVuIG92ZXJmbG93WCBhbmRcblx0XHQvLyBvdmVyZmxvd1kgYXJlIHNldCB0byB0aGUgc2FtZSB2YWx1ZVxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gU2V0IGRpc3BsYXkgcHJvcGVydHkgdG8gaW5saW5lLWJsb2NrIGZvciBoZWlnaHQvd2lkdGhcblx0XHQvLyBhbmltYXRpb25zIG9uIGlubGluZSBlbGVtZW50cyB0aGF0IGFyZSBoYXZpbmcgd2lkdGgvaGVpZ2h0IGFuaW1hdGVkXG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cblx0XHQvLyBUZXN0IGRlZmF1bHQgZGlzcGxheSBpZiBkaXNwbGF5IGlzIGN1cnJlbnRseSBcIm5vbmVcIlxuXHRcdGNoZWNrRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID9cblx0XHRcdGRhdGFQcml2LmdldCggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKSB8fCBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApIDogZGlzcGxheTtcblxuXHRcdGlmICggY2hlY2tEaXNwbGF5ID09PSBcImlubGluZVwiICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gc2hvdy9oaWRlIHBhc3Ncblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy5leGVjKCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBkYXRhU2hvdyBsZWZ0IG92ZXIgZnJvbSBhIHN0b3BwZWQgaGlkZSBvciBzaG93XG5cdFx0XHRcdC8vIGFuZCB3ZSBhcmUgZ29pbmcgdG8gcHJvY2VlZCB3aXRoIHNob3csIHdlIHNob3VsZCBwcmV0ZW5kIHRvIGJlIGhpZGRlblxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblxuXHRcdC8vIEFueSBub24tZnggdmFsdWUgc3RvcHMgdXMgZnJvbSByZXN0b3JpbmcgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWVcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGlzcGxheSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblxuXHRpZiAoICFqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHt9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3RvcmUgc3RhdGUgaWYgaXRzIHRvZ2dsZSAtIGVuYWJsZXMgLnN0b3AoKS50b2dnbGUoKSB0byBcInJldmVyc2VcIlxuXHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHR9XG5cdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRqUXVlcnkoIGVsZW0gKS5zaG93KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeSggZWxlbSApLmhpZGUoKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwcm9wO1xuXG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0dHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblxuXHRcdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSB0d2Vlbi5zdGFydDtcblx0XHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdFx0dHdlZW4uZW5kID0gdHdlZW4uc3RhcnQ7XG5cdFx0XHRcdFx0dHdlZW4uc3RhcnQgPSBwcm9wID09PSBcIndpZHRoXCIgfHwgcHJvcCA9PT0gXCJoZWlnaHRcIiA/IDEgOiAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdC8vIElmIHRoaXMgaXMgYSBub29wIGxpa2UgLmhpZGUoKS5oaWRlKCksIHJlc3RvcmUgYW4gb3ZlcndyaXR0ZW4gZGlzcGxheSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCAoIGRpc3BsYXkgPT09IFwibm9uZVwiID8gZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKSA6IGRpc3BsYXkgKSA9PT0gXCJpbmxpbmVcIiApIHtcblx0XHRzdHlsZS5kaXNwbGF5ID0gZGlzcGxheTtcblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0gKSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0alF1ZXJ5LnByb3h5KCByZXN1bHQuc3RvcCwgcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0Ly8gYXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0cmV0dXJuIGFuaW1hdGlvbi5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5vZmYgPyAwIDogdHlwZW9mIG9wdC5kdXJhdGlvbiA9PT0gXCJudW1iZXJcIiA/XG5cdFx0b3B0LmR1cmF0aW9uIDogb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgP1xuXHRcdFx0alF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF0gOiBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0galF1ZXJ5Lm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gQ2hlY2tzIHRoZSB0aW1lciBoYXMgbm90IGFscmVhZHkgYmVlbiByZW1vdmVkXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0aWYgKCB0aW1lcigpICkge1xuXHRcdGpRdWVyeS5meC5zdGFydCgpO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS50aW1lcnMucG9wKCk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggIXRpbWVySWQgKSB7XG5cdFx0dGltZXJJZCA9IHdpbmRvdy5zZXRJbnRlcnZhbCggalF1ZXJ5LmZ4LnRpY2ssIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHR3aW5kb3cuY2xlYXJJbnRlcnZhbCggdGltZXJJZCApO1xuXG5cdHRpbWVySWQgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHA6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBpT1M8PTUuMSwgQW5kcm9pZDw9NC4yK1xuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUU8PTExK1xuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8PTIuM1xuXHQvLyBPcHRpb25zIGluc2lkZSBkaXNhYmxlZCBzZWxlY3RzIGFyZSBpbmNvcnJlY3RseSBtYXJrZWQgYXMgZGlzYWJsZWRcblx0c2VsZWN0LmRpc2FibGVkID0gdHJ1ZTtcblx0c3VwcG9ydC5vcHREaXNhYmxlZCA9ICFvcHQuZGlzYWJsZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUU8PTExK1xuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGF0dHJpYnV0ZXMgYXJlIGxvd2VyY2FzZVxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsIHByb3BOYW1lLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdHByb3BOYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXG5cdFx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBnZXQgc3BlY2lhbCB0cmVhdG1lbnQgKCMxMDg3MClcblx0XHRcdFx0aWYgKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0XHRcdC8vIFNldCBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHRvIGZhbHNlXG5cdFx0XHRcdFx0ZWxlbVsgcHJvcE5hbWUgXSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGU7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIG5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIG5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGFiaW5kZXggP1xuXHRcdFx0XHRcdHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKSA6XG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmIGVsZW0uaHJlZiA/XG5cdFx0XHRcdFx0XHRcdDAgOlxuXHRcdFx0XHRcdFx0XHQtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSApO1xuXG5cblxuXG52YXIgcmNsYXNzID0gL1tcXHRcXHJcXG5cXGZdL2c7XG5cbmZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlICkge1xuXHRcdFx0Y2xhc3NlcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHQoIFwiIFwiICsgY3VyVmFsdWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhenogKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBqUXVlcnkudHJpbSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlICkge1xuXHRcdFx0Y2xhc3NlcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdCggXCIgXCIgKyBjdXJWYWx1ZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0galF1ZXJ5LnRyaW0oIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdFx0d2hpbGUgKCAoIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggXCIgXCIgKyBnZXRDbGFzcyggZWxlbSApICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMVxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZyxcblx0cnNwYWNlcyA9IC9bXFx4MjBcXHRcXHJcXG5cXGZdKy9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiID9cblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0XHRyZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApIDpcblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRcdHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTEwLTExK1xuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0alF1ZXJ5LnRyaW0oIGpRdWVyeS50ZXh0KCBlbGVtICkgKS5yZXBsYWNlKCByc3BhY2VzLCBcIiBcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIgfHwgaW5kZXggPCAwLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aCxcblx0XHRcdFx0XHRpID0gaW5kZXggPCAwID9cblx0XHRcdFx0XHRcdG1heCA6XG5cdFx0XHRcdFx0XHRvbmUgPyBpbmRleCA6IDA7XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCggc3VwcG9ydC5vcHREaXNhYmxlZCA/XG5cdFx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCA6IG9wdGlvbi5nZXRBdHRyaWJ1dGUoIFwiZGlzYWJsZWRcIiApID09PSBudWxsICkgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhalF1ZXJ5Lm5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldCggb3B0aW9uICksIHZhbHVlcyApID4gLTFcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdG9wdGlvblNldCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcblx0XHRcdFx0aWYgKCAhb3B0aW9uU2V0ICkge1xuXHRcdFx0XHRcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5qUXVlcnkuZWFjaCggWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvO1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoIGRhdGFQcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdICYmXG5cdFx0XHRcdGRhdGFQcml2LmdldCggY3VyLCBcImhhbmRsZVwiICk7XG5cdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTmF0aXZlIGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuXHRcdFx0aWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICggIXNwZWNpYWwuX2RlZmF1bHQgfHxcblx0XHRcdFx0c3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlICkgJiZcblx0XHRcdFx0YWNjZXB0RGF0YSggZWxlbSApICkge1xuXG5cdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZWFjaCggKCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCBsb2FkIHJlc2l6ZSBzY3JvbGwgdW5sb2FkIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBlcnJvciBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSApO1xuXG5cblxuXG5zdXBwb3J0LmZvY3VzaW4gPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94XG4vLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xuLy9cbi8vIFN1cHBvcnQ6IENocm9tZSwgU2FmYXJpXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG5pZiAoICFzdXBwb3J0LmZvY3VzaW4gKSB7XG5cdGpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSApO1xuXHRcdH07XG5cblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZG9jLCBmaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9ICk7XG59XG52YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbnZhciBub25jZSA9IGpRdWVyeS5ub3coKTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG4vLyBXb3JrYXJvdW5kIGZhaWx1cmUgdG8gc3RyaW5nLWNhc3QgbnVsbCBpbnB1dFxualF1ZXJ5LnBhcnNlSlNPTiA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSArIFwiXCIgKTtcbn07XG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWw7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRTlcblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJ0cyA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbIDAgXSA9PT0gXCIrXCIgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuXHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC9cXGJ4bWxcXGIvLFxuXHRcdFx0aHRtbDogL1xcYmh0bWwvLFxuXHRcdFx0anNvbjogL1xcYmpzb25cXGIvXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IGpRdWVyeS5wYXJzZUpTT04sXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0Ly8gVXJsIGNsZWFudXAgdmFyXG5cdFx0XHR1cmxBbmNob3IsXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxuXHRcdFx0XHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudCxcblxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cblx0XHRcdC8vIFRoZSBqcVhIUiBzdGF0ZVxuXHRcdFx0c3RhdGUgPSAwLFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgXSA9IG1hdGNoWyAyIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlID09PSAyID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0dmFyIGxuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdGlmICggIXN0YXRlICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIGxuYW1lIF0gPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggIXN0YXRlICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHN0YXRlIDwgMiApIHtcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKS5jb21wbGV0ZSA9IGNvbXBsZXRlRGVmZXJyZWQuYWRkO1xuXHRcdGpxWEhSLnN1Y2Nlc3MgPSBqcVhIUi5kb25lO1xuXHRcdGpxWEhSLmVycm9yID0ganFYSFIuZmFpbDtcblxuXHRcdC8vIFJlbW92ZSBoYXNoIGNoYXJhY3RlciAoIzc1MzE6IGFuZCBzdHJpbmcgcHJvbW90aW9uKVxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKS5yZXBsYWNlKCByaGFzaCwgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiApO1xuXG5cdFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9IGpRdWVyeS50cmltKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOC0xMStcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gaWYgdXJsIGlzIG1hbGZvcm1lZCwgZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTgtMTErXG5cdFx0XHRcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cblx0XHRcdFx0XHR1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuXHRcdFx0XHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybDtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSAoIHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGEgKTtcblxuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBhbnRpLWNhY2hlIGluIHVybCBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHMudXJsID0gcnRzLnRlc3QoIGNhY2hlVVJMICkgP1xuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYWxyZWFkeSBhICdfJyBwYXJhbWV0ZXIsIHNldCBpdHMgdmFsdWVcblx0XHRcdFx0XHRjYWNoZVVSTC5yZXBsYWNlKCBydHMsIFwiJDFfPVwiICsgbm9uY2UrKyApIDpcblxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSBhZGQgb25lIHRvIHRoZSBlbmRcblx0XHRcdFx0XHRjYWNoZVVSTCArICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyBub25jZSsrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcblx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxuXHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBzdGF0ZSA9PT0gMiApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Zm9yICggaSBpbiB7IHN1Y2Nlc3M6IDEsIGVycm9yOiAxLCBjb21wbGV0ZTogMSB9ICkge1xuXHRcdFx0anFYSFJbIGkgXSggc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHN0YXRlID0gMTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBQcm9wYWdhdGUgZXhjZXB0aW9uIGFzIGVycm9yIGlmIG5vdCBkb25lXG5cdFx0XHRcdGlmICggc3RhdGUgPCAyICkge1xuXHRcdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cblx0XHRcdFx0Ly8gU2ltcGx5IHJldGhyb3cgb3RoZXJ3aXNlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIENhbGxlZCBvbmNlXG5cdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXRlIGlzIFwiZG9uZVwiIG5vd1xuXHRcdFx0c3RhdGUgPSAyO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblxuXHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblx0XHRcInRocm93c1wiOiB0cnVlXG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnBhcmVudCgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImJvZHlcIiApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0XHR9XG5cdFx0fSApLmVuZCgpO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIuZmlsdGVycy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5maWx0ZXJzLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5maWx0ZXJzLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHQvLyBTdXBwb3J0OiBPcGVyYSA8PSAxMi4xMlxuXHQvLyBPcGVyYSByZXBvcnRzIG9mZnNldFdpZHRocyBhbmQgb2Zmc2V0SGVpZ2h0cyBsZXNzIHRoYW4gemVybyBvbiBzb21lIGVsZW1lbnRzXG5cdC8vIFVzZSBPUiBpbnN0ZWFkIG9mIEFORCBhcyB0aGUgZWxlbWVudCBpcyBub3QgdmlzaWJsZSBpZiBlaXRoZXIgaXMgdHJ1ZVxuXHQvLyBTZWUgdGlja2V0cyAjMTA0MDYgYW5kICMxMzEzMlxuXHRyZXR1cm4gZWxlbS5vZmZzZXRXaWR0aCA+IDAgfHwgZWxlbS5vZmZzZXRIZWlnaHQgPiAwIHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPiAwO1xufTtcblxuXG5cblxudmFyIHIyMCA9IC8lMjAvZyxcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgcmV0dXJuIGl0cyB2YWx1ZVxuXHRcdFx0dmFsdWUgPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSA/IHZhbHVlKCkgOiAoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlICk7XG5cdFx0fTtcblxuXHQvLyBTZXQgdHJhZGl0aW9uYWwgdG8gdHJ1ZSBmb3IgalF1ZXJ5IDw9IDEuMy4yIGJlaGF2aW9yLlxuXHRpZiAoIHRyYWRpdGlvbmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0dHJhZGl0aW9uYWwgPSBqUXVlcnkuYWpheFNldHRpbmdzICYmIGpRdWVyeS5hamF4U2V0dGluZ3MudHJhZGl0aW9uYWw7XG5cdH1cblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9IClcblx0XHQuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApXG5cdFx0Lm1hcCggZnVuY3Rpb24oIGksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdHJldHVybiB2YWwgPT0gbnVsbCA/XG5cdFx0XHRcdG51bGwgOlxuXHRcdFx0XHRqUXVlcnkuaXNBcnJheSggdmFsICkgP1xuXHRcdFx0XHRcdGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHR7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUU5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0gY2FsbGJhY2soIFwiZXJyb3JcIiApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFOVxuXHRcdFx0XHQvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxuXHRcdFx0XHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXG5cdFx0XHRcdGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcblx0XHRcdFx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG5cdFx0XHRcdFx0XHRcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxuXHRcdFx0XHRcdFx0XHQvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0XHQvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcblx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayggXCJhYm9ydFwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXCIgK1xuXHRcdFx0XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0fVxufSApO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblxuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRzY3JpcHQgPSBqUXVlcnkoIFwiPHNjcmlwdD5cIiApLnByb3AoIHtcblx0XHRcdFx0XHRjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsXG5cdFx0XHRcdFx0c3JjOiBzLnVybFxuXHRcdFx0XHR9ICkub24oXG5cdFx0XHRcdFx0XCJsb2FkIGVycm9yXCIsXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBqUXVlcnkuaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHR2YXIgcGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICksXG5cdFx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLy8gS2VlcCBhIGNvcHkgb2YgdGhlIG9sZCBsb2FkIG1ldGhvZFxudmFyIF9sb2FkID0galF1ZXJ5LmZuLmxvYWQ7XG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdGlmICggdHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIiAmJiBfbG9hZCApIHtcblx0XHRyZXR1cm4gX2xvYWQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHR9XG5cblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0galF1ZXJ5LnRyaW0oIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5leHByLmZpbHRlcnMuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG4vKipcbiAqIEdldHMgYSB3aW5kb3cgZnJvbSBhbiBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApID8gZWxlbSA6IGVsZW0ubm9kZVR5cGUgPT09IDkgJiYgZWxlbS5kZWZhdWx0Vmlldztcbn1cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIGRvY0VsZW0sIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRib3ggPSB7IHRvcDogMCwgbGVmdDogMCB9LFxuXHRcdFx0ZG9jID0gZWxlbSAmJiBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRpZiAoICFkb2MgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHQvLyBNYWtlIHN1cmUgaXQncyBub3QgYSBkaXNjb25uZWN0ZWQgRE9NIG5vZGVcblx0XHRpZiAoICFqUXVlcnkuY29udGFpbnMoIGRvY0VsZW0sIGVsZW0gKSApIHtcblx0XHRcdHJldHVybiBib3g7XG5cdFx0fVxuXG5cdFx0Ym94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBnZXRXaW5kb3coIGRvYyApO1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IGJveC50b3AgKyB3aW4ucGFnZVlPZmZzZXQgLSBkb2NFbGVtLmNsaWVudFRvcCxcblx0XHRcdGxlZnQ6IGJveC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRMZWZ0XG5cdFx0fTtcblx0fSxcblxuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gRml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHdpbmRvdyAocGFyZW50T2Zmc2V0ID0ge3RvcDowLCBsZWZ0OiAwfSxcblx0XHQvLyBiZWNhdXNlIGl0IGlzIGl0cyBvbmx5IG9mZnNldCBwYXJlbnRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIEFzc3VtZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgdGhlcmUgd2hlbiBjb21wdXRlZCBwb3NpdGlvbiBpcyBmaXhlZFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEdldCAqcmVhbCogb2Zmc2V0UGFyZW50XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpO1xuXG5cdFx0XHQvLyBHZXQgY29ycmVjdCBvZmZzZXRzXG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJodG1sXCIgKSApIHtcblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0gb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcblx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcblx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHQvL1xuXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcblx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdC8vXG5cdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblx0XHRcdHZhciB3aW4gPSBnZXRXaW5kb3coIGVsZW0gKTtcblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpPDctOCssIENocm9tZTwzNy00NCtcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIyOTI4MFxuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sXG5cdFx0ZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBBcyBvZiA1LzgvMjAxMiB0aGlzIHdpbGwgeWllbGQgaW5jb3JyZWN0IHJlc3VsdHMgZm9yIE1vYmlsZSBTYWZhcmksIGJ1dCB0aGVyZVxuXHRcdFx0XHRcdC8vIGlzbid0IGEgd2hvbGUgbG90IHdlIGNhbiBkby4gU2VlIHB1bGwgcmVxdWVzdCBhdCB0aGlzIFVSTCBmb3IgZGlzY3Vzc2lvbjpcblx0XHRcdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzc2NFxuXHRcdFx0XHRcdHJldHVybiBlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSwgbnVsbCApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9LFxuXHRzaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5sZW5ndGg7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmFuZFNlbGYgPSBqUXVlcnkuZm4uYWRkQmFjaztcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG52YXJcblxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5pZiAoICFub0dsb2JhbCApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5yZXR1cm4galF1ZXJ5O1xufSkpO1xuIiwiLyoqXHJcbiAqIGltYWdlZmlsbC5qc1xyXG4gKiBBdXRob3IgJiBjb3B5cmlnaHQgKGMpIDIwMTM6IEpvaG4gUG9sYWNla1xyXG4gKiBqb2hucG9sYWNlay5jb21cclxuICogaHR0cHM6Ly90d2l0dGVyLmNvbS9qb2hucG9sYWNla1xyXG4gKlxyXG4gKiBEdWFsIE1JVCAmIEdQTCBsaWNlbnNlXHJcbiAqXHJcbiAqIFByb2plY3QgUGFnZTogaHR0cDovL2pvaG5wb2xhY2VrLmdpdGh1Yi5pby9pbWFnZWZpbGwuanNcclxuICpcclxuICogVGhlIGpRdWVyeSBwbHVnaW4gZm9yIG1ha2luZyBpbWFnZXMgZmlsbCB0aGVpciBjb250YWluZXJzIChhbmQgYmUgY2VudGVyZWQpXHJcbiAqXHJcbiAqIEVYQU1QTEVcclxuICogR2l2ZW4gdGhpcyBodG1sOlxyXG4gKiA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+PGltZyBzcmM9XCJteWF3ZXNvbWVpbWFnZVwiIC8+PC9kaXY+XHJcbiAqICQoJy5jb250YWluZXInKS5pbWFnZWZpbGwoKTsgLy8gaW1hZ2Ugc3RyZXRjaGVzIHRvIGZpbGwgY29udGFpbmVyXHJcbiAqXHJcbiAqIFJFUVVJUkVTOlxyXG4gKiBpbWFnZXNMb2FkZWQgLSBodHRwczovL2dpdGh1Yi5jb20vZGVzYW5kcm8vaW1hZ2VzbG9hZGVkXHJcbiAqXHJcbiAqL1xyXG4gOyhmdW5jdGlvbigkKSB7XHJcblxyXG4gICQuZm4uaW1hZ2VmaWxsID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cclxuICAgIHZhciAkY29udGFpbmVyID0gdGhpcyxcclxuICAgICAgICBpbWFnZUFzcGVjdCA9IDEvMSxcclxuICAgICAgICBjb250YWluZXJzSCA9IDAsXHJcbiAgICAgICAgY29udGFpbmVyc1cgPSAwLFxyXG4gICAgICAgIGRlZmF1bHRzID0ge1xyXG4gICAgICAgICAgcnVuT25jZTogZmFsc2UsXHJcbiAgICAgICAgICB0YXJnZXQ6ICdpbWcnLFxyXG4gICAgICAgICAgdGhyb3R0bGUgOiAyMDAgIC8vIDVmcHNcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldHRpbmdzID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcclxuXHJcbiAgICB2YXIgJGltZyA9ICRjb250YWluZXIuZmluZChzZXR0aW5ncy50YXJnZXQpLmFkZENsYXNzKCdsb2FkaW5nJykuY3NzKHsncG9zaXRpb24nOidhYnNvbHV0ZSd9KTtcclxuXHJcbiAgICAvLyBtYWtlIHN1cmUgY29udGFpbmVyIGlzbid0IHBvc2l0aW9uOnN0YXRpY1xyXG4gICAgdmFyIGNvbnRhaW5lclBvcyA9ICRjb250YWluZXIuY3NzKCdwb3NpdGlvbicpO1xyXG4gICAgJGNvbnRhaW5lci5jc3MoeydvdmVyZmxvdyc6J2hpZGRlbicsJ3Bvc2l0aW9uJzooY29udGFpbmVyUG9zID09PSAnc3RhdGljJykgPyAncmVsYXRpdmUnIDogY29udGFpbmVyUG9zfSk7XHJcblxyXG4gICAgLy8gc2V0IGNvbnRhaW5lckgsIGNvbnRhaW5lcldcclxuICAgICRjb250YWluZXIuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgY29udGFpbmVyc0ggKz0gJCh0aGlzKS5vdXRlckhlaWdodCgpO1xyXG4gICAgICBjb250YWluZXJzVyArPSAkKHRoaXMpLm91dGVyV2lkdGgoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHdhaXQgZm9yIGltYWdlIHRvIGxvYWQsIHRoZW4gZml0IGl0IGluc2lkZSB0aGUgY29udGFpbmVyXHJcbiAgICAkY29udGFpbmVyLmltYWdlc0xvYWRlZCgpLmRvbmUoZnVuY3Rpb24oaW1nKSB7XHJcbiAgICAgIGltYWdlQXNwZWN0ID0gJGltZy53aWR0aCgpIC8gJGltZy5oZWlnaHQoKTtcclxuICAgICAgJGltZy5yZW1vdmVDbGFzcygnbG9hZGluZycpO1xyXG4gICAgICBmaXRJbWFnZXMoKTtcclxuICAgICAgaWYgKCFzZXR0aW5ncy5ydW5PbmNlKSB7XHJcbiAgICAgICAgY2hlY2tTaXplQ2hhbmdlKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIGZpdEltYWdlcygpIHtcclxuICAgICAgY29udGFpbmVyc0ggID0gMDtcclxuICAgICAgY29udGFpbmVyc1cgPSAwO1xyXG4gICAgICAkY29udGFpbmVyLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaW1hZ2VBc3BlY3QgPSAkKHRoaXMpLmZpbmQoc2V0dGluZ3MudGFyZ2V0KS53aWR0aCgpIC8gJCh0aGlzKS5maW5kKHNldHRpbmdzLnRhcmdldCkuaGVpZ2h0KCk7XHJcbiAgICAgICAgdmFyIGNvbnRhaW5lclcgPSAkKHRoaXMpLm91dGVyV2lkdGgoKSxcclxuICAgICAgICAgICAgY29udGFpbmVySCA9ICQodGhpcykub3V0ZXJIZWlnaHQoKTtcclxuICAgICAgICBjb250YWluZXJzSCArPSAkKHRoaXMpLm91dGVySGVpZ2h0KCk7XHJcbiAgICAgICAgY29udGFpbmVyc1cgKz0gJCh0aGlzKS5vdXRlcldpZHRoKCk7XHJcblxyXG4gICAgICAgIHZhciBjb250YWluZXJBc3BlY3QgPSBjb250YWluZXJXL2NvbnRhaW5lckg7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5lckFzcGVjdCA8IGltYWdlQXNwZWN0KSB7XHJcbiAgICAgICAgICAvLyB0YWxsZXJcclxuICAgICAgICAgICQodGhpcykuZmluZChzZXR0aW5ncy50YXJnZXQpLmNzcyh7XHJcbiAgICAgICAgICAgICAgd2lkdGg6ICdhdXRvJyxcclxuICAgICAgICAgICAgICBoZWlnaHQ6IGNvbnRhaW5lckgsXHJcbiAgICAgICAgICAgICAgdG9wOjAsXHJcbiAgICAgICAgICAgICAgbGVmdDotKGNvbnRhaW5lckgqaW1hZ2VBc3BlY3QtY29udGFpbmVyVykvMlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gd2lkZXJcclxuICAgICAgICAgICQodGhpcykuZmluZChzZXR0aW5ncy50YXJnZXQpLmNzcyh7XHJcbiAgICAgICAgICAgICAgd2lkdGg6IGNvbnRhaW5lclcsXHJcbiAgICAgICAgICAgICAgaGVpZ2h0OiAnYXV0bycsXHJcbiAgICAgICAgICAgICAgLy90b3A6LShjb250YWluZXJXL2ltYWdlQXNwZWN0LWNvbnRhaW5lckgpLzIsXHJcbiAgICAgICAgICAgICAgdG9wIDowLFxyXG4gICAgICAgICAgICAgIGxlZnQ6MFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNoZWNrU2l6ZUNoYW5nZSgpIHtcclxuICAgICAgdmFyIGNoZWNrVyA9IDAsXHJcbiAgICAgICAgICBjaGVja0ggPSAwO1xyXG4gICAgICAkY29udGFpbmVyLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY2hlY2tIICs9ICQodGhpcykub3V0ZXJIZWlnaHQoKTtcclxuICAgICAgICBjaGVja1cgKz0gJCh0aGlzKS5vdXRlcldpZHRoKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoY29udGFpbmVyc0ggIT09IGNoZWNrSCB8fCBjb250YWluZXJzVyAhPT0gY2hlY2tXKSB7XHJcbiAgICAgICAgZml0SW1hZ2VzKCk7XHJcbiAgICAgIH1cclxuICAgICAgc2V0VGltZW91dChjaGVja1NpemVDaGFuZ2UsIHNldHRpbmdzLnRocm90dGxlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxufShqUXVlcnkpKTtcclxuIiwiLyohXHJcbiAqIGpRdWVyeSBpbWFnZXNMb2FkZWQgcGx1Z2luIHYyLjEuMFxyXG4gKiBodHRwOi8vZ2l0aHViLmNvbS9kZXNhbmRyby9pbWFnZXNsb2FkZWRcclxuICpcclxuICogTUlUIExpY2Vuc2UuIGJ5IFBhdWwgSXJpc2ggZXQgYWwuXHJcbiAqL1xyXG5cclxuLypqc2hpbnQgY3VybHk6IHRydWUsIGVxZXFlcTogdHJ1ZSwgbm9lbXB0eTogdHJ1ZSwgc3RyaWN0OiB0cnVlLCB1bmRlZjogdHJ1ZSwgYnJvd3NlcjogdHJ1ZSAqL1xyXG4vKmdsb2JhbCBqUXVlcnk6IGZhbHNlICovXHJcblxyXG47KGZ1bmN0aW9uKCQsIHVuZGVmaW5lZCkge1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vLyBibGFuayBpbWFnZSBkYXRhLXVyaSBieXBhc3NlcyB3ZWJraXQgbG9nIHdhcm5pbmcgKHRoeCBkb3VnIGpvbmVzKVxyXG52YXIgQkxBTksgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBQUFBQVAvLy95d0FBQUFBQVFBQkFBQUNBVXdBT3c9PSc7XHJcblxyXG4kLmZuLmltYWdlc0xvYWRlZCA9IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcclxuXHR2YXIgJHRoaXMgPSB0aGlzLFxyXG5cdFx0ZGVmZXJyZWQgPSAkLmlzRnVuY3Rpb24oJC5EZWZlcnJlZCkgPyAkLkRlZmVycmVkKCkgOiAwLFxyXG5cdFx0aGFzTm90aWZ5ID0gJC5pc0Z1bmN0aW9uKGRlZmVycmVkLm5vdGlmeSksXHJcblx0XHQkaW1hZ2VzID0gJHRoaXMuZmluZCgnaW1nJykuYWRkKCAkdGhpcy5maWx0ZXIoJ2ltZycpICksXHJcblx0XHRsb2FkZWQgPSBbXSxcclxuXHRcdHByb3BlciA9IFtdLFxyXG5cdFx0YnJva2VuID0gW107XHJcblxyXG5cdC8vIFJlZ2lzdGVyIGRlZmVycmVkIGNhbGxiYWNrc1xyXG5cdGlmICgkLmlzUGxhaW5PYmplY3QoY2FsbGJhY2spKSB7XHJcblx0XHQkLmVhY2goY2FsbGJhY2ssIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcblx0XHRcdGlmIChrZXkgPT09ICdjYWxsYmFjaycpIHtcclxuXHRcdFx0XHRjYWxsYmFjayA9IHZhbHVlO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGRlZmVycmVkKSB7XHJcblx0XHRcdFx0ZGVmZXJyZWRba2V5XSh2YWx1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZG9uZUxvYWRpbmcoKSB7XHJcblx0XHR2YXIgJHByb3BlciA9ICQocHJvcGVyKSxcclxuXHRcdFx0JGJyb2tlbiA9ICQoYnJva2VuKTtcclxuXHJcblx0XHRpZiAoIGRlZmVycmVkICkge1xyXG5cdFx0XHRpZiAoIGJyb2tlbi5sZW5ndGggKSB7XHJcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0KCAkaW1hZ2VzLCAkcHJvcGVyLCAkYnJva2VuICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZSggJGltYWdlcyApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCAkLmlzRnVuY3Rpb24oIGNhbGxiYWNrICkgKSB7XHJcblx0XHRcdGNhbGxiYWNrLmNhbGwoICR0aGlzLCAkaW1hZ2VzLCAkcHJvcGVyLCAkYnJva2VuICk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBpbWdMb2FkZWQoIGltZywgaXNCcm9rZW4gKSB7XHJcblx0XHQvLyBkb24ndCBwcm9jZWVkIGlmIEJMQU5LIGltYWdlLCBvciBpbWFnZSBpcyBhbHJlYWR5IGxvYWRlZFxyXG5cdFx0aWYgKCBpbWcuc3JjID09PSBCTEFOSyB8fCAkLmluQXJyYXkoIGltZywgbG9hZGVkICkgIT09IC0xICkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc3RvcmUgZWxlbWVudCBpbiBsb2FkZWQgaW1hZ2VzIGFycmF5XHJcblx0XHRsb2FkZWQucHVzaCggaW1nICk7XHJcblxyXG5cdFx0Ly8ga2VlcCB0cmFjayBvZiBicm9rZW4gYW5kIHByb3Blcmx5IGxvYWRlZCBpbWFnZXNcclxuXHRcdGlmICggaXNCcm9rZW4gKSB7XHJcblx0XHRcdGJyb2tlbi5wdXNoKCBpbWcgKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHByb3Blci5wdXNoKCBpbWcgKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjYWNoZSBpbWFnZSBhbmQgaXRzIHN0YXRlIGZvciBmdXR1cmUgY2FsbHNcclxuXHRcdCQuZGF0YSggaW1nLCAnaW1hZ2VzTG9hZGVkJywgeyBpc0Jyb2tlbjogaXNCcm9rZW4sIHNyYzogaW1nLnNyYyB9ICk7XHJcblxyXG5cdFx0Ly8gdHJpZ2dlciBkZWZlcnJlZCBwcm9ncmVzcyBtZXRob2QgaWYgcHJlc2VudFxyXG5cdFx0aWYgKCBoYXNOb3RpZnkgKSB7XHJcblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoICQoaW1nKSwgWyBpc0Jyb2tlbiwgJGltYWdlcywgJChwcm9wZXIpLCAkKGJyb2tlbikgXSApO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNhbGwgZG9uZUxvYWRpbmcgYW5kIGNsZWFuIGxpc3RlbmVycyBpZiBhbGwgaW1hZ2VzIGFyZSBsb2FkZWRcclxuXHRcdGlmICggJGltYWdlcy5sZW5ndGggPT09IGxvYWRlZC5sZW5ndGggKXtcclxuXHRcdFx0c2V0VGltZW91dCggZG9uZUxvYWRpbmcgKTtcclxuXHRcdFx0JGltYWdlcy51bmJpbmQoICcuaW1hZ2VzTG9hZGVkJyApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gaWYgbm8gaW1hZ2VzLCB0cmlnZ2VyIGltbWVkaWF0ZWx5XHJcblx0aWYgKCAhJGltYWdlcy5sZW5ndGggKSB7XHJcblx0XHRkb25lTG9hZGluZygpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHQkaW1hZ2VzLmJpbmQoICdsb2FkLmltYWdlc0xvYWRlZCBlcnJvci5pbWFnZXNMb2FkZWQnLCBmdW5jdGlvbiggZXZlbnQgKXtcclxuXHRcdFx0Ly8gdHJpZ2dlciBpbWdMb2FkZWRcclxuXHRcdFx0aW1nTG9hZGVkKCBldmVudC50YXJnZXQsIGV2ZW50LnR5cGUgPT09ICdlcnJvcicgKTtcclxuXHRcdH0pLmVhY2goIGZ1bmN0aW9uKCBpLCBlbCApIHtcclxuXHRcdFx0dmFyIHNyYyA9IGVsLnNyYztcclxuXHJcblx0XHRcdC8vIGZpbmQgb3V0IGlmIHRoaXMgaW1hZ2UgaGFzIGJlZW4gYWxyZWFkeSBjaGVja2VkIGZvciBzdGF0dXNcclxuXHRcdFx0Ly8gaWYgaXQgd2FzLCBhbmQgc3JjIGhhcyBub3QgY2hhbmdlZCwgY2FsbCBpbWdMb2FkZWQgb24gaXRcclxuXHRcdFx0dmFyIGNhY2hlZCA9ICQuZGF0YSggZWwsICdpbWFnZXNMb2FkZWQnICk7XHJcblx0XHRcdGlmICggY2FjaGVkICYmIGNhY2hlZC5zcmMgPT09IHNyYyApIHtcclxuXHRcdFx0XHRpbWdMb2FkZWQoIGVsLCBjYWNoZWQuaXNCcm9rZW4gKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGlmIGNvbXBsZXRlIGlzIHRydWUgYW5kIGJyb3dzZXIgc3VwcG9ydHMgbmF0dXJhbCBzaXplcywgdHJ5XHJcblx0XHRcdC8vIHRvIGNoZWNrIGZvciBpbWFnZSBzdGF0dXMgbWFudWFsbHlcclxuXHRcdFx0aWYgKCBlbC5jb21wbGV0ZSAmJiBlbC5uYXR1cmFsV2lkdGggIT09IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0XHRpbWdMb2FkZWQoIGVsLCBlbC5uYXR1cmFsV2lkdGggPT09IDAgfHwgZWwubmF0dXJhbEhlaWdodCA9PT0gMCApO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gY2FjaGVkIGltYWdlcyBkb24ndCBmaXJlIGxvYWQgc29tZXRpbWVzLCBzbyB3ZSByZXNldCBzcmMsIGJ1dCBvbmx5IHdoZW5cclxuXHRcdFx0Ly8gZGVhbGluZyB3aXRoIElFLCBvciBpbWFnZSBpcyBjb21wbGV0ZSAobG9hZGVkKSBhbmQgZmFpbGVkIG1hbnVhbCBjaGVja1xyXG5cdFx0XHQvLyB3ZWJraXQgaGFjayBmcm9tIGh0dHA6Ly9ncm91cHMuZ29vZ2xlLmNvbS9ncm91cC9qcXVlcnktZGV2L2Jyb3dzZV90aHJlYWQvdGhyZWFkL2VlZTZhYjdiMmRhNTBlMWZcclxuXHRcdFx0aWYgKCBlbC5yZWFkeVN0YXRlIHx8IGVsLmNvbXBsZXRlICkge1xyXG5cdFx0XHRcdGVsLnNyYyA9IEJMQU5LO1xyXG5cdFx0XHRcdGVsLnNyYyA9IHNyYztcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZGVmZXJyZWQgPyBkZWZlcnJlZC5wcm9taXNlKCAkdGhpcyApIDogJHRoaXM7XHJcbn07XHJcblxyXG59KShqUXVlcnkpO1xyXG4iLCIoZnVuY3Rpb24gKEVMRU1FTlQpIHtcclxuXHRFTEVNRU5ULm1hdGNoZXMgPSBFTEVNRU5ULm1hdGNoZXMgfHwgRUxFTUVOVC5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgRUxFTUVOVC5tc01hdGNoZXNTZWxlY3RvciB8fCBFTEVNRU5ULm9NYXRjaGVzU2VsZWN0b3IgfHwgRUxFTUVOVC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZnVuY3Rpb24gbWF0Y2hlcyhzZWxlY3Rvcikge1xyXG5cdFx0dmFyXHJcblx0XHRlbGVtZW50ID0gdGhpcyxcclxuXHRcdGVsZW1lbnRzID0gKGVsZW1lbnQuZG9jdW1lbnQgfHwgZWxlbWVudC5vd25lckRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSxcclxuXHRcdGluZGV4ID0gMDtcclxuXHJcblx0XHR3aGlsZSAoZWxlbWVudHNbaW5kZXhdICYmIGVsZW1lbnRzW2luZGV4XSAhPT0gZWxlbWVudCkge1xyXG5cdFx0XHQrK2luZGV4O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBlbGVtZW50c1tpbmRleF0gPyB0cnVlIDogZmFsc2U7XHJcblx0fTtcclxuXHJcblx0RUxFTUVOVC5jbG9zZXN0ID0gRUxFTUVOVC5jbG9zZXN0IHx8IGZ1bmN0aW9uIGNsb3Nlc3Qoc2VsZWN0b3IpIHtcclxuXHRcdHZhciBlbGVtZW50ID0gdGhpcztcclxuXHJcblx0XHR3aGlsZSAoZWxlbWVudCkge1xyXG5cdFx0XHRpZiAoZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKSkge1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBlbGVtZW50O1xyXG5cdH07XHJcbn0oRWxlbWVudC5wcm90b3R5cGUpKTtcclxuXHJcbi8qIVxyXG4gKiBBIHBvbHlmaWxsIGZvciBXZWJraXQncyB3aW5kb3cuZ2V0TWF0Y2hlZENTU1J1bGVzLCBiYXNlZCBvblxyXG4gKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS95ZGFuaXYvMzAzMzAxMlxyXG4gKlxyXG4gKiBAYXV0aG9yOiBZZWhvbmF0YW4gRGFuaXZcclxuICogQGF1dGhvcjogc3NhZmVqYXZhXHJcbiAqIEBhdXRob3I6IENocmlzdGlhbiBcIlNjaGVwcFwiIFNjaGFlZmVyIDxzY2hhZXBwQGdteC5kZT5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG5cdC8vIHBvbHlmaWxsIHdpbmRvdy5nZXRNYXRjaGVkQ1NTUnVsZXMoKSBpbiBGaXJlRm94IDYrXHJcblx0aWYgKHR5cGVvZiB3aW5kb3cuZ2V0TWF0Y2hlZENTU1J1bGVzID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHR2YXIgRUxFTUVOVF9SRSA9IC9bXFx3LV0rL2csXHJcblx0XHRJRF9SRSA9IC8jW1xcdy1dKy9nLFxyXG5cdFx0Q0xBU1NfUkUgPSAvXFwuW1xcdy1dKy9nLFxyXG5cdFx0QVRUUl9SRSA9IC9cXFtbXlxcXV0rXFxdL2csXHJcblx0XHQvLyA6bm90KCkgcHNldWRvLWNsYXNzIGRvZXMgbm90IGFkZCB0byBzcGVjaWZpY2l0eSwgYnV0IGl0cyBjb250ZW50IGRvZXMgYXMgaWYgaXQgd2FzIG91dHNpZGUgaXRcclxuXHRcdFBTRVVET19DTEFTU0VTX1JFID0gL1xcOig/IW5vdClbXFx3LV0rKFxcKC4qXFwpKT8vZyxcclxuXHRcdFBTRVVET19FTEVNRU5UU19SRSA9IC9cXDpcXDo/KGFmdGVyfGJlZm9yZXxmaXJzdC1sZXR0ZXJ8Zmlyc3QtbGluZXxzZWxlY3Rpb24pL2c7XHJcblxyXG5cdC8vIGNvbnZlcnQgYW4gYXJyYXktbGlrZSBvYmplY3QgdG8gYXJyYXlcclxuXHR2YXIgdG9BcnJheSA9IGZ1bmN0aW9uIChsaXN0KSB7XHJcblx0XHR2YXIgaXRlbXMgPSBbXTtcclxuXHRcdHZhciBpID0gMDtcclxuXHRcdHZhciBsaXN0TGVuZ3RoID0gbGlzdC5sZW5ndGg7XHJcblxyXG5cdFx0Zm9yICg7IGkgPCBsaXN0TGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aXRlbXMucHVzaChsaXN0W2ldKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaXRlbXM7XHJcblx0fTtcclxuXHJcblx0Ly8gZ2V0IGhvc3Qgb2Ygc3R5bGVzaGVldFxyXG5cdHZhciBnZXRDU1NIb3N0ID0gZnVuY3Rpb24gKGhyZWYpIHtcclxuXHRcdHZhciBmYWtlTGlua09mU2hlZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XHJcblxyXG5cdFx0ZmFrZUxpbmtPZlNoZWV0LmhyZWYgPSBocmVmO1xyXG5cclxuXHRcdHJldHVybiBmYWtlTGlua09mU2hlZXQuaG9zdDtcclxuXHR9O1xyXG5cclxuXHQvLyBoYW5kbGVzIGV4dHJhY3Rpb24gb2YgYGNzc1J1bGVzYCBhcyBhbiBgQXJyYXlgIGZyb20gYSBzdHlsZXNoZWV0IG9yIHNvbWV0aGluZyB0aGF0IGJlaGF2ZXMgdGhlIHNhbWVcclxuXHR2YXIgZ2V0U2hlZXRSdWxlcyA9IGZ1bmN0aW9uIChzdHlsZXNoZWV0KSB7XHJcblx0XHR2YXIgc2hlZXRNZWRpYSA9IHN0eWxlc2hlZXQubWVkaWEgJiYgc3R5bGVzaGVldC5tZWRpYS5tZWRpYVRleHQ7XHJcblx0XHR2YXIgc2hlZXRIb3N0O1xyXG5cclxuXHRcdC8vIGlmIHRoaXMgc2hlZXQgaXMgY3Jvc3Mtb3JpZ2luIGFuZCBvcHRpb24gaXMgc2V0IHNraXAgaXRcclxuXHRcdGlmIChvYmplY3RGaXQuZGlzYWJsZUNyb3NzRG9tYWluID09ICd0cnVlJykge1xyXG5cdFx0XHRzaGVldEhvc3QgPSBnZXRDU1NIb3N0KHN0eWxlc2hlZXQuaHJlZik7XHJcblxyXG5cdFx0XHRpZiAoKHNoZWV0SG9zdCAhPT0gd2luZG93LmxvY2F0aW9uLmhvc3QpKSB7XHJcblx0XHRcdFx0cmV0dXJuIFtdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cclxuXHRcdC8vIGlmIHRoaXMgc2hlZXQgaXMgZGlzYWJsZWQgc2tpcCBpdFxyXG5cdFx0aWYgKHN0eWxlc2hlZXQuZGlzYWJsZWQpIHtcclxuXHRcdFx0cmV0dXJuIFtdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghd2luZG93Lm1hdGNoTWVkaWEpIHtcclxuXHRcdFx0aWYgKHNoZWV0TWVkaWEgJiYgc2hlZXRNZWRpYS5sZW5ndGgpIHtcclxuXHRcdFx0XHRyZXR1cm4gW107XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdC8vIGlmIHRoaXMgc2hlZXQncyBtZWRpYSBpcyBzcGVjaWZpZWQgYW5kIGRvZXNuJ3QgbWF0Y2ggdGhlIHZpZXdwb3J0IHRoZW4gc2tpcCBpdFxyXG5cdFx0ZWxzZSBpZiAoc2hlZXRNZWRpYSAmJiBzaGVldE1lZGlhLmxlbmd0aCAmJiAhIHdpbmRvdy5tYXRjaE1lZGlhKHNoZWV0TWVkaWEpLm1hdGNoZXMpIHtcclxuXHRcdFx0cmV0dXJuIFtdO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGdldCB0aGUgc3R5bGUgcnVsZXMgb2YgdGhpcyBzaGVldFxyXG5cdFx0cmV0dXJuIHRvQXJyYXkoc3R5bGVzaGVldC5jc3NSdWxlcyk7XHJcblx0fTtcclxuXHJcblx0dmFyIF9maW5kID0gZnVuY3Rpb24gKHN0cmluZywgcmUpIHtcclxuXHRcdHZhciBtYXRjaGVzID0gc3RyaW5nLm1hdGNoKHJlKTtcclxuXHJcblx0XHRyZXR1cm4gcmUgPyByZS5sZW5ndGggOiAwO1xyXG5cdH07XHJcblxyXG5cdC8vIGNhbGN1bGF0ZXMgdGhlIHNwZWNpZmljaXR5IG9mIGEgZ2l2ZW4gYHNlbGVjdG9yYFxyXG5cdHZhciBjYWxjdWxhdGVTY29yZSA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG5cdFx0dmFyIHNjb3JlID0gWzAsIDAsIDBdO1xyXG5cdFx0dmFyIHBhcnRzID0gc2VsZWN0b3Iuc3BsaXQoJyAnKTtcclxuXHRcdHZhciBwYXJ0O1xyXG5cdFx0dmFyIG1hdGNoO1xyXG5cclxuXHRcdC8vVE9ETzogY2xlYW4gdGhlICc6bm90JyBwYXJ0IHNpbmNlIHRoZSBsYXN0IEVMRU1FTlRfUkUgd2lsbCBwaWNrIGl0IHVwXHJcblx0XHR3aGlsZSAocGFydCA9IHBhcnRzLnNoaWZ0KCksIHR5cGVvZiBwYXJ0ID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHQvLyBmaW5kIGFsbCBwc2V1ZG8tZWxlbWVudHNcclxuXHRcdFx0bWF0Y2ggPSBfZmluZChwYXJ0LCBQU0VVRE9fRUxFTUVOVFNfUkUpO1xyXG5cdFx0XHRzY29yZVsyXSA9IG1hdGNoO1xyXG5cdFx0XHQvLyBhbmQgcmVtb3ZlIHRoZW1cclxuXHRcdFx0bWF0Y2ggJiYgKHBhcnQgPSBwYXJ0LnJlcGxhY2UoUFNFVURPX0VMRU1FTlRTX1JFLCAnJykpO1xyXG5cdFx0XHQvLyBmaW5kIGFsbCBwc2V1ZG8tY2xhc3Nlc1xyXG5cdFx0XHRtYXRjaCA9IF9maW5kKHBhcnQsIFBTRVVET19DTEFTU0VTX1JFKTtcclxuXHRcdFx0c2NvcmVbMV0gPSBtYXRjaDtcclxuXHRcdFx0Ly8gYW5kIHJlbW92ZSB0aGVtXHJcblx0XHRcdG1hdGNoICYmIChwYXJ0ID0gcGFydC5yZXBsYWNlKFBTRVVET19DTEFTU0VTX1JFLCAnJykpO1xyXG5cdFx0XHQvLyBmaW5kIGFsbCBhdHRyaWJ1dGVzXHJcblx0XHRcdG1hdGNoID0gX2ZpbmQocGFydCwgQVRUUl9SRSk7XHJcblx0XHRcdHNjb3JlWzFdICs9IG1hdGNoO1xyXG5cdFx0XHQvLyBhbmQgcmVtb3ZlIHRoZW1cclxuXHRcdFx0bWF0Y2ggJiYgKHBhcnQgPSBwYXJ0LnJlcGxhY2UoQVRUUl9SRSwgJycpKTtcclxuXHRcdFx0Ly8gZmluZCBhbGwgSURzXHJcblx0XHRcdG1hdGNoID0gX2ZpbmQocGFydCwgSURfUkUpO1xyXG5cdFx0XHRzY29yZVswXSA9IG1hdGNoO1xyXG5cdFx0XHQvLyBhbmQgcmVtb3ZlIHRoZW1cclxuXHRcdFx0bWF0Y2ggJiYgKHBhcnQgPSBwYXJ0LnJlcGxhY2UoSURfUkUsICcnKSk7XHJcblx0XHRcdC8vIGZpbmQgYWxsIGNsYXNzZXNcclxuXHRcdFx0bWF0Y2ggPSBfZmluZChwYXJ0LCBDTEFTU19SRSk7XHJcblx0XHRcdHNjb3JlWzFdICs9IG1hdGNoO1xyXG5cdFx0XHQvLyBhbmQgcmVtb3ZlIHRoZW1cclxuXHRcdFx0bWF0Y2ggJiYgKHBhcnQgPSBwYXJ0LnJlcGxhY2UoQ0xBU1NfUkUsICcnKSk7XHJcblx0XHRcdC8vIGZpbmQgYWxsIGVsZW1lbnRzXHJcblx0XHRcdHNjb3JlWzJdICs9IF9maW5kKHBhcnQsIEVMRU1FTlRfUkUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwYXJzZUludChzY29yZS5qb2luKCcnKSwgMTApO1xyXG5cdH07XHJcblxyXG5cdC8vIHJldHVybnMgdGhlIGhlaWdodHMgcG9zc2libGUgc3BlY2lmaWNpdHkgc2NvcmUgYW4gZWxlbWVudCBjYW4gZ2V0IGZyb20gYSBnaXZlIHJ1bGUncyBzZWxlY3RvclRleHRcclxuXHR2YXIgZ2V0U3BlY2lmaWNpdHlTY29yZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3RvclRleHQpIHtcclxuXHRcdHZhciBzZWxlY3RvcnMgPSBzZWxlY3RvclRleHQuc3BsaXQoJywnKSxcclxuXHRcdFx0c2VsZWN0b3IsIHNjb3JlLCByZXN1bHQgPSAwO1xyXG5cclxuXHRcdHdoaWxlIChzZWxlY3RvciA9IHNlbGVjdG9ycy5zaGlmdCgpKSB7XHJcblx0XHRcdGlmIChlbGVtZW50LmNsb3Nlc3Qoc2VsZWN0b3IpKSB7XHJcblx0XHRcdFx0c2NvcmUgPSBjYWxjdWxhdGVTY29yZShzZWxlY3Rvcik7XHJcblx0XHRcdFx0cmVzdWx0ID0gc2NvcmUgPiByZXN1bHQgPyBzY29yZSA6IHJlc3VsdDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fTtcclxuXHJcblx0dmFyIHNvcnRCeVNwZWNpZmljaXR5ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHJ1bGVzKSB7XHJcblx0XHQvLyBjb21wYXJpbmcgZnVuY3Rpb24gdGhhdCBzb3J0cyBDU1NTdHlsZVJ1bGVzIGFjY29yZGluZyB0byBzcGVjaWZpY2l0eSBvZiB0aGVpciBgc2VsZWN0b3JUZXh0YFxyXG5cdFx0dmFyIGNvbXBhcmVTcGVjaWZpY2l0eSA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcblx0XHRcdHJldHVybiBnZXRTcGVjaWZpY2l0eVNjb3JlKGVsZW1lbnQsIGIuc2VsZWN0b3JUZXh0KSAtIGdldFNwZWNpZmljaXR5U2NvcmUoZWxlbWVudCwgYS5zZWxlY3RvclRleHQpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gcnVsZXMuc29ydChjb21wYXJlU3BlY2lmaWNpdHkpO1xyXG5cdH07XHJcblxyXG5cdC8vVE9ETzogbm90IHN1cHBvcnRpbmcgMm5kIGFyZ3VtZW50IGZvciBzZWxlY3RpbmcgcHNldWRvIGVsZW1lbnRzXHJcblx0Ly9UT0RPOiBub3Qgc3VwcG9ydGluZyAzcmQgYXJndW1lbnQgZm9yIGNoZWNraW5nIGF1dGhvciBzdHlsZSBzaGVldHMgb25seVxyXG5cdHdpbmRvdy5nZXRNYXRjaGVkQ1NTUnVsZXMgPSBmdW5jdGlvbiAoZWxlbWVudCkgeyAgLyosIHBzZXVkbywgYXV0aG9yX29ubHkqL1xyXG5cdFx0dmFyIHN0eWxlU2hlZXRzO1xyXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdFx0dmFyIHNoZWV0O1xyXG5cdFx0dmFyIHJ1bGVzO1xyXG5cdFx0dmFyIHJ1bGU7XHJcblxyXG5cdFx0Ly8gZ2V0IHN0eWxlc2hlZXRzIGFuZCBjb252ZXJ0IHRvIGEgcmVndWxhciBBcnJheVxyXG5cdFx0c3R5bGVTaGVldHMgPSB0b0FycmF5KHdpbmRvdy5kb2N1bWVudC5zdHlsZVNoZWV0cyk7XHJcblxyXG5cdFx0Ly8gYXNzdW1pbmcgdGhlIGJyb3dzZXIgaGFuZHMgdXMgc3R5bGVzaGVldHMgaW4gb3JkZXIgb2YgYXBwZWFyYW5jZVxyXG5cdFx0Ly8gd2UgaXRlcmF0ZSB0aGVtIGZyb20gdGhlIGJlZ2lubmluZyB0byBmb2xsb3cgcHJvcGVyIGNhc2NhZGUgb3JkZXJcclxuXHRcdHdoaWxlIChzaGVldCA9IHN0eWxlU2hlZXRzLnNoaWZ0KCkpIHtcclxuXHRcdFx0Ly8gZ2V0IHRoZSBzdHlsZSBydWxlcyBvZiB0aGlzIHNoZWV0XHJcblx0XHRcdHJ1bGVzID0gZ2V0U2hlZXRSdWxlcyhzaGVldCk7XHJcblxyXG5cdFx0XHQvLyBsb29wIHRoZSBydWxlcyBpbiBvcmRlciBvZiBhcHBlYXJhbmNlXHJcblx0XHRcdHdoaWxlIChydWxlID0gcnVsZXMuc2hpZnQoKSkge1xyXG5cdFx0XHRcdC8vIGlmIHRoaXMgaXMgYW4gQGltcG9ydCBydWxlXHJcblx0XHRcdFx0aWYgKHJ1bGUuc3R5bGVTaGVldCkge1xyXG5cdFx0XHRcdFx0Ly8gaW5zZXJ0IHRoZSBpbXBvcnRlZCBzdHlsZXNoZWV0J3MgcnVsZXMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGlzIHN0eWxlc2hlZXQncyBydWxlc1xyXG5cdFx0XHRcdFx0cnVsZXMgPSBnZXRTaGVldFJ1bGVzKHJ1bGUuc3R5bGVTaGVldCkuY29uY2F0KHJ1bGVzKTtcclxuXHRcdFx0XHRcdC8vIGFuZCBza2lwIHRoaXMgcnVsZVxyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIGlmIHRoZXJlJ3Mgbm8gc3R5bGVzaGVldCBhdHRyaWJ1dGUgQlVUIHRoZXJlIElTIGEgbWVkaWEgYXR0cmlidXRlIGl0J3MgYSBtZWRpYSBydWxlXHJcblx0XHRcdFx0ZWxzZSBpZiAocnVsZS5tZWRpYSkge1xyXG5cdFx0XHRcdFx0Ly8gaW5zZXJ0IHRoZSBjb250YWluZWQgcnVsZXMgb2YgdGhpcyBtZWRpYSBydWxlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBzdHlsZXNoZWV0J3MgcnVsZXNcclxuXHRcdFx0XHRcdHJ1bGVzID0gZ2V0U2hlZXRSdWxlcyhydWxlKS5jb25jYXQocnVsZXMpO1xyXG5cdFx0XHRcdFx0Ly8gYW5kIHNraXAgaXRcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gY2hlY2sgaWYgdGhpcyBlbGVtZW50IG1hdGNoZXMgdGhpcyBydWxlJ3Mgc2VsZWN0b3JcclxuXHRcdFx0XHRpZiAoZWxlbWVudC5jbG9zZXN0KHJ1bGUuc2VsZWN0b3JUZXh0KSkge1xyXG5cdFx0XHRcdFx0Ly8gcHVzaCB0aGUgcnVsZSB0byB0aGUgcmVzdWx0cyBzZXRcclxuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKHJ1bGUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Ly8gc29ydCBhY2NvcmRpbmcgdG8gc3BlY2lmaWNpdHlcclxuXHRcdHJldHVybiBzb3J0QnlTcGVjaWZpY2l0eShlbGVtZW50LCByZXN1bHQpO1xyXG5cdH07XHJcbn0oKSk7XHJcblxyXG4vKlxyXG4gKiByYWYuanNcclxuICogaHR0cHM6Ly9naXRodWIuY29tL25ncnltYW4vcmFmLmpzXHJcbiAqXHJcbiAqIG9yaWdpbmFsIHJlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbCBieSBFcmlrIE3DtmxsZXJcclxuICogaW5zcGlyZWQgZnJvbSBwYXVsX2lyaXNoIGdpc3QgYW5kIHBvc3RcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEzIG5ncnltYW5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxyXG4gKi9cclxuXHJcbihmdW5jdGlvbih3aW5kb3cpIHtcclxuXHR2YXIgbGFzdFRpbWUgPSAwLFxyXG5cdFx0dmVuZG9ycyA9IFsnd2Via2l0JywgJ21veiddLFxyXG5cdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSxcclxuXHRcdGNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lLFxyXG5cdFx0aSA9IHZlbmRvcnMubGVuZ3RoO1xyXG5cclxuXHQvLyB0cnkgdG8gdW4tcHJlZml4IGV4aXN0aW5nIHJhZlxyXG5cdHdoaWxlICgtLWkgPj0gMCAmJiAhcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XHJcblx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdmVuZG9yc1tpXSArICdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcclxuXHRcdGNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbaV0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXTtcclxuXHR9XHJcblxyXG5cdC8vIHBvbHlmaWxsIHdpdGggc2V0VGltZW91dCBmYWxsYmFja1xyXG5cdC8vIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBAZGFyaXVzIGdpc3QgbW9kOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvMTU3OTY3MSNjb21tZW50LTgzNzk0NVxyXG5cdGlmICghcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8ICFjYW5jZWxBbmltYXRpb25GcmFtZSkge1xyXG5cdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHRcdFx0dmFyIG5vdyA9ICtuZXcgRGF0ZSgpLCBuZXh0VGltZSA9IE1hdGgubWF4KGxhc3RUaW1lICsgMTYsIG5vdyk7XHJcblx0XHRcdHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGNhbGxiYWNrKGxhc3RUaW1lID0gbmV4dFRpbWUpO1xyXG5cdFx0XHR9LCBuZXh0VGltZSAtIG5vdyk7XHJcblx0XHR9O1xyXG5cclxuXHRcdGNhbmNlbEFuaW1hdGlvbkZyYW1lID0gY2xlYXJUaW1lb3V0O1xyXG5cdH1cclxuXHJcblx0Ly8gZXhwb3J0IHRvIHdpbmRvd1xyXG5cdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XHJcblx0d2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gY2FuY2VsQW5pbWF0aW9uRnJhbWU7XHJcbn0od2luZG93KSk7XHJcblxyXG4vKiFcclxuICogUG9seWZpbGwgQ1NTIG9iamVjdC1maXRcclxuICogaHR0cDovL2hlbGxvYW5zZWxtLmNvbS9vYmplY3QtZml0XHJcbiAqXHJcbiAqIEBhdXRob3I6IEFuc2VsbSBIYW5uZW1hbm4gPGhlbGxvQGFuc2VsbS1oYW5uZW1hbm4uY29tPlxyXG4gKiBAYXV0aG9yOiBDaHJpc3RpYW4gXCJTY2hlcHBcIiBTY2hhZWZlciA8c2NoYWVwcEBnbXguZGU+XHJcbiAqIEB2ZXJzaW9uOiAwLjMuNFxyXG4gKlxyXG4gKi9cclxuXHJcbihmdW5jdGlvbiAoZ2xvYmFsKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0Ly8gU3RvcmFnZSB2YXJpYWJsZVxyXG5cdHZhciBvYmplY3RGaXQgPSB7fTtcclxuXHJcblx0b2JqZWN0Rml0Ll9kZWJ1ZyA9IGZhbHNlO1xyXG5cclxuXHRvYmplY3RGaXQub2JzZXJ2ZXIgPSBudWxsO1xyXG5cclxuXHRvYmplY3RGaXQuZGlzYWJsZUNyb3NzRG9tYWluID0gJ2ZhbHNlJztcclxuXHJcblx0b2JqZWN0Rml0LmdldENvbXB1dGVkU3R5bGUgPSBmdW5jdGlvbihlbGVtZW50LCBjb250ZXh0KSB7XHJcblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCB3aW5kb3c7XHJcblxyXG5cdFx0aWYgKGNvbnRleHQuZ2V0Q29tcHV0ZWRTdHlsZSkge1xyXG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHJldHVybiBlbGVtZW50LmN1cnJlbnRTdHlsZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRvYmplY3RGaXQuZ2V0RGVmYXVsdENvbXB1dGVkU3R5bGUgPSBmdW5jdGlvbihlbGVtZW50KXtcclxuXHRcdHZhciBuZXdlbGVtZW50ID0gZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XHJcblx0XHR2YXIgc3R5bGVzID0ge307XHJcblx0XHR2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XHJcblx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XHJcblx0XHRpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudC5vcGVuKCk7XHJcblx0XHRpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudC53cml0ZSgnPGJvZHk+PC9ib2R5PicpO1xyXG5cdFx0aWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChuZXdlbGVtZW50KTtcclxuXHRcdGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50LmNsb3NlKCk7XHJcblxyXG5cdFx0dmFyIGRlZmF1bHRFbGVtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpWzBdO1xyXG5cdFx0dmFyIGRlZmF1bHRDb21wdXRlZFN0eWxlID0gdGhpcy5nZXRDb21wdXRlZFN0eWxlKGRlZmF1bHRFbGVtZW50LCBpZnJhbWUuY29udGVudFdpbmRvdyk7XHJcblx0XHR2YXIgdmFsdWU7XHJcblx0XHR2YXIgcHJvcGVydHk7XHJcblxyXG5cdFx0Zm9yIChwcm9wZXJ0eSBpbiBkZWZhdWx0Q29tcHV0ZWRTdHlsZSkge1xyXG5cdFx0XHRpZiAoZGVmYXVsdENvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSA9PT0gdHJ1ZSkge1xyXG5cdFx0XHRcdHZhbHVlID0gZGVmYXVsdENvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFsdWUgPSBkZWZhdWx0Q29tcHV0ZWRTdHlsZVtwcm9wZXJ0eV07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh2YWx1ZSAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdHN3aXRjaCAocHJvcGVydHkpIHtcclxuXHRcdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRcdHN0eWxlc1twcm9wZXJ0eV0gPSB2YWx1ZTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ3dpZHRoJzpcclxuXHRcdFx0XHRcdGNhc2UgJ2hlaWdodCc6XHJcblx0XHRcdFx0XHRjYXNlICdtaW5XaWR0aCc6XHJcblx0XHRcdFx0XHRjYXNlICdtaW5IZWlnaHQnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbWF4V2lkdGgnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbWF4SGVpZ2h0JzpcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcclxuXHJcblx0XHRyZXR1cm4gc3R5bGVzO1xyXG5cdH07XHJcblxyXG5cdG9iamVjdEZpdC5nZXRNYXRjaGVkU3R5bGUgPSBmdW5jdGlvbihlbGVtZW50LCBwcm9wZXJ0eSl7XHJcblx0XHQvLyBlbGVtZW50IHByb3BlcnR5IGhhcyBoaWdoZXN0IHByaW9yaXR5XHJcblx0XHR2YXIgdmFsID0gbnVsbDtcclxuXHRcdHZhciBpbmxpbmV2YWwgPSBudWxsO1xyXG5cclxuXHRcdGlmIChlbGVtZW50LnN0eWxlLmdldFByb3BlcnR5VmFsdWUpIHtcclxuXHRcdFx0aW5saW5ldmFsID0gZWxlbWVudC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcclxuXHRcdH0gZWxzZSBpZiAoZWxlbWVudC5jdXJyZW50U3R5bGUpIHtcclxuXHRcdFx0aW5saW5ldmFsID0gZWxlbWVudC5jdXJyZW50U3R5bGVbcHJvcGVydHldO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGdldCBtYXRjaGVkIHJ1bGVzXHJcblx0XHR2YXIgcnVsZXMgPSB3aW5kb3cuZ2V0TWF0Y2hlZENTU1J1bGVzKGVsZW1lbnQpO1xyXG5cdFx0dmFyIGkgPSBydWxlcy5sZW5ndGg7XHJcblx0XHR2YXIgcjtcclxuXHRcdHZhciBpbXBvcnRhbnQ7XHJcblxyXG5cdFx0aWYgKGkpIHtcclxuXHRcdFx0Ly8gaXRlcmF0ZSB0aGUgcnVsZXMgYmFja3dhcmRzXHJcblx0XHRcdC8vIHJ1bGVzIGFyZSBvcmRlcmVkIGJ5IHByaW9yaXR5LCBoaWdoZXN0IGxhc3RcclxuXHRcdFx0Zm9yICg7IGkgLS0+IDA7KSB7XHJcblx0XHRcdFx0ciA9IHJ1bGVzW2ldO1xyXG5cdFx0XHRcdGltcG9ydGFudCA9IHIuc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eShwcm9wZXJ0eSk7XHJcblxyXG5cdFx0XHRcdC8vIGlmIHNldCwgb25seSByZXNldCBpZiBpbXBvcnRhbnRcclxuXHRcdFx0XHRpZiAodmFsID09PSBudWxsIHx8IGltcG9ydGFudCkge1xyXG5cdFx0XHRcdFx0dmFsID0gci5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcclxuXHJcblx0XHRcdFx0XHQvLyBkb25lIGlmIGltcG9ydGFudFxyXG5cdFx0XHRcdFx0aWYgKGltcG9ydGFudCkge1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBpZiBpdCdzIGltcG9ydGFudCwgd2UgYXJlIGRvbmVcclxuXHRcdGlmICghdmFsICYmIGlubGluZXZhbCAhPT0gbnVsbCkge1xyXG5cdFx0XHR2YWwgPSBpbmxpbmV2YWw7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHZhbDtcclxuXHR9O1xyXG5cclxuXHQvLyBEZXRlY3RzIG9yaWVudGF0aW9uXHJcblx0b2JqZWN0Rml0Lm9yaWVudGF0aW9uID0gZnVuY3Rpb24ocmVwbGFjZWRFbGVtZW50KSB7XHJcblx0XHRpZiAocmVwbGFjZWRFbGVtZW50LnBhcmVudE5vZGUgJiYgcmVwbGFjZWRFbGVtZW50LnBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3gtb2JqZWN0LWZpdCcpIHtcclxuXHRcdFx0dmFyIHdpZHRoID0gcmVwbGFjZWRFbGVtZW50Lm5hdHVyYWxXaWR0aCB8fCByZXBsYWNlZEVsZW1lbnQuY2xpZW50V2lkdGg7XHJcblx0XHRcdHZhciBoZWlnaHQgPSByZXBsYWNlZEVsZW1lbnQubmF0dXJhbEhlaWdodCB8fCByZXBsYWNlZEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xyXG5cdFx0XHR2YXIgcGFyZW50V2lkdGggPSByZXBsYWNlZEVsZW1lbnQucGFyZW50Tm9kZS5jbGllbnRXaWR0aDtcclxuXHRcdFx0dmFyIHBhcmVudEhlaWdodCA9IHJlcGxhY2VkRWxlbWVudC5wYXJlbnROb2RlLmNsaWVudEhlaWdodDtcclxuXHJcblx0XHRcdGlmICghaGVpZ2h0IHx8IHdpZHRoIC8gaGVpZ2h0ID4gcGFyZW50V2lkdGggLyBwYXJlbnRIZWlnaHQpIHtcclxuXHRcdFx0XHRpZiAocmVwbGFjZWRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS14LW9iamVjdC1yZWxhdGlvbicpICE9PSAnd2lkZXInKSB7XHJcblx0XHRcdFx0XHRyZXBsYWNlZEVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLXgtb2JqZWN0LXJlbGF0aW9uJywnd2lkZXInKTtcclxuXHRcdFx0XHRcdHJlcGxhY2VkRWxlbWVudC5jbGFzc05hbWUgPSAneC1vYmplY3QtZml0LXdpZGVyJztcclxuXHJcblx0XHRcdFx0XHRpZiAodGhpcy5fZGVidWcgJiYgd2luZG93LmNvbnNvbGUpIHtcclxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coJ3gtb2JqZWN0LWZpdC13aWRlcicpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiAocmVwbGFjZWRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS14LW9iamVjdC1yZWxhdGlvbicpICE9PSAndGFsbGVyJykge1xyXG5cdFx0XHRcdFx0cmVwbGFjZWRFbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS14LW9iamVjdC1yZWxhdGlvbicsJ3RhbGxlcicpO1xyXG5cdFx0XHRcdFx0cmVwbGFjZWRFbGVtZW50LmNsYXNzTmFtZSA9ICd4LW9iamVjdC1maXQtdGFsbGVyJztcclxuXHJcblx0XHRcdFx0XHRpZiAodGhpcy5fZGVidWcgJiYgd2luZG93LmNvbnNvbGUpIHtcclxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coJ3gtb2JqZWN0LWZpdC10YWxsZXInKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRvYmplY3RGaXQucHJvY2VzcyA9IGZ1bmN0aW9uKGFyZ3MpIHtcclxuXHRcdGlmICghYXJncy5zZWxlY3RvciB8fCAhYXJncy5yZXBsYWNlZEVsZW1lbnRzKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBTZXQgb3B0aW9uIG9iamVjdEZpdC5kaXNhYmxlQ3Jvc3NEb21haW5cclxuXHRcdG9iamVjdEZpdC5kaXNhYmxlQ3Jvc3NEb21haW4gPSBhcmdzLmRpc2FibGVDcm9zc0RvbWFpbiB8fCAnZmFsc2UnO1xyXG5cclxuXHRcdC8vIFNldCBvcHRpb24gZml0LXR5cGVcclxuXHRcdGFyZ3MuZml0dHlwZSA9IGFyZ3MuZml0dHlwZSB8fCAnbm9uZSc7XHJcblxyXG5cdFx0c3dpdGNoIChhcmdzLmZpdHR5cGUpIHtcclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHRjYXNlICdub25lJzpcclxuXHRcdFx0Y2FzZSAnZmlsbCc6XHJcblx0XHRcdGNhc2UgJ2NvbnRhaW4nOlxyXG5cdFx0XHRjYXNlICdjb3Zlcic6XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNldCBvcHRpb24gcmVwbGFjZWRFbGVtZW50c1xyXG5cdFx0dmFyIHJlcGxhY2VkRWxlbWVudHMgPSBhcmdzLnJlcGxhY2VkRWxlbWVudHM7XHJcblxyXG5cdFx0aWYoIXJlcGxhY2VkRWxlbWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgcmVwbGFjZWRFbGVtZW50c0xlbmd0aCA9IHJlcGxhY2VkRWxlbWVudHMubGVuZ3RoOyBpIDwgcmVwbGFjZWRFbGVtZW50c0xlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRoaXMucHJvY2Vzc0VsZW1lbnQocmVwbGFjZWRFbGVtZW50c1tpXSwgYXJncyk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0b2JqZWN0Rml0LnByb2Nlc3NFbGVtZW50ID0gZnVuY3Rpb24ocmVwbGFjZWRFbGVtZW50LCBhcmdzKSB7XHJcblx0XHR2YXIgcHJvcGVydHk7XHJcblx0XHR2YXIgdmFsdWU7XHJcblx0XHR2YXIgcmVwbGFjZWRFbGVtZW50U3R5bGVzID0gb2JqZWN0Rml0LmdldENvbXB1dGVkU3R5bGUocmVwbGFjZWRFbGVtZW50KTtcclxuXHRcdHZhciByZXBsYWNlZEVsZW1lbnREZWZhdWx0U3R5bGVzID0gb2JqZWN0Rml0LmdldERlZmF1bHRDb21wdXRlZFN0eWxlKHJlcGxhY2VkRWxlbWVudCk7XHJcblx0XHR2YXIgd3JhcHBlckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd4LW9iamVjdC1maXQnKTtcclxuXHJcblx0XHRpZiAob2JqZWN0Rml0Ll9kZWJ1ZyAmJiB3aW5kb3cuY29uc29sZSkge1xyXG5cdFx0XHRjb25zb2xlLmxvZygnQXBwbHlpbmcgdG8gV1JBUFBFUi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHByb3BlcnR5IGluIHJlcGxhY2VkRWxlbWVudFN0eWxlcykge1xyXG5cdFx0XHRzd2l0Y2ggKHByb3BlcnR5KSB7XHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdHZhbHVlID0gb2JqZWN0Rml0LmdldE1hdGNoZWRTdHlsZShyZXBsYWNlZEVsZW1lbnQsIHByb3BlcnR5KTtcclxuXHJcblx0XHRcdFx0XHRpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09ICcnKSB7XHJcblx0XHRcdFx0XHRcdGlmIChvYmplY3RGaXQuX2RlYnVnICYmIHdpbmRvdy5jb25zb2xlKSB7XHJcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2cocHJvcGVydHkgKyAnOiAnICsgdmFsdWUpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR3cmFwcGVyRWxlbWVudC5zdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnbGVuZ3RoJzpcclxuXHRcdFx0XHRjYXNlICdwYXJlbnRSdWxlJzpcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvYmplY3RGaXQuX2RlYnVnICYmIHdpbmRvdy5jb25zb2xlKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKCdBcHBseWluZyB0byBSRVBMQUNFRCBFTEVNRU5ULS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO1xyXG5cdFx0fVxyXG5cdFx0Zm9yIChwcm9wZXJ0eSBpbiByZXBsYWNlZEVsZW1lbnREZWZhdWx0U3R5bGVzKSB7XHJcblx0XHRcdHN3aXRjaCAocHJvcGVydHkpIHtcclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0dmFsdWUgPSByZXBsYWNlZEVsZW1lbnREZWZhdWx0U3R5bGVzW3Byb3BlcnR5XTtcclxuXHJcblx0XHRcdFx0XHRpZiAob2JqZWN0Rml0Ll9kZWJ1ZyAmJiB3aW5kb3cuY29uc29sZSAmJiB2YWx1ZSAhPT0gJycpIHtcclxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2cocHJvcGVydHkgKyAnOiAnICsgdmFsdWUpO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKHJlcGxhY2VkRWxlbWVudC5zdHlsZVtwcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCdJbmRleGVkIHN0eWxlIHByb3BlcnRpZXMgKGAnICsgcHJvcGVydHkgKyAnYCkgbm90IHN1cHBvcnRlZCBpbjogJyArIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmIChyZXBsYWNlZEVsZW1lbnQuc3R5bGVbcHJvcGVydHldKSB7XHJcblx0XHRcdFx0XHRcdHJlcGxhY2VkRWxlbWVudC5zdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTsgLy8gc2hvdWxkIHdvcmsgaW4gRmlyZWZveCAzNSsgYW5kIGFsbCBvdGhlciBicm93c2Vyc1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0cmVwbGFjZWRFbGVtZW50LnN0eWxlLnByb3BlcnR5ID0gdmFsdWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2xlbmd0aCc6XHJcblx0XHRcdFx0Y2FzZSAncGFyZW50UnVsZSc6XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR3cmFwcGVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywneC1vYmplY3QtZml0LScgKyBhcmdzLmZpdHR5cGUpO1xyXG5cdFx0cmVwbGFjZWRFbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHdyYXBwZXJFbGVtZW50LCByZXBsYWNlZEVsZW1lbnQpO1xyXG5cdFx0d3JhcHBlckVsZW1lbnQuYXBwZW5kQ2hpbGQocmVwbGFjZWRFbGVtZW50KTtcclxuXHJcblx0XHRvYmplY3RGaXQub3JpZW50YXRpb24ocmVwbGFjZWRFbGVtZW50KTtcclxuXHJcblx0XHR2YXIgcmVzaXplVGltZXIgPSBudWxsO1xyXG5cdFx0dmFyIHJlc2l6ZUFjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHJlc2l6ZVRpbWVyICE9PSBudWxsKSB7XHJcblx0XHRcdFx0d2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlc2l6ZVRpbWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXNpemVUaW1lciA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtcclxuXHRcdFx0XHRvYmplY3RGaXQub3JpZW50YXRpb24ocmVwbGFjZWRFbGVtZW50KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9O1xyXG5cclxuXHRcdHN3aXRjaCAoYXJncy5maXR0eXBlKSB7XHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAnY29udGFpbic6XHJcblx0XHRcdGNhc2UgJ2NvdmVyJzpcclxuXHRcdFx0XHRpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcclxuXHRcdFx0XHRcdHJlcGxhY2VkRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgcmVzaXplQWN0aW9uLCBmYWxzZSk7XHJcblx0XHRcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplQWN0aW9uLCBmYWxzZSk7XHJcblx0XHRcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCByZXNpemVBY3Rpb24sIGZhbHNlKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cmVwbGFjZWRFbGVtZW50LmF0dGFjaEV2ZW50KCdvbmxvYWQnLCByZXNpemVBY3Rpb24pO1xyXG5cdFx0XHRcdFx0d2luZG93LmF0dGFjaEV2ZW50KCdvbnJlc2l6ZScsIHJlc2l6ZUFjdGlvbik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRicmVhaztcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRvYmplY3RGaXQubGlzdGVuID0gZnVuY3Rpb24gKGFyZ3MpIHtcclxuXHRcdHZhciBkb21JbnNlcnRlZEFjdGlvbiA9IGZ1bmN0aW9uIChlbGVtZW50KXtcclxuXHRcdFx0dmFyIGkgPSAwO1xyXG5cdFx0XHR2YXIgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoO1xyXG5cclxuXHRcdFx0Zm9yICg7IGkgPCBhcmdzTGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRpZiAoKGVsZW1lbnQubW96TWF0Y2hlc1NlbGVjdG9yICYmIGVsZW1lbnQubW96TWF0Y2hlc1NlbGVjdG9yKGFyZ3NbaV0uc2VsZWN0b3IpKSB8fFxyXG5cdFx0XHRcdFx0KGVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3IgJiYgZWxlbWVudC5tc01hdGNoZXNTZWxlY3RvcihhcmdzW2ldLnNlbGVjdG9yKSkgfHxcclxuXHRcdFx0XHRcdChlbGVtZW50Lm9NYXRjaGVzU2VsZWN0b3IgJiYgZWxlbWVudC5vTWF0Y2hlc1NlbGVjdG9yKGFyZ3NbaV0uc2VsZWN0b3IpKSB8fFxyXG5cdFx0XHRcdFx0KGVsZW1lbnQud2Via2l0TWF0Y2hlc1NlbGVjdG9yICYmIGVsZW1lbnQud2Via2l0TWF0Y2hlc1NlbGVjdG9yKGFyZ3NbaV0uc2VsZWN0b3IpKVxyXG5cdFx0XHRcdCkge1xyXG5cdFx0XHRcdFx0YXJnc1tpXS5yZXBsYWNlZEVsZW1lbnRzID0gW2VsZW1lbnRdO1xyXG5cdFx0XHRcdFx0b2JqZWN0Rml0LnByb2Nlc3MoYXJnc1tpXSk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKG9iamVjdEZpdC5fZGVidWcgJiYgd2luZG93LmNvbnNvbGUpIHtcclxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coJ01hdGNoaW5nIG5vZGUgaW5zZXJ0ZWQ6ICcgKyBlbGVtZW50Lm5vZGVOYW1lKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIGRvbUluc2VydGVkT2JzZXJ2ZXJGdW5jdGlvbiA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcblx0XHRcdG9iamVjdEZpdC5vYnNlcnZlci5kaXNjb25uZWN0KCk7XHJcblx0XHRcdGRvbUluc2VydGVkQWN0aW9uKGVsZW1lbnQpO1xyXG5cdFx0XHRvYmplY3RGaXQub2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHtcclxuXHRcdFx0XHRjaGlsZExpc3Q6IHRydWUsXHJcblx0XHRcdFx0c3VidHJlZTogdHJ1ZVxyXG5cdFx0XHR9KTtcclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIGRvbUluc2VydGVkRXZlbnRGdW5jdGlvbiA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTm9kZUluc2VydGVkJywgZG9tSW5zZXJ0ZWRFdmVudEZ1bmN0aW9uLCBmYWxzZSk7XHJcblx0XHRcdGRvbUluc2VydGVkQWN0aW9uKGV2ZW50LnRhcmdldCk7XHJcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Ob2RlSW5zZXJ0ZWQnLCBkb21JbnNlcnRlZEV2ZW50RnVuY3Rpb24sIGZhbHNlKTtcclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIGRvbVJlbW92ZWRBY3Rpb24gPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG5cdFx0XHRpZiAoZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAneC1vYmplY3QtZml0Jykge1xyXG5cdFx0XHRcdGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcclxuXHJcblx0XHRcdFx0aWYgKG9iamVjdEZpdC5fZGVidWcgJiYgd2luZG93LmNvbnNvbGUpIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdNYXRjaGluZyBub2RlIHJlbW92ZWQ6ICcgKyBlbGVtZW50Lm5vZGVOYW1lKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIGRvbVJlbW92ZWRPYnNlcnZlckZ1bmN0aW9uID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuXHRcdFx0b2JqZWN0Rml0Lm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuXHRcdFx0ZG9tUmVtb3ZlZEFjdGlvbihlbGVtZW50KTtcclxuXHRcdFx0b2JqZWN0Rml0Lm9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7XHJcblx0XHRcdFx0Y2hpbGRMaXN0OiB0cnVlLFxyXG5cdFx0XHRcdHN1YnRyZWU6IHRydWVcclxuXHRcdFx0fSk7XHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciBkb21SZW1vdmVkRXZlbnRGdW5jdGlvbiA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTm9kZVJlbW92ZWQnLCBkb21SZW1vdmVkRXZlbnRGdW5jdGlvbiwgZmFsc2UpO1xyXG5cdFx0XHRkb21SZW1vdmVkQWN0aW9uKGV2ZW50LnRhcmdldC5wYXJlbnROb2RlKTtcclxuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU5vZGVSZW1vdmVkJywgZG9tUmVtb3ZlZEV2ZW50RnVuY3Rpb24sIGZhbHNlKTtcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyKSB7XHJcblx0XHRcdGlmIChvYmplY3RGaXQuX2RlYnVnICYmIHdpbmRvdy5jb25zb2xlKSB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coJ0RPTSBNdXRhdGlvbk9ic2VydmVyJyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbihtdXRhdGlvbnMpIHtcclxuXHRcdFx0XHRtdXRhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihtdXRhdGlvbikge1xyXG5cdFx0XHRcdFx0aWYgKG11dGF0aW9uLmFkZGVkTm9kZXMgJiYgbXV0YXRpb24uYWRkZWROb2Rlcy5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdFx0dmFyIG5vZGVzID0gbXV0YXRpb24uYWRkZWROb2RlcztcclxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoOyBpIDwgbm9kZXNMZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRcdGRvbUluc2VydGVkT2JzZXJ2ZXJGdW5jdGlvbihub2Rlc1tpXSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChtdXRhdGlvbi5yZW1vdmVkTm9kZXMgJiYgbXV0YXRpb24ucmVtb3ZlZE5vZGVzLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRkb21SZW1vdmVkT2JzZXJ2ZXJGdW5jdGlvbihtdXRhdGlvbi50YXJnZXQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHtcclxuXHRcdFx0XHRjaGlsZExpc3Q6IHRydWUsXHJcblx0XHRcdFx0c3VidHJlZTogdHJ1ZVxyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcclxuXHRcdFx0aWYgKG9iamVjdEZpdC5fZGVidWcgJiYgd2luZG93LmNvbnNvbGUpIHtcclxuXHRcdFx0XHRjb25zb2xlLmxvZygnRE9NIE11dGF0aW9uIEV2ZW50cycpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NTm9kZUluc2VydGVkJywgZG9tSW5zZXJ0ZWRFdmVudEZ1bmN0aW9uLCBmYWxzZSk7XHJcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Ob2RlUmVtb3ZlZCcsIGRvbVJlbW92ZWRFdmVudEZ1bmN0aW9uLCBmYWxzZSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0b2JqZWN0Rml0LmluaXQgPSBmdW5jdGlvbiAoYXJncykge1xyXG5cdFx0aWYgKCFhcmdzKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIShhcmdzIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcblx0XHRcdGFyZ3MgPSBbYXJnc107XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGkgPSAwO1xyXG5cdFx0dmFyIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aDtcclxuXHJcblx0XHRmb3IgKDsgaSA8IGFyZ3NMZW5ndGg7IGkrKykge1xyXG5cdFx0XHRhcmdzW2ldLnJlcGxhY2VkRWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGFyZ3NbaV0uc2VsZWN0b3IpO1xyXG5cdFx0XHR0aGlzLnByb2Nlc3MoYXJnc1tpXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5saXN0ZW4oYXJncyk7XHJcblx0fTtcclxuXHJcblx0b2JqZWN0Rml0LnBvbHlmaWxsID0gZnVuY3Rpb24gKGFyZ3MpIHtcclxuXHRcdGlmKCdvYmplY3RGaXQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSA9PT0gZmFsc2UpIHtcclxuXHRcdFx0aWYgKG9iamVjdEZpdC5fZGVidWcgJiYgd2luZG93LmNvbnNvbGUpIHtcclxuXHRcdFx0XHRjb25zb2xlLmxvZygnb2JqZWN0LWZpdCBub3QgbmF0aXZlbHkgc3VwcG9ydGVkJyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIElmIHRoZSBsaWJyYXJ5IGlzIGxvYWRlZCBhZnRlciBkb2N1bWVudCBvbmxvYWQgZXZlbnRcclxuXHRcdFx0aWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcclxuXHRcdFx0XHRvYmplY3RGaXQuaW5pdChhcmdzKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXR0YWNoIGV2ZW50IGxpc3RlbmVyc1xyXG5cdFx0XHRcdGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xyXG5cdFx0XHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbigpe1xyXG5cdFx0XHRcdFx0XHRvYmplY3RGaXQuaW5pdChhcmdzKTtcclxuXHRcdFx0XHRcdH0sIGZhbHNlKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0d2luZG93LmF0dGFjaEV2ZW50KCdvbmxvYWQnLCBmdW5jdGlvbigpe1xyXG5cdFx0XHRcdFx0XHRvYmplY3RGaXQuaW5pdChhcmdzKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKG9iamVjdEZpdC5fZGVidWcgJiYgd2luZG93LmNvbnNvbGUpIHtcclxuXHRcdFx0XHRjb25zb2xlLmxvZygnb2JqZWN0LWZpdCBuYXRpdmVseSBzdXBwb3J0ZWQnKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0ICogQU1ELCBtb2R1bGUgbG9hZGVyLCBnbG9iYWwgcmVnaXN0cmF0aW9uXHJcblx0ICovXHJcblxyXG5cdC8vIEV4cG9zZSBtb2RhbCBmb3IgbG9hZGVycyB0aGF0IGltcGxlbWVudCB0aGUgTm9kZSBtb2R1bGUgcGF0dGVybi5cclxuXHRpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdG1vZHVsZS5leHBvcnRzID0gb2JqZWN0Rml0O1xyXG5cclxuXHQvLyBSZWdpc3RlciBhcyBhbiBBTUQgbW9kdWxlXHJcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuXHRcdGRlZmluZShbXSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JqZWN0Rml0OyB9KTtcclxuXHJcblx0Ly8gRXhwb3J0IGludG8gZ2xvYmFsIHNwYWNlXHJcblx0fSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZ2xvYmFsLmRvY3VtZW50ID09PSAnb2JqZWN0Jykge1xyXG5cdFx0Z2xvYmFsLm9iamVjdEZpdCA9IG9iamVjdEZpdDtcclxuXHR9XHJcblxyXG59KHdpbmRvdykpO1xyXG4iLCIvLyBTdGlja3kgUGx1Z2luIHYxLjAuMiBmb3IgalF1ZXJ5XHJcbi8vID09PT09PT09PT09PT1cclxuLy8gQXV0aG9yOiBBbnRob255IEdhcmFuZFxyXG4vLyBJbXByb3ZlbWVudHMgYnkgR2VybWFuIE0uIEJyYXZvIChLcm9udXopIGFuZCBSdXVkIEthbXBodWlzIChydXVkaylcclxuLy8gSW1wcm92ZW1lbnRzIGJ5IExlb25hcmRvIEMuIERhcm9uY28gKGRhcm9uY28pXHJcbi8vIENyZWF0ZWQ6IDIvMTQvMjAxMVxyXG4vLyBEYXRlOiAxNi8wNC8yMDE1XHJcbi8vIFdlYnNpdGU6IGh0dHA6Ly9sYWJzLmFudGhvbnlnYXJhbmQuY29tL3N0aWNreVxyXG4vLyBEZXNjcmlwdGlvbjogTWFrZXMgYW4gZWxlbWVudCBvbiB0aGUgcGFnZSBzdGljayBvbiB0aGUgc2NyZWVuIGFzIHlvdSBzY3JvbGxcclxuLy8gICAgICAgSXQgd2lsbCBvbmx5IHNldCB0aGUgJ3RvcCcgYW5kICdwb3NpdGlvbicgb2YgeW91ciBlbGVtZW50LCB5b3VcclxuLy8gICAgICAgbWlnaHQgbmVlZCB0byBhZGp1c3QgdGhlIHdpZHRoIGluIHNvbWUgY2FzZXMuXHJcblxyXG4oZnVuY3Rpb24oJCkge1xyXG4gICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlOyAvLyBzYXZlIHJlZiB0byBvcmlnaW5hbCBzbGljZSgpXHJcbiAgICB2YXIgc3BsaWNlID0gQXJyYXkucHJvdG90eXBlLnNwbGljZTsgLy8gc2F2ZSByZWYgdG8gb3JpZ2luYWwgc2xpY2UoKVxyXG5cclxuICB2YXIgZGVmYXVsdHMgPSB7XHJcbiAgICAgIHRvcFNwYWNpbmc6IDAsXHJcbiAgICAgIGJvdHRvbVNwYWNpbmc6IDAsXHJcbiAgICAgIGNsYXNzTmFtZTogJ2lzLXN0aWNreScsXHJcbiAgICAgIHdyYXBwZXJDbGFzc05hbWU6ICdzdGlja3ktd3JhcHBlcicsXHJcbiAgICAgIGNlbnRlcjogZmFsc2UsXHJcbiAgICAgIGdldFdpZHRoRnJvbTogJycsXHJcbiAgICAgIHdpZHRoRnJvbVdyYXBwZXI6IHRydWUsIC8vIHdvcmtzIG9ubHkgd2hlbiAuZ2V0V2lkdGhGcm9tIGlzIGVtcHR5XHJcbiAgICAgIHJlc3BvbnNpdmVXaWR0aDogZmFsc2VcclxuICAgIH0sXHJcbiAgICAkd2luZG93ID0gJCh3aW5kb3cpLFxyXG4gICAgJGRvY3VtZW50ID0gJChkb2N1bWVudCksXHJcbiAgICBzdGlja2VkID0gW10sXHJcbiAgICB3aW5kb3dIZWlnaHQgPSAkd2luZG93LmhlaWdodCgpLFxyXG4gICAgc2Nyb2xsZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIHNjcm9sbFRvcCA9ICR3aW5kb3cuc2Nyb2xsVG9wKCksXHJcbiAgICAgICAgZG9jdW1lbnRIZWlnaHQgPSAkZG9jdW1lbnQuaGVpZ2h0KCksXHJcbiAgICAgICAgZHdoID0gZG9jdW1lbnRIZWlnaHQgLSB3aW5kb3dIZWlnaHQsXHJcbiAgICAgICAgZXh0cmEgPSAoc2Nyb2xsVG9wID4gZHdoKSA/IGR3aCAtIHNjcm9sbFRvcCA6IDA7XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0aWNrZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgcyA9IHN0aWNrZWRbaV0sXHJcbiAgICAgICAgICBlbGVtZW50VG9wID0gcy5zdGlja3lXcmFwcGVyLm9mZnNldCgpLnRvcCxcclxuICAgICAgICAgIGV0c2UgPSBlbGVtZW50VG9wIC0gcy50b3BTcGFjaW5nIC0gZXh0cmE7XHJcblxyXG4gICAgICAgIGlmIChzY3JvbGxUb3AgPD0gZXRzZSkge1xyXG4gICAgICAgICAgaWYgKHMuY3VycmVudFRvcCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzLnN0aWNreUVsZW1lbnRcclxuICAgICAgICAgICAgICAuY3NzKHtcclxuICAgICAgICAgICAgICAgICd3aWR0aCc6ICcnLFxyXG4gICAgICAgICAgICAgICAgJ3Bvc2l0aW9uJzogJycsXHJcbiAgICAgICAgICAgICAgICAndG9wJzogJydcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcy5zdGlja3lFbGVtZW50LnBhcmVudCgpLnJlbW92ZUNsYXNzKHMuY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgcy5zdGlja3lFbGVtZW50LnRyaWdnZXIoJ3N0aWNreS1lbmQnLCBbc10pO1xyXG4gICAgICAgICAgICBzLmN1cnJlbnRUb3AgPSBudWxsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHZhciBuZXdUb3AgPSBkb2N1bWVudEhlaWdodCAtIHMuc3RpY2t5RWxlbWVudC5vdXRlckhlaWdodCgpXHJcbiAgICAgICAgICAgIC0gcy50b3BTcGFjaW5nIC0gcy5ib3R0b21TcGFjaW5nIC0gc2Nyb2xsVG9wIC0gZXh0cmE7XHJcbiAgICAgICAgICBpZiAobmV3VG9wIDwgMCkge1xyXG4gICAgICAgICAgICBuZXdUb3AgPSBuZXdUb3AgKyBzLnRvcFNwYWNpbmc7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuZXdUb3AgPSBzLnRvcFNwYWNpbmc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAocy5jdXJyZW50VG9wICE9IG5ld1RvcCkge1xyXG4gICAgICAgICAgICB2YXIgbmV3V2lkdGg7XHJcbiAgICAgICAgICAgIGlmICggcy5nZXRXaWR0aEZyb20gKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdXaWR0aCA9ICQocy5nZXRXaWR0aEZyb20pLndpZHRoKCkgfHwgbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHMud2lkdGhGcm9tV3JhcHBlcikge1xyXG4gICAgICAgICAgICAgICAgbmV3V2lkdGggPSBzLnN0aWNreVdyYXBwZXIud2lkdGgoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIG5ld1dpZHRoID09IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdXaWR0aCA9IHMuc3RpY2t5RWxlbWVudC53aWR0aCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHMuc3RpY2t5RWxlbWVudFxyXG4gICAgICAgICAgICAgIC5jc3MoJ3dpZHRoJywgbmV3V2lkdGgpXHJcbiAgICAgICAgICAgICAgLmNzcygncG9zaXRpb24nLCAnZml4ZWQnKVxyXG4gICAgICAgICAgICAgIC5jc3MoJ3RvcCcsIG5ld1RvcCk7XHJcblxyXG4gICAgICAgICAgICBzLnN0aWNreUVsZW1lbnQucGFyZW50KCkuYWRkQ2xhc3Mocy5jbGFzc05hbWUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHMuY3VycmVudFRvcCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgIHMuc3RpY2t5RWxlbWVudC50cmlnZ2VyKCdzdGlja3ktc3RhcnQnLCBbc10pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIC8vIHN0aWNreSBpcyBzdGFydGVkIGJ1dCBpdCBoYXZlIHRvIGJlIHJlcG9zaXRpb25lZFxyXG4gICAgICAgICAgICAgIHMuc3RpY2t5RWxlbWVudC50cmlnZ2VyKCdzdGlja3ktdXBkYXRlJywgW3NdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHMuY3VycmVudFRvcCA9PT0gcy50b3BTcGFjaW5nICYmIHMuY3VycmVudFRvcCA+IG5ld1RvcCB8fCBzLmN1cnJlbnRUb3AgPT09IG51bGwgJiYgbmV3VG9wIDwgcy50b3BTcGFjaW5nKSB7XHJcbiAgICAgICAgICAgICAgLy8ganVzdCByZWFjaGVkIGJvdHRvbSB8fCBqdXN0IHN0YXJ0ZWQgdG8gc3RpY2sgYnV0IGJvdHRvbSBpcyBhbHJlYWR5IHJlYWNoZWRcclxuICAgICAgICAgICAgICBzLnN0aWNreUVsZW1lbnQudHJpZ2dlcignc3RpY2t5LWJvdHRvbS1yZWFjaGVkJywgW3NdKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmKHMuY3VycmVudFRvcCAhPT0gbnVsbCAmJiBuZXdUb3AgPT09IHMudG9wU3BhY2luZyAmJiBzLmN1cnJlbnRUb3AgPCBuZXdUb3ApIHtcclxuICAgICAgICAgICAgICAvLyBzdGlja3kgaXMgc3RhcnRlZCAmJiBzdGlja2VkIGF0IHRvcFNwYWNpbmcgJiYgb3ZlcmZsb3dpbmcgZnJvbSB0b3AganVzdCBmaW5pc2hlZFxyXG4gICAgICAgICAgICAgIHMuc3RpY2t5RWxlbWVudC50cmlnZ2VyKCdzdGlja3ktYm90dG9tLXVucmVhY2hlZCcsIFtzXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHMuY3VycmVudFRvcCA9IG5ld1RvcDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZXNpemVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHdpbmRvd0hlaWdodCA9ICR3aW5kb3cuaGVpZ2h0KCk7XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0aWNrZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgcyA9IHN0aWNrZWRbaV07XHJcbiAgICAgICAgdmFyIG5ld1dpZHRoID0gbnVsbDtcclxuICAgICAgICBpZiAoIHMuZ2V0V2lkdGhGcm9tICkge1xyXG4gICAgICAgICAgICBpZiAoIHMucmVzcG9uc2l2ZVdpZHRoID09PSB0cnVlICkge1xyXG4gICAgICAgICAgICAgICAgbmV3V2lkdGggPSAkKHMuZ2V0V2lkdGhGcm9tKS53aWR0aCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYocy53aWR0aEZyb21XcmFwcGVyKSB7XHJcbiAgICAgICAgICAgIG5ld1dpZHRoID0gcy5zdGlja3lXcmFwcGVyLndpZHRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggbmV3V2lkdGggIT0gbnVsbCApIHtcclxuICAgICAgICAgICAgcy5zdGlja3lFbGVtZW50LmNzcygnd2lkdGgnLCBuZXdXaWR0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWV0aG9kcyA9IHtcclxuICAgICAgaW5pdDogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBvID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdmFyIHN0aWNreUVsZW1lbnQgPSAkKHRoaXMpO1xyXG5cclxuICAgICAgICAgIHZhciBzdGlja3lJZCA9IHN0aWNreUVsZW1lbnQuYXR0cignaWQnKTtcclxuICAgICAgICAgIHZhciBzdGlja3lIZWlnaHQgPSBzdGlja3lFbGVtZW50Lm91dGVySGVpZ2h0KCk7XHJcbiAgICAgICAgICB2YXIgd3JhcHBlcklkID0gc3RpY2t5SWQgPyBzdGlja3lJZCArICctJyArIGRlZmF1bHRzLndyYXBwZXJDbGFzc05hbWUgOiBkZWZhdWx0cy53cmFwcGVyQ2xhc3NOYW1lXHJcbiAgICAgICAgICB2YXIgd3JhcHBlciA9ICQoJzxkaXY+PC9kaXY+JylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgd3JhcHBlcklkKVxyXG4gICAgICAgICAgICAuYWRkQ2xhc3Moby53cmFwcGVyQ2xhc3NOYW1lKTtcclxuXHJcbiAgICAgICAgICBzdGlja3lFbGVtZW50LndyYXBBbGwod3JhcHBlcik7XHJcblxyXG4gICAgICAgICAgdmFyIHN0aWNreVdyYXBwZXIgPSBzdGlja3lFbGVtZW50LnBhcmVudCgpO1xyXG5cclxuICAgICAgICAgIGlmIChvLmNlbnRlcikge1xyXG4gICAgICAgICAgICBzdGlja3lXcmFwcGVyLmNzcyh7d2lkdGg6c3RpY2t5RWxlbWVudC5vdXRlcldpZHRoKCksbWFyZ2luTGVmdDpcImF1dG9cIixtYXJnaW5SaWdodDpcImF1dG9cIn0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChzdGlja3lFbGVtZW50LmNzcyhcImZsb2F0XCIpID09IFwicmlnaHRcIikge1xyXG4gICAgICAgICAgICBzdGlja3lFbGVtZW50LmNzcyh7XCJmbG9hdFwiOlwibm9uZVwifSkucGFyZW50KCkuY3NzKHtcImZsb2F0XCI6XCJyaWdodFwifSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgc3RpY2t5V3JhcHBlci5jc3MoJ21pbi1oZWlnaHQnLCBzdGlja3lIZWlnaHQpO1xyXG5cclxuICAgICAgICAgIG8uc3RpY2t5RWxlbWVudCA9IHN0aWNreUVsZW1lbnQ7XHJcbiAgICAgICAgICBvLnN0aWNreVdyYXBwZXIgPSBzdGlja3lXcmFwcGVyO1xyXG4gICAgICAgICAgby5jdXJyZW50VG9wICAgID0gbnVsbDtcclxuXHJcbiAgICAgICAgICBzdGlja2VkLnB1c2gobyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHVwZGF0ZTogc2Nyb2xsZXIsXHJcbiAgICAgIHVuc3RpY2s6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgdmFyIHVuc3RpY2t5RWxlbWVudCA9ICQodGhhdCk7XHJcblxyXG4gICAgICAgICAgdmFyIHJlbW92ZUlkeCA9IC0xO1xyXG4gICAgICAgICAgdmFyIGkgPSBzdGlja2VkLmxlbmd0aDtcclxuICAgICAgICAgIHdoaWxlICggaS0tID4gMCApXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChzdGlja2VkW2ldLnN0aWNreUVsZW1lbnQuZ2V0KDApID09PSB0aGF0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzcGxpY2UuY2FsbChzdGlja2VkLGksMSk7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVJZHggPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZihyZW1vdmVJZHggIT0gLTEpXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIHVuc3RpY2t5RWxlbWVudC51bndyYXAoKTtcclxuICAgICAgICAgICAgdW5zdGlja3lFbGVtZW50XHJcbiAgICAgICAgICAgICAgLmNzcyh7XHJcbiAgICAgICAgICAgICAgICAnd2lkdGgnOiAnJyxcclxuICAgICAgICAgICAgICAgICdwb3NpdGlvbic6ICcnLFxyXG4gICAgICAgICAgICAgICAgJ3RvcCc6ICcnLFxyXG4gICAgICAgICAgICAgICAgJ2Zsb2F0JzogJydcclxuICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gIC8vIHNob3VsZCBiZSBtb3JlIGVmZmljaWVudCB0aGFuIHVzaW5nICR3aW5kb3cuc2Nyb2xsKHNjcm9sbGVyKSBhbmQgJHdpbmRvdy5yZXNpemUocmVzaXplcik6XHJcbiAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc2Nyb2xsZXIsIGZhbHNlKTtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVyLCBmYWxzZSk7XHJcbiAgfSBlbHNlIGlmICh3aW5kb3cuYXR0YWNoRXZlbnQpIHtcclxuICAgIHdpbmRvdy5hdHRhY2hFdmVudCgnb25zY3JvbGwnLCBzY3JvbGxlcik7XHJcbiAgICB3aW5kb3cuYXR0YWNoRXZlbnQoJ29ucmVzaXplJywgcmVzaXplcik7XHJcbiAgfVxyXG5cclxuICAkLmZuLnN0aWNreSA9IGZ1bmN0aW9uKG1ldGhvZCkge1xyXG4gICAgaWYgKG1ldGhvZHNbbWV0aG9kXSkge1xyXG4gICAgICByZXR1cm4gbWV0aG9kc1ttZXRob2RdLmFwcGx5KHRoaXMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdvYmplY3QnIHx8ICFtZXRob2QgKSB7XHJcbiAgICAgIHJldHVybiBtZXRob2RzLmluaXQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgJC5lcnJvcignTWV0aG9kICcgKyBtZXRob2QgKyAnIGRvZXMgbm90IGV4aXN0IG9uIGpRdWVyeS5zdGlja3knKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAkLmZuLnVuc3RpY2sgPSBmdW5jdGlvbihtZXRob2QpIHtcclxuICAgIGlmIChtZXRob2RzW21ldGhvZF0pIHtcclxuICAgICAgcmV0dXJuIG1ldGhvZHNbbWV0aG9kXS5hcHBseSh0aGlzLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWV0aG9kID09PSAnb2JqZWN0JyB8fCAhbWV0aG9kICkge1xyXG4gICAgICByZXR1cm4gbWV0aG9kcy51bnN0aWNrLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICQuZXJyb3IoJ01ldGhvZCAnICsgbWV0aG9kICsgJyBkb2VzIG5vdCBleGlzdCBvbiBqUXVlcnkuc3RpY2t5Jyk7XHJcbiAgICB9XHJcblxyXG4gIH07XHJcbiAgJChmdW5jdGlvbigpIHtcclxuICAgIHNldFRpbWVvdXQoc2Nyb2xsZXIsIDApO1xyXG4gIH0pO1xyXG59KShqUXVlcnkpO1xyXG4iLCIvKiFcbiAqIGpRdWVyeSB0aHJvdHRsZSAvIGRlYm91bmNlIC0gdjEuMSAtIDMvNy8yMDEwXG4gKiBodHRwOi8vYmVuYWxtYW4uY29tL3Byb2plY3RzL2pxdWVyeS10aHJvdHRsZS1kZWJvdW5jZS1wbHVnaW4vXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwIFwiQ293Ym95XCIgQmVuIEFsbWFuXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTCBsaWNlbnNlcy5cbiAqIGh0dHA6Ly9iZW5hbG1hbi5jb20vYWJvdXQvbGljZW5zZS9cbiAqL1xuXG4vLyBTY3JpcHQ6IGpRdWVyeSB0aHJvdHRsZSAvIGRlYm91bmNlOiBTb21ldGltZXMsIGxlc3MgaXMgbW9yZSFcbi8vXG4vLyAqVmVyc2lvbjogMS4xLCBMYXN0IHVwZGF0ZWQ6IDMvNy8yMDEwKlxuLy9cbi8vIFByb2plY3QgSG9tZSAtIGh0dHA6Ly9iZW5hbG1hbi5jb20vcHJvamVjdHMvanF1ZXJ5LXRocm90dGxlLWRlYm91bmNlLXBsdWdpbi9cbi8vIEdpdEh1YiAgICAgICAtIGh0dHA6Ly9naXRodWIuY29tL2Nvd2JveS9qcXVlcnktdGhyb3R0bGUtZGVib3VuY2UvXG4vLyBTb3VyY2UgICAgICAgLSBodHRwOi8vZ2l0aHViLmNvbS9jb3dib3kvanF1ZXJ5LXRocm90dGxlLWRlYm91bmNlL3Jhdy9tYXN0ZXIvanF1ZXJ5LmJhLXRocm90dGxlLWRlYm91bmNlLmpzXG4vLyAoTWluaWZpZWQpICAgLSBodHRwOi8vZ2l0aHViLmNvbS9jb3dib3kvanF1ZXJ5LXRocm90dGxlLWRlYm91bmNlL3Jhdy9tYXN0ZXIvanF1ZXJ5LmJhLXRocm90dGxlLWRlYm91bmNlLm1pbi5qcyAoMC43a2IpXG4vL1xuLy8gQWJvdXQ6IExpY2Vuc2Vcbi8vXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTAgXCJDb3dib3lcIiBCZW4gQWxtYW4sXG4vLyBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTCBsaWNlbnNlcy5cbi8vIGh0dHA6Ly9iZW5hbG1hbi5jb20vYWJvdXQvbGljZW5zZS9cbi8vXG4vLyBBYm91dDogRXhhbXBsZXNcbi8vXG4vLyBUaGVzZSB3b3JraW5nIGV4YW1wbGVzLCBjb21wbGV0ZSB3aXRoIGZ1bGx5IGNvbW1lbnRlZCBjb2RlLCBpbGx1c3RyYXRlIGEgZmV3XG4vLyB3YXlzIGluIHdoaWNoIHRoaXMgcGx1Z2luIGNhbiBiZSB1c2VkLlxuLy9cbi8vIFRocm90dGxlIC0gaHR0cDovL2JlbmFsbWFuLmNvbS9jb2RlL3Byb2plY3RzL2pxdWVyeS10aHJvdHRsZS1kZWJvdW5jZS9leGFtcGxlcy90aHJvdHRsZS9cbi8vIERlYm91bmNlIC0gaHR0cDovL2JlbmFsbWFuLmNvbS9jb2RlL3Byb2plY3RzL2pxdWVyeS10aHJvdHRsZS1kZWJvdW5jZS9leGFtcGxlcy9kZWJvdW5jZS9cbi8vXG4vLyBBYm91dDogU3VwcG9ydCBhbmQgVGVzdGluZ1xuLy9cbi8vIEluZm9ybWF0aW9uIGFib3V0IHdoYXQgdmVyc2lvbiBvciB2ZXJzaW9ucyBvZiBqUXVlcnkgdGhpcyBwbHVnaW4gaGFzIGJlZW5cbi8vIHRlc3RlZCB3aXRoLCB3aGF0IGJyb3dzZXJzIGl0IGhhcyBiZWVuIHRlc3RlZCBpbiwgYW5kIHdoZXJlIHRoZSB1bml0IHRlc3RzXG4vLyByZXNpZGUgKHNvIHlvdSBjYW4gdGVzdCBpdCB5b3Vyc2VsZikuXG4vL1xuLy8galF1ZXJ5IFZlcnNpb25zIC0gbm9uZSwgMS4zLjIsIDEuNC4yXG4vLyBCcm93c2VycyBUZXN0ZWQgLSBJbnRlcm5ldCBFeHBsb3JlciA2LTgsIEZpcmVmb3ggMi0zLjYsIFNhZmFyaSAzLTQsIENocm9tZSA0LTUsIE9wZXJhIDkuNi0xMC4xLlxuLy8gVW5pdCBUZXN0cyAgICAgIC0gaHR0cDovL2JlbmFsbWFuLmNvbS9jb2RlL3Byb2plY3RzL2pxdWVyeS10aHJvdHRsZS1kZWJvdW5jZS91bml0L1xuLy9cbi8vIEFib3V0OiBSZWxlYXNlIEhpc3Rvcnlcbi8vXG4vLyAxLjEgLSAoMy83LzIwMTApIEZpeGVkIGEgYnVnIGluIDxqUXVlcnkudGhyb3R0bGU+IHdoZXJlIHRyYWlsaW5nIGNhbGxiYWNrc1xuLy8gICAgICAgZXhlY3V0ZWQgbGF0ZXIgdGhhbiB0aGV5IHNob3VsZC4gUmV3b3JrZWQgYSBmYWlyIGFtb3VudCBvZiBpbnRlcm5hbFxuLy8gICAgICAgbG9naWMgYXMgd2VsbC5cbi8vIDEuMCAtICgzLzYvMjAxMCkgSW5pdGlhbCByZWxlYXNlIGFzIGEgc3RhbmQtYWxvbmUgcHJvamVjdC4gTWlncmF0ZWQgb3ZlclxuLy8gICAgICAgZnJvbSBqcXVlcnktbWlzYyByZXBvIHYwLjQgdG8ganF1ZXJ5LXRocm90dGxlIHJlcG8gdjEuMCwgYWRkZWQgdGhlXG4vLyAgICAgICBub190cmFpbGluZyB0aHJvdHRsZSBwYXJhbWV0ZXIgYW5kIGRlYm91bmNlIGZ1bmN0aW9uYWxpdHkuXG4vL1xuLy8gVG9waWM6IE5vdGUgZm9yIG5vbi1qUXVlcnkgdXNlcnNcbi8vXG4vLyBqUXVlcnkgaXNuJ3QgYWN0dWFsbHkgcmVxdWlyZWQgZm9yIHRoaXMgcGx1Z2luLCBiZWNhdXNlIG5vdGhpbmcgaW50ZXJuYWxcbi8vIHVzZXMgYW55IGpRdWVyeSBtZXRob2RzIG9yIHByb3BlcnRpZXMuIGpRdWVyeSBpcyBqdXN0IHVzZWQgYXMgYSBuYW1lc3BhY2Vcbi8vIHVuZGVyIHdoaWNoIHRoZXNlIG1ldGhvZHMgY2FuIGV4aXN0LlxuLy9cbi8vIFNpbmNlIGpRdWVyeSBpc24ndCBhY3R1YWxseSByZXF1aXJlZCBmb3IgdGhpcyBwbHVnaW4sIGlmIGpRdWVyeSBkb2Vzbid0IGV4aXN0XG4vLyB3aGVuIHRoaXMgcGx1Z2luIGlzIGxvYWRlZCwgdGhlIG1ldGhvZCBkZXNjcmliZWQgYmVsb3cgd2lsbCBiZSBjcmVhdGVkIGluXG4vLyB0aGUgYENvd2JveWAgbmFtZXNwYWNlLiBVc2FnZSB3aWxsIGJlIGV4YWN0bHkgdGhlIHNhbWUsIGJ1dCBpbnN0ZWFkIG9mXG4vLyAkLm1ldGhvZCgpIG9yIGpRdWVyeS5tZXRob2QoKSwgeW91J2xsIG5lZWQgdG8gdXNlIENvd2JveS5tZXRob2QoKS5cblxuKGZ1bmN0aW9uKGpRdWVyeSl7XG4gICckOm5vbXVuZ2UnOyAvLyBVc2VkIGJ5IFlVSSBjb21wcmVzc29yLlxuXG4gIC8vIFNpbmNlIGpRdWVyeSByZWFsbHkgaXNuJ3QgcmVxdWlyZWQgZm9yIHRoaXMgcGx1Z2luLCB1c2UgYGpRdWVyeWAgYXMgdGhlXG4gIC8vIG5hbWVzcGFjZSBvbmx5IGlmIGl0IGFscmVhZHkgZXhpc3RzLCBvdGhlcndpc2UgdXNlIHRoZSBgQ293Ym95YCBuYW1lc3BhY2UsXG4gIC8vIGNyZWF0aW5nIGl0IGlmIG5lY2Vzc2FyeS5cbiAgdmFyICQgPSBqUXVlcnkgfHwgd2luZG93LmpRdWVyeSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCByZWZlcmVuY2UuXG4gICAganFfdGhyb3R0bGU7XG5cbiAgLy8gTWV0aG9kOiBqUXVlcnkudGhyb3R0bGVcbiAgLy9cbiAgLy8gVGhyb3R0bGUgZXhlY3V0aW9uIG9mIGEgZnVuY3Rpb24uIEVzcGVjaWFsbHkgdXNlZnVsIGZvciByYXRlIGxpbWl0aW5nXG4gIC8vIGV4ZWN1dGlvbiBvZiBoYW5kbGVycyBvbiBldmVudHMgbGlrZSByZXNpemUgYW5kIHNjcm9sbC4gSWYgeW91IHdhbnQgdG9cbiAgLy8gcmF0ZS1saW1pdCBleGVjdXRpb24gb2YgYSBmdW5jdGlvbiB0byBhIHNpbmdsZSB0aW1lLCBzZWUgdGhlXG4gIC8vIDxqUXVlcnkuZGVib3VuY2U+IG1ldGhvZC5cbiAgLy9cbiAgLy8gSW4gdGhpcyB2aXN1YWxpemF0aW9uLCB8IGlzIGEgdGhyb3R0bGVkLWZ1bmN0aW9uIGNhbGwgYW5kIFggaXMgdGhlIGFjdHVhbFxuICAvLyBjYWxsYmFjayBleGVjdXRpb246XG4gIC8vXG4gIC8vID4gVGhyb3R0bGVkIHdpdGggYG5vX3RyYWlsaW5nYCBzcGVjaWZpZWQgYXMgZmFsc2Ugb3IgdW5zcGVjaWZpZWQ6XG4gIC8vID4gfHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fCAocGF1c2UpIHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHxcbiAgLy8gPiBYICAgIFggICAgWCAgICBYICAgIFggICAgWCAgICAgICAgWCAgICBYICAgIFggICAgWCAgICBYICAgIFhcbiAgLy8gPlxuICAvLyA+IFRocm90dGxlZCB3aXRoIGBub190cmFpbGluZ2Agc3BlY2lmaWVkIGFzIHRydWU6XG4gIC8vID4gfHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fCAocGF1c2UpIHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHxcbiAgLy8gPiBYICAgIFggICAgWCAgICBYICAgIFggICAgICAgICAgICAgWCAgICBYICAgIFggICAgWCAgICBYXG4gIC8vXG4gIC8vIFVzYWdlOlxuICAvL1xuICAvLyA+IHZhciB0aHJvdHRsZWQgPSBqUXVlcnkudGhyb3R0bGUoIGRlbGF5LCBbIG5vX3RyYWlsaW5nLCBdIGNhbGxiYWNrICk7XG4gIC8vID5cbiAgLy8gPiBqUXVlcnkoJ3NlbGVjdG9yJykuYmluZCggJ3NvbWVldmVudCcsIHRocm90dGxlZCApO1xuICAvLyA+IGpRdWVyeSgnc2VsZWN0b3InKS51bmJpbmQoICdzb21lZXZlbnQnLCB0aHJvdHRsZWQgKTtcbiAgLy9cbiAgLy8gVGhpcyBhbHNvIHdvcmtzIGluIGpRdWVyeSAxLjQrOlxuICAvL1xuICAvLyA+IGpRdWVyeSgnc2VsZWN0b3InKS5iaW5kKCAnc29tZWV2ZW50JywgalF1ZXJ5LnRocm90dGxlKCBkZWxheSwgWyBub190cmFpbGluZywgXSBjYWxsYmFjayApICk7XG4gIC8vID4galF1ZXJ5KCdzZWxlY3RvcicpLnVuYmluZCggJ3NvbWVldmVudCcsIGNhbGxiYWNrICk7XG4gIC8vXG4gIC8vIEFyZ3VtZW50czpcbiAgLy9cbiAgLy8gIGRlbGF5IC0gKE51bWJlcikgQSB6ZXJvLW9yLWdyZWF0ZXIgZGVsYXkgaW4gbWlsbGlzZWNvbmRzLiBGb3IgZXZlbnRcbiAgLy8gICAgY2FsbGJhY2tzLCB2YWx1ZXMgYXJvdW5kIDEwMCBvciAyNTAgKG9yIGV2ZW4gaGlnaGVyKSBhcmUgbW9zdCB1c2VmdWwuXG4gIC8vICBub190cmFpbGluZyAtIChCb29sZWFuKSBPcHRpb25hbCwgZGVmYXVsdHMgdG8gZmFsc2UuIElmIG5vX3RyYWlsaW5nIGlzXG4gIC8vICAgIHRydWUsIGNhbGxiYWNrIHdpbGwgb25seSBleGVjdXRlIGV2ZXJ5IGBkZWxheWAgbWlsbGlzZWNvbmRzIHdoaWxlIHRoZVxuICAvLyAgICB0aHJvdHRsZWQtZnVuY3Rpb24gaXMgYmVpbmcgY2FsbGVkLiBJZiBub190cmFpbGluZyBpcyBmYWxzZSBvclxuICAvLyAgICB1bnNwZWNpZmllZCwgY2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZCBvbmUgZmluYWwgdGltZSBhZnRlciB0aGUgbGFzdFxuICAvLyAgICB0aHJvdHRsZWQtZnVuY3Rpb24gY2FsbC4gKEFmdGVyIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaGFzIG5vdCBiZWVuXG4gIC8vICAgIGNhbGxlZCBmb3IgYGRlbGF5YCBtaWxsaXNlY29uZHMsIHRoZSBpbnRlcm5hbCBjb3VudGVyIGlzIHJlc2V0KVxuICAvLyAgY2FsbGJhY2sgLSAoRnVuY3Rpb24pIEEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgZGVsYXkgbWlsbGlzZWNvbmRzLlxuICAvLyAgICBUaGUgYHRoaXNgIGNvbnRleHQgYW5kIGFsbCBhcmd1bWVudHMgYXJlIHBhc3NlZCB0aHJvdWdoLCBhcy1pcywgdG9cbiAgLy8gICAgYGNhbGxiYWNrYCB3aGVuIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaXMgZXhlY3V0ZWQuXG4gIC8vXG4gIC8vIFJldHVybnM6XG4gIC8vXG4gIC8vICAoRnVuY3Rpb24pIEEgbmV3LCB0aHJvdHRsZWQsIGZ1bmN0aW9uLlxuXG4gICQudGhyb3R0bGUgPSBqcV90aHJvdHRsZSA9IGZ1bmN0aW9uKCBkZWxheSwgbm9fdHJhaWxpbmcsIGNhbGxiYWNrLCBkZWJvdW5jZV9tb2RlICkge1xuICAgIC8vIEFmdGVyIHdyYXBwZXIgaGFzIHN0b3BwZWQgYmVpbmcgY2FsbGVkLCB0aGlzIHRpbWVvdXQgZW5zdXJlcyB0aGF0XG4gICAgLy8gYGNhbGxiYWNrYCBpcyBleGVjdXRlZCBhdCB0aGUgcHJvcGVyIHRpbWVzIGluIGB0aHJvdHRsZWAgYW5kIGBlbmRgXG4gICAgLy8gZGVib3VuY2UgbW9kZXMuXG4gICAgdmFyIHRpbWVvdXRfaWQsXG5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGxhc3QgdGltZSBgY2FsbGJhY2tgIHdhcyBleGVjdXRlZC5cbiAgICAgIGxhc3RfZXhlYyA9IDA7XG5cbiAgICAvLyBgbm9fdHJhaWxpbmdgIGRlZmF1bHRzIHRvIGZhbHN5LlxuICAgIGlmICggdHlwZW9mIG5vX3RyYWlsaW5nICE9PSAnYm9vbGVhbicgKSB7XG4gICAgICBkZWJvdW5jZV9tb2RlID0gY2FsbGJhY2s7XG4gICAgICBjYWxsYmFjayA9IG5vX3RyYWlsaW5nO1xuICAgICAgbm9fdHJhaWxpbmcgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gVGhlIGB3cmFwcGVyYCBmdW5jdGlvbiBlbmNhcHN1bGF0ZXMgYWxsIG9mIHRoZSB0aHJvdHRsaW5nIC8gZGVib3VuY2luZ1xuICAgIC8vIGZ1bmN0aW9uYWxpdHkgYW5kIHdoZW4gZXhlY3V0ZWQgd2lsbCBsaW1pdCB0aGUgcmF0ZSBhdCB3aGljaCBgY2FsbGJhY2tgXG4gICAgLy8gaXMgZXhlY3V0ZWQuXG4gICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgZWxhcHNlZCA9ICtuZXcgRGF0ZSgpIC0gbGFzdF9leGVjLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgICAvLyBFeGVjdXRlIGBjYWxsYmFja2AgYW5kIHVwZGF0ZSB0aGUgYGxhc3RfZXhlY2AgdGltZXN0YW1wLlxuICAgICAgZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgICAgbGFzdF9leGVjID0gK25ldyBEYXRlKCk7XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KCB0aGF0LCBhcmdzICk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJZiBgZGVib3VuY2VfbW9kZWAgaXMgdHJ1ZSAoYXRfYmVnaW4pIHRoaXMgaXMgdXNlZCB0byBjbGVhciB0aGUgZmxhZ1xuICAgICAgLy8gdG8gYWxsb3cgZnV0dXJlIGBjYWxsYmFja2AgZXhlY3V0aW9ucy5cbiAgICAgIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICB0aW1lb3V0X2lkID0gdW5kZWZpbmVkO1xuICAgICAgfTtcblxuICAgICAgaWYgKCBkZWJvdW5jZV9tb2RlICYmICF0aW1lb3V0X2lkICkge1xuICAgICAgICAvLyBTaW5jZSBgd3JhcHBlcmAgaXMgYmVpbmcgY2FsbGVkIGZvciB0aGUgZmlyc3QgdGltZSBhbmRcbiAgICAgICAgLy8gYGRlYm91bmNlX21vZGVgIGlzIHRydWUgKGF0X2JlZ2luKSwgZXhlY3V0ZSBgY2FsbGJhY2tgLlxuICAgICAgICBleGVjKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFyIGFueSBleGlzdGluZyB0aW1lb3V0LlxuICAgICAgdGltZW91dF9pZCAmJiBjbGVhclRpbWVvdXQoIHRpbWVvdXRfaWQgKTtcblxuICAgICAgaWYgKCBkZWJvdW5jZV9tb2RlID09PSB1bmRlZmluZWQgJiYgZWxhcHNlZCA+IGRlbGF5ICkge1xuICAgICAgICAvLyBJbiB0aHJvdHRsZSBtb2RlLCBpZiBgZGVsYXlgIHRpbWUgaGFzIGJlZW4gZXhjZWVkZWQsIGV4ZWN1dGVcbiAgICAgICAgLy8gYGNhbGxiYWNrYC5cbiAgICAgICAgZXhlYygpO1xuXG4gICAgICB9IGVsc2UgaWYgKCBub190cmFpbGluZyAhPT0gdHJ1ZSApIHtcbiAgICAgICAgLy8gSW4gdHJhaWxpbmcgdGhyb3R0bGUgbW9kZSwgc2luY2UgYGRlbGF5YCB0aW1lIGhhcyBub3QgYmVlblxuICAgICAgICAvLyBleGNlZWRlZCwgc2NoZWR1bGUgYGNhbGxiYWNrYCB0byBleGVjdXRlIGBkZWxheWAgbXMgYWZ0ZXIgbW9zdFxuICAgICAgICAvLyByZWNlbnQgZXhlY3V0aW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiBgZGVib3VuY2VfbW9kZWAgaXMgdHJ1ZSAoYXRfYmVnaW4pLCBzY2hlZHVsZSBgY2xlYXJgIHRvIGV4ZWN1dGVcbiAgICAgICAgLy8gYWZ0ZXIgYGRlbGF5YCBtcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgYGRlYm91bmNlX21vZGVgIGlzIGZhbHNlIChhdCBlbmQpLCBzY2hlZHVsZSBgY2FsbGJhY2tgIHRvXG4gICAgICAgIC8vIGV4ZWN1dGUgYWZ0ZXIgYGRlbGF5YCBtcy5cbiAgICAgICAgdGltZW91dF9pZCA9IHNldFRpbWVvdXQoIGRlYm91bmNlX21vZGUgPyBjbGVhciA6IGV4ZWMsIGRlYm91bmNlX21vZGUgPT09IHVuZGVmaW5lZCA/IGRlbGF5IC0gZWxhcHNlZCA6IGRlbGF5ICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFNldCB0aGUgZ3VpZCBvZiBgd3JhcHBlcmAgZnVuY3Rpb24gdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgY2FsbGJhY2ssIHNvXG4gICAgLy8gaXQgY2FuIGJlIHJlbW92ZWQgaW4galF1ZXJ5IDEuNCsgLnVuYmluZCBvciAuZGllIGJ5IHVzaW5nIHRoZSBvcmlnaW5hbFxuICAgIC8vIGNhbGxiYWNrIGFzIGEgcmVmZXJlbmNlLlxuICAgIGlmICggJC5ndWlkICkge1xuICAgICAgd3JhcHBlci5ndWlkID0gY2FsbGJhY2suZ3VpZCA9IGNhbGxiYWNrLmd1aWQgfHwgJC5ndWlkKys7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgIHJldHVybiB3cmFwcGVyO1xuICB9O1xuXG4gIC8vIE1ldGhvZDogalF1ZXJ5LmRlYm91bmNlXG4gIC8vXG4gIC8vIERlYm91bmNlIGV4ZWN1dGlvbiBvZiBhIGZ1bmN0aW9uLiBEZWJvdW5jaW5nLCB1bmxpa2UgdGhyb3R0bGluZyxcbiAgLy8gZ3VhcmFudGVlcyB0aGF0IGEgZnVuY3Rpb24gaXMgb25seSBleGVjdXRlZCBhIHNpbmdsZSB0aW1lLCBlaXRoZXIgYXQgdGhlXG4gIC8vIHZlcnkgYmVnaW5uaW5nIG9mIGEgc2VyaWVzIG9mIGNhbGxzLCBvciBhdCB0aGUgdmVyeSBlbmQuIElmIHlvdSB3YW50IHRvXG4gIC8vIHNpbXBseSByYXRlLWxpbWl0IGV4ZWN1dGlvbiBvZiBhIGZ1bmN0aW9uLCBzZWUgdGhlIDxqUXVlcnkudGhyb3R0bGU+XG4gIC8vIG1ldGhvZC5cbiAgLy9cbiAgLy8gSW4gdGhpcyB2aXN1YWxpemF0aW9uLCB8IGlzIGEgZGVib3VuY2VkLWZ1bmN0aW9uIGNhbGwgYW5kIFggaXMgdGhlIGFjdHVhbFxuICAvLyBjYWxsYmFjayBleGVjdXRpb246XG4gIC8vXG4gIC8vID4gRGVib3VuY2VkIHdpdGggYGF0X2JlZ2luYCBzcGVjaWZpZWQgYXMgZmFsc2Ugb3IgdW5zcGVjaWZpZWQ6XG4gIC8vID4gfHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fCAocGF1c2UpIHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHxcbiAgLy8gPiAgICAgICAgICAgICAgICAgICAgICAgICAgWCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFhcbiAgLy8gPlxuICAvLyA+IERlYm91bmNlZCB3aXRoIGBhdF9iZWdpbmAgc3BlY2lmaWVkIGFzIHRydWU6XG4gIC8vID4gfHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fCAocGF1c2UpIHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHxcbiAgLy8gPiBYICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWFxuICAvL1xuICAvLyBVc2FnZTpcbiAgLy9cbiAgLy8gPiB2YXIgZGVib3VuY2VkID0galF1ZXJ5LmRlYm91bmNlKCBkZWxheSwgWyBhdF9iZWdpbiwgXSBjYWxsYmFjayApO1xuICAvLyA+IFxuICAvLyA+IGpRdWVyeSgnc2VsZWN0b3InKS5iaW5kKCAnc29tZWV2ZW50JywgZGVib3VuY2VkICk7XG4gIC8vID4galF1ZXJ5KCdzZWxlY3RvcicpLnVuYmluZCggJ3NvbWVldmVudCcsIGRlYm91bmNlZCApO1xuICAvL1xuICAvLyBUaGlzIGFsc28gd29ya3MgaW4galF1ZXJ5IDEuNCs6XG4gIC8vXG4gIC8vID4galF1ZXJ5KCdzZWxlY3RvcicpLmJpbmQoICdzb21lZXZlbnQnLCBqUXVlcnkuZGVib3VuY2UoIGRlbGF5LCBbIGF0X2JlZ2luLCBdIGNhbGxiYWNrICkgKTtcbiAgLy8gPiBqUXVlcnkoJ3NlbGVjdG9yJykudW5iaW5kKCAnc29tZWV2ZW50JywgY2FsbGJhY2sgKTtcbiAgLy9cbiAgLy8gQXJndW1lbnRzOlxuICAvL1xuICAvLyAgZGVsYXkgLSAoTnVtYmVyKSBBIHplcm8tb3ItZ3JlYXRlciBkZWxheSBpbiBtaWxsaXNlY29uZHMuIEZvciBldmVudFxuICAvLyAgICBjYWxsYmFja3MsIHZhbHVlcyBhcm91bmQgMTAwIG9yIDI1MCAob3IgZXZlbiBoaWdoZXIpIGFyZSBtb3N0IHVzZWZ1bC5cbiAgLy8gIGF0X2JlZ2luIC0gKEJvb2xlYW4pIE9wdGlvbmFsLCBkZWZhdWx0cyB0byBmYWxzZS4gSWYgYXRfYmVnaW4gaXMgZmFsc2Ugb3JcbiAgLy8gICAgdW5zcGVjaWZpZWQsIGNhbGxiYWNrIHdpbGwgb25seSBiZSBleGVjdXRlZCBgZGVsYXlgIG1pbGxpc2Vjb25kcyBhZnRlclxuICAvLyAgICB0aGUgbGFzdCBkZWJvdW5jZWQtZnVuY3Rpb24gY2FsbC4gSWYgYXRfYmVnaW4gaXMgdHJ1ZSwgY2FsbGJhY2sgd2lsbCBiZVxuICAvLyAgICBleGVjdXRlZCBvbmx5IGF0IHRoZSBmaXJzdCBkZWJvdW5jZWQtZnVuY3Rpb24gY2FsbC4gKEFmdGVyIHRoZVxuICAvLyAgICB0aHJvdHRsZWQtZnVuY3Rpb24gaGFzIG5vdCBiZWVuIGNhbGxlZCBmb3IgYGRlbGF5YCBtaWxsaXNlY29uZHMsIHRoZVxuICAvLyAgICBpbnRlcm5hbCBjb3VudGVyIGlzIHJlc2V0KVxuICAvLyAgY2FsbGJhY2sgLSAoRnVuY3Rpb24pIEEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgZGVsYXkgbWlsbGlzZWNvbmRzLlxuICAvLyAgICBUaGUgYHRoaXNgIGNvbnRleHQgYW5kIGFsbCBhcmd1bWVudHMgYXJlIHBhc3NlZCB0aHJvdWdoLCBhcy1pcywgdG9cbiAgLy8gICAgYGNhbGxiYWNrYCB3aGVuIHRoZSBkZWJvdW5jZWQtZnVuY3Rpb24gaXMgZXhlY3V0ZWQuXG4gIC8vXG4gIC8vIFJldHVybnM6XG4gIC8vXG4gIC8vICAoRnVuY3Rpb24pIEEgbmV3LCBkZWJvdW5jZWQsIGZ1bmN0aW9uLlxuXG4gIGpRdWVyeS5kZWJvdW5jZSA9IGZ1bmN0aW9uKCBkZWxheSwgYXRfYmVnaW4sIGNhbGxiYWNrICkge1xuICAgIHJldHVybiBjYWxsYmFjayA9PT0gdW5kZWZpbmVkXG4gICAgICA/IGpxX3Rocm90dGxlKCBkZWxheSwgYXRfYmVnaW4sIGZhbHNlIClcbiAgICAgIDoganFfdGhyb3R0bGUoIGRlbGF5LCBjYWxsYmFjaywgYXRfYmVnaW4gIT09IGZhbHNlICk7XG4gIH07XG5cbn0pKHJlcXVpcmUoJ2pxdWVyeScpKTtcbiIsInZhciBicm93c2VyID0ge307XG52YXIgb3MgPSB7fTtcbnZhciBkZXZpY2UgPSB7fTtcbnZhciB0b3VjaCA9IGZhbHNlO1xudmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbnZhciB3ZWJraXQgPSB1YS5tYXRjaCgvV2ViW2tLXWl0W1xcL117MCwxfShbXFxkLl0rKS8pLFxuICAgIGFuZHJvaWQgPSB1YS5tYXRjaCgvKEFuZHJvaWQpOz9bXFxzXFwvXSsoW1xcZC5dKyk/LyksXG4gICAgaXBhZCA9IHVhLm1hdGNoKC8oaVBhZCkuKk9TXFxzKFtcXGRfXSspLyksXG4gICAgaXBvZCA9IHVhLm1hdGNoKC8oaVBvZCkoLipPU1xccyhbXFxkX10rKSk/LyksXG4gICAgaXBob25lID0gIWlwYWQgJiYgdWEubWF0Y2goLyhpUGhvbmVcXHNPUylcXHMoW1xcZF9dKykvKSxcbiAgICB3ZWJvcyA9IHVhLm1hdGNoKC8od2ViT1N8aHB3T1MpW1xcc1xcL10oW1xcZC5dKykvKSxcbiAgICB0b3VjaHBhZCA9IHdlYm9zICYmIHVhLm1hdGNoKC9Ub3VjaFBhZC8pLFxuICAgIGtpbmRsZSA9IHVhLm1hdGNoKC9LaW5kbGVcXC8oW1xcZC5dKykvKSxcbiAgICBzaWxrID0gdWEubWF0Y2goL1NpbGtcXC8oW1xcZC5fXSspLyksXG4gICAgYmxhY2tiZXJyeSA9IHVhLm1hdGNoKC8oQmxhY2tCZXJyeSkuKlZlcnNpb25cXC8oW1xcZC5dKykvKSxcbiAgICBiYjEwID0gdWEubWF0Y2goLyhCQjEwKS4qVmVyc2lvblxcLyhbXFxkLl0rKS8pLFxuICAgIHJpbXRhYmxldG9zID0gdWEubWF0Y2goLyhSSU1cXHNUYWJsZXRcXHNPUylcXHMoW1xcZC5dKykvKSxcbiAgICBwbGF5Ym9vayA9IHVhLm1hdGNoKC9QbGF5Qm9vay8pLFxuICAgIGNocm9tZSA9IHVhLm1hdGNoKC9DaHJvbWVcXC8oW1xcZC5dKykvKSB8fCB1YS5tYXRjaCgvQ3JpT1NcXC8oW1xcZC5dKykvKSxcbiAgICBmaXJlZm94ID0gdWEubWF0Y2goL0ZpcmVmb3hcXC8oW1xcZC5dKykvKSxcbiAgICBpZSA9IHVhLm1hdGNoKC8oVHJpZGVudHxNU0lFXFxzKFtcXGQuXSkrKS8pLFxuICAgIGVkZ2UgPSB1YS5tYXRjaCgvKEVkZ2VcXC8oW1xcZC5dKSspLyksXG4gICAgLy93ZWJ2aWV3ID0gdWEubWF0Y2goLyhpUGhvbmV8aVBvZHxpUGFkKS4qQXBwbGVXZWJLaXQoPyEuKlNhZmFyaSkvKSxcbiAgICB3cDggPSB1YS5tYXRjaCgvVHJpZGVudFxcLyhbXFxkLl0rKS8pICYmIHVhLm1hdGNoKC9JRU1vYmlsZVxcLyhbXFxkLl0rKS8pXG4gICAgc2FmYXJpID0gd2Via2l0ICYmIHVhLm1hdGNoKC9TYWZhcmlcXC8vKSAmJiAhY2hyb21lICYmICF3cDhcblxuaWYgKGJyb3dzZXIud2Via2l0ID0gISF3ZWJraXQpIGJyb3dzZXIudmVyc2lvbiA9IHdlYmtpdFsxXVxuXG5pZiAoYW5kcm9pZCkgb3MuYW5kcm9pZCA9IHRydWUsIG9zLnZlcnNpb24gPSBhbmRyb2lkWzJdXG5pZiAoaXBob25lICYmICFpcG9kKSBvcy5pb3MgPSBvcy5pcGhvbmUgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBob25lWzJdLnJlcGxhY2UoL18vZywgJy4nKVxuaWYgKGlwYWQpIG9zLmlvcyA9IG9zLmlwYWQgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBhZFsyXS5yZXBsYWNlKC9fL2csICcuJylcbmlmIChpcG9kKSBvcy5pb3MgPSBvcy5pcG9kID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwb2RbM10gPyBpcG9kWzNdLnJlcGxhY2UoL18vZywgJy4nKSA6IG51bGxcbmlmICh3ZWJvcykgb3Mud2Vib3MgPSB0cnVlLCBvcy52ZXJzaW9uID0gd2Vib3NbMl1cbmlmICh0b3VjaHBhZCkgb3MudG91Y2hwYWQgPSB0cnVlXG5pZiAoYmxhY2tiZXJyeSkgb3MuYmxhY2tiZXJyeSA9IHRydWUsIG9zLnZlcnNpb24gPSBibGFja2JlcnJ5WzJdXG5pZiAoYmIxMCkgb3MuYmIxMCA9IHRydWUsIG9zLnZlcnNpb24gPSBiYjEwWzJdXG5pZiAocmltdGFibGV0b3MpIG9zLnJpbXRhYmxldG9zID0gdHJ1ZSwgb3MudmVyc2lvbiA9IHJpbXRhYmxldG9zWzJdXG5pZiAocGxheWJvb2spIGJyb3dzZXIucGxheWJvb2sgPSB0cnVlXG5pZiAoa2luZGxlKSBvcy5raW5kbGUgPSB0cnVlLCBvcy52ZXJzaW9uID0ga2luZGxlWzFdXG5pZiAoc2lsaykgYnJvd3Nlci5zaWxrID0gdHJ1ZSwgYnJvd3Nlci52ZXJzaW9uID0gc2lsa1sxXVxuaWYgKCFzaWxrICYmIG9zLmFuZHJvaWQgJiYgdWEubWF0Y2goL0tpbmRsZSBGaXJlLykpIGJyb3dzZXIuc2lsayA9IHRydWVcbmlmIChlZGdlKSBicm93c2VyLmVkZ2UgPSB0cnVlLCBicm93c2VyLnZlcnNpb24gPSBlZGdlWzBdLnNwbGl0KCcvJylbMV0sIGRlbGV0ZSBicm93c2VyLndlYmtpdDtcbmlmIChjaHJvbWUgJiYgIWVkZ2UpIGJyb3dzZXIuY2hyb21lID0gdHJ1ZSwgYnJvd3Nlci52ZXJzaW9uID0gY2hyb21lWzFdO1xuaWYgKGZpcmVmb3gpIGJyb3dzZXIuZmlyZWZveCA9IHRydWUsIGJyb3dzZXIudmVyc2lvbiA9IGZpcmVmb3hbMV07XG5pZiAoaWUpIGJyb3dzZXIuaWUgPSB0cnVlLCBicm93c2VyLnZlcnNpb24gPSBpZVsxXTtcbmlmIChzYWZhcmkgJiYgKHVhLm1hdGNoKC9TYWZhcmkvKSB8fCAhIW9zLmlvcykpIGJyb3dzZXIuc2FmYXJpID0gdHJ1ZTtcbi8vaWYgKHdlYmtpdCAmJiBhbmRyb2lkICYmICFjaHJvbWUgJiYgIWVkZ2UpIGJyb3dzZXIud2VidmlldyA9IHRydWU7XG5pZiAod3A4KSBicm93c2VyLmllID0gdHJ1ZSwgb3MuYW5kcm9pZCA9IG9zLmlvcyA9IG9zLmlwYWQgPSBvcy5pcGhvbmUgPSBicm93c2VyLndlYmtpdCA9IGJyb3dzZXIuc2FmYXJpID0gYnJvd3Nlci53ZWJ2aWV3ID0gZmFsc2U7XG5cbmRldmljZS50YWJsZXQgPSAhIShpcGFkIHx8IHBsYXlib29rIHx8IChhbmRyb2lkICYmICF1YS5tYXRjaCgvTW9iaWxlLykpIHx8XG4gIChmaXJlZm94ICYmIHVhLm1hdGNoKC9UYWJsZXQvKSkgfHwgKGllICYmICF1YS5tYXRjaCgvUGhvbmUvKSAmJiB1YS5tYXRjaCgvVG91Y2gvKSkpO1xuZGV2aWNlLnBob25lID0gISEoIWRldmljZS50YWJsZXQgJiYgIW9zLmlwb2QgJiYgKGFuZHJvaWQgfHwgaXBob25lIHx8IHdlYm9zIHx8IGJsYWNrYmVycnkgfHwgYmIxMCB8fFxuICAoY2hyb21lICYmIHVhLm1hdGNoKC9BbmRyb2lkLykpIHx8IChjaHJvbWUgJiYgdWEubWF0Y2goL0NyaU9TXFwvKFtcXGQuXSspLykpIHx8XG4gIChmaXJlZm94ICYmIHVhLm1hdGNoKC9Nb2JpbGUvKSkgfHwgKGllICYmIHVhLm1hdGNoKC9Ub3VjaC8pKSkgfHwgKHdwOCkpO1xuZGV2aWNlLmRlc2t0b3AgPSAhZGV2aWNlLnRhYmxldCAmJiAhZGV2aWNlLnBob25lO1xuXG5mdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgY2xhc3NlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSBpbiBvcylcbiAgICAgICAgaWYgKG9zW2ldID09PSB0cnVlKVxuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKGkpO1xuXG4gICAgZm9yICh2YXIgaSBpbiBicm93c2VyKVxuICAgICAgICBpZiAoYnJvd3NlcltpXSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaChpKTtcblxuICAgIGZvciAodmFyIGkgaW4gZGV2aWNlKVxuICAgICAgICBpZiAoZGV2aWNlW2ldID09PSB0cnVlKVxuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKGkpO1xuXG4gICAgaWYgKGRldmljZS5kZXNrdG9wKSB7XG4gICAgICAgIGlmICh0b3VjaCA9IGlzVG91Y2hEZXZpY2UoKSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCgndG91Y2gnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0b3VjaCA9IHRydWU7XG4gICAgICAgIGNsYXNzZXMucHVzaCgndG91Y2gnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG59XG5cbmZ1bmN0aW9uIGlzVG91Y2hEZXZpY2UoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJUb3VjaEV2ZW50XCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICB9O1xuXG5kb2N1bWVudC5ib2R5LmNsYXNzTmFtZSArPSAnICcgKyB0b1N0cmluZygpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnb3MnOiBvcyxcbiAgICAnYnJvd3Nlcic6IGJyb3dzZXIsXG4gICAgJ2RldmljZSc6IGRldmljZSxcbiAgICAndG91Y2gnOiB0b3VjaCxcbiAgICAndG9TdHJpbmcnOiB0b1N0cmluZ1xufTtcbiIsInZhciBTaWduYWwgPSByZXF1aXJlKCcuL3NpZ25hbCcpO1xudmFyIEVWRU5UUyA9IHt9O1xuXG5FVkVOVFMuU1RBUlQgPSAndG91Y2hzdGFydCc7XG5FVkVOVFMuTU9WRSA9ICd0b3VjaG1vdmUnO1xuRVZFTlRTLkVORCA9IFsndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnXTtcblxuaWYgKHdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcbiAgICBFVkVOVFMuU1RBUlQgPSAncG9pbnRlcmRvd24nO1xuICAgIEVWRU5UUy5NT1ZFID0gJ3BvaW50ZXJtb3ZlJztcbiAgICBFVkVOVFMuRU5EID0gJ3BvaW50ZXJvdXQnO1xufSBlbHNlIGlmICh3aW5kb3cuTVNQb2ludGVyRXZlbnQpIHtcbiAgICBFVkVOVFMuU1RBUlQgPSAnTVNQb2ludGVyRG93bic7XG4gICAgRVZFTlRTLk1PVkUgPSAnTVNQb2ludGVyTW92ZSc7XG4gICAgRVZFTlRTLkVORCA9ICdNU1BvaW50ZXJPdXQnO1xufVxuXG5cbi8qXG4gKiBCYXNlIEFQSVxuICovXG5mdW5jdGlvbiBHZXN0dXJlcygpIHt9O1xuR2VzdHVyZXMucHJvdG90eXBlLnRvdWNoZXMgPSB7fTtcbkdlc3R1cmVzLnByb3RvdHlwZS5vblRvdWNoU3RhcnQgPSBuZXcgU2lnbmFsKCk7XG5HZXN0dXJlcy5wcm90b3R5cGUub25Ub3VjaE1vdmUgID0gbmV3IFNpZ25hbCgpO1xuR2VzdHVyZXMucHJvdG90eXBlLm9uVG91Y2hFbmQgICA9IG5ldyBTaWduYWwoKTtcblxuR2VzdHVyZXMucHJvdG90eXBlLmdldEV2ZW50VG91Y2hlcyA9IGZ1bmN0aW9uKGV2ZW50KSB7cmV0dXJuIFtdfTtcbkdlc3R1cmVzLnByb3RvdHlwZS5nZXRUb3VjaElkID0gZnVuY3Rpb24odG91Y2gpIHtyZXR1cm4gMH07XG5HZXN0dXJlcy5wcm90b3R5cGUuZ2V0VG91Y2hYICA9IGZ1bmN0aW9uKHRvdWNoKSB7cmV0dXJuIDB9O1xuR2VzdHVyZXMucHJvdG90eXBlLmdldFRvdWNoWSAgPSBmdW5jdGlvbih0b3VjaCkge3JldHVybiAwfTtcblxuR2VzdHVyZXMucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGIudGltZSAtIGEudGltZTtcbn07XG5cbkdlc3R1cmVzLnByb3RvdHlwZS50b0xpc3QgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAodmFyIGlkIGluIHRoaXMudG91Y2hlcylcbiAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMudG91Y2hlc1tpZF0pO1xuICAgIHJldHVybiByZXN1bHRzLnNvcnQodGhpcy5zb3J0KTtcbn07XG5cbkdlc3R1cmVzLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRTLlNUQVJULCB0aGlzLnRvdWNoc3RhcnQuYmluZCh0aGlzKSk7XG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKEVWRU5UUy5NT1ZFLCAgdGhpcy50b3VjaG1vdmUuYmluZCh0aGlzKSk7XG5cbiAgICBpZiAoRVZFTlRTLkVORCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRVZFTlRTLkVORC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVFMuRU5EW2ldLCB0aGlzLnRvdWNoZW5kLmJpbmQodGhpcykpO1xuICAgIH0gZWxzZVxuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRTLkVORCwgICB0aGlzLnRvdWNoZW5kLmJpbmQodGhpcykpO1xufTtcblxuR2VzdHVyZXMucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRTLlNUQVJULCB0aGlzLnRvdWNoc3RhcnQuYmluZCh0aGlzKSk7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UUy5NT1ZFLCAgdGhpcy50b3VjaG1vdmUuYmluZCh0aGlzKSk7XG5cbiAgICBpZiAoRVZFTlRTLkVORCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRVZFTlRTLkVORC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMuRU5EW2ldLCB0aGlzLnRvdWNoZW5kLmJpbmQodGhpcykpO1xuICAgIH0gZWxzZVxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRTLkVORCwgICB0aGlzLnRvdWNoZW5kLmJpbmQodGhpcykpO1xufTtcblxuR2VzdHVyZXMucHJvdG90eXBlLnVwZGF0ZVRvdWNoID0gZnVuY3Rpb24obmV3VG91Y2gpIHtcbiAgICB2YXIgaWQgPSB0aGlzLmdldFRvdWNoSWQobmV3VG91Y2gpO1xuICAgIHZhciB0b3VjaCA9IHRoaXMudG91Y2hlc1tpZF07XG4gICAgdmFyIHggPSB0aGlzLmdldFRvdWNoWChuZXdUb3VjaCk7XG4gICAgdmFyIHkgPSB0aGlzLmdldFRvdWNoWShuZXdUb3VjaCk7XG4gICAgdG91Y2gueCA9IHg7XG4gICAgdG91Y2gueSA9IHk7XG4gICAgdG91Y2guZHggPSB0b3VjaC54IC0gdG91Y2guc3g7XG4gICAgdG91Y2guZHkgPSB0b3VjaC55IC0gdG91Y2guc3k7XG4gICAgcmV0dXJuIHRvdWNoO1xufTtcblxuR2VzdHVyZXMucHJvdG90eXBlLnRvdWNoc3RhcnQgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciB0b3VjaGVzID0gdGhpcy5nZXRFdmVudFRvdWNoZXMoZXZlbnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWQgPSB0aGlzLmdldFRvdWNoSWQodG91Y2hlc1tpXSk7XG4gICAgICAgIHZhciB4ID0gdGhpcy5nZXRUb3VjaFgodG91Y2hlc1tpXSk7XG4gICAgICAgIHZhciB5ID0gdGhpcy5nZXRUb3VjaFkodG91Y2hlc1tpXSk7XG4gICAgICAgIHZhciB0b3VjaCA9IHRoaXMudG91Y2hlc1tpZF0gPSB7XG4gICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICd4JzogeCxcbiAgICAgICAgICAgICd5JzogeSxcbiAgICAgICAgICAgICdzeCc6IHgsXG4gICAgICAgICAgICAnc3knOiB5LFxuICAgICAgICAgICAgJ2R4JzogMCxcbiAgICAgICAgICAgICdkeSc6IDAsXG4gICAgICAgICAgICAndGltZSc6IERhdGUubm93KCksXG4gICAgICAgICAgICAndGFyZ2V0JzogZXZlbnQudGFyZ2V0XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25Ub3VjaFN0YXJ0LnNlbmQoZXZlbnQudGFyZ2V0LCB0b3VjaCwgZXZlbnQpO1xuICAgIH1cbn07XG5cbkdlc3R1cmVzLnByb3RvdHlwZS50b3VjaG1vdmUgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciB0b3VjaGVzID0gdGhpcy5nZXRFdmVudFRvdWNoZXMoZXZlbnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWQgPSB0aGlzLmdldFRvdWNoSWQodG91Y2hlc1tpXSk7XG4gICAgICAgIGlmICghdGhpcy50b3VjaGVzW2lkXSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB0aGlzLm9uVG91Y2hNb3ZlLnNlbmQoZXZlbnQudGFyZ2V0LCB0aGlzLnVwZGF0ZVRvdWNoKHRvdWNoZXNbaV0pLCBldmVudCk7XG4gICAgfVxufTtcblxuR2VzdHVyZXMucHJvdG90eXBlLnRvdWNoZW5kID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgdG91Y2hlcyA9IHRoaXMuZ2V0RXZlbnRUb3VjaGVzKGV2ZW50KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5nZXRUb3VjaElkKHRvdWNoZXNbaV0pO1xuICAgICAgICBpZiAoIXRoaXMudG91Y2hlc1tpZF0pXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgdmFyIHRvdWNoID0gdGhpcy51cGRhdGVUb3VjaCh0b3VjaGVzW2ldKTtcbiAgICAgICAgdGhpcy5vblRvdWNoRW5kLnNlbmQoZXZlbnQudGFyZ2V0LCB0b3VjaCwgZXZlbnQpO1xuICAgICAgICBkZWxldGUgdGhpcy50b3VjaGVzW3RvdWNoLmlkXTtcbiAgICB9XG59O1xuXG5cblxuLypcbiAqIFRvdWNoIEFQSVxuICovXG5mdW5jdGlvbiBUb3VjaEFwaSgpIHt9XG5Ub3VjaEFwaS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdlc3R1cmVzLnByb3RvdHlwZSk7XG5cblRvdWNoQXBpLnByb3RvdHlwZS5nZXRFdmVudFRvdWNoZXMgPSBmdW5jdGlvbihldmVudCkge3JldHVybiBldmVudC50b3VjaGVzLmxlbmd0aCA/IGV2ZW50LnRvdWNoZXMgOiBldmVudC5jaGFuZ2VkVG91Y2hlc307XG5Ub3VjaEFwaS5wcm90b3R5cGUuZ2V0VG91Y2hJZCA9IGZ1bmN0aW9uKHRvdWNoKSB7cmV0dXJuIHRvdWNoLmlkZW50aWZpZXJ9O1xuVG91Y2hBcGkucHJvdG90eXBlLmdldFRvdWNoWCA9IGZ1bmN0aW9uKHRvdWNoKSB7cmV0dXJuIHRvdWNoLnBhZ2VYfTtcblRvdWNoQXBpLnByb3RvdHlwZS5nZXRUb3VjaFkgPSBmdW5jdGlvbih0b3VjaCkge3JldHVybiB0b3VjaC5wYWdlWX07XG5cblxuXG4vKlxuICogUG9pbnRlciBBUElcbiAqL1xuZnVuY3Rpb24gUG9pbnRlckFwaSgpIHt9XG5cblBvaW50ZXJBcGkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHZXN0dXJlcy5wcm90b3R5cGUpO1xuXG5Qb2ludGVyQXBpLnByb3RvdHlwZS5nZXRFdmVudFRvdWNoZXMgPSBmdW5jdGlvbihldmVudCkge3JldHVybiBbZXZlbnRdfTtcblBvaW50ZXJBcGkucHJvdG90eXBlLmdldFRvdWNoSWQgPSBmdW5jdGlvbihwb2ludGVyKSB7cmV0dXJuIHBvaW50ZXIucG9pbnRlcklkfTtcblBvaW50ZXJBcGkucHJvdG90eXBlLmdldFRvdWNoWCA9IGZ1bmN0aW9uKHBvaW50ZXIpIHtyZXR1cm4gcG9pbnRlci5wYWdlWH07XG5Qb2ludGVyQXBpLnByb3RvdHlwZS5nZXRUb3VjaFkgPSBmdW5jdGlvbihwb2ludGVyKSB7cmV0dXJuIHBvaW50ZXIucGFnZVl9O1xuXG5cblxuaWYgKHdpbmRvdy5Qb2ludGVyRXZlbnQgfHwgd2luZG93Lk1TUG9pbnRlckV2ZW50KVxuICBtb2R1bGUuZXhwb3J0cyA9IG5ldyBQb2ludGVyQXBpKCk7XG5lbHNlXG4gIG1vZHVsZS5leHBvcnRzID0gbmV3IFRvdWNoQXBpKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gc3VtKCkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKS5yZWR1Y2UoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyBzdW0uYXBwbHkodW5kZWZpbmVkLCB2YWx1ZSk7XG4gICAgICAgIGVsc2UgaWYgKGlzTmFOKE51bWJlcih2YWx1ZSkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc3VtKCk6IGAnICsgdmFsdWUgKyAnYCBpcyBub3QgYSBudW1iZXInKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIE51bWJlcih2YWx1ZSk7XG4gICAgfSwgMCk7XG59XG5cblxuZnVuY3Rpb24gbXVsdGlwbHkoKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMpLnJlZHVjZShmdW5jdGlvbihyZXN1bHQsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCAqIG11bHRpcGx5LmFwcGx5KHVuZGVmaW5lZCwgdmFsdWUpO1xuICAgICAgICBlbHNlIGlmIChpc05hTihOdW1iZXIodmFsdWUpKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N1bSgpOiBgJyArIHZhbHVlICsgJ2AgaXMgbm90IGEgbnVtYmVyJyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgKiBOdW1iZXIodmFsdWUpO1xuICAgIH0sIDEpO1xufVxuXG5cbmZ1bmN0aW9uIGZyYWN0KG4pIHtcbiAgICByZXR1cm4gbiAtIE1hdGgudHJ1bmMobik7XG59XG5cblxuZnVuY3Rpb24gbW9kKG4sIG0pIHtcbiAgICAvLyBBbHRlcm5hdGl2ZSBtb2R1bG8gb3BlcmF0aW9uIHdoZXJlIHJlc3VsdCdzIHNpZ24gaXMgdGhlIHNhbWUgYXMgZGl2aXNvcidzLlxuICAgIHJldHVybiAoKG4gJSBtKSArIG0pICUgbTtcbn1cblxuXG5mdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heCk7XG59XG5cblxuZnVuY3Rpb24gbWl4KG1pbiwgbWF4LCBhbHBoYSkge1xuICAgIHJldHVybiBtaW4gKiAoMSAtIGFscGhhKSArIG1heCAqIGFscGhhO1xufVxuXG5cbmZ1bmN0aW9uIHN0ZXAoZWRnZSwgbikge1xuICAgIHJldHVybiBuIDwgZWRnZSA/IDAgOiAxO1xufVxuXG5cbmZ1bmN0aW9uIHNtb290aFN0ZXAobWluRWRnZSwgbWF4RWRnZSwgbikge1xuICAgIC8vIFNlZSBhbHNvOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXBcbiAgICB2YXIgdCA9IHRoaXMuY2xhbXAoKG4gLSBtaW5FZGdlKSAvIChtYXhFZGdlIC0gbWluRWRnZSksIDAsIDEpO1xuICAgIHJldHVybiB0ICogdCAqICgzIC0gMip0KTtcbn1cblxuXG5mdW5jdGlvbiBzY2FsZShuLCBjdXJyZW50TWluLCBjdXJyZW50TWF4LCBuZXdNaW4sIG5ld01heCkge1xuICAgIC8vIFNjYWxlcyBuIGZyb20gb25lIHJhbmdlIHRvIGFub3RoZXIuXG4gICAgcmV0dXJuIG5ld01pbiArIChuIC0gY3VycmVudE1pbikgKiAobmV3TWF4IC0gbmV3TWluKSAvIChjdXJyZW50TWF4IC0gY3VycmVudE1pbik7XG59XG5cblxuZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICAvKlxuICAgICAqIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2YgdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgXG4gICAgICogZnVuY3Rpb24uIFNlZSB0aGUgUHl0aG9uIGRvY3VtZW50YXRpb246IGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS9mdW5jdGlvbnMuaHRtbCNyYW5nZS5cbiAgICAgKi9cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgc3RvcCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMylcbiAgICAgICAgc3RlcCA9IHN0YXJ0ID4gc3RvcCA/IC0xIDogMTtcbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciBpZHggPSAwO1xuICAgIHZhciByYW5nZSA9IG5ldyBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKGlkeCA8IGxlbmd0aCkge1xuICAgICAgICByYW5nZVtpZHgrK10gPSBzdGFydDtcbiAgICAgICAgc3RhcnQgKz0gc3RlcDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG59XG5cblxuZnVuY3Rpb24gdG9GaXhlZChudW0sIHByZWNpc2lvbikge1xuICAgIC8vIENvbnNpc3RlbnRseSBhY3Jvc3MgYnJvd3NlcnMgY29udmVydHMgYSBudW1iZXIgdG8gZ2l2ZW4gcHJlY2lzaW9uLlxuICAgIHJldHVybiAoKyhNYXRoLnJvdW5kKCsobnVtICsgJ2UnICsgcHJlY2lzaW9uKSkgKyAnZScgKyAtcHJlY2lzaW9uKSkudG9GaXhlZChwcmVjaXNpb24pO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdChudW1iZXIsIGRlY2ltYWxQbGFjZXMsIGRlY2ltYWxTZXBhcmF0b3IsIHRob3VzYW5kc1NlcGFyYXRvcikge1xuICAgIC8qXG4gICAgICogwqkgMjAxMSBFc2EtTWF0dGkgU3V1cm9uZW5cbiAgICAgKiBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VwZWxpL3VuZGVyc2NvcmUuc3RyaW5nXG4gICAgICovXG4gICAgaWYgKGlzTmFOKG51bWJlcikgfHwgbnVtYmVyID09IG51bGwpXG4gICAgICAgIHJldHVybiAnJztcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDQpXG4gICAgICAgIHRob3VzYW5kc1NlcGFyYXRvciA9ICcsJztcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpXG4gICAgICAgIGRlY2ltYWxTZXBhcmF0b3IgPSAnLic7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKVxuICAgICAgICBkZWNpbWFsUGxhY2VzID0gMjtcbiAgICBudW1iZXIgPSB0b0ZpeGVkKG51bWJlciwgZGVjaW1hbFBsYWNlcyk7XG4gICAgdmFyIHBhcnRzID0gbnVtYmVyLnNwbGl0KCcuJyk7XG4gICAgdmFyIGZudW1zID0gcGFydHNbMF07XG4gICAgdmFyIGRlY2ltYWxzID0gcGFydHNbMV0gPyBkZWNpbWFsU2VwYXJhdG9yICsgcGFydHNbMV0gOiAnJztcbiAgICByZXR1cm4gZm51bXMucmVwbGFjZSgvKFxcZCkoPz0oPzpcXGR7M30pKyQpL2csICckMScgKyB0aG91c2FuZHNTZXBhcmF0b3IpICsgZGVjaW1hbHM7XG59XG5cblxuZnVuY3Rpb24gZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB2YXIgZHggPSB4MSAtIHgyLCBkeSA9IHkxIC0geTI7XG4gICAgcmV0dXJuIE1hdGguc3FydChkeCpkeCArIGR5KmR5KTtcbn1cblxuXG5mdW5jdGlvbiByYWRpYW5zKGFuZ2xlKSB7XG4gICAgcmV0dXJuIGFuZ2xlICogTWF0aC5QSSAvIDE4MDtcbn1cblxuXG5mdW5jdGlvbiBkZWdyZWVzKGFuZ2xlKSB7XG4gICAgcmV0dXJuIGFuZ2xlICogMTgwIC8gTWF0aC5QSTtcbn1cblxuXG5mdW5jdGlvbiBpc1Bvd2VyT2ZUd28obikge1xuICAgIC8qXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgYG5gIGlzIGEgcG93ZXIgb2YgMi4gYG5gIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLiBXb3JrcyBvbmx5IHVwIHRvIDJeMzEuXG4gICAgICogU291cmNlOiBodHRwczovL2dyYXBoaWNzLnN0YW5mb3JkLmVkdS9+c2VhbmRlci9iaXRoYWNrcy5odG1sI0RldGVybWluZUlmUG93ZXJPZjJcbiAgICAgKi9cbiAgICBpZiAobiA8PSAwIHx8IChuICE9PSAyMTQ3NDgzNjQ4ICYmIG4gIT09IH5+bikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gIShuICYgKG4gLSAxKSk7XG59XG5cblxuZnVuY3Rpb24gbmV4dFBvd2VyT2ZUd28obikge1xuICAgIC8qXG4gICAgICogUmV0dXJucyBwb3dlciBvZiAyIGdyZWF0ZXIgb3IgZXF1YWwgdG8gYG5gLlxuICAgICAqIFNvdXJjZTogaHR0cHM6Ly9ncmFwaGljcy5zdGFuZm9yZC5lZHUvfnNlYW5kZXIvYml0aGFja3MuaHRtbCNSb3VuZFVwUG93ZXJPZjJcbiAgICAgKi9cbiAgICBpZiAobiA8IDEpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmICh0aGlzLmlzUG93ZXJPZlR3byhuKSlcbiAgICAgICAgcmV0dXJuIG47XG4gICAgbiAtPSAxO1xuICAgIG4gfD0gbiA+PiAxO1xuICAgIG4gfD0gbiA+PiAyO1xuICAgIG4gfD0gbiA+PiA0O1xuICAgIG4gfD0gbiA+PiA4O1xuICAgIG4gfD0gbiA+PiAxNjtcbiAgICByZXR1cm4gbiArIDE7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPXtcbiAgJ3N1bSc6IHN1bSxcbiAgJ211bHRpcGx5JzogbXVsdGlwbHksXG4gICdmcmFjdCc6IGZyYWN0LFxuICAnbW9kJzogbW9kLFxuICAnY2xhbXAnOiBjbGFtcCxcbiAgJ21peCc6IG1peCxcbiAgJ3N0ZXAnOiBzdGVwLFxuICAnc21vb3RoU3RlcCc6IHNtb290aFN0ZXAsXG4gICdzY2FsZSc6IHNjYWxlLFxuICAncmFuZ2UnOiByYW5nZSxcbiAgJ2Zvcm1hdCc6IGZvcm1hdCxcbiAgJ2Rpc3RhbmNlJzogZGlzdGFuY2UsXG4gICdyYWRpYW5zJzogcmFkaWFucyxcbiAgJ2RlZ3JlZXMnOiBkZWdyZWVzLFxuICAnaXNQb3dlck9mVHdvJzogaXNQb3dlck9mVHdvLFxuICAnbmV4dFBvd2VyT2ZUd28nOiBuZXh0UG93ZXJPZlR3b1xufVxuIiwiLypcbiAqIFB1dCBnbG9iYWwgY29uZmlndXJhdGlvbiBvcHRpb25zIGhlcmUuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8vIEVuYWJsZSBvciBkaXNhYmxlIGpRdWVyeSAnbm8gY29uZmxpY3QnIG1vZGUuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICAnSlFVRVJZX05PX0NPTkZMSUNUJzogdHJ1ZSxcblxuICAgIC8vIFNvbWUgbGlicmFyaWVzIHVzZSBuYW1pbmcgdGhhdCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIG91ciBzdHJpY3QgbmFtaW5nIHJ1bGVzLiBVc2luZyB0aGUgbWFwcGluZyBiZWxvdyB5b3VcbiAgICAvLyBjYW4gbWFrZSB0aGVzZSBsaWJyYXJpZXMgbG9hZCBwcm9wZXJseSB1bmRlciBhIG5ldywgY29tcGF0aWJsZSBuYW1lLlxuICAgIC8vJ0FMSUFTRVMnOiB7XG4gICAgLy8gICAgJ1BoYXNlcic6ICdwaGFzZXInLFxuICAgIC8vICAgICdQSVhJJzogJ3BpeGknXG4gICAgLy99LFxuXG4gICAgJ1ZJRVdQT1JUUyc6IHtcbiAgICAgICAgJzMyMCc6IFswLCAzMjBdLFxuICAgICAgICAnNzY4JzogWzMyMSwgNzY4XSxcbiAgICAgICAgJzEwMjQnOiBbNzY5LCBJbmZpbml0eV1cbiAgICB9LFxuICAgIC8vIFVuY29tbWVudCB0aGlzIHRvIGRpc2FibGUgJ3ZpZXdwb3J0LXBvcnRyYWl0JyBhbmQgJ3ZpZXdwb3J0LWxhbmRzY2FwZScgY2xhc3NlcyBhZGRlZCBhdXRvbWF0aWNhbGx5IHRvIGJvZHkuXG4gICAgLy8gJ1ZJRVdQT1JUX09SSUVOVEFUSU9OX0NMQVNTJzogdHJ1ZSxcblxuICAgICdTTUFSVF9CTE9DS1MnOiB7XG4gICAgICAgIC8vIEV4YW1wbGUgc21hcnQgYmxvY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgLy8gSW5pdGlhbCBlbGVtZW50IHNlbGVjdG9yLlxuICAgICAgICAvLyAnLmJsb2NrJzoge1xuICAgICAgICAvLyAgICAgLy9BZGRpdGlvbmFsIGNsYXNzZXMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgd2hlbiB3aWR0aCBvZiBwYXJlbnQgaXMgYmV0d2VlbiBnaXZlbiBudW1iZXJzLlxuICAgICAgICAvLyAgICAgJ3NtYWxsJzogWzAsIDI5OV0sXG4gICAgICAgIC8vICAgICAnbWVkaXVtJzogWzMwMCwgNjk5XSxcbiAgICAgICAgLy8gICAgICdiaWcnOiBbNzAwLCBJbmZpbml0eV0sXG4gICAgICAgIC8vIH0sXG4gICAgICAgIC8vICcuc2VsZi1ibG9jayc6IHtcbiAgICAgICAgLy8gICAgLy8gQWRkaXRpb25hbCBjbGFzc2VzIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHdoZW4gd2lkdGggb2YgZWxlbWVudCBpcyBiZXR3ZWVuIGdpdmVuIG51bWJlcnMuXG4gICAgICAgIC8vICAgICdzbWFsbCc6IFswLCAyOTksICdzZWxmJ10sXG4gICAgICAgIC8vICAgICdtZWRpdW0nOiBbMzAwLCA2OTksICdzZWxmJ10sXG4gICAgICAgIC8vICAgICdiaWcnOiBbNzAwLCBJbmZpbml0eSwgJ3NlbGYnXSxcbiAgICAgICAgLy99XG4gICAgfSxcblxuICAgICdUUkFOU0xBVElPTlMnOiB7XG4gICAgICAgICdFTkcnOiB7XG4gICAgICAgICAgICAnbm9fZmlsZSc6ICdDbGljayB0byBzZWxlY3QnLFxuICAgICAgICAgICAgJ2NoYXJhY3RlcnMnOiAnY2hhcmFjdGVycycsXG4gICAgICAgICAgICAnaGlkZSc6ICdoaWRlJyxcbiAgICAgICAgICAgICdtZXNzYWdlX2RlbGV0ZV9jb25maXJtJzogJ0RvIHlvdSByZWFsbHkgd2FudCB0byBkZWxldGUgdGhpcyBtZXNzYWdlPycsXG4gICAgICAgICAgICAndmFsaWRhdGlvbl9yZXF1aXJlZCc6ICdGaWVsZCBpcyByZXF1aXJlZCcsXG4gICAgICAgICAgICAndmFsaWRhdGlvbl9lbWFpbCc6ICdJbnZhbGlkIGVtYWlsIGZvcm1hdCcsXG4gICAgICAgICAgICAndmFsaWRhdGlvbl9taW5sZW5ndGgnOiAnTWluLiB7MH0gY2hhcmFjdGVycycsXG4gICAgICAgICAgICAndmFsaWRhdGlvbl9lcXVhbCc6ICdFcXVhbCBmaWVsZCcsXG4gICAgICAgICAgICAndmFsaWRhdGlvbl9waG9uZSc6ICdJbnZhbGlkIHBob25lIG51bWJlcicsXG4gICAgICAgICAgICAndmFsaWRhdGlvbl9udW1iZXJzJzogJ051bWJlcnMgb25seScsXG4gICAgICAgICAgICAndmFsaWRhdGlvbl9sZXR0ZXJzLW9ubHknOiAnTGV0dGVycyBvbmx5J1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIi8qXG4gKiBTaW1wbGUgc2lnbmFsIGRpc3BhdGNoZXIgaW1wbGVtZW50YXRpb24uXG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciBkZXRlY3QgPSByZXF1aXJlKCcuL2RldGVjdCcpO1xuXG5mdW5jdGlvbiBjb25uZWN0KCkge1xuICAgIHZhciBrd2FyZ3MgPSB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nID8geydyZWNlaXZlcic6IGFyZ3VtZW50c1swXX0gOiBhcmd1bWVudHNbMF07XG4gICAgaWYgKHR5cGVvZiBrd2FyZ3MucmVjZWl2ZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbid0IGNvbm5lY3QgcmVjZWl2ZXIgdG8gYSBzaWduYWwsIHJlY2VpdmVyIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWNlaXZlcnMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICh0aGlzLnJlY2VpdmVyc1tpXS5yZWNlaXZlciA9PT0ga3dhcmdzLnJlY2VpdmVyICYmIHRoaXMucmVjZWl2ZXJzW2ldLmNvbnRleHQgPT09IGt3YXJncy5jb250ZXh0ICYmIHRoaXMucmVjZWl2ZXJzW2ldLnNlbmRlciA9PT0ga3dhcmdzLnNlbmRlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbid0IGNvbm5lY3QgcmVjZWl2ZXIgdG8gYSBzaWduYWwsIHRoaXMgcmVjZWl2ZXIgd2l0aCBzYW1lIGNvbnRleHQgYW5kIHNhbWUgc2VuZGVyIGlzIGFscmVhZHkgY29ubmVjdGVkXCIpO1xuICAgIHRoaXMucmVjZWl2ZXJzLnB1c2goe1xuICAgICAgICAncmVjZWl2ZXInOiBrd2FyZ3MucmVjZWl2ZXIsXG4gICAgICAgICdzZW5kZXInOiBrd2FyZ3Muc2VuZGVyLFxuICAgICAgICAnY29udGV4dCc6IGt3YXJncy5jb250ZXh0fSk7XG59XG5cbmZ1bmN0aW9uIGRpc2Nvbm5lY3QoKSB7XG4gICAgLy8gR2l2ZW4gcmVjZWl2ZXIgd2lsbCBub3QgYmUgbm90aWZpZWQgYWJvdXQgdGhpcyBzaWduYWwgc2VuZGluZyBhbnltb3JlLlxuICAgIHZhciByZWNlaXZlciA9IHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgPyBhcmd1bWVudHNbMF0gOiBhcmd1bWVudHNbMF0ucmVjZWl2ZXI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlY2VpdmVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKHRoaXMucmVjZWl2ZXJzW2ldLnJlY2VpdmVyID09PSByZWNlaXZlcikge1xuICAgICAgICAgICAgdGhpcy5yZWNlaXZlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG59XG5cbmZ1bmN0aW9uIHNlbmQoc2VuZGVyKSB7XG4gICAgLy8gRXhlY3V0ZSBhbGwgY29ubmVjdGVkIHJlY2VpdmVycywgZm9yd2FyZGluZyBhbGwgYXJndW1lbnRzLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWNlaXZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5yZWNlaXZlcnNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkuc2VuZGVyID09PSAndW5kZWZpbmVkJyB8fCBlbnRyeS5zZW5kZXIgPT09IHNlbmRlcilcbiAgICAgICAgICAgIGVudHJ5LnJlY2VpdmVyLmFwcGx5KGVudHJ5LmNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBTaWduYWwoKSB7XG4gICAgLypcbiAgICAgKiBUaGlzIGlzIGNvbnN0cnVjdG9yIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBvcGVyYXRvciwgYnV0IGl0IHJldHVybnMgYSBmdW5jdGlvbiB3aXRoXG4gICAgICogYXR0cmlidXRlcyBhbmQgbWV0aG9kcy4gSW4gdGhpcyB3YXkgc2lnbmFsIGluc3RhbmNlcyBjYW4gYmUgY2FsbGVkIGRpcmVjdGx5LCBpLmUuIHRoZXkgY2FuIGJlIHVzZWQgYXNcbiAgICAgKiBhIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpZ25hbCgpIHtcbiAgICAgICAgY29ubmVjdC5hcHBseShzaWduYWwsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHNpZ25hbC5yZWNlaXZlcnMgPSBbXTtcbiAgICBzaWduYWwuY29ubmVjdCA9IGNvbm5lY3QuYmluZChzaWduYWwpO1xuICAgIHNpZ25hbC5kaXNjb25uZWN0ID0gZGlzY29ubmVjdC5iaW5kKHNpZ25hbCk7XG4gICAgc2lnbmFsLnNlbmQgPSBzZW5kLmJpbmQoc2lnbmFsKTtcbiAgICByZXR1cm4gc2lnbmFsO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gU2lnbmFsO1xuIiwiLypcbiAqIEF1dG9tYXRpY2FsbHkgYXBwbGllcyBhZGRpdGlvbmFsIGNsYXNzZXMgdG8gYW4gZWxlbWVudCBiYXNlZCBvbiB3aWR0aCBvZiB0aGlzIGVsZW1lbnQgb3IgaXRzIHBhcmVudC5cbiAqXG4gKiBFeGFtcGxlLCBzaW1wbGUgc2V0dGluZ3M6XG4gKlxuICogICAgICdTTUFSVF9CTE9DS1MnOiB7XG4gKiAgICAgICAgIC8vIEluaXRpYWwgZWxlbWVudCBzZWxlY3RvciwgY2FuIGJlIGFueSBDU1Mgc2VsZWN0b3Igc3VwcG9ydGVkIGJ5IGJyb3dzZXIuXG4gKiAgICAgICAgICcuYmxvY2snOiB7XG4gKiAgICAgICAgICAgICAvLyBBZGRpdGlvbmFsIGNsYXNzZXMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgd2hlbiB3aWR0aCBvZiBwYXJlbnQgaXMgYmV0d2VlbiBnaXZlbiBudW1iZXJzLlxuICogICAgICAgICAgICAgJ3NtYWxsJzogWzAsIDI5OV0sXG4gKiAgICAgICAgICAgICAnbWVkaXVtJzogWzMwMCwgNjk5XSxcbiAqICAgICAgICAgICAgICdtZWRpdW0nOiAndmlld3BvcnRuYW1lJyxcbiAqICAgICAgICAgICAgICdiaWcnOiBbNzAwLCBJbmZpbml0eV0sXG4gKiAgICAgICAgICAgICAnYmlnJzogZnVuY3Rpb24oYmxvY2spIHsuLi59LFxuICogICAgICAgICB9XG4gKiAgICAgfVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzZXR0aW5ncyA9IHJlcXVpcmUoJy4vc2V0dGluZ3MnKTtcbnZhciBTaWduYWwgPSByZXF1aXJlKCcuL3NpZ25hbCcpO1xudmFyIHZpZXdwb3J0ID0gcmVxdWlyZSgnLi92aWV3cG9ydCcpO1xuLy8gU2lnbmFsIHNlbnQgd2hlbmV2ZXIgYW55IG9mIHRoZSBibG9ja3MgaGFkIGNsYXNzIGNoYW5nZWQuXG52YXIgb25VcGRhdGUgPSBuZXcgU2lnbmFsKCk7XG5cblxuZnVuY3Rpb24gY2xlYW4oYmxvY2ssIGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3MgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiBhcmdzKGJsb2NrKTtcbiAgICBlbHNlIGlmIChhcmdzIGluc3RhbmNlb2YgQXJyYXkgJiYgKGFyZ3MubGVuZ3RoID09IDIgfHwgKGFyZ3MubGVuZ3RoID09IDMgJiYgYXJnc1syXSA9PT0gJ3NlbGYnKSkgJiZcbiAgICAgICAgICAgICB0eXBlb2YgYXJnc1swXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFyZ3NbMV0gPT09ICdudW1iZXInICYmIGFyZ3NbMF0gPD0gYXJnc1sxXSkge1xuICAgICAgICB2YXIgd2lkdGggPSBhcmdzWzJdID09PSAnc2VsZicgPyBibG9jay5vZmZzZXRXaWR0aCA6IGJsb2NrLnBhcmVudE5vZGUub2Zmc2V0V2lkdGg7XG4gICAgICAgIHJldHVybiBhcmdzWzBdIDw9IHdpZHRoICYmIHdpZHRoIDw9IGFyZ3NbMV07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJncyA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiB2aWV3cG9ydC5pcyhhcmdzKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc21hcnQgYmxvY2tzIGFyZ3M6ICcgKyBhcmdzKTtcbn1cblxuXG5mdW5jdGlvbiB1cGRhdGVCbG9jayhibG9jaywgc3BlY2lmaWNhdGlvbiwgc2VsZWN0b3IpIHtcbiAgICB2YXIgY2xhc3NNb2RpZmllZCA9IGZhbHNlO1xuICAgIGZvciAodmFyIGNsYXNzTmFtZSBpbiBzcGVjaWZpY2F0aW9uKSB7XG4gICAgICAgIHZhciBjbGFzc0FkZGVkID0gYmxvY2suY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7XG5cbiAgICAgICAgaWYgKGNsZWFuKGJsb2NrLCBzcGVjaWZpY2F0aW9uW2NsYXNzTmFtZV0pKSB7XG4gICAgICAgICAgICBpZiAoIWNsYXNzQWRkZWQpIHtcbiAgICAgICAgICAgICAgICBibG9jay5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgY2xhc3NNb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2xhc3NBZGRlZCkge1xuICAgICAgICAgICAgYmxvY2suY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgICAgICAgY2xhc3NNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsYXNzTW9kaWZpZWQpXG4gICAgICAgIG9uVXBkYXRlLnNlbmQoc2VsZWN0b3IsIGJsb2NrKTtcbn1cblxuXG5mdW5jdGlvbiB1cGRhdGVUcmVlKHJvb3QpIHtcbiAgICB2YXIgQkxPQ0tTID0gc2V0dGluZ3NbJ1NNQVJUX0JMT0NLUyddO1xuICAgIHZhciBzZWxlY3RvciwgYmxvY2tzLCBpO1xuICAgIGZvciAoc2VsZWN0b3IgaW4gQkxPQ0tTKSB7XG4gICAgICAgIGJsb2NrcyA9IHJvb3QucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB1cGRhdGVCbG9jayhibG9ja3NbaV0sIEJMT0NLU1tzZWxlY3Rvcl0sIHNlbGVjdG9yKTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gdXBkYXRlRG9jdW1lbnQoKSB7XG4gICAgdXBkYXRlVHJlZSh3aW5kb3cuZG9jdW1lbnQuYm9keSk7XG59XG5cblxuZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVEb2N1bWVudCk7XG59XG5cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlRG9jdW1lbnQpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdvblVwZGF0ZSc6IG9uVXBkYXRlLFxuICAgICd1cGRhdGVCbG9jayc6IHVwZGF0ZUJsb2NrLFxuICAgICd1cGRhdGVUcmVlJzogdXBkYXRlVHJlZSxcbiAgICAndXBkYXRlRG9jdW1lbnQnOiB1cGRhdGVEb2N1bWVudCxcbiAgICAnZW5hYmxlJzogZW5hYmxlLFxuICAgICdkaXNhYmxlJzogZGlzYWJsZVxufTtcbiIsIi8qXG4gKiBUaHJvdHRsZSBleGVjdXRpb24gb2YgYSBmdW5jdGlvbi5cbiAqIEVzcGVjaWFsbHkgdXNlZnVsIGZvciByYXRlIGxpbWl0aW5nIGV4ZWN1dGlvbiBvZiBoYW5kbGVycyBvbiBldmVudHMgbGlrZSByZXNpemUgYW5kIHNjcm9sbC5cbiAqIEV4ZWN1dGVzIGNhbGxiYWNrIGV2ZXJ5IFggc2Vjb25kcyBkZWZpbmVkIGluIHJhdGUgdmFyaWFibGUuXG4gKlxuICogIFVzYWdlIGV4YW1wbGU6XG4gKiAgICAgIGpRdWVyeS5vbignbW91c2Vtb3ZlJywgdGhyb3R0bGUodGhpcywgMjUwLCBmdW5jdGlvbihldmVudCkge1xuICogICAgICAgICAgLy8gRXZlbnQgaGFuZGxpbmcgY29kZVxuICogICAgICB9KTtcbiAqXG4gKiAgQXJndW1lbnRzOlxuICogICAgICBzY29wZSAtIChPYmplY3QpIFBhc3Npbmcgc2NvcGVcbiAqICAgICAgZGVsYXkgLSAoTnVtYmVyKSA+IDAgVGltZSBiZWV0d2VlbiBjYWxsYmFjayBmaXJpbmdcbiAqICAgICAgY2FsbGJhY2sgLSAoRnVuY3Rpb24pIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc2NvcGUsIGRlbGF5LCBjYWxsYmFjaykge1xuICAgIHZhciBkZWxheSA9IGRlbGF5IHx8IDI1MDtcbiAgICB2YXIgbGFzdEV4ZWN1dGlvbiwgdGltZXI7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG4gICAgICAgIHZhciBjb250ZXh0ID0gc2NvcGUgfHwgdGhpcztcblxuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUsXG4gICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxhc3RFeGVjdXRpb24gPSBub3cuZ2V0VGltZSgpO1xuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGxhc3RFeGVjdXRpb24gJiYgbm93LmdldFRpbWUoKSA8IGxhc3RFeGVjdXRpb24gKyBkZWxheSlcbiAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmbiwgZGVsYXkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmbigpO1xuICAgIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHNldHRpbmdzID0gcmVxdWlyZSgnLi9zZXR0aW5ncycpO1xuZnVuY3Rpb24gdHJhbnNsYXRlKGtleSwgdmFyaWFibGVzKSB7XG4gICAgdmFyIHRyYW5zbGF0aW9uO1xuICAgIC8vIHZhciBsYW5ndWFnZSA9IHNldHRpbmdzWydMQU5HVUFHRSddO1xuXG4gICAgaWYgKHR5cGVvZiBzZXR0aW5nc1trZXldICE9ICd1bmRlZmluZWQnKVxuICAgICAgICB0cmFuc2xhdGlvbiA9IHNldHRpbmdzW2tleV07XG4gICAgZWxzZVxuICAgICAgICB0cmFuc2xhdGlvbiA9IHNldHRpbmdzWydUUkFOU0xBVElPTlMnXVtsYW5ndWFnZV1ba2V5XTtcblxuICAgIHJldHVybiB0cmFuc2xhdGlvbi5yZXBsYWNlKC97KFxcZCspfS9nLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFyaWFibGVzW251bWJlcl0gIT0gJ3VuZGVmaW5lZCcgPyB2YXJpYWJsZXNbbnVtYmVyXSA6IG1hdGNoO1xuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYW5zbGF0ZTtcbiIsIi8qXG4gKiBBbGxvd3MgdG8gZGVmaW5lIGN1c3RvbSB2aWV3cG9ydHMgdXNpbmcgc2V0dGluZ3MgZmlsZSBhbmQgdGhlbiByZWFjdCwgd2hlbiB2aWV3cG9ydCBjaGFuZ2VzIChkdWUgdG8gYnJvd3NlciByZXNpemVcbiAqIG9yIGRldmljZSBvcmllbnRhdGlvbiBjaGFuZ2UpLlxuICpcbiAqIFRvIHNwZWNpZnkgb3duIHZpZXdwb3J0cyBhZGQgdGhpcyBzZXR0aW5nOlxuICpcbiAqICAgICAnVklFV1BPUlRTJzoge1xuICogICAgICAgICAnbXkgdmlld3BvcnQgbmFtZSc6IFswLCA1MDBdLFxuICogICAgICAgICAnb3RoZXIgdmlld3BvcnQnOiBbNTAxLCAxMDAwXSxcbiAqICAgICAgICAgJ3NvbWV0aGluZyBlbHNlJzogJyhtaW4td2lkdGg6IDEwMDFweCkgb3IgKG1heC13aWR0aDogOTk5OXB4KScsXG4gKiAgICAgICAgIC4uLlxuICogICAgIH1cbiAqXG4gKiBFYWNoIHZpZXdwb3J0IGNvbnNpc3RzIG9mIGEgYWxpYXMgYW5kIHNwZWNpZmljYXRpb24uIEEgc3BlY2lmaWNhdGlvbiBtYXkgYmUgYSBmdW5jdGlvbiwgdHdvLWVsZW1lbnQgYXJyYXkgb3JcbiAqIG1lZGlhIHF1ZXJ5IHN0cmluZy5cbiAqXG4gKiBPbmx5IG9uZSB2aWV3cG9ydCBpcyBhY3RpdmUgaW4gZ2l2ZW4gbW9tZW50LCBldmVuIHdoZW4gdHdvIHNwZWNpZmljYXRpb25zIGFyZSBvdmVybGFwcGluZ1xuICogKHJhbmRvbSBvbmUgd2lsbCBiZSByZXR1cm5lZCksIHRodXMgaXQncyByZWNvbW1lbmVkIHRvIGRlZmluZSBub24tb3ZlcmxhcHBpbmcgYnJlYWtwb2ludHMuXG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciBzZXR0aW5ncyA9IHJlcXVpcmUoJy4vc2V0dGluZ3MnKTtcbnZhciBTaWduYWwgPSByZXF1aXJlKCcuL3NpZ25hbCcpO1xudmFyIGFjdGl2ZSA9IHVuZGVmaW5lZCwgcG9ydHJhaXQgPSB1bmRlZmluZWQ7XG52YXIgb25DaGFuZ2UgPSBuZXcgU2lnbmFsKCk7XG5cbmZ1bmN0aW9uIF9jaGVjayhzcGVjaWZpY2F0aW9uKSB7XG4gICAgLypcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBnaXZlbiB2aWV3cG9ydCBzcGVjaWZpY2F0aW9uIChtYXkgYmUgYSBmdW5jdGlvbiwgYXJyYXkgb3IgbWVkaWEgcXVlcnkgc3RyaW5nKVxuICAgICAqIGlzIGFjdGl2ZS5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIHNwZWNpZmljYXRpb24gPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiBzcGVjaWZpY2F0aW9uKCk7XG4gICAgZWxzZSBpZiAoc3BlY2lmaWNhdGlvbiBpbnN0YW5jZW9mIEFycmF5ICYmIHNwZWNpZmljYXRpb24ubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgdHlwZW9mIHNwZWNpZmljYXRpb25bMF0gPT09ICdudW1iZXInICYmIHR5cGVvZiBzcGVjaWZpY2F0aW9uWzFdID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgIHNwZWNpZmljYXRpb25bMF0gPD0gc3BlY2lmaWNhdGlvblsxXSlcbiAgICAgICAgcmV0dXJuIHNwZWNpZmljYXRpb25bMF0gPD0gd2lkdGgoKSAmJiB3aWR0aCgpIDw9IHNwZWNpZmljYXRpb25bMV07XG4gICAgZWxzZSBpZiAodHlwZW9mIHNwZWNpZmljYXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghd2luZG93Lm1hdGNoTWVkaWEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hdGNoTWVkaWEgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGJyb3dzZXIsIHBsZWFzZSBhZGQgYSBwb2x5ZmlsbCcpO1xuICAgICAgICByZXR1cm4gd2luZG93Lm1hdGNoTWVkaWEoc3BlY2lmaWNhdGlvbikubWF0Y2hlcztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZpZXdwb3J0IHNwZWNpZmljYXRpb246ICcgKyBzcGVjaWZpY2F0aW9uKTtcbn1cblxuZnVuY3Rpb24gX2NoYW5nZU9yaWVudGF0aW9uKG5ld1BvcnRyYWl0KSB7XG4gICAgaWYgKG5ld1BvcnRyYWl0ICE9PSBwb3J0cmFpdCkge1xuICAgICAgICAvLyBpZiAoc2V0dGluZ3NbJ1ZJRVdQT1JUX09SSUVOVEFUSU9OX0NMQVNTJ10gPT09IHRydWUpKSB7XG4gICAgICAgICAgICB2YXIgVklFV1BPUlRfQ0xBU1NfUFJFRklYID0gJ3ZpZXdwb3J0LSc7XG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKFZJRVdQT1JUX0NMQVNTX1BSRUZJWCArIChwb3J0cmFpdCA/ICdwb3J0cmFpdCcgOiAnbGFuZHNjYXBlJykpO1xuICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChWSUVXUE9SVF9DTEFTU19QUkVGSVggKyAobmV3UG9ydHJhaXQgPyAncG9ydHJhaXQnIDogJ2xhbmRzY2FwZScpKTtcbiAgICAgICAgLy8gfVxuICAgICAgICBwb3J0cmFpdCA9IG5ld1BvcnRyYWl0O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX2NoYW5nZVZpZXdwb3J0KG5ld0NsYXNzKSB7XG4gICAgdmFyIHByZXZpb3VzQ2xhc3MgPSBhY3RpdmUgfHwgbnVsbDtcbiAgICBpZiAobmV3Q2xhc3MgIT09IGFjdGl2ZSkge1xuICAgICAgICB2YXIgVklFV1BPUlRfQ0xBU1NfUFJFRklYID0gJ3ZpZXdwb3J0LSc7XG4gICAgICAgIGlmIChhY3RpdmUpXG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKFZJRVdQT1JUX0NMQVNTX1BSRUZJWCArIGFjdGl2ZSk7XG4gICAgICAgIGlmIChuZXdDbGFzcylcbiAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoVklFV1BPUlRfQ0xBU1NfUFJFRklYICsgbmV3Q2xhc3MpO1xuICAgICAgICBhY3RpdmUgPSBuZXdDbGFzcztcbiAgICAgICAgb25DaGFuZ2Uuc2VuZChwcmV2aW91c0NsYXNzLCBhY3RpdmUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX3VwZGF0ZSgpIHtcbiAgICB2YXIgVklFV1BPUlRTID0gc2V0dGluZ3NbJ1ZJRVdQT1JUUyddLCBuZXdDbGFzcyA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBhbGlhcyBpbiBWSUVXUE9SVFMpXG4gICAgICAgIGlmIChfY2hlY2soVklFV1BPUlRTW2FsaWFzXSkpIHtcbiAgICAgICAgICAgIG5ld0NsYXNzID0gYWxpYXM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgX2NoYW5nZVZpZXdwb3J0KG5ld0NsYXNzKTtcbiAgICBfY2hhbmdlT3JpZW50YXRpb24oaGVpZ2h0KCkgPj0gd2lkdGgoKSk7XG59XG5cbmZ1bmN0aW9uIF9pcyhhbGlhcykge1xuICAgIC8qXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgZ2l2ZW4gYGFsaWFzYCBpcyBjdXJyZW50bHkgYWN0aXZlLiBgYWxpYXNgIG11c3QgYmUgb25lIG9mIHRoZSB2aWV3cG9ydCBuYW1lcyBkZWZpbmVkXG4gICAgICogaW4gc2V0dGluZ3MuXG4gICAgICovXG4gICAgdmFyIFZJRVdQT1JUUyA9IHNldHRpbmdzWydWSUVXUE9SVFMnXTtcbiAgICBpZiAoYWxpYXMgaW4gVklFV1BPUlRTKVxuICAgICAgICByZXR1cm4gYWxpYXMgPT09IGFjdGl2ZTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdmlld3BvcnQgYWxpYXM6ICcgKyBhbGlhcyk7XG59XG5cbmZ1bmN0aW9uIGlzKGFsaWFzZXMpIHtcbiAgICBpZiAoIWlzRW5hYmxlZCgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGNhbGwgYHZpZXdwb3J0LmVuYWJsZSgpYCBmaXJzdCB0byB1c2UgYHZpZXdwb3J0LmlzKClgJyk7XG4gICAgLypcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgb2YgdGhlIGFsaWFzZXMgaXMgY3VycmVudGx5IGFjdGl2ZS4gYGFsaWFzZXNgIG11c3QgYmUgYSBzdHJpbmcgd2l0aCBhbnlcbiAgICAgKiB2aWV3cG9ydCBuYW1lcyBkZWZpbmVkIGluIHNldHRpbmdzLCBzZXBhcmF0ZWQgYnkgc3BhY2UuXG4gICAgICovXG4gICAgYWxpYXNlcyA9IGFsaWFzZXMuc3BsaXQoJyAnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsaWFzZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChfaXMoYWxpYXNlc1tpXSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAoIWlzRW5hYmxlZCgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGNhbGwgYHZpZXdwb3J0LmVuYWJsZSgpYCBmaXJzdCB0byB1c2UgYHZpZXdwb3J0LmdldCgpYCcpO1xuICAgIC8qXG4gICAgICogUmV0dXJucyBuYW1lIG9mIGN1cnJlbnRseSBhY3RpdmUgdmlld3BvcnQuIE1heSByZXR1cm4gYG51bGxgIGlmIG5vbmUgdmlld3BvcnQgaXMgYWN0aXZlLlxuICAgICAqL1xuICAgIHJldHVybiBhY3RpdmU7XG59XG5cbmZ1bmN0aW9uIHdpZHRoKCkge1xuICAgIC8qXG4gICAgICogUmV0dXJucyB3aW5kb3cgd2lkdGgsIGV4Y2x1ZGluZyB0b29sYmFycyBhbmQgc2Nyb2xsYmFycy5cbiAgICAgKi9cbiAgICByZXR1cm4gd2luZG93LmlubmVyV2lkdGggfHwgd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbn1cblxuZnVuY3Rpb24gaGVpZ2h0KCkge1xuICAgIC8qXG4gICAgICogUmV0dXJucyB3aW5kb3cgaGVpZ2h0LCBleGNsdWRpbmcgdG9vbGJhcnMgYW5kIHNjcm9sbGJhcnMuXG4gICAgICovXG4gICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodCB8fCB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbn1cblxuZnVuY3Rpb24gaXNQb3J0cmFpdCgpIHtcbiAgICBpZiAoIWlzRW5hYmxlZCgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGNhbGwgYHZpZXdwb3J0LmVuYWJsZSgpYCBmaXJzdCB0byB1c2UgYHZpZXdwb3J0LmlzUG9ydHJhaXQoKWAnKTtcbiAgICByZXR1cm4gcG9ydHJhaXQ7XG59XG5cbmZ1bmN0aW9uIGlzTGFuZHNjYXBlKCkge1xuICAgIGlmICghaXNFbmFibGVkKCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgY2FsbCBgdmlld3BvcnQuZW5hYmxlKClgIGZpcnN0IHRvIHVzZSBgdmlld3BvcnQuaXNMYW5kc2NhcGUoKWAnKTtcbiAgICByZXR1cm4gIXBvcnRyYWl0O1xufVxuXG5mdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgX3VwZGF0ZSgpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBfdXBkYXRlKTtcbn1cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgX3VwZGF0ZSk7XG4gICAgYWN0aXZlID0gcG9ydHJhaXQgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIGFjdGl2ZSAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdfY2hhbmdlT3JpZW50YXRpb24nOiBfY2hhbmdlT3JpZW50YXRpb24sXG4gICAgJ19jaGFuZ2VWaWV3cG9ydCc6IF9jaGFuZ2VWaWV3cG9ydCxcbiAgICAnX2NoZWNrJzogX2NoZWNrLFxuICAgICdfdXBkYXRlJzogX3VwZGF0ZSxcbiAgICAnd2lkdGgnOiB3aWR0aCxcbiAgICAnaGVpZ2h0JzogaGVpZ2h0LFxuICAgICdpcyc6IGlzLFxuICAgICdnZXQnOiBnZXQsXG4gICAgJ2lzUG9ydHJhaXQnOiBpc1BvcnRyYWl0LFxuICAgICdpc0xhbmRzY2FwZSc6IGlzTGFuZHNjYXBlLFxuICAgICdvbkNoYW5nZSc6IG9uQ2hhbmdlLFxuICAgICdlbmFibGUnOiBlbmFibGUsXG4gICAgJ2Rpc2FibGUnOiBkaXNhYmxlLFxuICAgICdpc0VuYWJsZWQnOiBpc0VuYWJsZWRcbn1cbiIsIi8qKlxuICogQXV0b3BsYXkgUGx1Z2luXG4gKiBAdmVyc2lvbiAyLjEuMFxuICogQGF1dGhvciBCYXJ0b3N6IFdvamNpZWNob3dza2lcbiAqIEBhdXRob3IgQXJ0dXMgS29sYW5vd3NraVxuICogQGF1dGhvciBEYXZpZCBEZXV0c2NoXG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqL1xuOyhmdW5jdGlvbigkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcblxuXHQvKipcblx0ICogQ3JlYXRlcyB0aGUgYXV0b3BsYXkgcGx1Z2luLlxuXHQgKiBAY2xhc3MgVGhlIEF1dG9wbGF5IFBsdWdpblxuXHQgKiBAcGFyYW0ge093bH0gc2NvcGUgLSBUaGUgT3dsIENhcm91c2VsXG5cdCAqL1xuXHR2YXIgQXV0b3BsYXkgPSBmdW5jdGlvbihjYXJvdXNlbCkge1xuXHRcdC8qKlxuXHRcdCAqIFJlZmVyZW5jZSB0byB0aGUgY29yZS5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge093bH1cblx0XHQgKi9cblx0XHR0aGlzLl9jb3JlID0gY2Fyb3VzZWw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYXV0b3BsYXkgdGltZW91dC5cblx0XHQgKiBAdHlwZSB7VGltZW91dH1cblx0XHQgKi9cblx0XHR0aGlzLl90aW1lb3V0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGVuZXZlciB0aGUgYXV0b3BsYXkgaXMgcGF1c2VkLlxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogQWxsIGV2ZW50IGhhbmRsZXJzLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMuX2hhbmRsZXJzID0ge1xuXHRcdFx0J2NoYW5nZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XG5cdFx0XHRcdGlmIChlLm5hbWVzcGFjZSAmJiBlLnByb3BlcnR5Lm5hbWUgPT09ICdzZXR0aW5ncycpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheSkge1xuXHRcdFx0XHRcdFx0dGhpcy5wbGF5KCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuc3RvcCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChlLm5hbWVzcGFjZSAmJiBlLnByb3BlcnR5Lm5hbWUgPT09ICdwb3NpdGlvbicpIHtcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdwbGF5PycsIGUpO1xuXHRcdFx0XHRcdGlmICh0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5KSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zZXRBdXRvUGxheUludGVydmFsKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LCB0aGlzKSxcblx0XHRcdCdpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXkpIHtcblx0XHRcdFx0XHR0aGlzLnBsYXkoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcyksXG5cdFx0XHQncGxheS5vd2wuYXV0b3BsYXknOiAkLnByb3h5KGZ1bmN0aW9uKGUsIHQsIHMpIHtcblx0XHRcdFx0aWYgKGUubmFtZXNwYWNlKSB7XG5cdFx0XHRcdFx0dGhpcy5wbGF5KHQsIHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0aGlzKSxcblx0XHRcdCdzdG9wLm93bC5hdXRvcGxheSc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRpZiAoZS5uYW1lc3BhY2UpIHtcblx0XHRcdFx0XHR0aGlzLnN0b3AoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcyksXG5cdFx0XHQnbW91c2VvdmVyLm93bC5hdXRvcGxheSc6ICQucHJveHkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5SG92ZXJQYXVzZSAmJiB0aGlzLl9jb3JlLmlzKCdyb3RhdGluZycpKSB7XG5cdFx0XHRcdFx0dGhpcy5wYXVzZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0aGlzKSxcblx0XHRcdCdtb3VzZWxlYXZlLm93bC5hdXRvcGxheSc6ICQucHJveHkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5SG92ZXJQYXVzZSAmJiB0aGlzLl9jb3JlLmlzKCdyb3RhdGluZycpKSB7XG5cdFx0XHRcdFx0dGhpcy5wbGF5KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMpLFxuXHRcdFx0J3RvdWNoc3RhcnQub3dsLmNvcmUnOiAkLnByb3h5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAodGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheUhvdmVyUGF1c2UgJiYgdGhpcy5fY29yZS5pcygncm90YXRpbmcnKSkge1xuXHRcdFx0XHRcdHRoaXMucGF1c2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcyksXG5cdFx0XHQndG91Y2hlbmQub3dsLmNvcmUnOiAkLnByb3h5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAodGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheUhvdmVyUGF1c2UpIHtcblx0XHRcdFx0XHR0aGlzLnBsYXkoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcylcblx0XHR9O1xuXG5cdFx0Ly8gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnNcblx0XHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcblxuXHRcdC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcblx0XHR0aGlzLl9jb3JlLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQXV0b3BsYXkuRGVmYXVsdHMsIHRoaXMuX2NvcmUub3B0aW9ucyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERlZmF1bHQgb3B0aW9ucy5cblx0ICogQHB1YmxpY1xuXHQgKi9cblx0QXV0b3BsYXkuRGVmYXVsdHMgPSB7XG5cdFx0YXV0b3BsYXk6IGZhbHNlLFxuXHRcdGF1dG9wbGF5VGltZW91dDogNTAwMCxcblx0XHRhdXRvcGxheUhvdmVyUGF1c2U6IGZhbHNlLFxuXHRcdGF1dG9wbGF5U3BlZWQ6IGZhbHNlXG5cdH07XG5cblx0LyoqXG5cdCAqIFN0YXJ0cyB0aGUgYXV0b3BsYXkuXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lb3V0XSAtIFRoZSBpbnRlcnZhbCBiZWZvcmUgdGhlIG5leHQgYW5pbWF0aW9uIHN0YXJ0cy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZF0gLSBUaGUgYW5pbWF0aW9uIHNwZWVkIGZvciB0aGUgYW5pbWF0aW9ucy5cblx0ICovXG5cdEF1dG9wbGF5LnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24odGltZW91dCwgc3BlZWQpIHtcblx0XHR0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblxuXHRcdGlmICh0aGlzLl9jb3JlLmlzKCdyb3RhdGluZycpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fY29yZS5lbnRlcigncm90YXRpbmcnKTtcblxuXHRcdHRoaXMuX3NldEF1dG9QbGF5SW50ZXJ2YWwoKTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0cyBhIG5ldyB0aW1lb3V0XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZW91dF0gLSBUaGUgaW50ZXJ2YWwgYmVmb3JlIHRoZSBuZXh0IGFuaW1hdGlvbiBzdGFydHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIC0gVGhlIGFuaW1hdGlvbiBzcGVlZCBmb3IgdGhlIGFuaW1hdGlvbnMuXG5cdCAqIEByZXR1cm4ge1RpbWVvdXR9XG5cdCAqL1xuXHRBdXRvcGxheS5wcm90b3R5cGUuX2dldE5leHRUaW1lb3V0ID0gZnVuY3Rpb24odGltZW91dCwgc3BlZWQpIHtcblx0XHRpZiAoIHRoaXMuX3RpbWVvdXQgKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuXHRcdH1cblx0XHRyZXR1cm4gd2luZG93LnNldFRpbWVvdXQoJC5wcm94eShmdW5jdGlvbigpIHtcblx0XHRcdGlmICh0aGlzLl9wYXVzZWQgfHwgdGhpcy5fY29yZS5pcygnYnVzeScpIHx8IHRoaXMuX2NvcmUuaXMoJ2ludGVyYWN0aW5nJykgfHwgZG9jdW1lbnQuaGlkZGVuKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2NvcmUubmV4dChzcGVlZCB8fCB0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5U3BlZWQpO1xuXHRcdH0sIHRoaXMpLCB0aW1lb3V0IHx8IHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXlUaW1lb3V0KTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyBhdXRvcGxheSBpbiBtb3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRBdXRvcGxheS5wcm90b3R5cGUuX3NldEF1dG9QbGF5SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl90aW1lb3V0ID0gdGhpcy5fZ2V0TmV4dFRpbWVvdXQoKTtcblx0fTtcblxuXHQvKipcblx0ICogU3RvcHMgdGhlIGF1dG9wbGF5LlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRBdXRvcGxheS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fY29yZS5pcygncm90YXRpbmcnKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG5cdFx0dGhpcy5fY29yZS5sZWF2ZSgncm90YXRpbmcnKTtcblx0fTtcblxuXHQvKipcblx0ICogU3RvcHMgdGhlIGF1dG9wbGF5LlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRBdXRvcGxheS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX2NvcmUuaXMoJ3JvdGF0aW5nJykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9wYXVzZWQgPSB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxuXHQgKi9cblx0QXV0b3BsYXkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGFuZGxlciwgcHJvcGVydHk7XG5cblx0XHR0aGlzLnN0b3AoKTtcblxuXHRcdGZvciAoaGFuZGxlciBpbiB0aGlzLl9oYW5kbGVycykge1xuXHRcdFx0dGhpcy5fY29yZS4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5faGFuZGxlcnNbaGFuZGxlcl0pO1xuXHRcdH1cblx0XHRmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XG5cdFx0XHR0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gJ2Z1bmN0aW9uJyAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcblx0XHR9XG5cdH07XG5cblx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLmF1dG9wbGF5ID0gQXV0b3BsYXk7XG5cbn0pKHdpbmRvdy5aZXB0byB8fCB3aW5kb3cualF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcbiIsIi8qKlxuICogT3dsIGNhcm91c2VsXG4gKiBAdmVyc2lvbiAyLjEuNlxuICogQGF1dGhvciBCYXJ0b3N6IFdvamNpZWNob3dza2lcbiAqIEBhdXRob3IgRGF2aWQgRGV1dHNjaFxuICogQGxpY2Vuc2UgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBAdG9kbyBMYXp5IExvYWQgSWNvblxuICogQHRvZG8gcHJldmVudCBhbmltYXRpb25lbmQgYnVibGluZ1xuICogQHRvZG8gaXRlbXNTY2FsZVVwXG4gKiBAdG9kbyBUZXN0IFplcHRvXG4gKiBAdG9kbyBzdGFnZVBhZGRpbmcgY2FsY3VsYXRlIHdyb25nIGFjdGl2ZSBjbGFzc2VzXG4gKi9cbjsoZnVuY3Rpb24oJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBjYXJvdXNlbC5cblx0ICogQGNsYXNzIFRoZSBPd2wgQ2Fyb3VzZWwuXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudHxqUXVlcnl9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byBjcmVhdGUgdGhlIGNhcm91c2VsIGZvci5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zXG5cdCAqL1xuXHRmdW5jdGlvbiBPd2woZWxlbWVudCwgb3B0aW9ucykge1xuXG5cdFx0LyoqXG5cdFx0ICogQ3VycmVudCBzZXR0aW5ncyBmb3IgdGhlIGNhcm91c2VsLlxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHR0aGlzLnNldHRpbmdzID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEN1cnJlbnQgb3B0aW9ucyBzZXQgYnkgdGhlIGNhbGxlciBpbmNsdWRpbmcgZGVmYXVsdHMuXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBPd2wuRGVmYXVsdHMsIG9wdGlvbnMpO1xuXG5cdFx0LyoqXG5cdFx0ICogUGx1Z2luIGVsZW1lbnQuXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdHRoaXMuJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuXG5cdFx0LyoqXG5cdFx0ICogUHJveGllZCBldmVudCBoYW5kbGVycy5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5faGFuZGxlcnMgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIFJlZmVyZW5jZXMgdG8gdGhlIHJ1bm5pbmcgcGx1Z2lucyBvZiB0aGlzIGNhcm91c2VsLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9wbHVnaW5zID0ge307XG5cblx0XHQvKipcblx0XHQgKiBDdXJyZW50bHkgc3VwcHJlc3NlZCBldmVudHMgdG8gcHJldmVudCB0aGVtIGZyb20gYmVlaW5nIHJldHJpZ2dlcmVkLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9zdXByZXNzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBBYnNvbHV0ZSBjdXJyZW50IHBvc2l0aW9uLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9jdXJyZW50ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuaW1hdGlvbiBzcGVlZCBpbiBtaWxsaXNlY29uZHMuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3NwZWVkID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIENvb3JkaW5hdGVzIG9mIGFsbCBpdGVtcyBpbiBwaXhlbC5cblx0XHQgKiBAdG9kbyBUaGUgbmFtZSBvZiB0aGlzIG1lbWJlciBpcyBtaXNzbGVhZGluZy5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fY29vcmRpbmF0ZXMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEN1cnJlbnQgYnJlYWtwb2ludC5cblx0XHQgKiBAdG9kbyBSZWFsIG1lZGlhIHF1ZXJpZXMgd291bGQgYmUgbmljZS5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fYnJlYWtwb2ludCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBDdXJyZW50IHdpZHRoIG9mIHRoZSBwbHVnaW4gZWxlbWVudC5cblx0XHQgKi9cblx0XHR0aGlzLl93aWR0aCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBBbGwgcmVhbCBpdGVtcy5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5faXRlbXMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEFsbCBjbG9uZWQgaXRlbXMuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX2Nsb25lcyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogTWVyZ2UgdmFsdWVzIG9mIGFsbCBpdGVtcy5cblx0XHQgKiBAdG9kbyBNYXliZSB0aGlzIGNvdWxkIGJlIHBhcnQgb2YgYSBwbHVnaW4uXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX21lcmdlcnMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIFdpZHRocyBvZiBhbGwgaXRlbXMuXG5cdFx0ICovXG5cdFx0dGhpcy5fd2lkdGhzID0gW107XG5cblx0XHQvKipcblx0XHQgKiBJbnZhbGlkYXRlZCBwYXJ0cyB3aXRoaW4gdGhlIHVwZGF0ZSBwcm9jZXNzLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9pbnZhbGlkYXRlZCA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogT3JkZXJlZCBsaXN0IG9mIHdvcmtlcnMgZm9yIHRoZSB1cGRhdGUgcHJvY2Vzcy5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fcGlwZSA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogQ3VycmVudCBzdGF0ZSBpbmZvcm1hdGlvbiBmb3IgdGhlIGRyYWcgb3BlcmF0aW9uLlxuXHRcdCAqIEB0b2RvICMyNjFcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fZHJhZyA9IHtcblx0XHRcdHRpbWU6IG51bGwsXG5cdFx0XHR0YXJnZXQ6IG51bGwsXG5cdFx0XHRwb2ludGVyOiBudWxsLFxuXHRcdFx0c3RhZ2U6IHtcblx0XHRcdFx0c3RhcnQ6IG51bGwsXG5cdFx0XHRcdGN1cnJlbnQ6IG51bGxcblx0XHRcdH0sXG5cdFx0XHRkaXJlY3Rpb246IG51bGxcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQ3VycmVudCBzdGF0ZSBpbmZvcm1hdGlvbiBhbmQgdGhlaXIgdGFncy5cblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9zdGF0ZXMgPSB7XG5cdFx0XHRjdXJyZW50OiB7fSxcblx0XHRcdHRhZ3M6IHtcblx0XHRcdFx0J2luaXRpYWxpemluZyc6IFsgJ2J1c3knIF0sXG5cdFx0XHRcdCdhbmltYXRpbmcnOiBbICdidXN5JyBdLFxuXHRcdFx0XHQnZHJhZ2dpbmcnOiBbICdpbnRlcmFjdGluZycgXVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQkLmVhY2goWyAnb25SZXNpemUnLCAnb25UaHJvdHRsZWRSZXNpemUnIF0sICQucHJveHkoZnVuY3Rpb24oaSwgaGFuZGxlcikge1xuXHRcdFx0dGhpcy5faGFuZGxlcnNbaGFuZGxlcl0gPSAkLnByb3h5KHRoaXNbaGFuZGxlcl0sIHRoaXMpO1xuXHRcdH0sIHRoaXMpKTtcblxuXHRcdCQuZWFjaChPd2wuUGx1Z2lucywgJC5wcm94eShmdW5jdGlvbihrZXksIHBsdWdpbikge1xuXHRcdFx0dGhpcy5fcGx1Z2luc1trZXkuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSldXG5cdFx0XHRcdD0gbmV3IHBsdWdpbih0aGlzKTtcblx0XHR9LCB0aGlzKSk7XG5cblx0XHQkLmVhY2goT3dsLldvcmtlcnMsICQucHJveHkoZnVuY3Rpb24ocHJpb3JpdHksIHdvcmtlcikge1xuXHRcdFx0dGhpcy5fcGlwZS5wdXNoKHtcblx0XHRcdFx0J2ZpbHRlcic6IHdvcmtlci5maWx0ZXIsXG5cdFx0XHRcdCdydW4nOiAkLnByb3h5KHdvcmtlci5ydW4sIHRoaXMpXG5cdFx0XHR9KTtcblx0XHR9LCB0aGlzKSk7XG5cblx0XHR0aGlzLnNldHVwKCk7XG5cdFx0dGhpcy5pbml0aWFsaXplKCk7XG5cdH1cblxuXHQvKipcblx0ICogRGVmYXVsdCBvcHRpb25zIGZvciB0aGUgY2Fyb3VzZWwuXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdE93bC5EZWZhdWx0cyA9IHtcblx0XHRpdGVtczogMyxcblx0XHRsb29wOiBmYWxzZSxcblx0XHRjZW50ZXI6IGZhbHNlLFxuXHRcdHJld2luZDogZmFsc2UsXG5cblx0XHRtb3VzZURyYWc6IHRydWUsXG5cdFx0dG91Y2hEcmFnOiB0cnVlLFxuXHRcdHB1bGxEcmFnOiB0cnVlLFxuXHRcdGZyZWVEcmFnOiBmYWxzZSxcblxuXHRcdG1hcmdpbjogMCxcblx0XHRzdGFnZVBhZGRpbmc6IDAsXG5cblx0XHRtZXJnZTogZmFsc2UsXG5cdFx0bWVyZ2VGaXQ6IHRydWUsXG5cdFx0YXV0b1dpZHRoOiBmYWxzZSxcblxuXHRcdHN0YXJ0UG9zaXRpb246IDAsXG5cdFx0cnRsOiBmYWxzZSxcblxuXHRcdHNtYXJ0U3BlZWQ6IDI1MCxcblx0XHRmbHVpZFNwZWVkOiBmYWxzZSxcblx0XHRkcmFnRW5kU3BlZWQ6IGZhbHNlLFxuXG5cdFx0cmVzcG9uc2l2ZToge30sXG5cdFx0cmVzcG9uc2l2ZVJlZnJlc2hSYXRlOiAyMDAsXG5cdFx0cmVzcG9uc2l2ZUJhc2VFbGVtZW50OiB3aW5kb3csXG5cblx0XHRmYWxsYmFja0Vhc2luZzogJ3N3aW5nJyxcblxuXHRcdGluZm86IGZhbHNlLFxuXG5cdFx0bmVzdGVkSXRlbVNlbGVjdG9yOiBmYWxzZSxcblx0XHRpdGVtRWxlbWVudDogJ2RpdicsXG5cdFx0c3RhZ2VFbGVtZW50OiAnZGl2JyxcblxuXHRcdHJlZnJlc2hDbGFzczogJ293bC1yZWZyZXNoJyxcblx0XHRsb2FkZWRDbGFzczogJ293bC1sb2FkZWQnLFxuXHRcdGxvYWRpbmdDbGFzczogJ293bC1sb2FkaW5nJyxcblx0XHRydGxDbGFzczogJ293bC1ydGwnLFxuXHRcdHJlc3BvbnNpdmVDbGFzczogJ293bC1yZXNwb25zaXZlJyxcblx0XHRkcmFnQ2xhc3M6ICdvd2wtZHJhZycsXG5cdFx0aXRlbUNsYXNzOiAnb3dsLWl0ZW0nLFxuXHRcdHN0YWdlQ2xhc3M6ICdvd2wtc3RhZ2UnLFxuXHRcdHN0YWdlT3V0ZXJDbGFzczogJ293bC1zdGFnZS1vdXRlcicsXG5cdFx0Z3JhYkNsYXNzOiAnb3dsLWdyYWInXG5cdH07XG5cblx0LyoqXG5cdCAqIEVudW1lcmF0aW9uIGZvciB3aWR0aC5cblx0ICogQHB1YmxpY1xuXHQgKiBAcmVhZG9ubHlcblx0ICogQGVudW0ge1N0cmluZ31cblx0ICovXG5cdE93bC5XaWR0aCA9IHtcblx0XHREZWZhdWx0OiAnZGVmYXVsdCcsXG5cdFx0SW5uZXI6ICdpbm5lcicsXG5cdFx0T3V0ZXI6ICdvdXRlcidcblx0fTtcblxuXHQvKipcblx0ICogRW51bWVyYXRpb24gZm9yIHR5cGVzLlxuXHQgKiBAcHVibGljXG5cdCAqIEByZWFkb25seVxuXHQgKiBAZW51bSB7U3RyaW5nfVxuXHQgKi9cblx0T3dsLlR5cGUgPSB7XG5cdFx0RXZlbnQ6ICdldmVudCcsXG5cdFx0U3RhdGU6ICdzdGF0ZSdcblx0fTtcblxuXHQvKipcblx0ICogQ29udGFpbnMgYWxsIHJlZ2lzdGVyZWQgcGx1Z2lucy5cblx0ICogQHB1YmxpY1xuXHQgKi9cblx0T3dsLlBsdWdpbnMgPSB7fTtcblxuXHQvKipcblx0ICogTGlzdCBvZiB3b3JrZXJzIGludm9sdmVkIGluIHRoZSB1cGRhdGUgcHJvY2Vzcy5cblx0ICovXG5cdE93bC5Xb3JrZXJzID0gWyB7XG5cdFx0ZmlsdGVyOiBbICd3aWR0aCcsICdzZXR0aW5ncycgXSxcblx0XHRydW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fd2lkdGggPSB0aGlzLiRlbGVtZW50LndpZHRoKCk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0ZmlsdGVyOiBbICd3aWR0aCcsICdpdGVtcycsICdzZXR0aW5ncycgXSxcblx0XHRydW46IGZ1bmN0aW9uKGNhY2hlKSB7XG5cdFx0XHRjYWNoZS5jdXJyZW50ID0gdGhpcy5faXRlbXMgJiYgdGhpcy5faXRlbXNbdGhpcy5yZWxhdGl2ZSh0aGlzLl9jdXJyZW50KV07XG5cdFx0fVxuXHR9LCB7XG5cdFx0ZmlsdGVyOiBbICdpdGVtcycsICdzZXR0aW5ncycgXSxcblx0XHRydW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy4kc3RhZ2UuY2hpbGRyZW4oJy5jbG9uZWQnKS5yZW1vdmUoKTtcblx0XHR9XG5cdH0sIHtcblx0XHRmaWx0ZXI6IFsgJ3dpZHRoJywgJ2l0ZW1zJywgJ3NldHRpbmdzJyBdLFxuXHRcdHJ1bjogZnVuY3Rpb24oY2FjaGUpIHtcblx0XHRcdHZhciBtYXJnaW4gPSB0aGlzLnNldHRpbmdzLm1hcmdpbiB8fCAnJyxcblx0XHRcdFx0Z3JpZCA9ICF0aGlzLnNldHRpbmdzLmF1dG9XaWR0aCxcblx0XHRcdFx0cnRsID0gdGhpcy5zZXR0aW5ncy5ydGwsXG5cdFx0XHRcdGNzcyA9IHtcblx0XHRcdFx0XHQnd2lkdGgnOiAnYXV0bycsXG5cdFx0XHRcdFx0J21hcmdpbi1sZWZ0JzogcnRsID8gbWFyZ2luIDogJycsXG5cdFx0XHRcdFx0J21hcmdpbi1yaWdodCc6IHJ0bCA/ICcnIDogbWFyZ2luXG5cdFx0XHRcdH07XG5cblx0XHRcdCFncmlkICYmIHRoaXMuJHN0YWdlLmNoaWxkcmVuKCkuY3NzKGNzcyk7XG5cblx0XHRcdGNhY2hlLmNzcyA9IGNzcztcblx0XHR9XG5cdH0sIHtcblx0XHRmaWx0ZXI6IFsgJ3dpZHRoJywgJ2l0ZW1zJywgJ3NldHRpbmdzJyBdLFxuXHRcdHJ1bjogZnVuY3Rpb24oY2FjaGUpIHtcblx0XHRcdHZhciB3aWR0aCA9ICh0aGlzLndpZHRoKCkgLyB0aGlzLnNldHRpbmdzLml0ZW1zKS50b0ZpeGVkKDMpIC0gdGhpcy5zZXR0aW5ncy5tYXJnaW4sXG5cdFx0XHRcdG1lcmdlID0gbnVsbCxcblx0XHRcdFx0aXRlcmF0b3IgPSB0aGlzLl9pdGVtcy5sZW5ndGgsXG5cdFx0XHRcdGdyaWQgPSAhdGhpcy5zZXR0aW5ncy5hdXRvV2lkdGgsXG5cdFx0XHRcdHdpZHRocyA9IFtdO1xuXG5cdFx0XHRjYWNoZS5pdGVtcyA9IHtcblx0XHRcdFx0bWVyZ2U6IGZhbHNlLFxuXHRcdFx0XHR3aWR0aDogd2lkdGhcblx0XHRcdH07XG5cblx0XHRcdHdoaWxlIChpdGVyYXRvci0tKSB7XG5cdFx0XHRcdG1lcmdlID0gdGhpcy5fbWVyZ2Vyc1tpdGVyYXRvcl07XG5cdFx0XHRcdG1lcmdlID0gdGhpcy5zZXR0aW5ncy5tZXJnZUZpdCAmJiBNYXRoLm1pbihtZXJnZSwgdGhpcy5zZXR0aW5ncy5pdGVtcykgfHwgbWVyZ2U7XG5cblx0XHRcdFx0Y2FjaGUuaXRlbXMubWVyZ2UgPSBtZXJnZSA+IDEgfHwgY2FjaGUuaXRlbXMubWVyZ2U7XG5cblx0XHRcdFx0d2lkdGhzW2l0ZXJhdG9yXSA9ICFncmlkID8gdGhpcy5faXRlbXNbaXRlcmF0b3JdLndpZHRoKCkgOiB3aWR0aCAqIG1lcmdlO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl93aWR0aHMgPSB3aWR0aHM7XG5cdFx0fVxuXHR9LCB7XG5cdFx0ZmlsdGVyOiBbICdpdGVtcycsICdzZXR0aW5ncycgXSxcblx0XHRydW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNsb25lcyA9IFtdLFxuXHRcdFx0XHRpdGVtcyA9IHRoaXMuX2l0ZW1zLFxuXHRcdFx0XHRzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3MsXG5cdFx0XHRcdC8vIFRPRE86IFNob3VsZCBiZSBjb21wdXRlZCBmcm9tIG51bWJlciBvZiBtaW4gd2lkdGggaXRlbXMgaW4gc3RhZ2Vcblx0XHRcdFx0dmlldyA9IE1hdGgubWF4KHNldHRpbmdzLml0ZW1zICogMiwgNCksXG5cdFx0XHRcdHNpemUgPSBNYXRoLmNlaWwoaXRlbXMubGVuZ3RoIC8gMikgKiAyLFxuXHRcdFx0XHRyZXBlYXQgPSBzZXR0aW5ncy5sb29wICYmIGl0ZW1zLmxlbmd0aCA/IHNldHRpbmdzLnJld2luZCA/IHZpZXcgOiBNYXRoLm1heCh2aWV3LCBzaXplKSA6IDAsXG5cdFx0XHRcdGFwcGVuZCA9ICcnLFxuXHRcdFx0XHRwcmVwZW5kID0gJyc7XG5cblx0XHRcdHJlcGVhdCAvPSAyO1xuXG5cdFx0XHR3aGlsZSAocmVwZWF0LS0pIHtcblx0XHRcdFx0Ly8gU3dpdGNoIHRvIG9ubHkgdXNpbmcgYXBwZW5kZWQgY2xvbmVzXG5cdFx0XHRcdGNsb25lcy5wdXNoKHRoaXMubm9ybWFsaXplKGNsb25lcy5sZW5ndGggLyAyLCB0cnVlKSk7XG5cdFx0XHRcdGFwcGVuZCA9IGFwcGVuZCArIGl0ZW1zW2Nsb25lc1tjbG9uZXMubGVuZ3RoIC0gMV1dWzBdLm91dGVySFRNTDtcblx0XHRcdFx0Y2xvbmVzLnB1c2godGhpcy5ub3JtYWxpemUoaXRlbXMubGVuZ3RoIC0gMSAtIChjbG9uZXMubGVuZ3RoIC0gMSkgLyAyLCB0cnVlKSk7XG5cdFx0XHRcdHByZXBlbmQgPSBpdGVtc1tjbG9uZXNbY2xvbmVzLmxlbmd0aCAtIDFdXVswXS5vdXRlckhUTUwgKyBwcmVwZW5kO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9jbG9uZXMgPSBjbG9uZXM7XG5cblx0XHRcdCQoYXBwZW5kKS5hZGRDbGFzcygnY2xvbmVkJykuYXBwZW5kVG8odGhpcy4kc3RhZ2UpO1xuXHRcdFx0JChwcmVwZW5kKS5hZGRDbGFzcygnY2xvbmVkJykucHJlcGVuZFRvKHRoaXMuJHN0YWdlKTtcblx0XHR9XG5cdH0sIHtcblx0XHRmaWx0ZXI6IFsgJ3dpZHRoJywgJ2l0ZW1zJywgJ3NldHRpbmdzJyBdLFxuXHRcdHJ1bjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcnRsID0gdGhpcy5zZXR0aW5ncy5ydGwgPyAxIDogLTEsXG5cdFx0XHRcdHNpemUgPSB0aGlzLl9jbG9uZXMubGVuZ3RoICsgdGhpcy5faXRlbXMubGVuZ3RoLFxuXHRcdFx0XHRpdGVyYXRvciA9IC0xLFxuXHRcdFx0XHRwcmV2aW91cyA9IDAsXG5cdFx0XHRcdGN1cnJlbnQgPSAwLFxuXHRcdFx0XHRjb29yZGluYXRlcyA9IFtdO1xuXG5cdFx0XHR3aGlsZSAoKytpdGVyYXRvciA8IHNpemUpIHtcblx0XHRcdFx0cHJldmlvdXMgPSBjb29yZGluYXRlc1tpdGVyYXRvciAtIDFdIHx8IDA7XG5cdFx0XHRcdGN1cnJlbnQgPSB0aGlzLl93aWR0aHNbdGhpcy5yZWxhdGl2ZShpdGVyYXRvcildICsgdGhpcy5zZXR0aW5ncy5tYXJnaW47XG5cdFx0XHRcdGNvb3JkaW5hdGVzLnB1c2gocHJldmlvdXMgKyBjdXJyZW50ICogcnRsKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fY29vcmRpbmF0ZXMgPSBjb29yZGluYXRlcztcblx0XHR9XG5cdH0sIHtcblx0XHRmaWx0ZXI6IFsgJ3dpZHRoJywgJ2l0ZW1zJywgJ3NldHRpbmdzJyBdLFxuXHRcdHJ1bjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcGFkZGluZyA9IHRoaXMuc2V0dGluZ3Muc3RhZ2VQYWRkaW5nLFxuXHRcdFx0XHRjb29yZGluYXRlcyA9IHRoaXMuX2Nvb3JkaW5hdGVzLFxuXHRcdFx0XHRjc3MgPSB7XG5cdFx0XHRcdFx0J3dpZHRoJzogTWF0aC5jZWlsKE1hdGguYWJzKGNvb3JkaW5hdGVzW2Nvb3JkaW5hdGVzLmxlbmd0aCAtIDFdKSkgKyBwYWRkaW5nICogMixcblx0XHRcdFx0XHQncGFkZGluZy1sZWZ0JzogcGFkZGluZyB8fCAnJyxcblx0XHRcdFx0XHQncGFkZGluZy1yaWdodCc6IHBhZGRpbmcgfHwgJydcblx0XHRcdFx0fTtcblxuXHRcdFx0dGhpcy4kc3RhZ2UuY3NzKGNzcyk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0ZmlsdGVyOiBbICd3aWR0aCcsICdpdGVtcycsICdzZXR0aW5ncycgXSxcblx0XHRydW46IGZ1bmN0aW9uKGNhY2hlKSB7XG5cdFx0XHR2YXIgaXRlcmF0b3IgPSB0aGlzLl9jb29yZGluYXRlcy5sZW5ndGgsXG5cdFx0XHRcdGdyaWQgPSAhdGhpcy5zZXR0aW5ncy5hdXRvV2lkdGgsXG5cdFx0XHRcdGl0ZW1zID0gdGhpcy4kc3RhZ2UuY2hpbGRyZW4oKTtcblxuXHRcdFx0aWYgKGdyaWQgJiYgY2FjaGUuaXRlbXMubWVyZ2UpIHtcblx0XHRcdFx0d2hpbGUgKGl0ZXJhdG9yLS0pIHtcblx0XHRcdFx0XHRjYWNoZS5jc3Mud2lkdGggPSB0aGlzLl93aWR0aHNbdGhpcy5yZWxhdGl2ZShpdGVyYXRvcildO1xuXHRcdFx0XHRcdGl0ZW1zLmVxKGl0ZXJhdG9yKS5jc3MoY2FjaGUuY3NzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChncmlkKSB7XG5cdFx0XHRcdGNhY2hlLmNzcy53aWR0aCA9IGNhY2hlLml0ZW1zLndpZHRoO1xuXHRcdFx0XHRpdGVtcy5jc3MoY2FjaGUuY3NzKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sIHtcblx0XHRmaWx0ZXI6IFsgJ2l0ZW1zJyBdLFxuXHRcdHJ1bjogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9jb29yZGluYXRlcy5sZW5ndGggPCAxICYmIHRoaXMuJHN0YWdlLnJlbW92ZUF0dHIoJ3N0eWxlJyk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0ZmlsdGVyOiBbICd3aWR0aCcsICdpdGVtcycsICdzZXR0aW5ncycgXSxcblx0XHRydW46IGZ1bmN0aW9uKGNhY2hlKSB7XG5cdFx0XHRjYWNoZS5jdXJyZW50ID0gY2FjaGUuY3VycmVudCA/IHRoaXMuJHN0YWdlLmNoaWxkcmVuKCkuaW5kZXgoY2FjaGUuY3VycmVudCkgOiAwO1xuXHRcdFx0Y2FjaGUuY3VycmVudCA9IE1hdGgubWF4KHRoaXMubWluaW11bSgpLCBNYXRoLm1pbih0aGlzLm1heGltdW0oKSwgY2FjaGUuY3VycmVudCkpO1xuXHRcdFx0dGhpcy5yZXNldChjYWNoZS5jdXJyZW50KTtcblx0XHR9XG5cdH0sIHtcblx0XHRmaWx0ZXI6IFsgJ3Bvc2l0aW9uJyBdLFxuXHRcdHJ1bjogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmFuaW1hdGUodGhpcy5jb29yZGluYXRlcyh0aGlzLl9jdXJyZW50KSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0ZmlsdGVyOiBbICd3aWR0aCcsICdwb3NpdGlvbicsICdpdGVtcycsICdzZXR0aW5ncycgXSxcblx0XHRydW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHJ0bCA9IHRoaXMuc2V0dGluZ3MucnRsID8gMSA6IC0xLFxuXHRcdFx0XHRwYWRkaW5nID0gdGhpcy5zZXR0aW5ncy5zdGFnZVBhZGRpbmcgKiAyLFxuXHRcdFx0XHRiZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXModGhpcy5jdXJyZW50KCkpICsgcGFkZGluZyxcblx0XHRcdFx0ZW5kID0gYmVnaW4gKyB0aGlzLndpZHRoKCkgKiBydGwsXG5cdFx0XHRcdGlubmVyLCBvdXRlciwgbWF0Y2hlcyA9IFtdLCBpLCBuO1xuXG5cdFx0XHRmb3IgKGkgPSAwLCBuID0gdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdGlubmVyID0gdGhpcy5fY29vcmRpbmF0ZXNbaSAtIDFdIHx8IDA7XG5cdFx0XHRcdG91dGVyID0gTWF0aC5hYnModGhpcy5fY29vcmRpbmF0ZXNbaV0pICsgcGFkZGluZyAqIHJ0bDtcblxuXHRcdFx0XHRpZiAoKHRoaXMub3AoaW5uZXIsICc8PScsIGJlZ2luKSAmJiAodGhpcy5vcChpbm5lciwgJz4nLCBlbmQpKSlcblx0XHRcdFx0XHR8fCAodGhpcy5vcChvdXRlciwgJzwnLCBiZWdpbikgJiYgdGhpcy5vcChvdXRlciwgJz4nLCBlbmQpKSkge1xuXHRcdFx0XHRcdG1hdGNoZXMucHVzaChpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLiRzdGFnZS5jaGlsZHJlbignLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcblx0XHRcdHRoaXMuJHN0YWdlLmNoaWxkcmVuKCc6ZXEoJyArIG1hdGNoZXMuam9pbignKSwgOmVxKCcpICsgJyknKS5hZGRDbGFzcygnYWN0aXZlJyk7XG5cblx0XHRcdGlmICh0aGlzLnNldHRpbmdzLmNlbnRlcikge1xuXHRcdFx0XHR0aGlzLiRzdGFnZS5jaGlsZHJlbignLmNlbnRlcicpLnJlbW92ZUNsYXNzKCdjZW50ZXInKTtcblx0XHRcdFx0dGhpcy4kc3RhZ2UuY2hpbGRyZW4oKS5lcSh0aGlzLmN1cnJlbnQoKSkuYWRkQ2xhc3MoJ2NlbnRlcicpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBdO1xuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyB0aGUgY2Fyb3VzZWwuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdE93bC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZW50ZXIoJ2luaXRpYWxpemluZycpO1xuXHRcdHRoaXMudHJpZ2dlcignaW5pdGlhbGl6ZScpO1xuXG5cdFx0dGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLnNldHRpbmdzLnJ0bENsYXNzLCB0aGlzLnNldHRpbmdzLnJ0bCk7XG5cblx0XHRpZiAodGhpcy5zZXR0aW5ncy5hdXRvV2lkdGggJiYgIXRoaXMuaXMoJ3ByZS1sb2FkaW5nJykpIHtcblx0XHRcdHZhciBpbWdzLCBuZXN0ZWRTZWxlY3Rvciwgd2lkdGg7XG5cdFx0XHRpbWdzID0gdGhpcy4kZWxlbWVudC5maW5kKCdpbWcnKTtcblx0XHRcdG5lc3RlZFNlbGVjdG9yID0gdGhpcy5zZXR0aW5ncy5uZXN0ZWRJdGVtU2VsZWN0b3IgPyAnLicgKyB0aGlzLnNldHRpbmdzLm5lc3RlZEl0ZW1TZWxlY3RvciA6IHVuZGVmaW5lZDtcblx0XHRcdHdpZHRoID0gdGhpcy4kZWxlbWVudC5jaGlsZHJlbihuZXN0ZWRTZWxlY3Rvcikud2lkdGgoKTtcblxuXHRcdFx0aWYgKGltZ3MubGVuZ3RoICYmIHdpZHRoIDw9IDApIHtcblx0XHRcdFx0dGhpcy5wcmVsb2FkQXV0b1dpZHRoSW1hZ2VzKGltZ3MpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmxvYWRpbmdDbGFzcyk7XG5cblx0XHQvLyBjcmVhdGUgc3RhZ2Vcblx0XHR0aGlzLiRzdGFnZSA9ICQoJzwnICsgdGhpcy5zZXR0aW5ncy5zdGFnZUVsZW1lbnQgKyAnIGNsYXNzPVwiJyArIHRoaXMuc2V0dGluZ3Muc3RhZ2VDbGFzcyArICdcIi8+Jylcblx0XHRcdC53cmFwKCc8ZGl2IGNsYXNzPVwiJyArIHRoaXMuc2V0dGluZ3Muc3RhZ2VPdXRlckNsYXNzICsgJ1wiLz4nKTtcblxuXHRcdC8vIGFwcGVuZCBzdGFnZVxuXHRcdHRoaXMuJGVsZW1lbnQuYXBwZW5kKHRoaXMuJHN0YWdlLnBhcmVudCgpKTtcblxuXHRcdC8vIGFwcGVuZCBjb250ZW50XG5cdFx0dGhpcy5yZXBsYWNlKHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oKS5ub3QodGhpcy4kc3RhZ2UucGFyZW50KCkpKTtcblxuXHRcdC8vIGNoZWNrIHZpc2liaWxpdHlcblx0XHRpZiAodGhpcy4kZWxlbWVudC5pcygnOnZpc2libGUnKSkge1xuXHRcdFx0Ly8gdXBkYXRlIHZpZXdcblx0XHRcdHRoaXMucmVmcmVzaCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbnZhbGlkYXRlIHdpZHRoXG5cdFx0XHR0aGlzLmludmFsaWRhdGUoJ3dpZHRoJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy4kZWxlbWVudFxuXHRcdFx0LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5sb2FkaW5nQ2xhc3MpXG5cdFx0XHQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmxvYWRlZENsYXNzKTtcblxuXHRcdC8vIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXG5cdFx0dGhpcy5yZWdpc3RlckV2ZW50SGFuZGxlcnMoKTtcblxuXHRcdHRoaXMubGVhdmUoJ2luaXRpYWxpemluZycpO1xuXHRcdHRoaXMudHJpZ2dlcignaW5pdGlhbGl6ZWQnKTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0dXBzIHRoZSBjdXJyZW50IHNldHRpbmdzLlxuXHQgKiBAdG9kbyBSZW1vdmUgcmVzcG9uc2l2ZSBjbGFzc2VzLiBXaHkgc2hvdWxkIGFkYXB0aXZlIGRlc2lnbnMgYmUgYnJvdWdodCBpbnRvIElFOD9cblx0ICogQHRvZG8gU3VwcG9ydCBmb3IgbWVkaWEgcXVlcmllcyBieSB1c2luZyBgbWF0Y2hNZWRpYWAgd291bGQgYmUgbmljZS5cblx0ICogQHB1YmxpY1xuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2aWV3cG9ydCA9IHRoaXMudmlld3BvcnQoKSxcblx0XHRcdG92ZXJ3cml0ZXMgPSB0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSxcblx0XHRcdG1hdGNoID0gLTEsXG5cdFx0XHRzZXR0aW5ncyA9IG51bGw7XG5cblx0XHRpZiAoIW92ZXJ3cml0ZXMpIHtcblx0XHRcdHNldHRpbmdzID0gJC5leHRlbmQoe30sIHRoaXMub3B0aW9ucyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdCQuZWFjaChvdmVyd3JpdGVzLCBmdW5jdGlvbihicmVha3BvaW50KSB7XG5cdFx0XHRcdGlmIChicmVha3BvaW50IDw9IHZpZXdwb3J0ICYmIGJyZWFrcG9pbnQgPiBtYXRjaCkge1xuXHRcdFx0XHRcdG1hdGNoID0gTnVtYmVyKGJyZWFrcG9pbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0c2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCBvdmVyd3JpdGVzW21hdGNoXSk7XG5cdFx0XHRpZiAodHlwZW9mIHNldHRpbmdzLnN0YWdlUGFkZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRzZXR0aW5ncy5zdGFnZVBhZGRpbmcgPSBzZXR0aW5ncy5zdGFnZVBhZGRpbmcoKTtcblx0XHRcdH1cblx0XHRcdGRlbGV0ZSBzZXR0aW5ncy5yZXNwb25zaXZlO1xuXG5cdFx0XHQvLyByZXNwb25zaXZlIGNsYXNzXG5cdFx0XHRpZiAoc2V0dGluZ3MucmVzcG9uc2l2ZUNsYXNzKSB7XG5cdFx0XHRcdHRoaXMuJGVsZW1lbnQuYXR0cignY2xhc3MnLFxuXHRcdFx0XHRcdHRoaXMuJGVsZW1lbnQuYXR0cignY2xhc3MnKS5yZXBsYWNlKG5ldyBSZWdFeHAoJygnICsgdGhpcy5vcHRpb25zLnJlc3BvbnNpdmVDbGFzcyArICctKVxcXFxTK1xcXFxzJywgJ2cnKSwgJyQxJyArIG1hdGNoKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMudHJpZ2dlcignY2hhbmdlJywgeyBwcm9wZXJ0eTogeyBuYW1lOiAnc2V0dGluZ3MnLCB2YWx1ZTogc2V0dGluZ3MgfSB9KTtcblx0XHR0aGlzLl9icmVha3BvaW50ID0gbWF0Y2g7XG5cdFx0dGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuXHRcdHRoaXMuaW52YWxpZGF0ZSgnc2V0dGluZ3MnKTtcblx0XHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7IHByb3BlcnR5OiB7IG5hbWU6ICdzZXR0aW5ncycsIHZhbHVlOiB0aGlzLnNldHRpbmdzIH0gfSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgb3B0aW9uIGxvZ2ljIGlmIG5lY2Vzc2VyeS5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5vcHRpb25zTG9naWMgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5zZXR0aW5ncy5hdXRvV2lkdGgpIHtcblx0XHRcdHRoaXMuc2V0dGluZ3Muc3RhZ2VQYWRkaW5nID0gZmFsc2U7XG5cdFx0XHR0aGlzLnNldHRpbmdzLm1lcmdlID0gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBQcmVwYXJlcyBhbiBpdGVtIGJlZm9yZSBhZGQuXG5cdCAqIEB0b2RvIFJlbmFtZSBldmVudCBwYXJhbWV0ZXIgYGNvbnRlbnRgIHRvIGBpdGVtYC5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJucyB7alF1ZXJ5fEhUTUxFbGVtZW50fSAtIFRoZSBpdGVtIGNvbnRhaW5lci5cblx0ICovXG5cdE93bC5wcm90b3R5cGUucHJlcGFyZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR2YXIgZXZlbnQgPSB0aGlzLnRyaWdnZXIoJ3ByZXBhcmUnLCB7IGNvbnRlbnQ6IGl0ZW0gfSk7XG5cblx0XHRpZiAoIWV2ZW50LmRhdGEpIHtcblx0XHRcdGV2ZW50LmRhdGEgPSAkKCc8JyArIHRoaXMuc2V0dGluZ3MuaXRlbUVsZW1lbnQgKyAnLz4nKVxuXHRcdFx0XHQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLml0ZW1DbGFzcykuYXBwZW5kKGl0ZW0pXG5cdFx0fVxuXG5cdFx0dGhpcy50cmlnZ2VyKCdwcmVwYXJlZCcsIHsgY29udGVudDogZXZlbnQuZGF0YSB9KTtcblxuXHRcdHJldHVybiBldmVudC5kYXRhO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSB2aWV3LlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdG4gPSB0aGlzLl9waXBlLmxlbmd0aCxcblx0XHRcdGZpbHRlciA9ICQucHJveHkoZnVuY3Rpb24ocCkgeyByZXR1cm4gdGhpc1twXSB9LCB0aGlzLl9pbnZhbGlkYXRlZCksXG5cdFx0XHRjYWNoZSA9IHt9O1xuXG5cdFx0d2hpbGUgKGkgPCBuKSB7XG5cdFx0XHRpZiAodGhpcy5faW52YWxpZGF0ZWQuYWxsIHx8ICQuZ3JlcCh0aGlzLl9waXBlW2ldLmZpbHRlciwgZmlsdGVyKS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHRoaXMuX3BpcGVbaV0ucnVuKGNhY2hlKTtcblx0XHRcdH1cblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHR0aGlzLl9pbnZhbGlkYXRlZCA9IHt9O1xuXG5cdFx0IXRoaXMuaXMoJ3ZhbGlkJykgJiYgdGhpcy5lbnRlcigndmFsaWQnKTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgd2lkdGggb2YgdGhlIHZpZXcuXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtPd2wuV2lkdGh9IFtkaW1lbnNpb249T3dsLldpZHRoLkRlZmF1bHRdIC0gVGhlIGRpbWVuc2lvbiB0byByZXR1cm4uXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gVGhlIHdpZHRoIG9mIHRoZSB2aWV3IGluIHBpeGVsLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uKGRpbWVuc2lvbikge1xuXHRcdGRpbWVuc2lvbiA9IGRpbWVuc2lvbiB8fCBPd2wuV2lkdGguRGVmYXVsdDtcblx0XHRzd2l0Y2ggKGRpbWVuc2lvbikge1xuXHRcdFx0Y2FzZSBPd2wuV2lkdGguSW5uZXI6XG5cdFx0XHRjYXNlIE93bC5XaWR0aC5PdXRlcjpcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3dpZHRoO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3dpZHRoIC0gdGhpcy5zZXR0aW5ncy5zdGFnZVBhZGRpbmcgKiAyICsgdGhpcy5zZXR0aW5ncy5tYXJnaW47XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZWZyZXNoZXMgdGhlIGNhcm91c2VsIHByaW1hcmlseSBmb3IgYWRhcHRpdmUgcHVycG9zZXMuXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdE93bC5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZW50ZXIoJ3JlZnJlc2hpbmcnKTtcblx0XHR0aGlzLnRyaWdnZXIoJ3JlZnJlc2gnKTtcblxuXHRcdHRoaXMuc2V0dXAoKTtcblxuXHRcdHRoaXMub3B0aW9uc0xvZ2ljKCk7XG5cblx0XHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5yZWZyZXNoQ2xhc3MpO1xuXG5cdFx0dGhpcy51cGRhdGUoKTtcblxuXHRcdHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLnJlZnJlc2hDbGFzcyk7XG5cblx0XHR0aGlzLmxlYXZlKCdyZWZyZXNoaW5nJyk7XG5cdFx0dGhpcy50cmlnZ2VyKCdyZWZyZXNoZWQnKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2tzIHdpbmRvdyBgcmVzaXplYCBldmVudC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5vblRocm90dGxlZFJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lcik7XG5cdFx0dGhpcy5yZXNpemVUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMuX2hhbmRsZXJzLm9uUmVzaXplLCB0aGlzLnNldHRpbmdzLnJlc3BvbnNpdmVSZWZyZXNoUmF0ZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrcyB3aW5kb3cgYHJlc2l6ZWAgZXZlbnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdE93bC5wcm90b3R5cGUub25SZXNpemUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl93aWR0aCA9PT0gdGhpcy4kZWxlbWVudC53aWR0aCgpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLiRlbGVtZW50LmlzKCc6dmlzaWJsZScpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dGhpcy5lbnRlcigncmVzaXppbmcnKTtcblxuXHRcdGlmICh0aGlzLnRyaWdnZXIoJ3Jlc2l6ZScpLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG5cdFx0XHR0aGlzLmxlYXZlKCdyZXNpemluZycpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHRoaXMuaW52YWxpZGF0ZSgnd2lkdGgnKTtcblxuXHRcdHRoaXMucmVmcmVzaCgpO1xuXG5cdFx0dGhpcy5sZWF2ZSgncmVzaXppbmcnKTtcblx0XHR0aGlzLnRyaWdnZXIoJ3Jlc2l6ZWQnKTtcblx0fTtcblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGV2ZW50IGhhbmRsZXJzLlxuXHQgKiBAdG9kbyBDaGVjayBgbXNQb2ludGVyRW5hYmxlZGBcblx0ICogQHRvZG8gIzI2MVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLnJlZ2lzdGVyRXZlbnRIYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICgkLnN1cHBvcnQudHJhbnNpdGlvbikge1xuXHRcdFx0dGhpcy4kc3RhZ2Uub24oJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kICsgJy5vd2wuY29yZScsICQucHJveHkodGhpcy5vblRyYW5zaXRpb25FbmQsIHRoaXMpKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5zZXR0aW5ncy5yZXNwb25zaXZlICE9PSBmYWxzZSkge1xuXHRcdFx0dGhpcy5vbih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9oYW5kbGVycy5vblRocm90dGxlZFJlc2l6ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuc2V0dGluZ3MubW91c2VEcmFnKSB7XG5cdFx0XHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5kcmFnQ2xhc3MpO1xuXHRcdFx0dGhpcy4kc3RhZ2Uub24oJ21vdXNlZG93bi5vd2wuY29yZScsICQucHJveHkodGhpcy5vbkRyYWdTdGFydCwgdGhpcykpO1xuXHRcdFx0dGhpcy4kc3RhZ2Uub24oJ2RyYWdzdGFydC5vd2wuY29yZSBzZWxlY3RzdGFydC5vd2wuY29yZScsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2UgfSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuc2V0dGluZ3MudG91Y2hEcmFnKXtcblx0XHRcdHRoaXMuJHN0YWdlLm9uKCd0b3VjaHN0YXJ0Lm93bC5jb3JlJywgJC5wcm94eSh0aGlzLm9uRHJhZ1N0YXJ0LCB0aGlzKSk7XG5cdFx0XHR0aGlzLiRzdGFnZS5vbigndG91Y2hjYW5jZWwub3dsLmNvcmUnLCAkLnByb3h5KHRoaXMub25EcmFnRW5kLCB0aGlzKSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIGB0b3VjaHN0YXJ0YCBhbmQgYG1vdXNlZG93bmAgZXZlbnRzLlxuXHQgKiBAdG9kbyBIb3Jpem9udGFsIHN3aXBlIHRocmVzaG9sZCBhcyBvcHRpb25cblx0ICogQHRvZG8gIzI2MVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IGFyZ3VtZW50cy5cblx0ICovXG5cdE93bC5wcm90b3R5cGUub25EcmFnU3RhcnQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBzdGFnZSA9IG51bGw7XG5cblx0XHRpZiAoZXZlbnQud2hpY2ggPT09IDMpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoJC5zdXBwb3J0LnRyYW5zZm9ybSkge1xuXHRcdFx0c3RhZ2UgPSB0aGlzLiRzdGFnZS5jc3MoJ3RyYW5zZm9ybScpLnJlcGxhY2UoLy4qXFwofFxcKXwgL2csICcnKS5zcGxpdCgnLCcpO1xuXHRcdFx0c3RhZ2UgPSB7XG5cdFx0XHRcdHg6IHN0YWdlW3N0YWdlLmxlbmd0aCA9PT0gMTYgPyAxMiA6IDRdLFxuXHRcdFx0XHR5OiBzdGFnZVtzdGFnZS5sZW5ndGggPT09IDE2ID8gMTMgOiA1XVxuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3RhZ2UgPSB0aGlzLiRzdGFnZS5wb3NpdGlvbigpO1xuXHRcdFx0c3RhZ2UgPSB7XG5cdFx0XHRcdHg6IHRoaXMuc2V0dGluZ3MucnRsID9cblx0XHRcdFx0XHRzdGFnZS5sZWZ0ICsgdGhpcy4kc3RhZ2Uud2lkdGgoKSAtIHRoaXMud2lkdGgoKSArIHRoaXMuc2V0dGluZ3MubWFyZ2luIDpcblx0XHRcdFx0XHRzdGFnZS5sZWZ0LFxuXHRcdFx0XHR5OiBzdGFnZS50b3Bcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuaXMoJ2FuaW1hdGluZycpKSB7XG5cdFx0XHQkLnN1cHBvcnQudHJhbnNmb3JtID8gdGhpcy5hbmltYXRlKHN0YWdlLngpIDogdGhpcy4kc3RhZ2Uuc3RvcCgpXG5cdFx0XHR0aGlzLmludmFsaWRhdGUoJ3Bvc2l0aW9uJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLm9wdGlvbnMuZ3JhYkNsYXNzLCBldmVudC50eXBlID09PSAnbW91c2Vkb3duJyk7XG5cblx0XHR0aGlzLnNwZWVkKDApO1xuXG5cdFx0dGhpcy5fZHJhZy50aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdFx0dGhpcy5fZHJhZy50YXJnZXQgPSAkKGV2ZW50LnRhcmdldCk7XG5cdFx0dGhpcy5fZHJhZy5zdGFnZS5zdGFydCA9IHN0YWdlO1xuXHRcdHRoaXMuX2RyYWcuc3RhZ2UuY3VycmVudCA9IHN0YWdlO1xuXHRcdHRoaXMuX2RyYWcucG9pbnRlciA9IHRoaXMucG9pbnRlcihldmVudCk7XG5cblx0XHQkKGRvY3VtZW50KS5vbignbW91c2V1cC5vd2wuY29yZSB0b3VjaGVuZC5vd2wuY29yZScsICQucHJveHkodGhpcy5vbkRyYWdFbmQsIHRoaXMpKTtcblxuXHRcdCQoZG9jdW1lbnQpLm9uZSgnbW91c2Vtb3ZlLm93bC5jb3JlIHRvdWNobW92ZS5vd2wuY29yZScsICQucHJveHkoZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHZhciBkZWx0YSA9IHRoaXMuZGlmZmVyZW5jZSh0aGlzLl9kcmFnLnBvaW50ZXIsIHRoaXMucG9pbnRlcihldmVudCkpO1xuXG5cdFx0XHQkKGRvY3VtZW50KS5vbignbW91c2Vtb3ZlLm93bC5jb3JlIHRvdWNobW92ZS5vd2wuY29yZScsICQucHJveHkodGhpcy5vbkRyYWdNb3ZlLCB0aGlzKSk7XG5cblx0XHRcdGlmIChNYXRoLmFicyhkZWx0YS54KSA8IE1hdGguYWJzKGRlbHRhLnkpICYmIHRoaXMuaXMoJ3ZhbGlkJykpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHR0aGlzLmVudGVyKCdkcmFnZ2luZycpO1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdkcmFnJyk7XG5cdFx0fSwgdGhpcykpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIHRoZSBgdG91Y2htb3ZlYCBhbmQgYG1vdXNlbW92ZWAgZXZlbnRzLlxuXHQgKiBAdG9kbyAjMjYxXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5vbkRyYWdNb3ZlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgbWluaW11bSA9IG51bGwsXG5cdFx0XHRtYXhpbXVtID0gbnVsbCxcblx0XHRcdHB1bGwgPSBudWxsLFxuXHRcdFx0ZGVsdGEgPSB0aGlzLmRpZmZlcmVuY2UodGhpcy5fZHJhZy5wb2ludGVyLCB0aGlzLnBvaW50ZXIoZXZlbnQpKSxcblx0XHRcdHN0YWdlID0gdGhpcy5kaWZmZXJlbmNlKHRoaXMuX2RyYWcuc3RhZ2Uuc3RhcnQsIGRlbHRhKTtcblxuXHRcdGlmICghdGhpcy5pcygnZHJhZ2dpbmcnKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRpZiAodGhpcy5zZXR0aW5ncy5sb29wKSB7XG5cdFx0XHRtaW5pbXVtID0gdGhpcy5jb29yZGluYXRlcyh0aGlzLm1pbmltdW0oKSk7XG5cdFx0XHRtYXhpbXVtID0gdGhpcy5jb29yZGluYXRlcyh0aGlzLm1heGltdW0oKSArIDEpIC0gbWluaW11bTtcblx0XHRcdHN0YWdlLnggPSAoKChzdGFnZS54IC0gbWluaW11bSkgJSBtYXhpbXVtICsgbWF4aW11bSkgJSBtYXhpbXVtKSArIG1pbmltdW07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1pbmltdW0gPSB0aGlzLnNldHRpbmdzLnJ0bCA/IHRoaXMuY29vcmRpbmF0ZXModGhpcy5tYXhpbXVtKCkpIDogdGhpcy5jb29yZGluYXRlcyh0aGlzLm1pbmltdW0oKSk7XG5cdFx0XHRtYXhpbXVtID0gdGhpcy5zZXR0aW5ncy5ydGwgPyB0aGlzLmNvb3JkaW5hdGVzKHRoaXMubWluaW11bSgpKSA6IHRoaXMuY29vcmRpbmF0ZXModGhpcy5tYXhpbXVtKCkpO1xuXHRcdFx0cHVsbCA9IHRoaXMuc2V0dGluZ3MucHVsbERyYWcgPyAtMSAqIGRlbHRhLnggLyA1IDogMDtcblx0XHRcdHN0YWdlLnggPSBNYXRoLm1heChNYXRoLm1pbihzdGFnZS54LCBtaW5pbXVtICsgcHVsbCksIG1heGltdW0gKyBwdWxsKTtcblx0XHR9XG5cblx0XHR0aGlzLl9kcmFnLnN0YWdlLmN1cnJlbnQgPSBzdGFnZTtcblxuXHRcdHRoaXMuYW5pbWF0ZShzdGFnZS54KTtcblx0fTtcblxuXHQvKipcblx0ICogSGFuZGxlcyB0aGUgYHRvdWNoZW5kYCBhbmQgYG1vdXNldXBgIGV2ZW50cy5cblx0ICogQHRvZG8gIzI2MVxuXHQgKiBAdG9kbyBUaHJlc2hvbGQgZm9yIGNsaWNrIGV2ZW50XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5vbkRyYWdFbmQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBkZWx0YSA9IHRoaXMuZGlmZmVyZW5jZSh0aGlzLl9kcmFnLnBvaW50ZXIsIHRoaXMucG9pbnRlcihldmVudCkpLFxuXHRcdFx0c3RhZ2UgPSB0aGlzLl9kcmFnLnN0YWdlLmN1cnJlbnQsXG5cdFx0XHRkaXJlY3Rpb24gPSBkZWx0YS54ID4gMCBeIHRoaXMuc2V0dGluZ3MucnRsID8gJ2xlZnQnIDogJ3JpZ2h0JztcblxuXHRcdCQoZG9jdW1lbnQpLm9mZignLm93bC5jb3JlJyk7XG5cblx0XHR0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5ncmFiQ2xhc3MpO1xuXG5cdFx0aWYgKGRlbHRhLnggIT09IDAgJiYgdGhpcy5pcygnZHJhZ2dpbmcnKSB8fCAhdGhpcy5pcygndmFsaWQnKSkge1xuXHRcdFx0dGhpcy5zcGVlZCh0aGlzLnNldHRpbmdzLmRyYWdFbmRTcGVlZCB8fCB0aGlzLnNldHRpbmdzLnNtYXJ0U3BlZWQpO1xuXHRcdFx0dGhpcy5jdXJyZW50KHRoaXMuY2xvc2VzdChzdGFnZS54LCBkZWx0YS54ICE9PSAwID8gZGlyZWN0aW9uIDogdGhpcy5fZHJhZy5kaXJlY3Rpb24pKTtcblx0XHRcdHRoaXMuaW52YWxpZGF0ZSgncG9zaXRpb24nKTtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHRcdHRoaXMuX2RyYWcuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuXG5cdFx0XHRpZiAoTWF0aC5hYnMoZGVsdGEueCkgPiAzIHx8IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5fZHJhZy50aW1lID4gMzAwKSB7XG5cdFx0XHRcdHRoaXMuX2RyYWcudGFyZ2V0Lm9uZSgnY2xpY2sub3dsLmNvcmUnLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuaXMoJ2RyYWdnaW5nJykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLmxlYXZlKCdkcmFnZ2luZycpO1xuXHRcdHRoaXMudHJpZ2dlcignZHJhZ2dlZCcpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXRzIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBjbG9zZXN0IGl0ZW0gZm9yIGEgY29vcmRpbmF0ZS5cblx0ICogQHRvZG8gU2V0dGluZyBgZnJlZURyYWdgIG1ha2VzIGBjbG9zZXN0YCBub3QgcmV1c2FibGUuIFNlZSAjMTY1LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb29yZGluYXRlIC0gVGhlIGNvb3JkaW5hdGUgaW4gcGl4ZWwuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gLSBUaGUgZGlyZWN0aW9uIHRvIGNoZWNrIGZvciB0aGUgY2xvc2VzdCBpdGVtLiBFdGhlciBgbGVmdGAgb3IgYHJpZ2h0YC5cblx0ICogQHJldHVybiB7TnVtYmVyfSAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgY2xvc2VzdCBpdGVtLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5jbG9zZXN0ID0gZnVuY3Rpb24oY29vcmRpbmF0ZSwgZGlyZWN0aW9uKSB7XG5cdFx0dmFyIHBvc2l0aW9uID0gLTEsXG5cdFx0XHRwdWxsID0gMzAsXG5cdFx0XHR3aWR0aCA9IHRoaXMud2lkdGgoKSxcblx0XHRcdGNvb3JkaW5hdGVzID0gdGhpcy5jb29yZGluYXRlcygpO1xuXG5cdFx0aWYgKCF0aGlzLnNldHRpbmdzLmZyZWVEcmFnKSB7XG5cdFx0XHQvLyBjaGVjayBjbG9zZXN0IGl0ZW1cblx0XHRcdCQuZWFjaChjb29yZGluYXRlcywgJC5wcm94eShmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcblx0XHRcdFx0Ly8gb24gYSBsZWZ0IHB1bGwsIGNoZWNrIG9uIGN1cnJlbnQgaW5kZXhcblx0XHRcdFx0aWYgKGRpcmVjdGlvbiA9PT0gJ2xlZnQnICYmIGNvb3JkaW5hdGUgPiB2YWx1ZSAtIHB1bGwgJiYgY29vcmRpbmF0ZSA8IHZhbHVlICsgcHVsbCkge1xuXHRcdFx0XHRcdHBvc2l0aW9uID0gaW5kZXg7XG5cdFx0XHRcdC8vIG9uIGEgcmlnaHQgcHVsbCwgY2hlY2sgb24gcHJldmlvdXMgaW5kZXhcblx0XHRcdFx0Ly8gdG8gZG8gc28sIHN1YnRyYWN0IHdpZHRoIGZyb20gdmFsdWUgYW5kIHNldCBwb3NpdGlvbiA9IGluZGV4ICsgMVxuXHRcdFx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyAmJiBjb29yZGluYXRlID4gdmFsdWUgLSB3aWR0aCAtIHB1bGwgJiYgY29vcmRpbmF0ZSA8IHZhbHVlIC0gd2lkdGggKyBwdWxsKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24gPSBpbmRleCArIDE7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5vcChjb29yZGluYXRlLCAnPCcsIHZhbHVlKVxuXHRcdFx0XHRcdCYmIHRoaXMub3AoY29vcmRpbmF0ZSwgJz4nLCBjb29yZGluYXRlc1tpbmRleCArIDFdIHx8IHZhbHVlIC0gd2lkdGgpKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24gPSBkaXJlY3Rpb24gPT09ICdsZWZ0JyA/IGluZGV4ICsgMSA6IGluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwb3NpdGlvbiA9PT0gLTE7XG5cdFx0XHR9LCB0aGlzKSk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLnNldHRpbmdzLmxvb3ApIHtcblx0XHRcdC8vIG5vbiBsb29wIGJvdW5kcmllc1xuXHRcdFx0aWYgKHRoaXMub3AoY29vcmRpbmF0ZSwgJz4nLCBjb29yZGluYXRlc1t0aGlzLm1pbmltdW0oKV0pKSB7XG5cdFx0XHRcdHBvc2l0aW9uID0gY29vcmRpbmF0ZSA9IHRoaXMubWluaW11bSgpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLm9wKGNvb3JkaW5hdGUsICc8JywgY29vcmRpbmF0ZXNbdGhpcy5tYXhpbXVtKCldKSkge1xuXHRcdFx0XHRwb3NpdGlvbiA9IGNvb3JkaW5hdGUgPSB0aGlzLm1heGltdW0oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcG9zaXRpb247XG5cdH07XG5cblx0LyoqXG5cdCAqIEFuaW1hdGVzIHRoZSBzdGFnZS5cblx0ICogQHRvZG8gIzI3MFxuXHQgKiBAcHVibGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb29yZGluYXRlIC0gVGhlIGNvb3JkaW5hdGUgaW4gcGl4ZWxzLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5hbmltYXRlID0gZnVuY3Rpb24oY29vcmRpbmF0ZSkge1xuXHRcdHZhciBhbmltYXRlID0gdGhpcy5zcGVlZCgpID4gMDtcblxuXHRcdHRoaXMuaXMoJ2FuaW1hdGluZycpICYmIHRoaXMub25UcmFuc2l0aW9uRW5kKCk7XG5cblx0XHRpZiAoYW5pbWF0ZSkge1xuXHRcdFx0dGhpcy5lbnRlcignYW5pbWF0aW5nJyk7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3RyYW5zbGF0ZScpO1xuXHRcdH1cblxuXHRcdGlmICgkLnN1cHBvcnQudHJhbnNmb3JtM2QgJiYgJC5zdXBwb3J0LnRyYW5zaXRpb24pIHtcblx0XHRcdHRoaXMuJHN0YWdlLmNzcyh7XG5cdFx0XHRcdHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKCcgKyBjb29yZGluYXRlICsgJ3B4LDBweCwwcHgpJyxcblx0XHRcdFx0dHJhbnNpdGlvbjogKHRoaXMuc3BlZWQoKSAvIDEwMDApICsgJ3MnXG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYgKGFuaW1hdGUpIHtcblx0XHRcdHRoaXMuJHN0YWdlLmFuaW1hdGUoe1xuXHRcdFx0XHRsZWZ0OiBjb29yZGluYXRlICsgJ3B4J1xuXHRcdFx0fSwgdGhpcy5zcGVlZCgpLCB0aGlzLnNldHRpbmdzLmZhbGxiYWNrRWFzaW5nLCAkLnByb3h5KHRoaXMub25UcmFuc2l0aW9uRW5kLCB0aGlzKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuJHN0YWdlLmNzcyh7XG5cdFx0XHRcdGxlZnQ6IGNvb3JkaW5hdGUgKyAncHgnXG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrcyB3aGV0aGVyIHRoZSBjYXJvdXNlbCBpcyBpbiBhIHNwZWNpZmljIHN0YXRlIG9yIG5vdC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0YXRlIC0gVGhlIHN0YXRlIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSBUaGUgZmxhZyB3aGljaCBpbmRpY2F0ZXMgaWYgdGhlIGNhcm91c2VsIGlzIGJ1c3kuXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLmlzID0gZnVuY3Rpb24oc3RhdGUpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3RhdGVzLmN1cnJlbnRbc3RhdGVdICYmIHRoaXMuX3N0YXRlcy5jdXJyZW50W3N0YXRlXSA+IDA7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGl0ZW0uXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtwb3NpdGlvbl0gLSBUaGUgbmV3IGFic29sdXRlIHBvc2l0aW9uIG9yIG5vdGhpbmcgdG8gbGVhdmUgaXQgdW5jaGFuZ2VkLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBpdGVtLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcblx0XHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2N1cnJlbnQ7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX2l0ZW1zLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRwb3NpdGlvbiA9IHRoaXMubm9ybWFsaXplKHBvc2l0aW9uKTtcblxuXHRcdGlmICh0aGlzLl9jdXJyZW50ICE9PSBwb3NpdGlvbikge1xuXHRcdFx0dmFyIGV2ZW50ID0gdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB7IHByb3BlcnR5OiB7IG5hbWU6ICdwb3NpdGlvbicsIHZhbHVlOiBwb3NpdGlvbiB9IH0pO1xuXG5cdFx0XHRpZiAoZXZlbnQuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHBvc2l0aW9uID0gdGhpcy5ub3JtYWxpemUoZXZlbnQuZGF0YSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2N1cnJlbnQgPSBwb3NpdGlvbjtcblxuXHRcdFx0dGhpcy5pbnZhbGlkYXRlKCdwb3NpdGlvbicpO1xuXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7IHByb3BlcnR5OiB7IG5hbWU6ICdwb3NpdGlvbicsIHZhbHVlOiB0aGlzLl9jdXJyZW50IH0gfSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX2N1cnJlbnQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIEludmFsaWRhdGVzIHRoZSBnaXZlbiBwYXJ0IG9mIHRoZSB1cGRhdGUgcm91dGluZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtwYXJ0XSAtIFRoZSBwYXJ0IHRvIGludmFsaWRhdGUuXG5cdCAqIEByZXR1cm5zIHtBcnJheS48U3RyaW5nPn0gLSBUaGUgaW52YWxpZGF0ZWQgcGFydHMuXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbihwYXJ0KSB7XG5cdFx0aWYgKCQudHlwZShwYXJ0KSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHRoaXMuX2ludmFsaWRhdGVkW3BhcnRdID0gdHJ1ZTtcblx0XHRcdHRoaXMuaXMoJ3ZhbGlkJykgJiYgdGhpcy5sZWF2ZSgndmFsaWQnKTtcblx0XHR9XG5cdFx0cmV0dXJuICQubWFwKHRoaXMuX2ludmFsaWRhdGVkLCBmdW5jdGlvbih2LCBpKSB7IHJldHVybiBpIH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXNldHMgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGl0ZW0uXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gVGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBuZXcgaXRlbS5cblx0ICovXG5cdE93bC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuXHRcdHBvc2l0aW9uID0gdGhpcy5ub3JtYWxpemUocG9zaXRpb24pO1xuXG5cdFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9zcGVlZCA9IDA7XG5cdFx0dGhpcy5fY3VycmVudCA9IHBvc2l0aW9uO1xuXG5cdFx0dGhpcy5zdXBwcmVzcyhbICd0cmFuc2xhdGUnLCAndHJhbnNsYXRlZCcgXSk7XG5cblx0XHR0aGlzLmFuaW1hdGUodGhpcy5jb29yZGluYXRlcyhwb3NpdGlvbikpO1xuXG5cdFx0dGhpcy5yZWxlYXNlKFsgJ3RyYW5zbGF0ZScsICd0cmFuc2xhdGVkJyBdKTtcblx0fTtcblxuXHQvKipcblx0ICogTm9ybWFsaXplcyBhbiBhYnNvbHV0ZSBvciBhIHJlbGF0aXZlIHBvc2l0aW9uIG9mIGFuIGl0ZW0uXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gVGhlIGFic29sdXRlIG9yIHJlbGF0aXZlIHBvc2l0aW9uIHRvIG5vcm1hbGl6ZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcmVsYXRpdmU9ZmFsc2VdIC0gV2hldGhlciB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgcmVsYXRpdmUgb3Igbm90LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSAtIFRoZSBub3JtYWxpemVkIHBvc2l0aW9uLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbihwb3NpdGlvbiwgcmVsYXRpdmUpIHtcblx0XHR2YXIgbiA9IHRoaXMuX2l0ZW1zLmxlbmd0aCxcblx0XHRcdG0gPSByZWxhdGl2ZSA/IDAgOiB0aGlzLl9jbG9uZXMubGVuZ3RoO1xuXG5cdFx0aWYgKCF0aGlzLmlzTnVtZXJpYyhwb3NpdGlvbikgfHwgbiA8IDEpIHtcblx0XHRcdHBvc2l0aW9uID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IG4gKyBtKSB7XG5cdFx0XHRwb3NpdGlvbiA9ICgocG9zaXRpb24gLSBtIC8gMikgJSBuICsgbikgJSBuICsgbSAvIDI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBvc2l0aW9uO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhbiBhYnNvbHV0ZSBwb3NpdGlvbiBvZiBhbiBpdGVtIGludG8gYSByZWxhdGl2ZSBvbmUuXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gVGhlIGFic29sdXRlIHBvc2l0aW9uIHRvIGNvbnZlcnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gVGhlIGNvbnZlcnRlZCBwb3NpdGlvbi5cblx0ICovXG5cdE93bC5wcm90b3R5cGUucmVsYXRpdmUgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuXHRcdHBvc2l0aW9uIC09IHRoaXMuX2Nsb25lcy5sZW5ndGggLyAyO1xuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZShwb3NpdGlvbiwgdHJ1ZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIG1heGltdW0gcG9zaXRpb24gZm9yIHRoZSBjdXJyZW50IGl0ZW0uXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtCb29sZWFufSBbcmVsYXRpdmU9ZmFsc2VdIC0gV2hldGhlciB0byByZXR1cm4gYW4gYWJzb2x1dGUgcG9zaXRpb24gb3IgYSByZWxhdGl2ZSBwb3NpdGlvbi5cblx0ICogQHJldHVybnMge051bWJlcn1cblx0ICovXG5cdE93bC5wcm90b3R5cGUubWF4aW11bSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG5cdFx0dmFyIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncyxcblx0XHRcdG1heGltdW0gPSB0aGlzLl9jb29yZGluYXRlcy5sZW5ndGgsXG5cdFx0XHRpdGVyYXRvcixcblx0XHRcdHJlY2lwcm9jYWxJdGVtc1dpZHRoLFxuXHRcdFx0ZWxlbWVudFdpZHRoO1xuXG5cdFx0aWYgKHNldHRpbmdzLmxvb3ApIHtcblx0XHRcdG1heGltdW0gPSB0aGlzLl9jbG9uZXMubGVuZ3RoIC8gMiArIHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDE7XG5cdFx0fSBlbHNlIGlmIChzZXR0aW5ncy5hdXRvV2lkdGggfHwgc2V0dGluZ3MubWVyZ2UpIHtcblx0XHRcdGl0ZXJhdG9yID0gdGhpcy5faXRlbXMubGVuZ3RoO1xuXHRcdFx0cmVjaXByb2NhbEl0ZW1zV2lkdGggPSB0aGlzLl9pdGVtc1stLWl0ZXJhdG9yXS53aWR0aCgpO1xuXHRcdFx0ZWxlbWVudFdpZHRoID0gdGhpcy4kZWxlbWVudC53aWR0aCgpO1xuXHRcdFx0d2hpbGUgKGl0ZXJhdG9yLS0pIHtcblx0XHRcdFx0cmVjaXByb2NhbEl0ZW1zV2lkdGggKz0gdGhpcy5faXRlbXNbaXRlcmF0b3JdLndpZHRoKCkgKyB0aGlzLnNldHRpbmdzLm1hcmdpbjtcblx0XHRcdFx0aWYgKHJlY2lwcm9jYWxJdGVtc1dpZHRoID4gZWxlbWVudFdpZHRoKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG1heGltdW0gPSBpdGVyYXRvciArIDE7XG5cdFx0fSBlbHNlIGlmIChzZXR0aW5ncy5jZW50ZXIpIHtcblx0XHRcdG1heGltdW0gPSB0aGlzLl9pdGVtcy5sZW5ndGggLSAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXhpbXVtID0gdGhpcy5faXRlbXMubGVuZ3RoIC0gc2V0dGluZ3MuaXRlbXM7XG5cdFx0fVxuXG5cdFx0aWYgKHJlbGF0aXZlKSB7XG5cdFx0XHRtYXhpbXVtIC09IHRoaXMuX2Nsb25lcy5sZW5ndGggLyAyO1xuXHRcdH1cblxuXHRcdHJldHVybiBNYXRoLm1heChtYXhpbXVtLCAwKTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgbWluaW11bSBwb3NpdGlvbiBmb3IgdGhlIGN1cnJlbnQgaXRlbS5cblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWxhdGl2ZT1mYWxzZV0gLSBXaGV0aGVyIHRvIHJldHVybiBhbiBhYnNvbHV0ZSBwb3NpdGlvbiBvciBhIHJlbGF0aXZlIHBvc2l0aW9uLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfVxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5taW5pbXVtID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcblx0XHRyZXR1cm4gcmVsYXRpdmUgPyAwIDogdGhpcy5fY2xvbmVzLmxlbmd0aCAvIDI7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldHMgYW4gaXRlbSBhdCB0aGUgc3BlY2lmaWVkIHJlbGF0aXZlIHBvc2l0aW9uLlxuXHQgKiBAcHVibGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb25dIC0gVGhlIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBpdGVtLlxuXHQgKiBAcmV0dXJuIHtqUXVlcnl8QXJyYXkuPGpRdWVyeT59IC0gVGhlIGl0ZW0gYXQgdGhlIGdpdmVuIHBvc2l0aW9uIG9yIGFsbCBpdGVtcyBpZiBubyBwb3NpdGlvbiB3YXMgZ2l2ZW4uXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLml0ZW1zID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcblx0XHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2l0ZW1zLnNsaWNlKCk7XG5cdFx0fVxuXG5cdFx0cG9zaXRpb24gPSB0aGlzLm5vcm1hbGl6ZShwb3NpdGlvbiwgdHJ1ZSk7XG5cdFx0cmV0dXJuIHRoaXMuX2l0ZW1zW3Bvc2l0aW9uXTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0cyBhbiBpdGVtIGF0IHRoZSBzcGVjaWZpZWQgcmVsYXRpdmUgcG9zaXRpb24uXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtwb3NpdGlvbl0gLSBUaGUgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGl0ZW0uXG5cdCAqIEByZXR1cm4ge2pRdWVyeXxBcnJheS48alF1ZXJ5Pn0gLSBUaGUgaXRlbSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gb3IgYWxsIGl0ZW1zIGlmIG5vIHBvc2l0aW9uIHdhcyBnaXZlbi5cblx0ICovXG5cdE93bC5wcm90b3R5cGUubWVyZ2VycyA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG5cdFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiB0aGlzLl9tZXJnZXJzLnNsaWNlKCk7XG5cdFx0fVxuXG5cdFx0cG9zaXRpb24gPSB0aGlzLm5vcm1hbGl6ZShwb3NpdGlvbiwgdHJ1ZSk7XG5cdFx0cmV0dXJuIHRoaXMuX21lcmdlcnNbcG9zaXRpb25dO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbnMgb2YgY2xvbmVzIGZvciBhbiBpdGVtLlxuXHQgKiBAcHVibGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb25dIC0gVGhlIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXkuPE51bWJlcj59IC0gVGhlIGFic29sdXRlIHBvc2l0aW9ucyBvZiBjbG9uZXMgZm9yIHRoZSBpdGVtIG9yIGFsbCBpZiBubyBwb3NpdGlvbiB3YXMgZ2l2ZW4uXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLmNsb25lcyA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG5cdFx0dmFyIG9kZCA9IHRoaXMuX2Nsb25lcy5sZW5ndGggLyAyLFxuXHRcdFx0ZXZlbiA9IG9kZCArIHRoaXMuX2l0ZW1zLmxlbmd0aCxcblx0XHRcdG1hcCA9IGZ1bmN0aW9uKGluZGV4KSB7IHJldHVybiBpbmRleCAlIDIgPT09IDAgPyBldmVuICsgaW5kZXggLyAyIDogb2RkIC0gKGluZGV4ICsgMSkgLyAyIH07XG5cblx0XHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuICQubWFwKHRoaXMuX2Nsb25lcywgZnVuY3Rpb24odiwgaSkgeyByZXR1cm4gbWFwKGkpIH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiAkLm1hcCh0aGlzLl9jbG9uZXMsIGZ1bmN0aW9uKHYsIGkpIHsgcmV0dXJuIHYgPT09IHBvc2l0aW9uID8gbWFwKGkpIDogbnVsbCB9KTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgY3VycmVudCBhbmltYXRpb24gc3BlZWQuXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZF0gLSBUaGUgYW5pbWF0aW9uIHNwZWVkIGluIG1pbGxpc2Vjb25kcyBvciBub3RoaW5nIHRvIGxlYXZlIGl0IHVuY2hhbmdlZC5cblx0ICogQHJldHVybnMge051bWJlcn0gLSBUaGUgY3VycmVudCBhbmltYXRpb24gc3BlZWQgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5zcGVlZCA9IGZ1bmN0aW9uKHNwZWVkKSB7XG5cdFx0aWYgKHNwZWVkICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuX3NwZWVkID0gc3BlZWQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX3NwZWVkO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBjb29yZGluYXRlIG9mIGFuIGl0ZW0uXG5cdCAqIEB0b2RvIFRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIGlzIG1pc3NsZWFuZGluZy5cblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0gd2l0aGluIGBtaW5pbXVtKClgIGFuZCBgbWF4aW11bSgpYC5cblx0ICogQHJldHVybnMge051bWJlcnxBcnJheS48TnVtYmVyPn0gLSBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgaXRlbSBpbiBwaXhlbCBvciBhbGwgY29vcmRpbmF0ZXMuXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLmNvb3JkaW5hdGVzID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcblx0XHR2YXIgbXVsdGlwbGllciA9IDEsXG5cdFx0XHRuZXdQb3NpdGlvbiA9IHBvc2l0aW9uIC0gMSxcblx0XHRcdGNvb3JkaW5hdGU7XG5cblx0XHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuICQubWFwKHRoaXMuX2Nvb3JkaW5hdGVzLCAkLnByb3h5KGZ1bmN0aW9uKGNvb3JkaW5hdGUsIGluZGV4KSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvb3JkaW5hdGVzKGluZGV4KTtcblx0XHRcdH0sIHRoaXMpKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5zZXR0aW5ncy5jZW50ZXIpIHtcblx0XHRcdGlmICh0aGlzLnNldHRpbmdzLnJ0bCkge1xuXHRcdFx0XHRtdWx0aXBsaWVyID0gLTE7XG5cdFx0XHRcdG5ld1Bvc2l0aW9uID0gcG9zaXRpb24gKyAxO1xuXHRcdFx0fVxuXG5cdFx0XHRjb29yZGluYXRlID0gdGhpcy5fY29vcmRpbmF0ZXNbcG9zaXRpb25dO1xuXHRcdFx0Y29vcmRpbmF0ZSArPSAodGhpcy53aWR0aCgpIC0gY29vcmRpbmF0ZSArICh0aGlzLl9jb29yZGluYXRlc1tuZXdQb3NpdGlvbl0gfHwgMCkpIC8gMiAqIG11bHRpcGxpZXI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvb3JkaW5hdGUgPSB0aGlzLl9jb29yZGluYXRlc1tuZXdQb3NpdGlvbl0gfHwgMDtcblx0XHR9XG5cblx0XHRjb29yZGluYXRlID0gTWF0aC5jZWlsKGNvb3JkaW5hdGUpO1xuXG5cdFx0cmV0dXJuIGNvb3JkaW5hdGU7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZXMgdGhlIHNwZWVkIGZvciBhIHRyYW5zbGF0aW9uLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBmcm9tIC0gVGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBzdGFydCBpdGVtLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdG8gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBpdGVtLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2ZhY3Rvcj11bmRlZmluZWRdIC0gVGhlIHRpbWUgZmFjdG9yIGluIG1pbGxpc2Vjb25kcy5cblx0ICogQHJldHVybnMge051bWJlcn0gLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2xhdGlvbi5cblx0ICovXG5cdE93bC5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbihmcm9tLCB0bywgZmFjdG9yKSB7XG5cdFx0aWYgKGZhY3RvciA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIE1hdGgubWluKE1hdGgubWF4KE1hdGguYWJzKHRvIC0gZnJvbSksIDEpLCA2KSAqIE1hdGguYWJzKChmYWN0b3IgfHwgdGhpcy5zZXR0aW5ncy5zbWFydFNwZWVkKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNsaWRlcyB0byB0aGUgc3BlY2lmaWVkIGl0ZW0uXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBpdGVtLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkXSAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zaXRpb24uXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLnRvID0gZnVuY3Rpb24ocG9zaXRpb24sIHNwZWVkKSB7XG5cdFx0dmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQoKSxcblx0XHRcdHJldmVydCA9IG51bGwsXG5cdFx0XHRkaXN0YW5jZSA9IHBvc2l0aW9uIC0gdGhpcy5yZWxhdGl2ZShjdXJyZW50KSxcblx0XHRcdGRpcmVjdGlvbiA9IChkaXN0YW5jZSA+IDApIC0gKGRpc3RhbmNlIDwgMCksXG5cdFx0XHRpdGVtcyA9IHRoaXMuX2l0ZW1zLmxlbmd0aCxcblx0XHRcdG1pbmltdW0gPSB0aGlzLm1pbmltdW0oKSxcblx0XHRcdG1heGltdW0gPSB0aGlzLm1heGltdW0oKTtcblxuXHRcdGlmICh0aGlzLnNldHRpbmdzLmxvb3ApIHtcblx0XHRcdGlmICghdGhpcy5zZXR0aW5ncy5yZXdpbmQgJiYgTWF0aC5hYnMoZGlzdGFuY2UpID4gaXRlbXMgLyAyKSB7XG5cdFx0XHRcdGRpc3RhbmNlICs9IGRpcmVjdGlvbiAqIC0xICogaXRlbXM7XG5cdFx0XHR9XG5cblx0XHRcdHBvc2l0aW9uID0gY3VycmVudCArIGRpc3RhbmNlO1xuXHRcdFx0cmV2ZXJ0ID0gKChwb3NpdGlvbiAtIG1pbmltdW0pICUgaXRlbXMgKyBpdGVtcykgJSBpdGVtcyArIG1pbmltdW07XG5cblx0XHRcdGlmIChyZXZlcnQgIT09IHBvc2l0aW9uICYmIHJldmVydCAtIGRpc3RhbmNlIDw9IG1heGltdW0gJiYgcmV2ZXJ0IC0gZGlzdGFuY2UgPiAwKSB7XG5cdFx0XHRcdGN1cnJlbnQgPSByZXZlcnQgLSBkaXN0YW5jZTtcblx0XHRcdFx0cG9zaXRpb24gPSByZXZlcnQ7XG5cdFx0XHRcdHRoaXMucmVzZXQoY3VycmVudCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0aGlzLnNldHRpbmdzLnJld2luZCkge1xuXHRcdFx0bWF4aW11bSArPSAxO1xuXHRcdFx0cG9zaXRpb24gPSAocG9zaXRpb24gJSBtYXhpbXVtICsgbWF4aW11bSkgJSBtYXhpbXVtO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwb3NpdGlvbiA9IE1hdGgubWF4KG1pbmltdW0sIE1hdGgubWluKG1heGltdW0sIHBvc2l0aW9uKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zcGVlZCh0aGlzLmR1cmF0aW9uKGN1cnJlbnQsIHBvc2l0aW9uLCBzcGVlZCkpO1xuXHRcdHRoaXMuY3VycmVudChwb3NpdGlvbik7XG5cblx0XHRpZiAodGhpcy4kZWxlbWVudC5pcygnOnZpc2libGUnKSkge1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFNsaWRlcyB0byB0aGUgbmV4dCBpdGVtLlxuXHQgKiBAcHVibGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHJhbnNpdGlvbi5cblx0ICovXG5cdE93bC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKHNwZWVkKSB7XG5cdFx0c3BlZWQgPSBzcGVlZCB8fCBmYWxzZTtcblx0XHR0aGlzLnRvKHRoaXMucmVsYXRpdmUodGhpcy5jdXJyZW50KCkpICsgMSwgc3BlZWQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTbGlkZXMgdG8gdGhlIHByZXZpb3VzIGl0ZW0uXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZF0gLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2l0aW9uLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24oc3BlZWQpIHtcblx0XHRzcGVlZCA9IHNwZWVkIHx8IGZhbHNlO1xuXHRcdHRoaXMudG8odGhpcy5yZWxhdGl2ZSh0aGlzLmN1cnJlbnQoKSkgLSAxLCBzcGVlZCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgdGhlIGVuZCBvZiBhbiBhbmltYXRpb24uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5vblRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0Ly8gaWYgY3NzMiBhbmltYXRpb24gdGhlbiBldmVudCBvYmplY3QgaXMgdW5kZWZpbmVkXG5cdFx0aWYgKGV2ZW50ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0XHQvLyBDYXRjaCBvbmx5IG93bC1zdGFnZSB0cmFuc2l0aW9uRW5kIGV2ZW50XG5cdFx0XHRpZiAoKGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50IHx8IGV2ZW50Lm9yaWdpbmFsVGFyZ2V0KSAhPT0gdGhpcy4kc3RhZ2UuZ2V0KDApKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmxlYXZlKCdhbmltYXRpbmcnKTtcblx0XHR0aGlzLnRyaWdnZXIoJ3RyYW5zbGF0ZWQnKTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0cyB2aWV3cG9ydCB3aWR0aC5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gVGhlIHdpZHRoIGluIHBpeGVsLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS52aWV3cG9ydCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB3aWR0aDtcblx0XHRpZiAodGhpcy5vcHRpb25zLnJlc3BvbnNpdmVCYXNlRWxlbWVudCAhPT0gd2luZG93KSB7XG5cdFx0XHR3aWR0aCA9ICQodGhpcy5vcHRpb25zLnJlc3BvbnNpdmVCYXNlRWxlbWVudCkud2lkdGgoKTtcblx0XHR9IGVsc2UgaWYgKHdpbmRvdy5pbm5lcldpZHRoKSB7XG5cdFx0XHR3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuXHRcdH0gZWxzZSBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCkge1xuXHRcdFx0d2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93ICdDYW4gbm90IGRldGVjdCB2aWV3cG9ydCB3aWR0aC4nO1xuXHRcdH1cblx0XHRyZXR1cm4gd2lkdGg7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlcGxhY2VzIHRoZSBjdXJyZW50IGNvbnRlbnQuXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudHxqUXVlcnl8U3RyaW5nfSBjb250ZW50IC0gVGhlIG5ldyBjb250ZW50LlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24oY29udGVudCkge1xuXHRcdHRoaXMuJHN0YWdlLmVtcHR5KCk7XG5cdFx0dGhpcy5faXRlbXMgPSBbXTtcblxuXHRcdGlmIChjb250ZW50KSB7XG5cdFx0XHRjb250ZW50ID0gKGNvbnRlbnQgaW5zdGFuY2VvZiBqUXVlcnkpID8gY29udGVudCA6ICQoY29udGVudCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuc2V0dGluZ3MubmVzdGVkSXRlbVNlbGVjdG9yKSB7XG5cdFx0XHRjb250ZW50ID0gY29udGVudC5maW5kKCcuJyArIHRoaXMuc2V0dGluZ3MubmVzdGVkSXRlbVNlbGVjdG9yKTtcblx0XHR9XG5cblx0XHRjb250ZW50LmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLm5vZGVUeXBlID09PSAxO1xuXHRcdH0pLmVhY2goJC5wcm94eShmdW5jdGlvbihpbmRleCwgaXRlbSkge1xuXHRcdFx0aXRlbSA9IHRoaXMucHJlcGFyZShpdGVtKTtcblx0XHRcdHRoaXMuJHN0YWdlLmFwcGVuZChpdGVtKTtcblx0XHRcdHRoaXMuX2l0ZW1zLnB1c2goaXRlbSk7XG5cdFx0XHR0aGlzLl9tZXJnZXJzLnB1c2goaXRlbS5maW5kKCdbZGF0YS1tZXJnZV0nKS5hZGRCYWNrKCdbZGF0YS1tZXJnZV0nKS5hdHRyKCdkYXRhLW1lcmdlJykgKiAxIHx8IDEpO1xuXHRcdH0sIHRoaXMpKTtcblxuXHRcdHRoaXMucmVzZXQodGhpcy5pc051bWVyaWModGhpcy5zZXR0aW5ncy5zdGFydFBvc2l0aW9uKSA/IHRoaXMuc2V0dGluZ3Muc3RhcnRQb3NpdGlvbiA6IDApO1xuXG5cdFx0dGhpcy5pbnZhbGlkYXRlKCdpdGVtcycpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGl0ZW0uXG5cdCAqIEB0b2RvIFVzZSBgaXRlbWAgaW5zdGVhZCBvZiBgY29udGVudGAgZm9yIHRoZSBldmVudCBhcmd1bWVudHMuXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudHxqUXVlcnl8U3RyaW5nfSBjb250ZW50IC0gVGhlIGl0ZW0gY29udGVudCB0byBhZGQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb25dIC0gVGhlIHJlbGF0aXZlIHBvc2l0aW9uIGF0IHdoaWNoIHRvIGluc2VydCB0aGUgaXRlbSBvdGhlcndpc2UgdGhlIGl0ZW0gd2lsbCBiZSBhZGRlZCB0byB0aGUgZW5kLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihjb250ZW50LCBwb3NpdGlvbikge1xuXHRcdHZhciBjdXJyZW50ID0gdGhpcy5yZWxhdGl2ZSh0aGlzLl9jdXJyZW50KTtcblxuXHRcdHBvc2l0aW9uID0gcG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IHRoaXMuX2l0ZW1zLmxlbmd0aCA6IHRoaXMubm9ybWFsaXplKHBvc2l0aW9uLCB0cnVlKTtcblx0XHRjb250ZW50ID0gY29udGVudCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRlbnQgOiAkKGNvbnRlbnQpO1xuXG5cdFx0dGhpcy50cmlnZ2VyKCdhZGQnLCB7IGNvbnRlbnQ6IGNvbnRlbnQsIHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcblxuXHRcdGNvbnRlbnQgPSB0aGlzLnByZXBhcmUoY29udGVudCk7XG5cblx0XHRpZiAodGhpcy5faXRlbXMubGVuZ3RoID09PSAwIHx8IHBvc2l0aW9uID09PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcblx0XHRcdHRoaXMuX2l0ZW1zLmxlbmd0aCA9PT0gMCAmJiB0aGlzLiRzdGFnZS5hcHBlbmQoY29udGVudCk7XG5cdFx0XHR0aGlzLl9pdGVtcy5sZW5ndGggIT09IDAgJiYgdGhpcy5faXRlbXNbcG9zaXRpb24gLSAxXS5hZnRlcihjb250ZW50KTtcblx0XHRcdHRoaXMuX2l0ZW1zLnB1c2goY29udGVudCk7XG5cdFx0XHR0aGlzLl9tZXJnZXJzLnB1c2goY29udGVudC5maW5kKCdbZGF0YS1tZXJnZV0nKS5hZGRCYWNrKCdbZGF0YS1tZXJnZV0nKS5hdHRyKCdkYXRhLW1lcmdlJykgKiAxIHx8IDEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9pdGVtc1twb3NpdGlvbl0uYmVmb3JlKGNvbnRlbnQpO1xuXHRcdFx0dGhpcy5faXRlbXMuc3BsaWNlKHBvc2l0aW9uLCAwLCBjb250ZW50KTtcblx0XHRcdHRoaXMuX21lcmdlcnMuc3BsaWNlKHBvc2l0aW9uLCAwLCBjb250ZW50LmZpbmQoJ1tkYXRhLW1lcmdlXScpLmFkZEJhY2soJ1tkYXRhLW1lcmdlXScpLmF0dHIoJ2RhdGEtbWVyZ2UnKSAqIDEgfHwgMSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5faXRlbXNbY3VycmVudF0gJiYgdGhpcy5yZXNldCh0aGlzLl9pdGVtc1tjdXJyZW50XS5pbmRleCgpKTtcblxuXHRcdHRoaXMuaW52YWxpZGF0ZSgnaXRlbXMnKTtcblxuXHRcdHRoaXMudHJpZ2dlcignYWRkZWQnLCB7IGNvbnRlbnQ6IGNvbnRlbnQsIHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbiBpdGVtIGJ5IGl0cyBwb3NpdGlvbi5cblx0ICogQHRvZG8gVXNlIGBpdGVtYCBpbnN0ZWFkIG9mIGBjb250ZW50YCBmb3IgdGhlIGV2ZW50IGFyZ3VtZW50cy5cblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBUaGUgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGl0ZW0gdG8gcmVtb3ZlLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuXHRcdHBvc2l0aW9uID0gdGhpcy5ub3JtYWxpemUocG9zaXRpb24sIHRydWUpO1xuXG5cdFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnRyaWdnZXIoJ3JlbW92ZScsIHsgY29udGVudDogdGhpcy5faXRlbXNbcG9zaXRpb25dLCBwb3NpdGlvbjogcG9zaXRpb24gfSk7XG5cblx0XHR0aGlzLl9pdGVtc1twb3NpdGlvbl0ucmVtb3ZlKCk7XG5cdFx0dGhpcy5faXRlbXMuc3BsaWNlKHBvc2l0aW9uLCAxKTtcblx0XHR0aGlzLl9tZXJnZXJzLnNwbGljZShwb3NpdGlvbiwgMSk7XG5cblx0XHR0aGlzLmludmFsaWRhdGUoJ2l0ZW1zJyk7XG5cblx0XHR0aGlzLnRyaWdnZXIoJ3JlbW92ZWQnLCB7IGNvbnRlbnQ6IG51bGwsIHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcblx0fTtcblxuXHQvKipcblx0ICogUHJlbG9hZHMgaW1hZ2VzIHdpdGggYXV0byB3aWR0aC5cblx0ICogQHRvZG8gUmVwbGFjZSBieSBhIG1vcmUgZ2VuZXJpYyBhcHByb2FjaFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLnByZWxvYWRBdXRvV2lkdGhJbWFnZXMgPSBmdW5jdGlvbihpbWFnZXMpIHtcblx0XHRpbWFnZXMuZWFjaCgkLnByb3h5KGZ1bmN0aW9uKGksIGVsZW1lbnQpIHtcblx0XHRcdHRoaXMuZW50ZXIoJ3ByZS1sb2FkaW5nJyk7XG5cdFx0XHRlbGVtZW50ID0gJChlbGVtZW50KTtcblx0XHRcdCQobmV3IEltYWdlKCkpLm9uZSgnbG9hZCcsICQucHJveHkoZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRlbGVtZW50LmF0dHIoJ3NyYycsIGUudGFyZ2V0LnNyYyk7XG5cdFx0XHRcdGVsZW1lbnQuY3NzKCdvcGFjaXR5JywgMSk7XG5cdFx0XHRcdHRoaXMubGVhdmUoJ3ByZS1sb2FkaW5nJyk7XG5cdFx0XHRcdCF0aGlzLmlzKCdwcmUtbG9hZGluZycpICYmICF0aGlzLmlzKCdpbml0aWFsaXppbmcnKSAmJiB0aGlzLnJlZnJlc2goKTtcblx0XHRcdH0sIHRoaXMpKS5hdHRyKCdzcmMnLCBlbGVtZW50LmF0dHIoJ3NyYycpIHx8IGVsZW1lbnQuYXR0cignZGF0YS1zcmMnKSB8fCBlbGVtZW50LmF0dHIoJ2RhdGEtc3JjLXJldGluYScpKTtcblx0XHR9LCB0aGlzKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERlc3Ryb3lzIHRoZSBjYXJvdXNlbC5cblx0ICogQHB1YmxpY1xuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cblx0XHR0aGlzLiRlbGVtZW50Lm9mZignLm93bC5jb3JlJyk7XG5cdFx0dGhpcy4kc3RhZ2Uub2ZmKCcub3dsLmNvcmUnKTtcblx0XHQkKGRvY3VtZW50KS5vZmYoJy5vd2wuY29yZScpO1xuXG5cdFx0aWYgKHRoaXMuc2V0dGluZ3MucmVzcG9uc2l2ZSAhPT0gZmFsc2UpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lcik7XG5cdFx0XHR0aGlzLm9mZih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9oYW5kbGVycy5vblRocm90dGxlZFJlc2l6ZSk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9wbHVnaW5zKSB7XG5cdFx0XHR0aGlzLl9wbHVnaW5zW2ldLmRlc3Ryb3koKTtcblx0XHR9XG5cblx0XHR0aGlzLiRzdGFnZS5jaGlsZHJlbignLmNsb25lZCcpLnJlbW92ZSgpO1xuXG5cdFx0dGhpcy4kc3RhZ2UudW53cmFwKCk7XG5cdFx0dGhpcy4kc3RhZ2UuY2hpbGRyZW4oKS5jb250ZW50cygpLnVud3JhcCgpO1xuXHRcdHRoaXMuJHN0YWdlLmNoaWxkcmVuKCkudW53cmFwKCk7XG5cblx0XHR0aGlzLiRlbGVtZW50XG5cdFx0XHQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLnJlZnJlc2hDbGFzcylcblx0XHRcdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMubG9hZGluZ0NsYXNzKVxuXHRcdFx0LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5sb2FkZWRDbGFzcylcblx0XHRcdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMucnRsQ2xhc3MpXG5cdFx0XHQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmRyYWdDbGFzcylcblx0XHRcdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZ3JhYkNsYXNzKVxuXHRcdFx0LmF0dHIoJ2NsYXNzJywgdGhpcy4kZWxlbWVudC5hdHRyKCdjbGFzcycpLnJlcGxhY2UobmV3IFJlZ0V4cCh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZUNsYXNzICsgJy1cXFxcUytcXFxccycsICdnJyksICcnKSlcblx0XHRcdC5yZW1vdmVEYXRhKCdvd2wuY2Fyb3VzZWwnKTtcblx0fTtcblxuXHQvKipcblx0ICogT3BlcmF0b3JzIHRvIGNhbGN1bGF0ZSByaWdodC10by1sZWZ0IGFuZCBsZWZ0LXRvLXJpZ2h0LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYV0gLSBUaGUgbGVmdCBzaWRlIG9wZXJhbmQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbb10gLSBUaGUgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYl0gLSBUaGUgcmlnaHQgc2lkZSBvcGVyYW5kLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5vcCA9IGZ1bmN0aW9uKGEsIG8sIGIpIHtcblx0XHR2YXIgcnRsID0gdGhpcy5zZXR0aW5ncy5ydGw7XG5cdFx0c3dpdGNoIChvKSB7XG5cdFx0XHRjYXNlICc8Jzpcblx0XHRcdFx0cmV0dXJuIHJ0bCA/IGEgPiBiIDogYSA8IGI7XG5cdFx0XHRjYXNlICc+Jzpcblx0XHRcdFx0cmV0dXJuIHJ0bCA/IGEgPCBiIDogYSA+IGI7XG5cdFx0XHRjYXNlICc+PSc6XG5cdFx0XHRcdHJldHVybiBydGwgPyBhIDw9IGIgOiBhID49IGI7XG5cdFx0XHRjYXNlICc8PSc6XG5cdFx0XHRcdHJldHVybiBydGwgPyBhID49IGIgOiBhIDw9IGI7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEF0dGFjaGVzIHRvIGFuIGludGVybmFsIGV2ZW50LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZXZlbnQgc291cmNlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgLSBUaGUgZXZlbnQgbmFtZS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgZXZlbnQgaGFuZGxlciB0byBhdHRhY2guXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FwdHVyZSAtIFdldGhlciB0aGUgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQgYXQgdGhlIGNhcHR1cmluZyBwaGFzZSBvciBub3QuXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnQsIGxpc3RlbmVyLCBjYXB0dXJlKSB7XG5cdFx0aWYgKGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHRcdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgY2FwdHVyZSk7XG5cdFx0fSBlbHNlIGlmIChlbGVtZW50LmF0dGFjaEV2ZW50KSB7XG5cdFx0XHRlbGVtZW50LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRGV0YWNoZXMgZnJvbSBhbiBpbnRlcm5hbCBldmVudC5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIGV2ZW50IHNvdXJjZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IC0gVGhlIGV2ZW50IG5hbWUuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGF0dGFjaGVkIGV2ZW50IGhhbmRsZXIgdG8gZGV0YWNoLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmUgLSBXZXRoZXIgdGhlIGF0dGFjaGVkIGV2ZW50IGhhbmRsZXIgd2FzIHJlZ2lzdGVyZWQgYXMgYSBjYXB0dXJpbmcgbGlzdGVuZXIgb3Igbm90LlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbihlbGVtZW50LCBldmVudCwgbGlzdGVuZXIsIGNhcHR1cmUpIHtcblx0XHRpZiAoZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG5cdFx0XHRlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBjYXB0dXJlKTtcblx0XHR9IGVsc2UgaWYgKGVsZW1lbnQuZGV0YWNoRXZlbnQpIHtcblx0XHRcdGVsZW1lbnQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUcmlnZ2VycyBhIHB1YmxpYyBldmVudC5cblx0ICogQHRvZG8gUmVtb3ZlIGBzdGF0dXNgLCBgcmVsYXRlZFRhcmdldGAgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSBldmVudCBuYW1lLlxuXHQgKiBAcGFyYW0geyp9IFtkYXRhPW51bGxdIC0gVGhlIGV2ZW50IGRhdGEuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZXNwYWNlPWNhcm91c2VsXSAtIFRoZSBldmVudCBuYW1lc3BhY2UuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbc3RhdGVdIC0gVGhlIHN0YXRlIHdoaWNoIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2VudGVyPWZhbHNlXSAtIEluZGljYXRlcyBpZiB0aGUgY2FsbCBlbnRlcnMgdGhlIHNwZWNpZmllZCBzdGF0ZSBvciBub3QuXG5cdCAqIEByZXR1cm5zIHtFdmVudH0gLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24obmFtZSwgZGF0YSwgbmFtZXNwYWNlLCBzdGF0ZSwgZW50ZXIpIHtcblx0XHR2YXIgc3RhdHVzID0ge1xuXHRcdFx0aXRlbTogeyBjb3VudDogdGhpcy5faXRlbXMubGVuZ3RoLCBpbmRleDogdGhpcy5jdXJyZW50KCkgfVxuXHRcdH0sIGhhbmRsZXIgPSAkLmNhbWVsQ2FzZShcblx0XHRcdCQuZ3JlcChbICdvbicsIG5hbWUsIG5hbWVzcGFjZSBdLCBmdW5jdGlvbih2KSB7IHJldHVybiB2IH0pXG5cdFx0XHRcdC5qb2luKCctJykudG9Mb3dlckNhc2UoKVxuXHRcdCksIGV2ZW50ID0gJC5FdmVudChcblx0XHRcdFsgbmFtZSwgJ293bCcsIG5hbWVzcGFjZSB8fCAnY2Fyb3VzZWwnIF0uam9pbignLicpLnRvTG93ZXJDYXNlKCksXG5cdFx0XHQkLmV4dGVuZCh7IHJlbGF0ZWRUYXJnZXQ6IHRoaXMgfSwgc3RhdHVzLCBkYXRhKVxuXHRcdCk7XG5cblx0XHRpZiAoIXRoaXMuX3N1cHJlc3NbbmFtZV0pIHtcblx0XHRcdCQuZWFjaCh0aGlzLl9wbHVnaW5zLCBmdW5jdGlvbihuYW1lLCBwbHVnaW4pIHtcblx0XHRcdFx0aWYgKHBsdWdpbi5vblRyaWdnZXIpIHtcblx0XHRcdFx0XHRwbHVnaW4ub25UcmlnZ2VyKGV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMucmVnaXN0ZXIoeyB0eXBlOiBPd2wuVHlwZS5FdmVudCwgbmFtZTogbmFtZSB9KTtcblx0XHRcdHRoaXMuJGVsZW1lbnQudHJpZ2dlcihldmVudCk7XG5cblx0XHRcdGlmICh0aGlzLnNldHRpbmdzICYmIHR5cGVvZiB0aGlzLnNldHRpbmdzW2hhbmRsZXJdID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHRoaXMuc2V0dGluZ3NbaGFuZGxlcl0uY2FsbCh0aGlzLCBldmVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbnRlcnMgYSBzdGF0ZS5cblx0ICogQHBhcmFtIG5hbWUgLSBUaGUgc3RhdGUgbmFtZS5cblx0ICovXG5cdE93bC5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG5cdFx0JC5lYWNoKFsgbmFtZSBdLmNvbmNhdCh0aGlzLl9zdGF0ZXMudGFnc1tuYW1lXSB8fCBbXSksICQucHJveHkoZnVuY3Rpb24oaSwgbmFtZSkge1xuXHRcdFx0aWYgKHRoaXMuX3N0YXRlcy5jdXJyZW50W25hbWVdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5fc3RhdGVzLmN1cnJlbnRbbmFtZV0gPSAwO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9zdGF0ZXMuY3VycmVudFtuYW1lXSsrO1xuXHRcdH0sIHRoaXMpKTtcblx0fTtcblxuXHQvKipcblx0ICogTGVhdmVzIGEgc3RhdGUuXG5cdCAqIEBwYXJhbSBuYW1lIC0gVGhlIHN0YXRlIG5hbWUuXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLmxlYXZlID0gZnVuY3Rpb24obmFtZSkge1xuXHRcdCQuZWFjaChbIG5hbWUgXS5jb25jYXQodGhpcy5fc3RhdGVzLnRhZ3NbbmFtZV0gfHwgW10pLCAkLnByb3h5KGZ1bmN0aW9uKGksIG5hbWUpIHtcblx0XHRcdHRoaXMuX3N0YXRlcy5jdXJyZW50W25hbWVdLS07XG5cdFx0fSwgdGhpcykpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYW4gZXZlbnQgb3Igc3RhdGUuXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBldmVudCBvciBzdGF0ZSB0byByZWdpc3Rlci5cblx0ICovXG5cdE93bC5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbihvYmplY3QpIHtcblx0XHRpZiAob2JqZWN0LnR5cGUgPT09IE93bC5UeXBlLkV2ZW50KSB7XG5cdFx0XHRpZiAoISQuZXZlbnQuc3BlY2lhbFtvYmplY3QubmFtZV0pIHtcblx0XHRcdFx0JC5ldmVudC5zcGVjaWFsW29iamVjdC5uYW1lXSA9IHt9O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoISQuZXZlbnQuc3BlY2lhbFtvYmplY3QubmFtZV0ub3dsKSB7XG5cdFx0XHRcdHZhciBfZGVmYXVsdCA9ICQuZXZlbnQuc3BlY2lhbFtvYmplY3QubmFtZV0uX2RlZmF1bHQ7XG5cdFx0XHRcdCQuZXZlbnQuc3BlY2lhbFtvYmplY3QubmFtZV0uX2RlZmF1bHQgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0aWYgKF9kZWZhdWx0ICYmIF9kZWZhdWx0LmFwcGx5ICYmICghZS5uYW1lc3BhY2UgfHwgZS5uYW1lc3BhY2UuaW5kZXhPZignb3dsJykgPT09IC0xKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIF9kZWZhdWx0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBlLm5hbWVzcGFjZSAmJiBlLm5hbWVzcGFjZS5pbmRleE9mKCdvd2wnKSA+IC0xO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHQkLmV2ZW50LnNwZWNpYWxbb2JqZWN0Lm5hbWVdLm93bCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChvYmplY3QudHlwZSA9PT0gT3dsLlR5cGUuU3RhdGUpIHtcblx0XHRcdGlmICghdGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdKSB7XG5cdFx0XHRcdHRoaXMuX3N0YXRlcy50YWdzW29iamVjdC5uYW1lXSA9IG9iamVjdC50YWdzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdID0gdGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdLmNvbmNhdChvYmplY3QudGFncyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3N0YXRlcy50YWdzW29iamVjdC5uYW1lXSA9ICQuZ3JlcCh0aGlzLl9zdGF0ZXMudGFnc1tvYmplY3QubmFtZV0sICQucHJveHkoZnVuY3Rpb24odGFnLCBpKSB7XG5cdFx0XHRcdHJldHVybiAkLmluQXJyYXkodGFnLCB0aGlzLl9zdGF0ZXMudGFnc1tvYmplY3QubmFtZV0pID09PSBpO1xuXHRcdFx0fSwgdGhpcykpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogU3VwcHJlc3NlcyBldmVudHMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gZXZlbnRzIC0gVGhlIGV2ZW50cyB0byBzdXBwcmVzcy5cblx0ICovXG5cdE93bC5wcm90b3R5cGUuc3VwcHJlc3MgPSBmdW5jdGlvbihldmVudHMpIHtcblx0XHQkLmVhY2goZXZlbnRzLCAkLnByb3h5KGZ1bmN0aW9uKGluZGV4LCBldmVudCkge1xuXHRcdFx0dGhpcy5fc3VwcmVzc1tldmVudF0gPSB0cnVlO1xuXHRcdH0sIHRoaXMpKTtcblx0fTtcblxuXHQvKipcblx0ICogUmVsZWFzZXMgc3VwcHJlc3NlZCBldmVudHMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gZXZlbnRzIC0gVGhlIGV2ZW50cyB0byByZWxlYXNlLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24oZXZlbnRzKSB7XG5cdFx0JC5lYWNoKGV2ZW50cywgJC5wcm94eShmdW5jdGlvbihpbmRleCwgZXZlbnQpIHtcblx0XHRcdGRlbGV0ZSB0aGlzLl9zdXByZXNzW2V2ZW50XTtcblx0XHR9LCB0aGlzKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldHMgdW5pZmllZCBwb2ludGVyIGNvb3JkaW5hdGVzIGZyb20gZXZlbnQuXG5cdCAqIEB0b2RvICMyNjFcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge0V2ZW50fSAtIFRoZSBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnQuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IC0gQ29udGFpbnMgYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb2ludGVyIHBvc2l0aW9uLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5wb2ludGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgcmVzdWx0ID0geyB4OiBudWxsLCB5OiBudWxsIH07XG5cblx0XHRldmVudCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQgfHwgZXZlbnQgfHwgd2luZG93LmV2ZW50O1xuXG5cdFx0ZXZlbnQgPSBldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID9cblx0XHRcdGV2ZW50LnRvdWNoZXNbMF0gOiBldmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggP1xuXHRcdFx0XHRldmVudC5jaGFuZ2VkVG91Y2hlc1swXSA6IGV2ZW50O1xuXG5cdFx0aWYgKGV2ZW50LnBhZ2VYKSB7XG5cdFx0XHRyZXN1bHQueCA9IGV2ZW50LnBhZ2VYO1xuXHRcdFx0cmVzdWx0LnkgPSBldmVudC5wYWdlWTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0LnggPSBldmVudC5jbGllbnRYO1xuXHRcdFx0cmVzdWx0LnkgPSBldmVudC5jbGllbnRZO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGlucHV0IGlzIGEgTnVtYmVyIG9yIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGEgTnVtYmVyXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfE9iamVjdHxBcnJheXxCb29sZWFufFJlZ0V4cHxGdW5jdGlvbnxTeW1ib2x9IC0gVGhlIGlucHV0IHRvIGJlIHRlc3RlZFxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSBBbiBpbmRpY2F0aW9uIGlmIHRoZSBpbnB1dCBpcyBhIE51bWJlciBvciBjYW4gYmUgY29lcmNlZCB0byBhIE51bWJlclxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5pc051bWVyaWMgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0XHRyZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobnVtYmVyKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGRpZmZlcmVuY2Ugb2YgdHdvIHZlY3RvcnMuXG5cdCAqIEB0b2RvICMyNjFcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gLSBUaGUgZmlyc3QgdmVjdG9yLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gLSBUaGUgc2Vjb25kIHZlY3Rvci5cblx0ICogQHJldHVybnMge09iamVjdH0gLSBUaGUgZGlmZmVyZW5jZS5cblx0ICovXG5cdE93bC5wcm90b3R5cGUuZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGZpcnN0LCBzZWNvbmQpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogZmlyc3QueCAtIHNlY29uZC54LFxuXHRcdFx0eTogZmlyc3QueSAtIHNlY29uZC55XG5cdFx0fTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIGpRdWVyeSBQbHVnaW4gZm9yIHRoZSBPd2wgQ2Fyb3VzZWxcblx0ICogQHRvZG8gTmF2aWdhdGlvbiBwbHVnaW4gYG5leHRgIGFuZCBgcHJldmBcblx0ICogQHB1YmxpY1xuXHQgKi9cblx0JC5mbi5vd2xDYXJvdXNlbCA9IGZ1bmN0aW9uKG9wdGlvbikge1xuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgJHRoaXMgPSAkKHRoaXMpLFxuXHRcdFx0XHRkYXRhID0gJHRoaXMuZGF0YSgnb3dsLmNhcm91c2VsJyk7XG5cblx0XHRcdGlmICghZGF0YSkge1xuXHRcdFx0XHRkYXRhID0gbmV3IE93bCh0aGlzLCB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvbik7XG5cdFx0XHRcdCR0aGlzLmRhdGEoJ293bC5jYXJvdXNlbCcsIGRhdGEpO1xuXG5cdFx0XHRcdCQuZWFjaChbXG5cdFx0XHRcdFx0J25leHQnLCAncHJldicsICd0bycsICdkZXN0cm95JywgJ3JlZnJlc2gnLCAncmVwbGFjZScsICdhZGQnLCAncmVtb3ZlJ1xuXHRcdFx0XHRdLCBmdW5jdGlvbihpLCBldmVudCkge1xuXHRcdFx0XHRcdGRhdGEucmVnaXN0ZXIoeyB0eXBlOiBPd2wuVHlwZS5FdmVudCwgbmFtZTogZXZlbnQgfSk7XG5cdFx0XHRcdFx0ZGF0YS4kZWxlbWVudC5vbihldmVudCArICcub3dsLmNhcm91c2VsLmNvcmUnLCAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRcdGlmIChlLm5hbWVzcGFjZSAmJiBlLnJlbGF0ZWRUYXJnZXQgIT09IHRoaXMpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zdXBwcmVzcyhbIGV2ZW50IF0pO1xuXHRcdFx0XHRcdFx0XHRkYXRhW2V2ZW50XS5hcHBseSh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnJlbGVhc2UoWyBldmVudCBdKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCBkYXRhKSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJyAmJiBvcHRpb24uY2hhckF0KDApICE9PSAnXycpIHtcblx0XHRcdFx0ZGF0YVtvcHRpb25dLmFwcGx5KGRhdGEsIGFyZ3MpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgY29uc3RydWN0b3IgZm9yIHRoZSBqUXVlcnkgUGx1Z2luXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdCQuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IgPSBPd2w7XG5cbn0pKHdpbmRvdy5aZXB0byB8fCB3aW5kb3cualF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcbiIsIi8qXG4gICAgU3RhY2tCbHVyIC0gYSBmYXN0IGFsbW9zdCBHYXVzc2lhbiBCbHVyIEZvciBDYW52YXNcblxuICAgIFZlcnNpb246ICAgICAwLjVcbiAgICBBdXRob3I6ICAgICAgICBNYXJpbyBLbGluZ2VtYW5uXG4gICAgQ29udGFjdDogICAgIG1hcmlvQHF1YXNpbW9uZG8uY29tXG4gICAgV2Vic2l0ZTogICAgaHR0cDovL3d3dy5xdWFzaW1vbmRvLmNvbS9TdGFja0JsdXJGb3JDYW52YXNcbiAgICBUd2l0dGVyOiAgICBAcXVhc2ltb25kb1xuXG4gICAgSW4gY2FzZSB5b3UgZmluZCB0aGlzIGNsYXNzIHVzZWZ1bCAtIGVzcGVjaWFsbHkgaW4gY29tbWVyY2lhbCBwcm9qZWN0cyAtXG4gICAgSSBhbSBub3QgdG90YWxseSB1bmhhcHB5IGZvciBhIHNtYWxsIGRvbmF0aW9uIHRvIG15IFBheVBhbCBhY2NvdW50XG4gICAgbWFyaW9AcXVhc2ltb25kby5kZVxuXG4gICAgT3Igc3VwcG9ydCBtZSBvbiBmbGF0dHI6XG4gICAgaHR0cHM6Ly9mbGF0dHIuY29tL3RoaW5nLzcyNzkxL1N0YWNrQmx1ci1hLWZhc3QtYWxtb3N0LUdhdXNzaWFuLUJsdXItRWZmZWN0LWZvci1DYW52YXNKYXZhc2NyaXB0XG5cbiAgICBDb3B5cmlnaHQgKGMpIDIwMTAgTWFyaW8gS2xpbmdlbWFublxuXG4gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICAgIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICAgIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICAgIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gICAgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAgICBjb25kaXRpb25zOlxuXG4gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gICAgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICAgIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuICAgIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICAgIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAgICBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gICAgKi9cblxuXG52YXIgbXVsX3RhYmxlID0gW1xuICAgIDUxMiw1MTIsNDU2LDUxMiwzMjgsNDU2LDMzNSw1MTIsNDA1LDMyOCwyNzEsNDU2LDM4OCwzMzUsMjkyLDUxMixcbiAgICA0NTQsNDA1LDM2NCwzMjgsMjk4LDI3MSw0OTYsNDU2LDQyMCwzODgsMzYwLDMzNSwzMTIsMjkyLDI3Myw1MTIsXG4gICAgNDgyLDQ1NCw0MjgsNDA1LDM4MywzNjQsMzQ1LDMyOCwzMTIsMjk4LDI4NCwyNzEsMjU5LDQ5Niw0NzUsNDU2LFxuICAgIDQzNyw0MjAsNDA0LDM4OCwzNzQsMzYwLDM0NywzMzUsMzIzLDMxMiwzMDIsMjkyLDI4MiwyNzMsMjY1LDUxMixcbiAgICA0OTcsNDgyLDQ2OCw0NTQsNDQxLDQyOCw0MTcsNDA1LDM5NCwzODMsMzczLDM2NCwzNTQsMzQ1LDMzNywzMjgsXG4gICAgMzIwLDMxMiwzMDUsMjk4LDI5MSwyODQsMjc4LDI3MSwyNjUsMjU5LDUwNyw0OTYsNDg1LDQ3NSw0NjUsNDU2LFxuICAgIDQ0Niw0MzcsNDI4LDQyMCw0MTIsNDA0LDM5NiwzODgsMzgxLDM3NCwzNjcsMzYwLDM1NCwzNDcsMzQxLDMzNSxcbiAgICAzMjksMzIzLDMxOCwzMTIsMzA3LDMwMiwyOTcsMjkyLDI4NywyODIsMjc4LDI3MywyNjksMjY1LDI2MSw1MTIsXG4gICAgNTA1LDQ5Nyw0ODksNDgyLDQ3NSw0NjgsNDYxLDQ1NCw0NDcsNDQxLDQzNSw0MjgsNDIyLDQxNyw0MTEsNDA1LFxuICAgIDM5OSwzOTQsMzg5LDM4MywzNzgsMzczLDM2OCwzNjQsMzU5LDM1NCwzNTAsMzQ1LDM0MSwzMzcsMzMyLDMyOCxcbiAgICAzMjQsMzIwLDMxNiwzMTIsMzA5LDMwNSwzMDEsMjk4LDI5NCwyOTEsMjg3LDI4NCwyODEsMjc4LDI3NCwyNzEsXG4gICAgMjY4LDI2NSwyNjIsMjU5LDI1Nyw1MDcsNTAxLDQ5Niw0OTEsNDg1LDQ4MCw0NzUsNDcwLDQ2NSw0NjAsNDU2LFxuICAgIDQ1MSw0NDYsNDQyLDQzNyw0MzMsNDI4LDQyNCw0MjAsNDE2LDQxMiw0MDgsNDA0LDQwMCwzOTYsMzkyLDM4OCxcbiAgICAzODUsMzgxLDM3NywzNzQsMzcwLDM2NywzNjMsMzYwLDM1NywzNTQsMzUwLDM0NywzNDQsMzQxLDMzOCwzMzUsXG4gICAgMzMyLDMyOSwzMjYsMzIzLDMyMCwzMTgsMzE1LDMxMiwzMTAsMzA3LDMwNCwzMDIsMjk5LDI5NywyOTQsMjkyLFxuICAgIDI4OSwyODcsMjg1LDI4MiwyODAsMjc4LDI3NSwyNzMsMjcxLDI2OSwyNjcsMjY1LDI2MywyNjEsMjU5XTtcblxuXG52YXIgc2hnX3RhYmxlID0gW1xuICAgIDksIDExLCAxMiwgMTMsIDEzLCAxNCwgMTQsIDE1LCAxNSwgMTUsIDE1LCAxNiwgMTYsIDE2LCAxNiwgMTcsXG4gICAgMTcsIDE3LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTksXG4gICAgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDIwLCAyMCwgMjAsXG4gICAgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjEsXG4gICAgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsXG4gICAgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsXG4gICAgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsXG4gICAgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjMsXG4gICAgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsXG4gICAgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsXG4gICAgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsXG4gICAgMjMsIDIzLCAyMywgMjMsIDIzLCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsXG4gICAgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsXG4gICAgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsXG4gICAgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsXG4gICAgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCBdO1xuXG5cbmZ1bmN0aW9uIHByb2Nlc3NJbWFnZShpbWcsIGNhbnZhcywgcmFkaXVzLCBibHVyQWxwaGFDaGFubmVsKVxue1xuICAgIGlmICh0eXBlb2YoaW1nKSA9PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgaW1nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaW1nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmICFpbWcgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHcgPSBpbWcubmF0dXJhbFdpZHRoO1xuICAgIHZhciBoID0gaW1nLm5hdHVyYWxIZWlnaHQ7XG5cbiAgICBpZiAodHlwZW9mKGNhbnZhcykgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgIWNhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYW52YXMuc3R5bGUud2lkdGggID0gMTAwICsgJyUnO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSAxMDAgKyAnJSc7XG4gICAgY2FudmFzLndpZHRoID0gdztcbiAgICBjYW52YXMuaGVpZ2h0ID0gaDtcblxuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcblxuICAgIGlmIChpc05hTihyYWRpdXMpIHx8IHJhZGl1cyA8IDEpIHJldHVybjtcblxuICAgIGlmIChibHVyQWxwaGFDaGFubmVsKVxuICAgICAgICBwcm9jZXNzQ2FudmFzUkdCQShjYW52YXMsIDAsIDAsIHcsIGgsIHJhZGl1cyk7XG4gICAgZWxzZVxuICAgICAgICBwcm9jZXNzQ2FudmFzUkdCKGNhbnZhcywgMCwgMCwgdywgaCwgcmFkaXVzKTtcbn1cblxuZnVuY3Rpb24gZ2V0SW1hZ2VEYXRhRnJvbUNhbnZhcyhjYW52YXMsIHRvcF94LCB0b3BfeSwgd2lkdGgsIGhlaWdodClcbntcbiAgICBpZiAodHlwZW9mKGNhbnZhcykgPT0gJ3N0cmluZycpXG4gICAgICAgIHZhciBjYW52YXMgID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2FudmFzKTtcbiAgICBlbHNlIGlmICh0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmICFjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudClcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB2YXIgaW1hZ2VEYXRhO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKHRvcF94LCB0b3BfeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5hYmxlIHRvIGFjY2VzcyBsb2NhbCBpbWFnZSBkYXRhOiBcIiArIGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuYWJsZSB0byBhY2Nlc3MgaW1hZ2UgZGF0YTogXCIgKyBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW1hZ2VEYXRhO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ2FudmFzUkdCQShjYW52YXMsIHRvcF94LCB0b3BfeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKVxue1xuICAgIGlmIChpc05hTihyYWRpdXMpIHx8IHJhZGl1cyA8IDEpIHJldHVybjtcbiAgICByYWRpdXMgfD0gMDtcblxuICAgIHZhciBpbWFnZURhdGEgPSBnZXRJbWFnZURhdGFGcm9tQ2FudmFzKGNhbnZhcywgdG9wX3gsIHRvcF95LCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGltYWdlRGF0YSA9IHByb2Nlc3NJbWFnZURhdGFSR0JBKGltYWdlRGF0YSwgdG9wX3gsIHRvcF95LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpO1xuXG4gICAgY2FudmFzLmdldENvbnRleHQoJzJkJykucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgdG9wX3gsIHRvcF95KTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0ltYWdlRGF0YVJHQkEoaW1hZ2VEYXRhLCB0b3BfeCwgdG9wX3ksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cylcbntcbiAgICB2YXIgcGl4ZWxzID0gaW1hZ2VEYXRhLmRhdGE7XG5cbiAgICB2YXIgeCwgeSwgaSwgcCwgeXAsIHlpLCB5dywgcl9zdW0sIGdfc3VtLCBiX3N1bSwgYV9zdW0sXG4gICAgICAgIHJfb3V0X3N1bSwgZ19vdXRfc3VtLCBiX291dF9zdW0sIGFfb3V0X3N1bSxcbiAgICAgICAgcl9pbl9zdW0sIGdfaW5fc3VtLCBiX2luX3N1bSwgYV9pbl9zdW0sXG4gICAgICAgIHByLCBwZywgcGIsIHBhLCByYnM7XG5cbiAgICB2YXIgZGl2ID0gcmFkaXVzICsgcmFkaXVzICsgMTtcbiAgICB2YXIgdzQgPSB3aWR0aCA8PCAyO1xuICAgIHZhciB3aWR0aE1pbnVzMSAgPSB3aWR0aCAtIDE7XG4gICAgdmFyIGhlaWdodE1pbnVzMSA9IGhlaWdodCAtIDE7XG4gICAgdmFyIHJhZGl1c1BsdXMxICA9IHJhZGl1cyArIDE7XG4gICAgdmFyIHN1bUZhY3RvciA9IHJhZGl1c1BsdXMxICogKHJhZGl1c1BsdXMxICsgMSkgLyAyO1xuXG4gICAgdmFyIHN0YWNrU3RhcnQgPSBuZXcgQmx1clN0YWNrKCk7XG4gICAgdmFyIHN0YWNrID0gc3RhY2tTdGFydDtcbiAgICBmb3IgKGkgPSAxOyBpIDwgZGl2OyBpKyspXG4gICAge1xuICAgICAgICBzdGFjayA9IHN0YWNrLm5leHQgPSBuZXcgQmx1clN0YWNrKCk7XG4gICAgICAgIGlmIChpID09IHJhZGl1c1BsdXMxKSB2YXIgc3RhY2tFbmQgPSBzdGFjaztcbiAgICB9XG4gICAgc3RhY2submV4dCA9IHN0YWNrU3RhcnQ7XG4gICAgdmFyIHN0YWNrSW4gPSBudWxsO1xuICAgIHZhciBzdGFja091dCA9IG51bGw7XG5cbiAgICB5dyA9IHlpID0gMDtcblxuICAgIHZhciBtdWxfc3VtID0gbXVsX3RhYmxlW3JhZGl1c107XG4gICAgdmFyIHNoZ19zdW0gPSBzaGdfdGFibGVbcmFkaXVzXTtcblxuICAgIGZvciAoeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKylcbiAgICB7XG4gICAgICAgIHJfaW5fc3VtID0gZ19pbl9zdW0gPSBiX2luX3N1bSA9IGFfaW5fc3VtID0gcl9zdW0gPSBnX3N1bSA9IGJfc3VtID0gYV9zdW0gPSAwO1xuXG4gICAgICAgIHJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKHByID0gcGl4ZWxzW3lpXSk7XG4gICAgICAgIGdfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKHBnID0gcGl4ZWxzW3lpKzFdKTtcbiAgICAgICAgYl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAocGIgPSBwaXhlbHNbeWkrMl0pO1xuICAgICAgICBhX291dF9zdW0gPSByYWRpdXNQbHVzMSAqIChwYSA9IHBpeGVsc1t5aSszXSk7XG5cbiAgICAgICAgcl9zdW0gKz0gc3VtRmFjdG9yICogcHI7XG4gICAgICAgIGdfc3VtICs9IHN1bUZhY3RvciAqIHBnO1xuICAgICAgICBiX3N1bSArPSBzdW1GYWN0b3IgKiBwYjtcbiAgICAgICAgYV9zdW0gKz0gc3VtRmFjdG9yICogcGE7XG5cbiAgICAgICAgc3RhY2sgPSBzdGFja1N0YXJ0O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByYWRpdXNQbHVzMTsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBzdGFjay5yID0gcHI7XG4gICAgICAgICAgICBzdGFjay5nID0gcGc7XG4gICAgICAgICAgICBzdGFjay5iID0gcGI7XG4gICAgICAgICAgICBzdGFjay5hID0gcGE7XG4gICAgICAgICAgICBzdGFjayA9IHN0YWNrLm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcmFkaXVzUGx1czE7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgcCA9IHlpICsgKCh3aWR0aE1pbnVzMSA8IGkgPyB3aWR0aE1pbnVzMSA6IGkpIDw8IDIpO1xuICAgICAgICAgICAgcl9zdW0gKz0gKHN0YWNrLnIgPSAocHIgPSBwaXhlbHNbcF0pKSAqIChyYnMgPSByYWRpdXNQbHVzMSAtIGkpO1xuICAgICAgICAgICAgZ19zdW0gKz0gKHN0YWNrLmcgPSAocGcgPSBwaXhlbHNbcCsxXSkpICogcmJzO1xuICAgICAgICAgICAgYl9zdW0gKz0gKHN0YWNrLmIgPSAocGIgPSBwaXhlbHNbcCsyXSkpICogcmJzO1xuICAgICAgICAgICAgYV9zdW0gKz0gKHN0YWNrLmEgPSAocGEgPSBwaXhlbHNbcCszXSkpICogcmJzO1xuXG4gICAgICAgICAgICByX2luX3N1bSArPSBwcjtcbiAgICAgICAgICAgIGdfaW5fc3VtICs9IHBnO1xuICAgICAgICAgICAgYl9pbl9zdW0gKz0gcGI7XG4gICAgICAgICAgICBhX2luX3N1bSArPSBwYTtcblxuICAgICAgICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuICAgICAgICB9XG5cblxuICAgICAgICBzdGFja0luID0gc3RhY2tTdGFydDtcbiAgICAgICAgc3RhY2tPdXQgPSBzdGFja0VuZDtcbiAgICAgICAgZm9yICh4ID0gMDsgeCA8IHdpZHRoOyB4KyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBpeGVsc1t5aSszXSA9IHBhID0gKGFfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bTtcbiAgICAgICAgICAgIGlmIChwYSAhPSAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBhID0gMjU1IC8gcGE7XG4gICAgICAgICAgICAgICAgcGl4ZWxzW3lpXSAgID0gKChyX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0pICogcGE7XG4gICAgICAgICAgICAgICAgcGl4ZWxzW3lpKzFdID0gKChnX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0pICogcGE7XG4gICAgICAgICAgICAgICAgcGl4ZWxzW3lpKzJdID0gKChiX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0pICogcGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBpeGVsc1t5aV0gPSBwaXhlbHNbeWkrMV0gPSBwaXhlbHNbeWkrMl0gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByX3N1bSAtPSByX291dF9zdW07XG4gICAgICAgICAgICBnX3N1bSAtPSBnX291dF9zdW07XG4gICAgICAgICAgICBiX3N1bSAtPSBiX291dF9zdW07XG4gICAgICAgICAgICBhX3N1bSAtPSBhX291dF9zdW07XG5cbiAgICAgICAgICAgIHJfb3V0X3N1bSAtPSBzdGFja0luLnI7XG4gICAgICAgICAgICBnX291dF9zdW0gLT0gc3RhY2tJbi5nO1xuICAgICAgICAgICAgYl9vdXRfc3VtIC09IHN0YWNrSW4uYjtcbiAgICAgICAgICAgIGFfb3V0X3N1bSAtPSBzdGFja0luLmE7XG5cbiAgICAgICAgICAgIHAgPSAgKHl3ICsgKChwID0geCArIHJhZGl1cyArIDEpIDwgd2lkdGhNaW51czEgPyBwIDogd2lkdGhNaW51czEpKSA8PCAyO1xuXG4gICAgICAgICAgICByX2luX3N1bSArPSAoc3RhY2tJbi5yID0gcGl4ZWxzW3BdKTtcbiAgICAgICAgICAgIGdfaW5fc3VtICs9IChzdGFja0luLmcgPSBwaXhlbHNbcCsxXSk7XG4gICAgICAgICAgICBiX2luX3N1bSArPSAoc3RhY2tJbi5iID0gcGl4ZWxzW3ArMl0pO1xuICAgICAgICAgICAgYV9pbl9zdW0gKz0gKHN0YWNrSW4uYSA9IHBpeGVsc1twKzNdKTtcblxuICAgICAgICAgICAgcl9zdW0gKz0gcl9pbl9zdW07XG4gICAgICAgICAgICBnX3N1bSArPSBnX2luX3N1bTtcbiAgICAgICAgICAgIGJfc3VtICs9IGJfaW5fc3VtO1xuICAgICAgICAgICAgYV9zdW0gKz0gYV9pbl9zdW07XG5cbiAgICAgICAgICAgIHN0YWNrSW4gPSBzdGFja0luLm5leHQ7XG5cbiAgICAgICAgICAgIHJfb3V0X3N1bSArPSAocHIgPSBzdGFja091dC5yKTtcbiAgICAgICAgICAgIGdfb3V0X3N1bSArPSAocGcgPSBzdGFja091dC5nKTtcbiAgICAgICAgICAgIGJfb3V0X3N1bSArPSAocGIgPSBzdGFja091dC5iKTtcbiAgICAgICAgICAgIGFfb3V0X3N1bSArPSAocGEgPSBzdGFja091dC5hKTtcblxuICAgICAgICAgICAgcl9pbl9zdW0gLT0gcHI7XG4gICAgICAgICAgICBnX2luX3N1bSAtPSBwZztcbiAgICAgICAgICAgIGJfaW5fc3VtIC09IHBiO1xuICAgICAgICAgICAgYV9pbl9zdW0gLT0gcGE7XG5cbiAgICAgICAgICAgIHN0YWNrT3V0ID0gc3RhY2tPdXQubmV4dDtcblxuICAgICAgICAgICAgeWkgKz0gNDtcbiAgICAgICAgfVxuICAgICAgICB5dyArPSB3aWR0aDtcbiAgICB9XG5cblxuICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKVxuICAgIHtcbiAgICAgICAgZ19pbl9zdW0gPSBiX2luX3N1bSA9IGFfaW5fc3VtID0gcl9pbl9zdW0gPSBnX3N1bSA9IGJfc3VtID0gYV9zdW0gPSByX3N1bSA9IDA7XG5cbiAgICAgICAgeWkgPSB4IDw8IDI7XG4gICAgICAgIHJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKHByID0gcGl4ZWxzW3lpXSk7XG4gICAgICAgIGdfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKHBnID0gcGl4ZWxzW3lpKzFdKTtcbiAgICAgICAgYl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAocGIgPSBwaXhlbHNbeWkrMl0pO1xuICAgICAgICBhX291dF9zdW0gPSByYWRpdXNQbHVzMSAqIChwYSA9IHBpeGVsc1t5aSszXSk7XG5cbiAgICAgICAgcl9zdW0gKz0gc3VtRmFjdG9yICogcHI7XG4gICAgICAgIGdfc3VtICs9IHN1bUZhY3RvciAqIHBnO1xuICAgICAgICBiX3N1bSArPSBzdW1GYWN0b3IgKiBwYjtcbiAgICAgICAgYV9zdW0gKz0gc3VtRmFjdG9yICogcGE7XG5cbiAgICAgICAgc3RhY2sgPSBzdGFja1N0YXJ0O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByYWRpdXNQbHVzMTsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBzdGFjay5yID0gcHI7XG4gICAgICAgICAgICBzdGFjay5nID0gcGc7XG4gICAgICAgICAgICBzdGFjay5iID0gcGI7XG4gICAgICAgICAgICBzdGFjay5hID0gcGE7XG4gICAgICAgICAgICBzdGFjayA9IHN0YWNrLm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICB5cCA9IHdpZHRoO1xuXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPD0gcmFkaXVzOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHlpID0gKHlwICsgeCkgPDwgMjtcblxuICAgICAgICAgICAgcl9zdW0gKz0gKHN0YWNrLnIgPSAocHIgPSBwaXhlbHNbeWldKSkgKiAocmJzID0gcmFkaXVzUGx1czEgLSBpKTtcbiAgICAgICAgICAgIGdfc3VtICs9IChzdGFjay5nID0gKHBnID0gcGl4ZWxzW3lpKzFdKSkgKiByYnM7XG4gICAgICAgICAgICBiX3N1bSArPSAoc3RhY2suYiA9IChwYiA9IHBpeGVsc1t5aSsyXSkpICogcmJzO1xuICAgICAgICAgICAgYV9zdW0gKz0gKHN0YWNrLmEgPSAocGEgPSBwaXhlbHNbeWkrM10pKSAqIHJicztcblxuICAgICAgICAgICAgcl9pbl9zdW0gKz0gcHI7XG4gICAgICAgICAgICBnX2luX3N1bSArPSBwZztcbiAgICAgICAgICAgIGJfaW5fc3VtICs9IHBiO1xuICAgICAgICAgICAgYV9pbl9zdW0gKz0gcGE7XG5cbiAgICAgICAgICAgIHN0YWNrID0gc3RhY2submV4dDtcblxuICAgICAgICAgICAgaWYoaSA8IGhlaWdodE1pbnVzMSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB5cCArPSB3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHlpID0geDtcbiAgICAgICAgc3RhY2tJbiA9IHN0YWNrU3RhcnQ7XG4gICAgICAgIHN0YWNrT3V0ID0gc3RhY2tFbmQ7XG4gICAgICAgIGZvciAoeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgcCA9IHlpIDw8IDI7XG4gICAgICAgICAgICBwaXhlbHNbcCszXSA9IHBhID0gKGFfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bTtcbiAgICAgICAgICAgIGlmIChwYSA+IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcGEgPSAyNTUgLyBwYTtcbiAgICAgICAgICAgICAgICBwaXhlbHNbcF0gICA9ICgocl9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtKSAqIHBhO1xuICAgICAgICAgICAgICAgIHBpeGVsc1twKzFdID0gKChnX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0pICogcGE7XG4gICAgICAgICAgICAgICAgcGl4ZWxzW3ArMl0gPSAoKGJfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSkgKiBwYTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGl4ZWxzW3BdID0gcGl4ZWxzW3ArMV0gPSBwaXhlbHNbcCsyXSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJfc3VtIC09IHJfb3V0X3N1bTtcbiAgICAgICAgICAgIGdfc3VtIC09IGdfb3V0X3N1bTtcbiAgICAgICAgICAgIGJfc3VtIC09IGJfb3V0X3N1bTtcbiAgICAgICAgICAgIGFfc3VtIC09IGFfb3V0X3N1bTtcblxuICAgICAgICAgICAgcl9vdXRfc3VtIC09IHN0YWNrSW4ucjtcbiAgICAgICAgICAgIGdfb3V0X3N1bSAtPSBzdGFja0luLmc7XG4gICAgICAgICAgICBiX291dF9zdW0gLT0gc3RhY2tJbi5iO1xuICAgICAgICAgICAgYV9vdXRfc3VtIC09IHN0YWNrSW4uYTtcblxuICAgICAgICAgICAgcCA9ICh4ICsgKCgocCA9IHkgKyByYWRpdXNQbHVzMSkgPCBoZWlnaHRNaW51czEgPyBwIDogaGVpZ2h0TWludXMxKSAqIHdpZHRoKSkgPDwgMjtcblxuICAgICAgICAgICAgcl9zdW0gKz0gKHJfaW5fc3VtICs9IChzdGFja0luLnIgPSBwaXhlbHNbcF0pKTtcbiAgICAgICAgICAgIGdfc3VtICs9IChnX2luX3N1bSArPSAoc3RhY2tJbi5nID0gcGl4ZWxzW3ArMV0pKTtcbiAgICAgICAgICAgIGJfc3VtICs9IChiX2luX3N1bSArPSAoc3RhY2tJbi5iID0gcGl4ZWxzW3ArMl0pKTtcbiAgICAgICAgICAgIGFfc3VtICs9IChhX2luX3N1bSArPSAoc3RhY2tJbi5hID0gcGl4ZWxzW3ArM10pKTtcblxuICAgICAgICAgICAgc3RhY2tJbiA9IHN0YWNrSW4ubmV4dDtcblxuICAgICAgICAgICAgcl9vdXRfc3VtICs9IChwciA9IHN0YWNrT3V0LnIpO1xuICAgICAgICAgICAgZ19vdXRfc3VtICs9IChwZyA9IHN0YWNrT3V0LmcpO1xuICAgICAgICAgICAgYl9vdXRfc3VtICs9IChwYiA9IHN0YWNrT3V0LmIpO1xuICAgICAgICAgICAgYV9vdXRfc3VtICs9IChwYSA9IHN0YWNrT3V0LmEpO1xuXG4gICAgICAgICAgICByX2luX3N1bSAtPSBwcjtcbiAgICAgICAgICAgIGdfaW5fc3VtIC09IHBnO1xuICAgICAgICAgICAgYl9pbl9zdW0gLT0gcGI7XG4gICAgICAgICAgICBhX2luX3N1bSAtPSBwYTtcblxuICAgICAgICAgICAgc3RhY2tPdXQgPSBzdGFja091dC5uZXh0O1xuXG4gICAgICAgICAgICB5aSArPSB3aWR0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW1hZ2VEYXRhO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ2FudmFzUkdCKGNhbnZhcywgdG9wX3gsIHRvcF95LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpXG57XG4gICAgaWYgKGlzTmFOKHJhZGl1cykgfHwgcmFkaXVzIDwgMSkgcmV0dXJuO1xuICAgIHJhZGl1cyB8PSAwO1xuXG4gICAgdmFyIGltYWdlRGF0YSA9IGdldEltYWdlRGF0YUZyb21DYW52YXMoY2FudmFzLCB0b3BfeCwgdG9wX3ksIHdpZHRoLCBoZWlnaHQpO1xuICAgIGltYWdlRGF0YSA9IHByb2Nlc3NJbWFnZURhdGFSR0IoaW1hZ2VEYXRhLCB0b3BfeCwgdG9wX3ksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cyk7XG5cbiAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCB0b3BfeCwgdG9wX3kpO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzSW1hZ2VEYXRhUkdCKGltYWdlRGF0YSwgdG9wX3gsIHRvcF95LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpXG57XG4gICAgdmFyIHBpeGVscyA9IGltYWdlRGF0YS5kYXRhO1xuXG4gICAgdmFyIHgsIHksIGksIHAsIHlwLCB5aSwgeXcsIHJfc3VtLCBnX3N1bSwgYl9zdW0sXG4gICAgICAgIHJfb3V0X3N1bSwgZ19vdXRfc3VtLCBiX291dF9zdW0sXG4gICAgICAgIHJfaW5fc3VtLCBnX2luX3N1bSwgYl9pbl9zdW0sXG4gICAgICAgIHByLCBwZywgcGIsIHJicztcblxuICAgIHZhciBkaXYgPSByYWRpdXMgKyByYWRpdXMgKyAxO1xuICAgIHZhciB3NCA9IHdpZHRoIDw8IDI7XG4gICAgdmFyIHdpZHRoTWludXMxICA9IHdpZHRoIC0gMTtcbiAgICB2YXIgaGVpZ2h0TWludXMxID0gaGVpZ2h0IC0gMTtcbiAgICB2YXIgcmFkaXVzUGx1czEgID0gcmFkaXVzICsgMTtcbiAgICB2YXIgc3VtRmFjdG9yID0gcmFkaXVzUGx1czEgKiAocmFkaXVzUGx1czEgKyAxKSAvIDI7XG5cbiAgICB2YXIgc3RhY2tTdGFydCA9IG5ldyBCbHVyU3RhY2soKTtcbiAgICB2YXIgc3RhY2sgPSBzdGFja1N0YXJ0O1xuICAgIGZvciAoaSA9IDE7IGkgPCBkaXY7IGkrKylcbiAgICB7XG4gICAgICAgIHN0YWNrID0gc3RhY2submV4dCA9IG5ldyBCbHVyU3RhY2soKTtcbiAgICAgICAgaWYgKGkgPT0gcmFkaXVzUGx1czEpIHZhciBzdGFja0VuZCA9IHN0YWNrO1xuICAgIH1cbiAgICBzdGFjay5uZXh0ID0gc3RhY2tTdGFydDtcbiAgICB2YXIgc3RhY2tJbiA9IG51bGw7XG4gICAgdmFyIHN0YWNrT3V0ID0gbnVsbDtcblxuICAgIHl3ID0geWkgPSAwO1xuXG4gICAgdmFyIG11bF9zdW0gPSBtdWxfdGFibGVbcmFkaXVzXTtcbiAgICB2YXIgc2hnX3N1bSA9IHNoZ190YWJsZVtyYWRpdXNdO1xuXG4gICAgZm9yICh5ID0gMDsgeSA8IGhlaWdodDsgeSsrKVxuICAgIHtcbiAgICAgICAgcl9pbl9zdW0gPSBnX2luX3N1bSA9IGJfaW5fc3VtID0gcl9zdW0gPSBnX3N1bSA9IGJfc3VtID0gMDtcblxuICAgICAgICByX291dF9zdW0gPSByYWRpdXNQbHVzMSAqIChwciA9IHBpeGVsc1t5aV0pO1xuICAgICAgICBnX291dF9zdW0gPSByYWRpdXNQbHVzMSAqIChwZyA9IHBpeGVsc1t5aSsxXSk7XG4gICAgICAgIGJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKHBiID0gcGl4ZWxzW3lpKzJdKTtcblxuICAgICAgICByX3N1bSArPSBzdW1GYWN0b3IgKiBwcjtcbiAgICAgICAgZ19zdW0gKz0gc3VtRmFjdG9yICogcGc7XG4gICAgICAgIGJfc3VtICs9IHN1bUZhY3RvciAqIHBiO1xuXG4gICAgICAgIHN0YWNrID0gc3RhY2tTdGFydDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmFkaXVzUGx1czE7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgc3RhY2suciA9IHByO1xuICAgICAgICAgICAgc3RhY2suZyA9IHBnO1xuICAgICAgICAgICAgc3RhY2suYiA9IHBiO1xuICAgICAgICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHJhZGl1c1BsdXMxOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHAgPSB5aSArICgod2lkdGhNaW51czEgPCBpID8gd2lkdGhNaW51czEgOiBpKSA8PCAyKTtcbiAgICAgICAgICAgIHJfc3VtICs9IChzdGFjay5yID0gKHByID0gcGl4ZWxzW3BdKSkgKiAocmJzID0gcmFkaXVzUGx1czEgLSBpKTtcbiAgICAgICAgICAgIGdfc3VtICs9IChzdGFjay5nID0gKHBnID0gcGl4ZWxzW3ArMV0pKSAqIHJicztcbiAgICAgICAgICAgIGJfc3VtICs9IChzdGFjay5iID0gKHBiID0gcGl4ZWxzW3ArMl0pKSAqIHJicztcblxuICAgICAgICAgICAgcl9pbl9zdW0gKz0gcHI7XG4gICAgICAgICAgICBnX2luX3N1bSArPSBwZztcbiAgICAgICAgICAgIGJfaW5fc3VtICs9IHBiO1xuXG4gICAgICAgICAgICBzdGFjayA9IHN0YWNrLm5leHQ7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHN0YWNrSW4gPSBzdGFja1N0YXJ0O1xuICAgICAgICBzdGFja091dCA9IHN0YWNrRW5kO1xuICAgICAgICBmb3IgKHggPSAwOyB4IDwgd2lkdGg7IHgrKylcbiAgICAgICAge1xuICAgICAgICAgICAgcGl4ZWxzW3lpXSAgID0gKHJfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bTtcbiAgICAgICAgICAgIHBpeGVsc1t5aSsxXSA9IChnX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW07XG4gICAgICAgICAgICBwaXhlbHNbeWkrMl0gPSAoYl9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtO1xuXG4gICAgICAgICAgICByX3N1bSAtPSByX291dF9zdW07XG4gICAgICAgICAgICBnX3N1bSAtPSBnX291dF9zdW07XG4gICAgICAgICAgICBiX3N1bSAtPSBiX291dF9zdW07XG5cbiAgICAgICAgICAgIHJfb3V0X3N1bSAtPSBzdGFja0luLnI7XG4gICAgICAgICAgICBnX291dF9zdW0gLT0gc3RhY2tJbi5nO1xuICAgICAgICAgICAgYl9vdXRfc3VtIC09IHN0YWNrSW4uYjtcblxuICAgICAgICAgICAgcCA9ICAoeXcgKyAoKHAgPSB4ICsgcmFkaXVzICsgMSkgPCB3aWR0aE1pbnVzMSA/IHAgOiB3aWR0aE1pbnVzMSkpIDw8IDI7XG5cbiAgICAgICAgICAgIHJfaW5fc3VtICs9IChzdGFja0luLnIgPSBwaXhlbHNbcF0pO1xuICAgICAgICAgICAgZ19pbl9zdW0gKz0gKHN0YWNrSW4uZyA9IHBpeGVsc1twKzFdKTtcbiAgICAgICAgICAgIGJfaW5fc3VtICs9IChzdGFja0luLmIgPSBwaXhlbHNbcCsyXSk7XG5cbiAgICAgICAgICAgIHJfc3VtICs9IHJfaW5fc3VtO1xuICAgICAgICAgICAgZ19zdW0gKz0gZ19pbl9zdW07XG4gICAgICAgICAgICBiX3N1bSArPSBiX2luX3N1bTtcblxuICAgICAgICAgICAgc3RhY2tJbiA9IHN0YWNrSW4ubmV4dDtcblxuICAgICAgICAgICAgcl9vdXRfc3VtICs9IChwciA9IHN0YWNrT3V0LnIpO1xuICAgICAgICAgICAgZ19vdXRfc3VtICs9IChwZyA9IHN0YWNrT3V0LmcpO1xuICAgICAgICAgICAgYl9vdXRfc3VtICs9IChwYiA9IHN0YWNrT3V0LmIpO1xuXG4gICAgICAgICAgICByX2luX3N1bSAtPSBwcjtcbiAgICAgICAgICAgIGdfaW5fc3VtIC09IHBnO1xuICAgICAgICAgICAgYl9pbl9zdW0gLT0gcGI7XG5cbiAgICAgICAgICAgIHN0YWNrT3V0ID0gc3RhY2tPdXQubmV4dDtcblxuICAgICAgICAgICAgeWkgKz0gNDtcbiAgICAgICAgfVxuICAgICAgICB5dyArPSB3aWR0aDtcbiAgICB9XG5cblxuICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKVxuICAgIHtcbiAgICAgICAgZ19pbl9zdW0gPSBiX2luX3N1bSA9IHJfaW5fc3VtID0gZ19zdW0gPSBiX3N1bSA9IHJfc3VtID0gMDtcblxuICAgICAgICB5aSA9IHggPDwgMjtcbiAgICAgICAgcl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAocHIgPSBwaXhlbHNbeWldKTtcbiAgICAgICAgZ19vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAocGcgPSBwaXhlbHNbeWkrMV0pO1xuICAgICAgICBiX291dF9zdW0gPSByYWRpdXNQbHVzMSAqIChwYiA9IHBpeGVsc1t5aSsyXSk7XG5cbiAgICAgICAgcl9zdW0gKz0gc3VtRmFjdG9yICogcHI7XG4gICAgICAgIGdfc3VtICs9IHN1bUZhY3RvciAqIHBnO1xuICAgICAgICBiX3N1bSArPSBzdW1GYWN0b3IgKiBwYjtcblxuICAgICAgICBzdGFjayA9IHN0YWNrU3RhcnQ7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJhZGl1c1BsdXMxOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN0YWNrLnIgPSBwcjtcbiAgICAgICAgICAgIHN0YWNrLmcgPSBwZztcbiAgICAgICAgICAgIHN0YWNrLmIgPSBwYjtcbiAgICAgICAgICAgIHN0YWNrID0gc3RhY2submV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHlwID0gd2lkdGg7XG5cbiAgICAgICAgZm9yIChpID0gMTsgaSA8PSByYWRpdXM7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgeWkgPSAoeXAgKyB4KSA8PCAyO1xuXG4gICAgICAgICAgICByX3N1bSArPSAoc3RhY2suciA9IChwciA9IHBpeGVsc1t5aV0pKSAqIChyYnMgPSByYWRpdXNQbHVzMSAtIGkpO1xuICAgICAgICAgICAgZ19zdW0gKz0gKHN0YWNrLmcgPSAocGcgPSBwaXhlbHNbeWkrMV0pKSAqIHJicztcbiAgICAgICAgICAgIGJfc3VtICs9IChzdGFjay5iID0gKHBiID0gcGl4ZWxzW3lpKzJdKSkgKiByYnM7XG5cbiAgICAgICAgICAgIHJfaW5fc3VtICs9IHByO1xuICAgICAgICAgICAgZ19pbl9zdW0gKz0gcGc7XG4gICAgICAgICAgICBiX2luX3N1bSArPSBwYjtcblxuICAgICAgICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuXG4gICAgICAgICAgICBpZihpIDwgaGVpZ2h0TWludXMxKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHlwICs9IHdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgeWkgPSB4O1xuICAgICAgICBzdGFja0luID0gc3RhY2tTdGFydDtcbiAgICAgICAgc3RhY2tPdXQgPSBzdGFja0VuZDtcbiAgICAgICAgZm9yICh5ID0gMDsgeSA8IGhlaWdodDsgeSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBwID0geWkgPDwgMjtcbiAgICAgICAgICAgIHBpeGVsc1twXSAgID0gKHJfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bTtcbiAgICAgICAgICAgIHBpeGVsc1twKzFdID0gKGdfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bTtcbiAgICAgICAgICAgIHBpeGVsc1twKzJdID0gKGJfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bTtcblxuICAgICAgICAgICAgcl9zdW0gLT0gcl9vdXRfc3VtO1xuICAgICAgICAgICAgZ19zdW0gLT0gZ19vdXRfc3VtO1xuICAgICAgICAgICAgYl9zdW0gLT0gYl9vdXRfc3VtO1xuXG4gICAgICAgICAgICByX291dF9zdW0gLT0gc3RhY2tJbi5yO1xuICAgICAgICAgICAgZ19vdXRfc3VtIC09IHN0YWNrSW4uZztcbiAgICAgICAgICAgIGJfb3V0X3N1bSAtPSBzdGFja0luLmI7XG5cbiAgICAgICAgICAgIHAgPSAoeCArICgoKHAgPSB5ICsgcmFkaXVzUGx1czEpIDwgaGVpZ2h0TWludXMxID8gcCA6IGhlaWdodE1pbnVzMSkgKiB3aWR0aCkpIDw8IDI7XG5cbiAgICAgICAgICAgIHJfc3VtICs9IChyX2luX3N1bSArPSAoc3RhY2tJbi5yID0gcGl4ZWxzW3BdKSk7XG4gICAgICAgICAgICBnX3N1bSArPSAoZ19pbl9zdW0gKz0gKHN0YWNrSW4uZyA9IHBpeGVsc1twKzFdKSk7XG4gICAgICAgICAgICBiX3N1bSArPSAoYl9pbl9zdW0gKz0gKHN0YWNrSW4uYiA9IHBpeGVsc1twKzJdKSk7XG5cbiAgICAgICAgICAgIHN0YWNrSW4gPSBzdGFja0luLm5leHQ7XG5cbiAgICAgICAgICAgIHJfb3V0X3N1bSArPSAocHIgPSBzdGFja091dC5yKTtcbiAgICAgICAgICAgIGdfb3V0X3N1bSArPSAocGcgPSBzdGFja091dC5nKTtcbiAgICAgICAgICAgIGJfb3V0X3N1bSArPSAocGIgPSBzdGFja091dC5iKTtcblxuICAgICAgICAgICAgcl9pbl9zdW0gLT0gcHI7XG4gICAgICAgICAgICBnX2luX3N1bSAtPSBwZztcbiAgICAgICAgICAgIGJfaW5fc3VtIC09IHBiO1xuXG4gICAgICAgICAgICBzdGFja091dCA9IHN0YWNrT3V0Lm5leHQ7XG5cbiAgICAgICAgICAgIHlpICs9IHdpZHRoO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGltYWdlRGF0YTtcbn1cblxuZnVuY3Rpb24gQmx1clN0YWNrKClcbntcbiAgICB0aGlzLnIgPSAwO1xuICAgIHRoaXMuZyA9IDA7XG4gICAgdGhpcy5iID0gMDtcbiAgICB0aGlzLmEgPSAwO1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGltYWdlOiBwcm9jZXNzSW1hZ2UsXG4gICAgY2FudmFzUkdCQTogcHJvY2Vzc0NhbnZhc1JHQkEsXG4gICAgY2FudmFzUkdCOiBwcm9jZXNzQ2FudmFzUkdCLFxuICAgIGltYWdlRGF0YVJHQkE6IHByb2Nlc3NJbWFnZURhdGFSR0JBLFxuICAgIGltYWdlRGF0YVJHQjogcHJvY2Vzc0ltYWdlRGF0YVJHQlxufTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMC4wXG5cbi8qKlxuQGxpY2Vuc2UgU3RpY2t5LWtpdCB2MS4xLjMgfCBNSVQgfCBMZWFmIENvcmNvcmFuIDIwMTUgfCBodHRwOi8vbGVhZm8ubmV0XG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgJCwgd2luO1xuXG4gICQgPSB3aW5kb3cualF1ZXJ5O1xuXG4gIHdpbiA9ICQod2luZG93KTtcblxuICAkLmZuLnN0aWNrX2luX3BhcmVudCA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICB2YXIgZG9jLCBlbG0sIGVuYWJsZV9ib3R0b21pbmcsIGZuLCBpLCBpbm5lcl9zY3JvbGxpbmcsIGxlbiwgbWFudWFsX3NwYWNlciwgb2Zmc2V0X3RvcCwgb3V0ZXJfd2lkdGgsIHBhcmVudF9zZWxlY3RvciwgcmVjYWxjX2V2ZXJ5LCBzdGlja3lfY2xhc3M7XG4gICAgaWYgKG9wdHMgPT0gbnVsbCkge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cbiAgICBzdGlja3lfY2xhc3MgPSBvcHRzLnN0aWNreV9jbGFzcywgaW5uZXJfc2Nyb2xsaW5nID0gb3B0cy5pbm5lcl9zY3JvbGxpbmcsIHJlY2FsY19ldmVyeSA9IG9wdHMucmVjYWxjX2V2ZXJ5LCBwYXJlbnRfc2VsZWN0b3IgPSBvcHRzLnBhcmVudCwgb2Zmc2V0X3RvcCA9IG9wdHMub2Zmc2V0X3RvcCwgbWFudWFsX3NwYWNlciA9IG9wdHMuc3BhY2VyLCBlbmFibGVfYm90dG9taW5nID0gb3B0cy5ib3R0b21pbmc7XG4gICAgaWYgKG9mZnNldF90b3AgPT0gbnVsbCkge1xuICAgICAgb2Zmc2V0X3RvcCA9IDA7XG4gICAgfVxuICAgIGlmIChwYXJlbnRfc2VsZWN0b3IgPT0gbnVsbCkge1xuICAgICAgcGFyZW50X3NlbGVjdG9yID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoaW5uZXJfc2Nyb2xsaW5nID09IG51bGwpIHtcbiAgICAgIGlubmVyX3Njcm9sbGluZyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChzdGlja3lfY2xhc3MgPT0gbnVsbCkge1xuICAgICAgc3RpY2t5X2NsYXNzID0gXCJpc19zdHVja1wiO1xuICAgIH1cbiAgICBkb2MgPSAkKGRvY3VtZW50KTtcbiAgICBpZiAoZW5hYmxlX2JvdHRvbWluZyA9PSBudWxsKSB7XG4gICAgICBlbmFibGVfYm90dG9taW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgb3V0ZXJfd2lkdGggPSBmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIF9lbCwgY29tcHV0ZWQsIHc7XG4gICAgICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgX2VsID0gZWxbMF07XG4gICAgICAgIGNvbXB1dGVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxbMF0pO1xuICAgICAgICB3ID0gcGFyc2VGbG9hdChjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKFwid2lkdGhcIikpICsgcGFyc2VGbG9hdChjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKFwibWFyZ2luLWxlZnRcIikpICsgcGFyc2VGbG9hdChjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKFwibWFyZ2luLXJpZ2h0XCIpKTtcbiAgICAgICAgaWYgKGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoXCJib3gtc2l6aW5nXCIpICE9PSBcImJvcmRlci1ib3hcIikge1xuICAgICAgICAgIHcgKz0gcGFyc2VGbG9hdChjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKFwiYm9yZGVyLWxlZnQtd2lkdGhcIikpICsgcGFyc2VGbG9hdChjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKFwiYm9yZGVyLXJpZ2h0LXdpZHRoXCIpKSArIHBhcnNlRmxvYXQoY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZShcInBhZGRpbmctbGVmdFwiKSkgKyBwYXJzZUZsb2F0KGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoXCJwYWRkaW5nLXJpZ2h0XCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlbC5vdXRlcldpZHRoKHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgZm4gPSBmdW5jdGlvbihlbG0sIHBhZGRpbmdfYm90dG9tLCBwYXJlbnRfdG9wLCBwYXJlbnRfaGVpZ2h0LCB0b3AsIGhlaWdodCwgZWxfZmxvYXQsIGRldGFjaGVkKSB7XG4gICAgICB2YXIgYm90dG9tZWQsIGRldGFjaCwgZml4ZWQsIGxhc3RfcG9zLCBsYXN0X3Njcm9sbF9oZWlnaHQsIG9mZnNldCwgcGFyZW50LCByZWNhbGMsIHJlY2FsY19hbmRfdGljaywgcmVjYWxjX2NvdW50ZXIsIHNwYWNlciwgdGljaztcbiAgICAgIGlmIChlbG0uZGF0YShcInN0aWNreV9raXRcIikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxtLmRhdGEoXCJzdGlja3lfa2l0XCIsIHRydWUpO1xuICAgICAgbGFzdF9zY3JvbGxfaGVpZ2h0ID0gZG9jLmhlaWdodCgpO1xuICAgICAgcGFyZW50ID0gZWxtLnBhcmVudCgpO1xuICAgICAgaWYgKHBhcmVudF9zZWxlY3RvciAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5jbG9zZXN0KHBhcmVudF9zZWxlY3Rvcik7XG4gICAgICB9XG4gICAgICBpZiAoIXBhcmVudC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgXCJmYWlsZWQgdG8gZmluZCBzdGljayBwYXJlbnRcIjtcbiAgICAgIH1cbiAgICAgIGZpeGVkID0gZmFsc2U7XG4gICAgICBib3R0b21lZCA9IGZhbHNlO1xuICAgICAgc3BhY2VyID0gbWFudWFsX3NwYWNlciAhPSBudWxsID8gbWFudWFsX3NwYWNlciAmJiBlbG0uY2xvc2VzdChtYW51YWxfc3BhY2VyKSA6ICQoXCI8ZGl2IC8+XCIpO1xuICAgICAgaWYgKHNwYWNlcikge1xuICAgICAgICBzcGFjZXIuY3NzKCdwb3NpdGlvbicsIGVsbS5jc3MoJ3Bvc2l0aW9uJykpO1xuICAgICAgfVxuICAgICAgcmVjYWxjID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBib3JkZXJfdG9wLCBwYWRkaW5nX3RvcCwgcmVzdG9yZTtcbiAgICAgICAgaWYgKGRldGFjaGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxhc3Rfc2Nyb2xsX2hlaWdodCA9IGRvYy5oZWlnaHQoKTtcbiAgICAgICAgYm9yZGVyX3RvcCA9IHBhcnNlSW50KHBhcmVudC5jc3MoXCJib3JkZXItdG9wLXdpZHRoXCIpLCAxMCk7XG4gICAgICAgIHBhZGRpbmdfdG9wID0gcGFyc2VJbnQocGFyZW50LmNzcyhcInBhZGRpbmctdG9wXCIpLCAxMCk7XG4gICAgICAgIHBhZGRpbmdfYm90dG9tID0gcGFyc2VJbnQocGFyZW50LmNzcyhcInBhZGRpbmctYm90dG9tXCIpLCAxMCk7XG4gICAgICAgIHBhcmVudF90b3AgPSBwYXJlbnQub2Zmc2V0KCkudG9wICsgYm9yZGVyX3RvcCArIHBhZGRpbmdfdG9wO1xuICAgICAgICBwYXJlbnRfaGVpZ2h0ID0gcGFyZW50LmhlaWdodCgpO1xuICAgICAgICBpZiAoZml4ZWQpIHtcbiAgICAgICAgICBmaXhlZCA9IGZhbHNlO1xuICAgICAgICAgIGJvdHRvbWVkID0gZmFsc2U7XG4gICAgICAgICAgaWYgKG1hbnVhbF9zcGFjZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgZWxtLmluc2VydEFmdGVyKHNwYWNlcik7XG4gICAgICAgICAgICBzcGFjZXIuZGV0YWNoKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsbS5jc3Moe1xuICAgICAgICAgICAgcG9zaXRpb246IFwiXCIsXG4gICAgICAgICAgICB0b3A6IFwiXCIsXG4gICAgICAgICAgICB3aWR0aDogXCJcIixcbiAgICAgICAgICAgIGJvdHRvbTogXCJcIlxuICAgICAgICAgIH0pLnJlbW92ZUNsYXNzKHN0aWNreV9jbGFzcyk7XG4gICAgICAgICAgcmVzdG9yZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdG9wID0gZWxtLm9mZnNldCgpLnRvcCAtIChwYXJzZUludChlbG0uY3NzKFwibWFyZ2luLXRvcFwiKSwgMTApIHx8IDApIC0gb2Zmc2V0X3RvcDtcbiAgICAgICAgaGVpZ2h0ID0gZWxtLm91dGVySGVpZ2h0KHRydWUpO1xuICAgICAgICBlbF9mbG9hdCA9IGVsbS5jc3MoXCJmbG9hdFwiKTtcbiAgICAgICAgaWYgKHNwYWNlcikge1xuICAgICAgICAgIHNwYWNlci5jc3Moe1xuICAgICAgICAgICAgd2lkdGg6IG91dGVyX3dpZHRoKGVsbSksXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIGRpc3BsYXk6IGVsbS5jc3MoXCJkaXNwbGF5XCIpLFxuICAgICAgICAgICAgXCJ2ZXJ0aWNhbC1hbGlnblwiOiBlbG0uY3NzKFwidmVydGljYWwtYWxpZ25cIiksXG4gICAgICAgICAgICBcImZsb2F0XCI6IGVsX2Zsb2F0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3RvcmUpIHtcbiAgICAgICAgICByZXR1cm4gdGljaygpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmVjYWxjKCk7XG4gICAgICBpZiAoaGVpZ2h0ID09PSBwYXJlbnRfaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxhc3RfcG9zID0gdm9pZCAwO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0X3RvcDtcbiAgICAgIHJlY2FsY19jb3VudGVyID0gcmVjYWxjX2V2ZXJ5O1xuICAgICAgdGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3NzLCBkZWx0YSwgcmVjYWxjZWQsIHNjcm9sbCwgd2lsbF9ib3R0b20sIHdpbl9oZWlnaHQ7XG4gICAgICAgIGlmIChkZXRhY2hlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWNhbGNlZCA9IGZhbHNlO1xuICAgICAgICBpZiAocmVjYWxjX2NvdW50ZXIgIT0gbnVsbCkge1xuICAgICAgICAgIHJlY2FsY19jb3VudGVyIC09IDE7XG4gICAgICAgICAgaWYgKHJlY2FsY19jb3VudGVyIDw9IDApIHtcbiAgICAgICAgICAgIHJlY2FsY19jb3VudGVyID0gcmVjYWxjX2V2ZXJ5O1xuICAgICAgICAgICAgcmVjYWxjKCk7XG4gICAgICAgICAgICByZWNhbGNlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcmVjYWxjZWQgJiYgZG9jLmhlaWdodCgpICE9PSBsYXN0X3Njcm9sbF9oZWlnaHQpIHtcbiAgICAgICAgICByZWNhbGMoKTtcbiAgICAgICAgICByZWNhbGNlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc2Nyb2xsID0gd2luLnNjcm9sbFRvcCgpO1xuICAgICAgICBpZiAobGFzdF9wb3MgIT0gbnVsbCkge1xuICAgICAgICAgIGRlbHRhID0gc2Nyb2xsIC0gbGFzdF9wb3M7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdF9wb3MgPSBzY3JvbGw7XG4gICAgICAgIGlmIChmaXhlZCkge1xuICAgICAgICAgIGlmIChlbmFibGVfYm90dG9taW5nKSB7XG4gICAgICAgICAgICB3aWxsX2JvdHRvbSA9IHNjcm9sbCArIGhlaWdodCArIG9mZnNldCA+IHBhcmVudF9oZWlnaHQgKyBwYXJlbnRfdG9wO1xuICAgICAgICAgICAgaWYgKGJvdHRvbWVkICYmICF3aWxsX2JvdHRvbSkge1xuICAgICAgICAgICAgICBib3R0b21lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBlbG0uY3NzKHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJmaXhlZFwiLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogXCJcIixcbiAgICAgICAgICAgICAgICB0b3A6IG9mZnNldFxuICAgICAgICAgICAgICB9KS50cmlnZ2VyKFwic3RpY2t5X2tpdDp1bmJvdHRvbVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNjcm9sbCA8IHRvcCkge1xuICAgICAgICAgICAgZml4ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIG9mZnNldCA9IG9mZnNldF90b3A7XG4gICAgICAgICAgICBpZiAobWFudWFsX3NwYWNlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChlbF9mbG9hdCA9PT0gXCJsZWZ0XCIgfHwgZWxfZmxvYXQgPT09IFwicmlnaHRcIikge1xuICAgICAgICAgICAgICAgIGVsbS5pbnNlcnRBZnRlcihzcGFjZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNwYWNlci5kZXRhY2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNzcyA9IHtcbiAgICAgICAgICAgICAgcG9zaXRpb246IFwiXCIsXG4gICAgICAgICAgICAgIHdpZHRoOiBcIlwiLFxuICAgICAgICAgICAgICB0b3A6IFwiXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbG0uY3NzKGNzcykucmVtb3ZlQ2xhc3Moc3RpY2t5X2NsYXNzKS50cmlnZ2VyKFwic3RpY2t5X2tpdDp1bnN0aWNrXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5uZXJfc2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICB3aW5faGVpZ2h0ID0gd2luLmhlaWdodCgpO1xuICAgICAgICAgICAgaWYgKGhlaWdodCArIG9mZnNldF90b3AgPiB3aW5faGVpZ2h0KSB7XG4gICAgICAgICAgICAgIGlmICghYm90dG9tZWQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgLT0gZGVsdGE7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgod2luX2hlaWdodCAtIGhlaWdodCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBNYXRoLm1pbihvZmZzZXRfdG9wLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChmaXhlZCkge1xuICAgICAgICAgICAgICAgICAgZWxtLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgIHRvcDogb2Zmc2V0ICsgXCJweFwiXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNjcm9sbCA+IHRvcCkge1xuICAgICAgICAgICAgZml4ZWQgPSB0cnVlO1xuICAgICAgICAgICAgY3NzID0ge1xuICAgICAgICAgICAgICBwb3NpdGlvbjogXCJmaXhlZFwiLFxuICAgICAgICAgICAgICB0b3A6IG9mZnNldFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNzcy53aWR0aCA9IGVsbS5jc3MoXCJib3gtc2l6aW5nXCIpID09PSBcImJvcmRlci1ib3hcIiA/IGVsbS5vdXRlcldpZHRoKCkgKyBcInB4XCIgOiBlbG0ud2lkdGgoKSArIFwicHhcIjtcbiAgICAgICAgICAgIGVsbS5jc3MoY3NzKS5hZGRDbGFzcyhzdGlja3lfY2xhc3MpO1xuICAgICAgICAgICAgaWYgKG1hbnVhbF9zcGFjZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBlbG0uYWZ0ZXIoc3BhY2VyKTtcbiAgICAgICAgICAgICAgaWYgKGVsX2Zsb2F0ID09PSBcImxlZnRcIiB8fCBlbF9mbG9hdCA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgICAgICAgc3BhY2VyLmFwcGVuZChlbG0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbG0udHJpZ2dlcihcInN0aWNreV9raXQ6c3RpY2tcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaXhlZCAmJiBlbmFibGVfYm90dG9taW5nKSB7XG4gICAgICAgICAgaWYgKHdpbGxfYm90dG9tID09IG51bGwpIHtcbiAgICAgICAgICAgIHdpbGxfYm90dG9tID0gc2Nyb2xsICsgaGVpZ2h0ICsgb2Zmc2V0ID4gcGFyZW50X2hlaWdodCArIHBhcmVudF90b3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYm90dG9tZWQgJiYgd2lsbF9ib3R0b20pIHtcbiAgICAgICAgICAgIGJvdHRvbWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuY3NzKFwicG9zaXRpb25cIikgPT09IFwic3RhdGljXCIpIHtcbiAgICAgICAgICAgICAgcGFyZW50LmNzcyh7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbG0uY3NzKHtcbiAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgICAgYm90dG9tOiBwYWRkaW5nX2JvdHRvbSxcbiAgICAgICAgICAgICAgdG9wOiBcImF1dG9cIlxuICAgICAgICAgICAgfSkudHJpZ2dlcihcInN0aWNreV9raXQ6Ym90dG9tXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlY2FsY19hbmRfdGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWNhbGMoKTtcbiAgICAgICAgcmV0dXJuIHRpY2soKTtcbiAgICAgIH07XG4gICAgICBkZXRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZGV0YWNoZWQgPSB0cnVlO1xuICAgICAgICB3aW4ub2ZmKFwidG91Y2htb3ZlXCIsIHRpY2spO1xuICAgICAgICB3aW4ub2ZmKFwic2Nyb2xsXCIsIHRpY2spO1xuICAgICAgICB3aW4ub2ZmKFwicmVzaXplXCIsIHJlY2FsY19hbmRfdGljayk7XG4gICAgICAgICQoZG9jdW1lbnQuYm9keSkub2ZmKFwic3RpY2t5X2tpdDpyZWNhbGNcIiwgcmVjYWxjX2FuZF90aWNrKTtcbiAgICAgICAgZWxtLm9mZihcInN0aWNreV9raXQ6ZGV0YWNoXCIsIGRldGFjaCk7XG4gICAgICAgIGVsbS5yZW1vdmVEYXRhKFwic3RpY2t5X2tpdFwiKTtcbiAgICAgICAgZWxtLmNzcyh7XG4gICAgICAgICAgcG9zaXRpb246IFwiXCIsXG4gICAgICAgICAgYm90dG9tOiBcIlwiLFxuICAgICAgICAgIHRvcDogXCJcIixcbiAgICAgICAgICB3aWR0aDogXCJcIlxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LnBvc2l0aW9uKFwicG9zaXRpb25cIiwgXCJcIik7XG4gICAgICAgIGlmIChmaXhlZCkge1xuICAgICAgICAgIGlmIChtYW51YWxfc3BhY2VyID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChlbF9mbG9hdCA9PT0gXCJsZWZ0XCIgfHwgZWxfZmxvYXQgPT09IFwicmlnaHRcIikge1xuICAgICAgICAgICAgICBlbG0uaW5zZXJ0QWZ0ZXIoc3BhY2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwYWNlci5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGVsbS5yZW1vdmVDbGFzcyhzdGlja3lfY2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgd2luLm9uKFwidG91Y2htb3ZlXCIsIHRpY2spO1xuICAgICAgd2luLm9uKFwic2Nyb2xsXCIsIHRpY2spO1xuICAgICAgd2luLm9uKFwicmVzaXplXCIsIHJlY2FsY19hbmRfdGljayk7XG4gICAgICAkKGRvY3VtZW50LmJvZHkpLm9uKFwic3RpY2t5X2tpdDpyZWNhbGNcIiwgcmVjYWxjX2FuZF90aWNrKTtcbiAgICAgIGVsbS5vbihcInN0aWNreV9raXQ6ZGV0YWNoXCIsIGRldGFjaCk7XG4gICAgICByZXR1cm4gc2V0VGltZW91dCh0aWNrLCAwKTtcbiAgICB9O1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGVsbSA9IHRoaXNbaV07XG4gICAgICBmbigkKGVsbSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxufSkuY2FsbCh0aGlzKTsiLCJmdW5jdGlvbiBBamF4QXBpKGVsZW1lbnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmVsZW1lbnRUeXBlID0gZWxlbWVudC5wcm9wKCd0YWdOYW1lJyk7XG5cbiAgICBpZiAodGhpcy5lbGVtZW50VHlwZSA9PT0gJ0ZPUk0nICYmIHRoaXMuZWxlbWVudC5oYXNDbGFzcygnYWpheCcpKSB7XG4gICAgICAgIHRoaXMuc2VuZEZvcm0odGhpcy5lbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZWxlbWVudFR5cGUgPT09ICdBJyAmJiB0aGlzLmVsZW1lbnQuaGFzQ2xhc3MoJ2FqYXgnKSkge1xuICAgICAgICB0aGlzLnNlbmRMaW5rKHRoaXMuZWxlbWVudCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmVsZW1lbnQuaGFzQ2xhc3MoJ2FqYXgtZmVlZGJhY2snKSAmJiB0aGlzLmVsZW1lbnQuaGFzQ2xhc3MoJ2FqYXgnKSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnaW5wdXQsIHRleHRhcmVhLCBzZWxlY3QnKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5zZW5kRmllbGQoalF1ZXJ5KHRoaXMpKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVsZW1lbnQuaGFzQ2xhc3MoJ2FqYXgtZmVlZGJhY2snKSkge1xuICAgICAgICB0aGlzLnNlbmRGaWVsZCh0aGlzLmVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAoKHRoaXMuZWxlbWVudC5jbG9zZXN0KCdmb3JtLmFqYXguYWpheC1mZWVkYmFjaycpLmxlbmd0aCA+IDApICYmICh0aGlzLmVsZW1lbnQuaXMoJ2lucHV0JykgfHwgdGhpcy5lbGVtZW50LmlzKCdzZWxlY3QnKSB8fCB0aGlzLmVsZW1lbnQuaXMoJ3RleHRhcmVhJykpKSB7XG4gICAgICAgIHRoaXMuc2VuZEZpZWxkKHRoaXMuZWxlbWVudCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmVsZW1lbnQuaGFzQ2xhc3MoJ2FqYXgtb3ZlcnJpZGUnKSkge1xuICAgICAgICB0aGlzLm92ZXJyaWRlRm9ybSh0aGlzLmVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lbGVtZW50Lmhhc0NsYXNzKCdhamF4LXNlbmQnKSkge1xuICAgICAgICB0aGlzLnNlbmRGb3JtQnlMaW5rKHRoaXMuZWxlbWVudCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmVsZW1lbnQuaGFzQ2xhc3MoJ2FqYXgtb3ZlcnJpZGUtc3VibWl0JykpIHtcbiAgICAgICAgdGhpcy5zZW5kTm9ybWFsRm9ybUJ5TGluayh0aGlzLmVsZW1lbnQpO1xuICAgIH1cbn1cblxuQWpheEFwaS5wcm90b3R5cGUuc2VuZEZvcm0gPSBmdW5jdGlvbihmb3JtKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGZvcm0ub24oJ3N1Ym1pdCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghZm9ybS5oYXNDbGFzcygnb3ZlcnJpZGUtc3VibWl0JykpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgdXJsID0gZm9ybS5hdHRyKCdhY3Rpb24nKTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZm9ybS5zZXJpYWxpemVBcnJheSgpO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBmb3JtLmRhdGEoJ3BhZ2UtdHlwZScpO1xuXG4gICAgICAgICAgICAvLyBzZXQgc3BlY2lhbCBwYXJhbSBpZiBhdXRvLWNvbXBsZXRlIGlzIGFjdGl2ZVxuICAgICAgICAgICAgaWYgKGZvcm0uZmluZCgnaW5wdXRbdHlwZT1zZWFyY2hdJykuaXMoJzpmb2N1cycpKSB7XG4gICAgICAgICAgICAgICAgZGF0YS51bnNoaWZ0KHsnbmFtZSc6ICdzZWFyY2hhdXRvY29tcGxldGUnLCAndmFsdWUnOiAxfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmFqYXhSZXF1ZXN0KHVybCwgZGF0YSwgdHlwZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbkFqYXhBcGkucHJvdG90eXBlLnNlbmRMaW5rID0gZnVuY3Rpb24obGluaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBsaW5rLm9uKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciB1cmwgPSBsaW5rLmF0dHIoJ2hyZWYnKTtcbiAgICAgICAgdmFyIGRhdGEgPSBbXTtcbiAgICAgICAgdmFyIHR5cGUgPSBsaW5rLmRhdGEoJ3BhZ2UtdHlwZScpO1xuICAgICAgICBpZiAoISBsaW5rLmhhc0NsYXNzKCdkaXNhYmxlZCcpKSB7XG4gICAgICAgICAgICBzZWxmLmFqYXhSZXF1ZXN0KHVybCwgZGF0YSwgdHlwZSk7XG5cbiAgICAgICAgICAgIGlmIChsaW5rLmhhc0NsYXNzKCduZXh0LXBhZ2UnKSkge1xuICAgICAgICAgICAgICAgIGpRdWVyeShkb2N1bWVudCkudHJpZ2dlcignbmV4dC1wYWdlJywgbGluayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbkFqYXhBcGkucHJvdG90eXBlLnNlbmRGaWVsZCA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgaWYgKCFmaWVsZC5oYXNDbGFzcygnZmVlZGJhY2stZmllbGQnKSkge1xuICAgICAgICBmaWVsZC5hZGRDbGFzcygnZmVlZGJhY2stZmllbGQnKTtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciB1cmw7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICB2YXIgdHlwZTtcblxuICAgICAgICBpZiAodHlwZW9mIGZpZWxkLmF0dHIoJ2RhdGEtZmVlZGJhY2stdXJsJykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB1cmwgPSBmaWVsZC5kYXRhKCdmZWVkYmFjay11cmwnKTtcbiAgICAgICAgICAgIHR5cGUgPSBmaWVsZC5kYXRhKCdwYWdlLXR5cGUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybCA9IGZpZWxkLmNsb3Nlc3QoJ2Zvcm0uYWpheCcpLmRhdGEoJ2ZlZWRiYWNrLXVybCcpO1xuICAgICAgICAgICAgdHlwZSA9IGZpZWxkLmNsb3Nlc3QoJ2Zvcm0uYWpheCcpLmRhdGEoJ3BhZ2UtdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZC5pcygnOnJhZGlvJykgfHwgZmllbGQuaXMoJzpjaGVja2JveCcpIHx8IGZpZWxkLmlzKCdzZWxlY3QnKSkge1xuICAgICAgICAgICAgZmllbGQub24oJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBmaWVsZC5zZXJpYWxpemVBcnJheSgpO1xuICAgICAgICAgICAgICAgIHNlbGYuYWpheFJlcXVlc3QodXJsLCBkYXRhLCB0eXBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmllbGQub24oJ2JsdXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZmllbGQuc2VyaWFsaXplQXJyYXkoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmFqYXhSZXF1ZXN0KHVybCwgZGF0YSwgdHlwZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkFqYXhBcGkucHJvdG90eXBlLm92ZXJyaWRlRm9ybSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRhdGE7XG4gICAgdmFyIHR5cGU7XG4gICAgaWYgKGVsZW1lbnQucHJvcCgndGFnTmFtZScpID09PSAnQScpIHtcbiAgICAgICAgZWxlbWVudC5vbignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHZhciBmb3JtID0gZWxlbWVudC5jbG9zZXN0KCdmb3JtLmFqYXgnKTtcbiAgICAgICAgICAgIHZhciB1cmwgPSBlbGVtZW50LmF0dHIoJ2hyZWYnKTtcbiAgICAgICAgICAgIHR5cGUgPSBmb3JtLmRhdGEoJ3BhZ2UtdHlwZScpO1xuICAgICAgICAgICAgZGF0YSA9IGZvcm0uc2VyaWFsaXplQXJyYXkoKTtcbiAgICAgICAgICAgIHNlbGYuYWpheFJlcXVlc3QodXJsLCBkYXRhLCB0eXBlKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50LnByb3AoJ3RhZ05hbWUnKSA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgICAgZWxlbWVudC5vbignY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ID0galF1ZXJ5KHRoaXMpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdC52YWwoKSkge1xuICAgICAgICAgICAgICAgIHZhciBmb3JtID0gc2VsZWN0LmNsb3Nlc3QoJ2Zvcm0uYWpheCcpO1xuICAgICAgICAgICAgICAgIHZhciB1cmwgPSBzZWxlY3QudmFsKCk7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGZvcm0uZGF0YSgncGFnZS10eXBlJyk7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGZvcm0uc2VyaWFsaXplQXJyYXkoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmFqYXhSZXF1ZXN0KHVybCwgZGF0YSwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbkFqYXhBcGkucHJvdG90eXBlLnNlbmRGb3JtQnlMaW5rID0gZnVuY3Rpb24obGluaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBsaW5rLm9uKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBmb3JtID0gbGluay5jbG9zZXN0KCdmb3JtLmFqYXgnKTtcbiAgICAgICAgdmFyIHVybCA9IGZvcm0uYXR0cignYWN0aW9uJyk7XG4gICAgICAgIHZhciBkYXRhID0gZm9ybS5zZXJpYWxpemVBcnJheSgpO1xuICAgICAgICB2YXIgdHlwZSA9IGZvcm0uZGF0YSgncGFnZS10eXBlJyk7XG5cbiAgICAgICAgc2VsZi5hamF4UmVxdWVzdCh1cmwsIGRhdGEsIHR5cGUpO1xuICAgIH0pO1xufTtcblxuQWpheEFwaS5wcm90b3R5cGUuc2VuZE5vcm1hbEZvcm1CeUxpbmsgPSBmdW5jdGlvbihsaW5rKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGxpbmsub24oJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIGZvcm0gPSBsaW5rLmNsb3Nlc3QoJ2Zvcm0uYWpheCcpO1xuICAgICAgICBmb3JtLmF0dHIoJ2FjdGlvbicsIGxpbmsuYXR0cignaHJlZicpKS5hZGRDbGFzcygnb3ZlcnJpZGUtc3VibWl0Jyk7XG4gICAgICAgIGZvcm0uc3VibWl0KCk7XG4gICAgfSk7XG59O1xuXG5BamF4QXBpLnByb3RvdHlwZS5hamF4UmVxdWVzdCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgdHlwZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoISB0eXBlKVxuICAgICAgICB0eXBlID0gMTQzMzc3MDkwMjtcbiAgICBkYXRhLnVuc2hpZnQoeyduYW1lJzogJ3R5cGUnLCAndmFsdWUnOiB0eXBlfSk7XG4gICAgalF1ZXJ5LmFqYXgoe1xuICAgICAgICAnbWV0aG9kJzogJ2dldCcsXG4gICAgICAgICd1cmwnOiB1cmwsXG4gICAgICAgICdkYXRhJzogalF1ZXJ5LnBhcmFtKGRhdGEpLFxuICAgICAgICAnZGF0YVR5cGUnOiAnanNvbicsXG4gICAgICAgIC8vJ3VzZXJuYW1lJzogJ3Jrdy1rb21wZXRlbnonLFxuICAgICAgICAvLydwYXNzd29yZCc6ICdudkZIS0dHNjU3OHpmYXNmRicsXG4gICAgICAgICdjb21wbGV0ZSc6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IEpTT04ucGFyc2UocmVzcG9uc2UucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICBzZWxmLnBhcnNlQ29udGVudChyZXNwb25zZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5BamF4QXBpLnByb3RvdHlwZS5wYXJzZUNvbnRlbnQgPSBmdW5jdGlvbihqc29uKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwYXJlbnQ7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4ganNvbikge1xuICAgICAgICBpZiAocHJvcGVydHkgPT09ICdtZXNzYWdlJykge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2VPYmplY3QgPSBqc29uW3Byb3BlcnR5XTtcbiAgICAgICAgICAgIGZvciAocGFyZW50IGluIG1lc3NhZ2VPYmplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZUNvbnRlbnQgPSBzZWxmLmdldE1lc3NhZ2VCb3gobWVzc2FnZU9iamVjdFtwYXJlbnRdLm1lc3NhZ2UsIG1lc3NhZ2VPYmplY3RbcGFyZW50XS50eXBlLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgIHNlbGYuYXBwZW5kQ29udGVudChwYXJlbnQsIG1lc3NhZ2VDb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lbGVtZW50LnByb3AoJ3RhZ05hbWUnKSA9PT0gJ0ZPUk0nKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmRhdGEodGhpcy5lbGVtZW50WzBdLCAnZGF0YU9iamVjdCcsIGpzb25bcHJvcGVydHldKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcignYWpheC1kYXRhLW9iamVjdCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmVsZW1lbnQuY2xvc2VzdCgnZm9ybS5hamF4JykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmRhdGEodGhpcy5lbGVtZW50LmNsb3Nlc3QoJ2Zvcm0uYWpheCcpWzBdLCAnZGF0YU9iamVjdCcsIGpzb25bcHJvcGVydHldKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuY2xvc2VzdCgnZm9ybS5hamF4JykudHJpZ2dlcignYWpheC1kYXRhLW9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5ID09PSAnaHRtbCcpIHtcbiAgICAgICAgICAgIHZhciBodG1sT2JqZWN0ID0ganNvbltwcm9wZXJ0eV07XG4gICAgICAgICAgICBmb3IgKHBhcmVudCBpbiBodG1sT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbWV0aG9kIGluIGh0bWxPYmplY3RbcGFyZW50XSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSAnYXBwZW5kJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hcHBlbmRDb250ZW50KHBhcmVudCwgaHRtbE9iamVjdFtwYXJlbnRdW21ldGhvZF0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gJ3ByZXBlbmQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnByZXBlbmRDb250ZW50KHBhcmVudCwgaHRtbE9iamVjdFtwYXJlbnRdW21ldGhvZF0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlcGxhY2VDb250ZW50KHBhcmVudCwgaHRtbE9iamVjdFtwYXJlbnRdW21ldGhvZF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgKHByb3BlcnR5ID09PSAnamF2YVNjcmlwdEJlZm9yZScpXG4gICAgICAgICAgICB8fCAocHJvcGVydHkgPT09ICdqYXZhU2NyaXB0QWZ0ZXInKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZXZhbChqc29uW3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgalF1ZXJ5KGRvY3VtZW50KS5vbignbmV4dC1wYWdlJywgZnVuY3Rpb24oZXZlbnQsIGVsZW1lbnQpIHtcbiAgICAgICAgalF1ZXJ5LmRhdGEoZWxlbWVudCwgJ2pzb24tYWpheCcsIGpzb24pO1xuICAgIH0pO1xufTtcblxuQWpheEFwaS5wcm90b3R5cGUuZ2V0TWVzc2FnZUJveCA9IGZ1bmN0aW9uKHRleHQsIHR5cGUsIHBhcmVudCkge1xuICAgIHZhciBib3ggPSBqUXVlcnkoJzxkaXYgY2xhc3M9XCJtZXNzYWdlLWJveFwiIGRhdGEtZm9yPVwiIycgKyBwYXJlbnQgKyAnXCI+JyArIHRleHQgKyAnPC9kaXY+Jyk7XG4gICAgaWYgKHR5cGUgPT09IDEpIHtcbiAgICAgICAgYm94LmFkZENsYXNzKCdzdWNjZXNzJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAyKSB7XG4gICAgICAgIGJveC5hZGRDbGFzcygnaGludCcpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gOTkpIHtcbiAgICAgICAgYm94LmFkZENsYXNzKCdlcnJvcicpO1xuICAgIH1cblxuICAgIHJldHVybiBib3g7XG59O1xuXG5BamF4QXBpLnByb3RvdHlwZS5hcHBlbmRDb250ZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY29udGVudCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBuZXdDb250ZW50ID0galF1ZXJ5KGNvbnRlbnQpLmFwcGVuZFRvKGpRdWVyeSgnIycgKyBlbGVtZW50KSk7XG4gICAgICAgIGpRdWVyeSgnIycgKyBlbGVtZW50KS5maW5kKCcuYm94LWxvYWRpbmcnKS5yZW1vdmUoKTtcbiAgICAgICAgalF1ZXJ5KGRvY3VtZW50KS50cmlnZ2VyKCdya3ctYWpheC1hcGktY29udGVudC1jaGFuZ2VkJywgbmV3Q29udGVudC5wYXJlbnQoKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHt9XG59O1xuXG5BamF4QXBpLnByb3RvdHlwZS5wcmVwZW5kQ29udGVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNvbnRlbnQpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgbmV3Q29udGVudCA9IGpRdWVyeShjb250ZW50KS5wcmVwZW5kVG8oalF1ZXJ5KCcjJyArIGVsZW1lbnQpKTtcbiAgICAgICAgalF1ZXJ5KCcjJyArIGVsZW1lbnQpLmZpbmQoJy5ib3gtbG9hZGluZycpLnJlbW92ZSgpO1xuICAgICAgICBqUXVlcnkoZG9jdW1lbnQpLnRyaWdnZXIoJ3Jrdy1hamF4LWFwaS1jb250ZW50LWNoYW5nZWQnLCBuZXdDb250ZW50LnBhcmVudCgpKTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxufTtcblxuQWpheEFwaS5wcm90b3R5cGUucmVwbGFjZUNvbnRlbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjb250ZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGpRdWVyeShjb250ZW50KS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgbmV3Q29udGVudCA9IGpRdWVyeShjb250ZW50KS5hcHBlbmRUbyhqUXVlcnkoJyMnICsgZWxlbWVudCkuZW1wdHkoKSk7XG4gICAgICAgICAgICBqUXVlcnkoZG9jdW1lbnQpLnRyaWdnZXIoJ3Jrdy1hamF4LWFwaS1jb250ZW50LWNoYW5nZWQnLCBuZXdDb250ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGpRdWVyeSgnIycgKyBlbGVtZW50KS5lbXB0eSgpLmFwcGVuZChjb250ZW50KTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxufTtcblxualF1ZXJ5LmZuLmFqYXhBcGkgPSBmdW5jdGlvbigpIHtcbiAgICBqUXVlcnkodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgbmV3IEFqYXhBcGkoalF1ZXJ5KHRoaXMpKTtcbiAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWpheEFwaTtcbiIsInZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcblxuZnVuY3Rpb24gQ29sbGFwc2UoZWxlbWVudCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmVsZW1lbnQgPSBqUXVlcnkoZWxlbWVudCk7XG4gICAgXG4gICAgdGhpcy5lbGVtZW50LndyYXAoJzxkaXYgY2xhc3M9XCJjb2xsYXBzZWQtdGV4dF9fY29udGFpbmVyXCI+PC9kaXY+Jyk7XG4gICAgdGhpcy5jb250YWluZXIgPSB0aGlzLmVsZW1lbnQucGFyZW50KCk7XG5cbiAgICBcbiAgICB0aGlzLnNob3dMYWJlbCA9IHRoaXMuZWxlbWVudC5kYXRhKCdzaG93JykgfHwgJ1Nob3cgbW9yZSc7XG4gICAgdGhpcy5oaWRlTGFiZWwgPSB0aGlzLmVsZW1lbnQuZGF0YSgnaGlkZScpIHx8ICdIaWRlJztcbiAgICBcbiAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcygnY29sbGFwc2VkLXRleHQtLWhpZGRlbicpO1xuICAgIHRoaXMuY29udGFpbmVyLmFmdGVyKCc8YSBjbGFzcz1cImNvbGxhcHNlZC10ZXh0X190b2dnbGVcIj4nICsgdGhpcy5zaG93TGFiZWwgKyAnPC9hPicpO1xuICAgIHRoaXMuY2hlY2tTaXplKCk7XG4gICAgICAgICAgICBcbiAgICB0aGlzLnRvZ2dsZUhhbmRsZXIgPSB0aGlzLmNvbnRhaW5lci5uZXh0KCcuY29sbGFwc2VkLXRleHRfX3RvZ2dsZScpO1xuXG4gICAgalF1ZXJ5KHdpbmRvdykucmVzaXplKHRoaXMuY2hlY2tTaXplLmJpbmQodGhpcykpO1xuICAgIGpRdWVyeSh3aW5kb3cpLm9uKCdmb250LXJlbG9hZCcsIHRoaXMuY2hlY2tTaXplLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgXG4gICAgdGhpcy50b2dnbGVIYW5kbGVyLmNsaWNrKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lci5oYXNDbGFzcygnY29sbGFwc2VkLXRleHQtLWhpZGRlbicpKSB7XG4gICAgICAgICAgICBqUXVlcnkoJy5jb2xsYXBzZWQtdGV4dF9fY29udGFpbmVyOm5vdCguY29sbGFwc2VkLXRleHQtLWhpZGRlbiknKS5hZGRDbGFzcygnY29sbGFwc2VkLXRleHQtLWhpZGRlbicpLmNzcygnaGVpZ2h0JywgJycpLm5leHQoJy5jb2xsYXBzZWQtdGV4dF9fdG9nZ2xlJykuaHRtbCh0aGlzLnNob3dMYWJlbCk7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG5cbiAgICB9LmJpbmQodGhpcykpO1xufVxuXG5Db2xsYXBzZS5wcm90b3R5cGUuY2hlY2tTaXplID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50ZXh0SGVpZ2h0ID0gdGhpcy5lbGVtZW50LmhlaWdodCgpO1xuXG4gICAgaWYgKCF0aGlzLmNvbnRhaW5lci5oYXNDbGFzcygnY29sbGFwc2VkLXRleHQtLWhpZGRlbicpKVxuICAgICAgICBpZiAodGhpcy50ZXh0SGVpZ2h0ID4gMTAwKVxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY3NzKCdoZWlnaHQnLCB0aGlzLnRleHRIZWlnaHQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jc3MoJ2hlaWdodCcsICcnKTtcblxuICAgIGlmICh0aGlzLnRleHRIZWlnaHQgPD0gMTAwKVxuICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcygnY29sbGFwc2VkLXRleHQtLXZpc2libGUnKTtcbiAgICBlbHNlXG4gICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNsYXNzKCdjb2xsYXBzZWQtdGV4dC0tdmlzaWJsZScpO1xufTtcblxuQ29sbGFwc2UucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcygnY29sbGFwc2VkLXRleHQtLWhpZGRlbicpO1xuICAgIHRoaXMuY29udGFpbmVyLmNzcygnaGVpZ2h0JywgdGhpcy50ZXh0SGVpZ2h0KTtcbiAgICB0aGlzLnRvZ2dsZUhhbmRsZXIuaHRtbCh0aGlzLmhpZGVMYWJlbCk7XG59O1xuXG5Db2xsYXBzZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKCdjb2xsYXBzZWQtdGV4dC0taGlkZGVuJyk7XG4gICAgdGhpcy5jb250YWluZXIuY3NzKCdoZWlnaHQnLCAnJyk7XG4gICAgdGhpcy50b2dnbGVIYW5kbGVyLmh0bWwodGhpcy5zaG93TGFiZWwpO1xufTtcblxuQ29sbGFwc2UucHJvdG90eXBlLm9uU2xpZGVDaGFuZ2UgPSBmdW5jdGlvbihpdGVtSW5kZXgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG59O1xuXG5qUXVlcnkuZm4uY29sbGFwc2UgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4galF1ZXJ5KHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIG5ldyBDb2xsYXBzZShqUXVlcnkodGhpcykpO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsYXBzZTtcbiIsInZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcbnZhciB2aWV3cG9ydCA9IHJlcXVpcmUoJy4uL3V0aWxzL3ZpZXdwb3J0Jyk7XG52YXIgZ3JvdXBzID0ge307XG5cbmZ1bmN0aW9uIGFkZChlbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IGpRdWVyeShlbGVtZW50KTtcbiAgICB2YXIgZ3JvdXBOYW1lID0gZWxlbWVudC5kYXRhKCdlcXVhbC13aWR0aC1ncm91cCcpO1xuICAgIGdyb3Vwc1tncm91cE5hbWVdID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQWxsKCkge1xuICAgIGZvciAodmFyIGdyb3VwTmFtZSBpbiBncm91cHMpXG4gICAgICAgIHVwZGF0ZUdyb3VwKGdyb3VwTmFtZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUdyb3VwKGdyb3VwTmFtZSkge1xuICAgIHZhciB3aWR0aCA9IDA7XG4gICAgdmFyIGVsZW1lbnRzID0gW107XG5cbiAgICBqUXVlcnkoJ1tkYXRhLWVxdWFsLXdpZHRoLWdyb3VwPVwiJyArIGdyb3VwTmFtZSArICdcIl0nKS5jc3MoJ3dpZHRoJywgJycpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0galF1ZXJ5KHRoaXMpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZWxlbWVudC5hdHRyKCdkYXRhLWdyb3VwLXZpZXdwb3J0JykgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHZhciB2aWV3cG9ydHMgPSBlbGVtZW50LmRhdGEoJ2dyb3VwLXZpZXdwb3J0JykudG9TdHJpbmcoKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3cG9ydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodmlld3BvcnQuaXModmlld3BvcnRzW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgZWxlbWVudHNbaV0ub3V0ZXJXaWR0aCgpKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgIGVsZW1lbnRzW2ldLmNzcygnd2lkdGgnLCB3aWR0aCk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgYWRkKHRoaXMpO1xufVxuXG5qUXVlcnkod2luZG93KS5yZXNpemUodXBkYXRlQWxsKTtcbnZpZXdwb3J0Lm9uQ2hhbmdlLmNvbm5lY3QodXBkYXRlQWxsKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ2hhbmRsZXInOiBoYW5kbGVyLFxuICAgICdhZGQnOiBhZGQsXG4gICAgJ3VwZGF0ZUdyb3VwJzogdXBkYXRlR3JvdXAsXG4gICAgJ3VwZGF0ZUFsbCc6IHVwZGF0ZUFsbFxufTtcbiIsImZ1bmN0aW9uIEhvbWUoY29udGFpbmVyKSB7XG4gICAgdGhpcy5zZWxmID0gdGhpcztcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLmJvZHkgPSBqUXVlcnkoJ2JvZHknKTtcbiAgICB0aGlzLndpbmRvdyA9IGpRdWVyeSh3aW5kb3cpO1xuXG4gICAgdGhpcy5zZXRPd2woKTtcbiAgICBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgdGhpcy5zZXRPd2wuYmluZCh0aGlzKSk7XG59XG5cbkhvbWUucHJvdG90eXBlLnNldE93bCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICgkKHdpbmRvdykud2lkdGgoKSA+PSA5NjApe1xuICAgICAgICB2YXIgc2xpZGVyID0gdGhpcy5jb250YWluZXIuZmluZCgnLnRpdGxlX19zbGlkZXItLWRlc2t0b3AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2xpZGVyID0gdGhpcy5jb250YWluZXIuZmluZCgnLnRpdGxlX19zbGlkZXItLW1vYmlsZScpO1xuICAgIH1cblxuICAgIHNsaWRlci5vd2xDYXJvdXNlbCh7XG4gICAgICAgIGxvb3A6IHRydWUsXG4gICAgICAgIGF1dG9wbGF5OiB0cnVlLFxuICAgICAgICBhdXRvcGxheVRpbWVvdXQ6IDUwMDAsXG4gICAgICAgIGl0ZW1zOiAxXG4gICAgfSk7XG59XG5cbmpRdWVyeS5mbi5Ib21lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGpRdWVyeSh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICBuZXcgSG9tZShqUXVlcnkodGhpcykpO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgSG9tZTogSG9tZVxufTsiLCIvKiFcbiAqIEphdmFTY3JpcHQgQ3VzdG9tIEZvcm1zIDogQ2hlY2tib3ggTW9kdWxlXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSBQU0QySFRNTCAtIGh0dHA6Ly9wc2QyaHRtbC5jb20vamNmXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgKExJQ0VOU0UudHh0KVxuICpcbiAqIFZlcnNpb246IDEuMS4yXG4gKi9cbjsoZnVuY3Rpb24oJCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0amNmLmFkZE1vZHVsZSh7XG5cdFx0bmFtZTogJ0NoZWNrYm94Jyxcblx0XHRzZWxlY3RvcjogJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScsXG5cdFx0b3B0aW9uczoge1xuXHRcdFx0d3JhcE5hdGl2ZTogdHJ1ZSxcblx0XHRcdGNoZWNrZWRDbGFzczogJ2pjZi1jaGVja2VkJyxcblx0XHRcdHVuY2hlY2tlZENsYXNzOiAnamNmLXVuY2hlY2tlZCcsXG5cdFx0XHRsYWJlbEFjdGl2ZUNsYXNzOiAnamNmLWxhYmVsLWFjdGl2ZScsXG5cdFx0XHRmYWtlU3RydWN0dXJlOiAnPHNwYW4gY2xhc3M9XCJqY2YtY2hlY2tib3hcIj48c3Bhbj48L3NwYW4+PC9zcGFuPidcblx0XHR9LFxuXHRcdG1hdGNoRWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIGVsZW1lbnQuaXMoJzpjaGVja2JveCcpO1xuXHRcdH0sXG5cdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmluaXRTdHJ1Y3R1cmUoKTtcblx0XHRcdHRoaXMuYXR0YWNoRXZlbnRzKCk7XG5cdFx0XHR0aGlzLnJlZnJlc2goKTtcblx0XHR9LFxuXHRcdGluaXRTdHJ1Y3R1cmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gcHJlcGFyZSBzdHJ1Y3R1cmVcblx0XHRcdHRoaXMuZG9jID0gJChkb2N1bWVudCk7XG5cdFx0XHR0aGlzLnJlYWxFbGVtZW50ID0gJCh0aGlzLm9wdGlvbnMuZWxlbWVudCk7XG5cdFx0XHR0aGlzLmZha2VFbGVtZW50ID0gJCh0aGlzLm9wdGlvbnMuZmFrZVN0cnVjdHVyZSkuaW5zZXJ0QWZ0ZXIodGhpcy5yZWFsRWxlbWVudCk7XG5cdFx0XHR0aGlzLmxhYmVsRWxlbWVudCA9IHRoaXMuZ2V0TGFiZWxGb3IoKTtcblxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy53cmFwTmF0aXZlKSB7XG5cdFx0XHRcdC8vIHdyYXAgbmF0aXZlIGNoZWNrYm94IGluc2lkZSBmYWtlIGJsb2NrXG5cdFx0XHRcdHRoaXMucmVhbEVsZW1lbnQuYXBwZW5kVG8odGhpcy5mYWtlRWxlbWVudCkuY3NzKHtcblx0XHRcdFx0XHRwb3NpdGlvbjogJ2Fic29sdXRlJyxcblx0XHRcdFx0XHRoZWlnaHQ6ICcxMDAlJyxcblx0XHRcdFx0XHR3aWR0aDogJzEwMCUnLFxuXHRcdFx0XHRcdG9wYWNpdHk6IDAsXG5cdFx0XHRcdFx0bWFyZ2luOiAwXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8ganVzdCBoaWRlIG5hdGl2ZSBjaGVja2JveFxuXHRcdFx0XHR0aGlzLnJlYWxFbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5oaWRkZW5DbGFzcyk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhdHRhY2hFdmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gYWRkIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHR0aGlzLnJlYWxFbGVtZW50Lm9uKHtcblx0XHRcdFx0Zm9jdXM6IHRoaXMub25Gb2N1cyxcblx0XHRcdFx0Y2xpY2s6IHRoaXMub25SZWFsQ2xpY2tcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5mYWtlRWxlbWVudC5vbignY2xpY2snLCB0aGlzLm9uRmFrZUNsaWNrKTtcblx0XHRcdHRoaXMuZmFrZUVsZW1lbnQub24oJ2pjZi1wb2ludGVyZG93bicsIHRoaXMub25QcmVzcyk7XG5cdFx0fSxcblx0XHRvblJlYWxDbGljazogZnVuY3Rpb24oZSkge1xuXHRcdFx0Ly8ganVzdCByZWRyYXcgZmFrZSBlbGVtZW50IChzZXRUaW1lb3V0IGhhbmRsZXMgY2xpY2sgdGhhdCBtaWdodCBiZSBwcmV2ZW50ZWQpXG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHR0aGlzLnNhdmVkRXZlbnRPYmplY3QgPSBlO1xuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5yZWZyZXNoKCk7XG5cdFx0XHR9LCAwKTtcblx0XHR9LFxuXHRcdG9uRmFrZUNsaWNrOiBmdW5jdGlvbihlKSB7XG5cdFx0XHQvLyBza2lwIGV2ZW50IGlmIGNsaWNrZWQgb24gcmVhbCBlbGVtZW50IGluc2lkZSB3cmFwcGVyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLndyYXBOYXRpdmUgJiYgdGhpcy5yZWFsRWxlbWVudC5pcyhlLnRhcmdldCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB0b2dnbGUgY2hlY2tlZCBjbGFzc1xuXHRcdFx0aWYgKCF0aGlzLnJlYWxFbGVtZW50LmlzKCc6ZGlzYWJsZWQnKSkge1xuXHRcdFx0XHRkZWxldGUgdGhpcy5zYXZlZEV2ZW50T2JqZWN0O1xuXHRcdFx0XHR0aGlzLnN0YXRlQ2hlY2tlZCA9IHRoaXMucmVhbEVsZW1lbnQucHJvcCgnY2hlY2tlZCcpO1xuXHRcdFx0XHR0aGlzLnJlYWxFbGVtZW50LnByb3AoJ2NoZWNrZWQnLCAhdGhpcy5zdGF0ZUNoZWNrZWQpO1xuXHRcdFx0XHR0aGlzLmZpcmVOYXRpdmVFdmVudCh0aGlzLnJlYWxFbGVtZW50LCAnY2xpY2snKTtcblx0XHRcdFx0aWYgKHRoaXMuc2F2ZWRFdmVudE9iamVjdCAmJiB0aGlzLnNhdmVkRXZlbnRPYmplY3QuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcblx0XHRcdFx0XHR0aGlzLnJlYWxFbGVtZW50LnByb3AoJ2NoZWNrZWQnLCB0aGlzLnN0YXRlQ2hlY2tlZCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5maXJlTmF0aXZlRXZlbnQodGhpcy5yZWFsRWxlbWVudCwgJ2NoYW5nZScpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLnNhdmVkRXZlbnRPYmplY3Q7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvbkZvY3VzOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICghdGhpcy5wcmVzc2VkRmxhZyB8fCAhdGhpcy5mb2N1c2VkRmxhZykge1xuXHRcdFx0XHR0aGlzLmZvY3VzZWRGbGFnID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5mYWtlRWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZm9jdXNDbGFzcyk7XG5cdFx0XHRcdHRoaXMucmVhbEVsZW1lbnQub24oJ2JsdXInLCB0aGlzLm9uQmx1cik7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvbkJsdXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCF0aGlzLnByZXNzZWRGbGFnKSB7XG5cdFx0XHRcdHRoaXMuZm9jdXNlZEZsYWcgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5mYWtlRWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZm9jdXNDbGFzcyk7XG5cdFx0XHRcdHRoaXMucmVhbEVsZW1lbnQub2ZmKCdibHVyJywgdGhpcy5vbkJsdXIpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0b25QcmVzczogZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYgKCF0aGlzLmZvY3VzZWRGbGFnICYmIGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHtcblx0XHRcdFx0dGhpcy5yZWFsRWxlbWVudC5mb2N1cygpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5wcmVzc2VkRmxhZyA9IHRydWU7XG5cdFx0XHR0aGlzLmZha2VFbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5wcmVzc2VkQ2xhc3MpO1xuXHRcdFx0dGhpcy5kb2Mub24oJ2pjZi1wb2ludGVydXAnLCB0aGlzLm9uUmVsZWFzZSk7XG5cdFx0fSxcblx0XHRvblJlbGVhc2U6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdGlmICh0aGlzLmZvY3VzZWRGbGFnICYmIGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHtcblx0XHRcdFx0dGhpcy5yZWFsRWxlbWVudC5mb2N1cygpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5wcmVzc2VkRmxhZyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5mYWtlRWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMucHJlc3NlZENsYXNzKTtcblx0XHRcdHRoaXMuZG9jLm9mZignamNmLXBvaW50ZXJ1cCcsIHRoaXMub25SZWxlYXNlKTtcblx0XHR9LFxuXHRcdGdldExhYmVsRm9yOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwYXJlbnRMYWJlbCA9IHRoaXMucmVhbEVsZW1lbnQuY2xvc2VzdCgnbGFiZWwnKSxcblx0XHRcdFx0ZWxlbWVudElkID0gdGhpcy5yZWFsRWxlbWVudC5wcm9wKCdpZCcpO1xuXG5cdFx0XHRpZiAoIXBhcmVudExhYmVsLmxlbmd0aCAmJiBlbGVtZW50SWQpIHtcblx0XHRcdFx0cGFyZW50TGFiZWwgPSAkKCdsYWJlbFtmb3I9XCInICsgZWxlbWVudElkICsgJ1wiXScpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBhcmVudExhYmVsLmxlbmd0aCA/IHBhcmVudExhYmVsIDogbnVsbDtcblx0XHR9LFxuXHRcdHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gcmVkcmF3IGN1c3RvbSBjaGVja2JveFxuXHRcdFx0dmFyIGlzQ2hlY2tlZCA9IHRoaXMucmVhbEVsZW1lbnQuaXMoJzpjaGVja2VkJyksXG5cdFx0XHRcdGlzRGlzYWJsZWQgPSB0aGlzLnJlYWxFbGVtZW50LmlzKCc6ZGlzYWJsZWQnKTtcblxuXHRcdFx0dGhpcy5mYWtlRWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLm9wdGlvbnMuY2hlY2tlZENsYXNzLCBpc0NoZWNrZWQpXG5cdFx0XHRcdFx0XHRcdC50b2dnbGVDbGFzcyh0aGlzLm9wdGlvbnMudW5jaGVja2VkQ2xhc3MsICFpc0NoZWNrZWQpXG5cdFx0XHRcdFx0XHRcdC50b2dnbGVDbGFzcyh0aGlzLm9wdGlvbnMuZGlzYWJsZWRDbGFzcywgaXNEaXNhYmxlZCk7XG5cblx0XHRcdGlmICh0aGlzLmxhYmVsRWxlbWVudCkge1xuXHRcdFx0XHR0aGlzLmxhYmVsRWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLm9wdGlvbnMubGFiZWxBY3RpdmVDbGFzcywgaXNDaGVja2VkKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gcmVzdG9yZSBzdHJ1Y3R1cmVcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMud3JhcE5hdGl2ZSkge1xuXHRcdFx0XHR0aGlzLnJlYWxFbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLmZha2VFbGVtZW50KS5jc3Moe1xuXHRcdFx0XHRcdHBvc2l0aW9uOiAnJyxcblx0XHRcdFx0XHR3aWR0aDogJycsXG5cdFx0XHRcdFx0aGVpZ2h0OiAnJyxcblx0XHRcdFx0XHRvcGFjaXR5OiAnJyxcblx0XHRcdFx0XHRtYXJnaW46ICcnXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5yZWFsRWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuaGlkZGVuQ2xhc3MpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyByZW1vdmluZyBlbGVtZW50IHdpbGwgYWxzbyByZW1vdmUgaXRzIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHR0aGlzLmZha2VFbGVtZW50Lm9mZignamNmLXBvaW50ZXJkb3duJywgdGhpcy5vblByZXNzKTtcblx0XHRcdHRoaXMuZmFrZUVsZW1lbnQucmVtb3ZlKCk7XG5cblx0XHRcdC8vIHJlbW92ZSBvdGhlciBldmVudCBoYW5kbGVyc1xuXHRcdFx0dGhpcy5kb2Mub2ZmKCdqY2YtcG9pbnRlcnVwJywgdGhpcy5vblJlbGVhc2UpO1xuXHRcdFx0dGhpcy5yZWFsRWxlbWVudC5vZmYoe1xuXHRcdFx0XHRmb2N1czogdGhpcy5vbkZvY3VzLFxuXHRcdFx0XHRjbGljazogdGhpcy5vblJlYWxDbGlja1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9KTtcblxufShqUXVlcnkpKTtcbiIsIi8qIVxuICogSmF2YVNjcmlwdCBDdXN0b20gRm9ybXMgOiBGaWxlIE1vZHVsZVxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUgUFNEMkhUTUwgLSBodHRwOi8vcHNkMmh0bWwuY29tL2pjZlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIChMSUNFTlNFLnR4dClcbiAqXG4gKiBWZXJzaW9uOiAxLjEuMlxuICovXG47KGZ1bmN0aW9uKCQpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGpjZi5hZGRNb2R1bGUoe1xuXHRcdG5hbWU6ICdGaWxlJyxcblx0XHRzZWxlY3RvcjogJ2lucHV0W3R5cGU9XCJmaWxlXCJdJyxcblx0XHRvcHRpb25zOiB7XG5cdFx0XHRmYWtlU3RydWN0dXJlOiAnPHNwYW4gY2xhc3M9XCJqY2YtZmlsZVwiPjxzcGFuIGNsYXNzPVwiamNmLWZha2UtaW5wdXRcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJqY2YtdXBsb2FkLWJ1dHRvblwiPjxzcGFuIGNsYXNzPVwiamNmLWJ1dHRvbi1jb250ZW50XCI+PC9zcGFuPjwvc3Bhbj48L3NwYW4+Jyxcblx0XHRcdGJ1dHRvblRleHQ6ICdDaG9vc2UgZmlsZScsXG5cdFx0XHRwbGFjZWhvbGRlclRleHQ6ICdObyBmaWxlIGNob3NlbicsXG5cdFx0XHRyZWFsRWxlbWVudENsYXNzOiAnamNmLXJlYWwtZWxlbWVudCcsXG5cdFx0XHRleHRlbnNpb25QcmVmaXhDbGFzczogJ2pjZi1leHRlbnNpb24tJyxcblx0XHRcdHNlbGVjdGVkRmlsZUJsb2NrOiAnLmpjZi1mYWtlLWlucHV0Jyxcblx0XHRcdGJ1dHRvblRleHRCbG9jazogJy5qY2YtYnV0dG9uLWNvbnRlbnQnXG5cdFx0fSxcblx0XHRtYXRjaEVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdHJldHVybiBlbGVtZW50LmlzKCdpbnB1dFt0eXBlPVwiZmlsZVwiXScpO1xuXHRcdH0sXG5cdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmluaXRTdHJ1Y3R1cmUoKTtcblx0XHRcdHRoaXMuYXR0YWNoRXZlbnRzKCk7XG5cdFx0XHR0aGlzLnJlZnJlc2goKTtcblx0XHR9LFxuXHRcdGluaXRTdHJ1Y3R1cmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5kb2MgPSAkKGRvY3VtZW50KTtcblx0XHRcdHRoaXMucmVhbEVsZW1lbnQgPSAkKHRoaXMub3B0aW9ucy5lbGVtZW50KS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMucmVhbEVsZW1lbnRDbGFzcyk7XG5cdFx0XHR0aGlzLmZha2VFbGVtZW50ID0gJCh0aGlzLm9wdGlvbnMuZmFrZVN0cnVjdHVyZSkuaW5zZXJ0QmVmb3JlKHRoaXMucmVhbEVsZW1lbnQpO1xuXHRcdFx0dGhpcy5maWxlTmFtZUJsb2NrID0gdGhpcy5mYWtlRWxlbWVudC5maW5kKHRoaXMub3B0aW9ucy5zZWxlY3RlZEZpbGVCbG9jayk7XG5cdFx0XHR0aGlzLmJ1dHRvblRleHRCbG9jayA9IHRoaXMuZmFrZUVsZW1lbnQuZmluZCh0aGlzLm9wdGlvbnMuYnV0dG9uVGV4dEJsb2NrKS50ZXh0KHRoaXMub3B0aW9ucy5idXR0b25UZXh0KTtcblxuXHRcdFx0dGhpcy5yZWFsRWxlbWVudC5hcHBlbmRUbyh0aGlzLmZha2VFbGVtZW50KS5jc3Moe1xuXHRcdFx0XHRwb3NpdGlvbjogJ2Fic29sdXRlJyxcblx0XHRcdFx0b3BhY2l0eTogMFxuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRhdHRhY2hFdmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5yZWFsRWxlbWVudC5vbih7XG5cdFx0XHRcdCdqY2YtcG9pbnRlcmRvd24nOiB0aGlzLm9uUHJlc3MsXG5cdFx0XHRcdGNoYW5nZTogdGhpcy5vbkNoYW5nZSxcblx0XHRcdFx0Zm9jdXM6IHRoaXMub25Gb2N1c1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRvbkNoYW5nZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnJlZnJlc2goKTtcblx0XHR9LFxuXHRcdG9uRm9jdXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5mYWtlRWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZm9jdXNDbGFzcyk7XG5cdFx0XHR0aGlzLnJlYWxFbGVtZW50Lm9uKCdibHVyJywgdGhpcy5vbkJsdXIpO1xuXHRcdH0sXG5cdFx0b25CbHVyOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuZmFrZUVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmZvY3VzQ2xhc3MpO1xuXHRcdFx0dGhpcy5yZWFsRWxlbWVudC5vZmYoJ2JsdXInLCB0aGlzLm9uQmx1cik7XG5cdFx0fSxcblx0XHRvblByZXNzOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuZmFrZUVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnByZXNzZWRDbGFzcyk7XG5cdFx0XHR0aGlzLmRvYy5vbignamNmLXBvaW50ZXJ1cCcsIHRoaXMub25SZWxlYXNlKTtcblx0XHR9LFxuXHRcdG9uUmVsZWFzZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmZha2VFbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5wcmVzc2VkQ2xhc3MpO1xuXHRcdFx0dGhpcy5kb2Mub2ZmKCdqY2YtcG9pbnRlcnVwJywgdGhpcy5vblJlbGVhc2UpO1xuXHRcdH0sXG5cdFx0Z2V0RmlsZU5hbWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHJlc3VsdEZpbGVOYW1lID0gJycsXG5cdFx0XHRcdGZpbGVzID0gdGhpcy5yZWFsRWxlbWVudC5wcm9wKCdmaWxlcycpO1xuXG5cdFx0XHRpZiAoZmlsZXMgJiYgZmlsZXMubGVuZ3RoKSB7XG5cdFx0XHRcdCQuZWFjaChmaWxlcywgZnVuY3Rpb24oaW5kZXgsIGZpbGUpIHtcblx0XHRcdFx0XHRyZXN1bHRGaWxlTmFtZSArPSAoaW5kZXggPiAwID8gJywgJyA6ICcnKSArIGZpbGUubmFtZTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHRGaWxlTmFtZSA9IHRoaXMucmVhbEVsZW1lbnQudmFsKCkucmVwbGFjZSgvXltcXHNcXFNdKig/OlxcXFx8XFwvKShbXFxzXFxTXlxcXFxcXC9dKikkL2csICckMScpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0RmlsZU5hbWU7XG5cdFx0fSxcblx0XHRnZXRGaWxlRXh0ZW5zaW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBmaWxlTmFtZSA9IHRoaXMucmVhbEVsZW1lbnQudmFsKCk7XG5cdFx0XHRyZXR1cm4gZmlsZU5hbWUubGFzdEluZGV4T2YoJy4nKSA8IDAgPyAnJyA6IGZpbGVOYW1lLnN1YnN0cmluZyhmaWxlTmFtZS5sYXN0SW5kZXhPZignLicpICsgMSkudG9Mb3dlckNhc2UoKTtcblx0XHR9LFxuXHRcdHVwZGF0ZUV4dGVuc2lvbkNsYXNzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjdXJyZW50RXh0ZW5zaW9uID0gdGhpcy5nZXRGaWxlRXh0ZW5zaW9uKCksXG5cdFx0XHRcdGN1cnJlbnRDbGFzc0xpc3QgPSB0aGlzLmZha2VFbGVtZW50LnByb3AoJ2NsYXNzTmFtZScpLFxuXHRcdFx0XHRjbGVhbmVkQ2xhc3NMaXN0ID0gY3VycmVudENsYXNzTGlzdC5yZXBsYWNlKG5ldyBSZWdFeHAoJyhcXFxcc3xeKScgKyB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9uUHJlZml4Q2xhc3MgKyAnW14gXSsnLCdnaScpLCAnJyk7XG5cblx0XHRcdHRoaXMuZmFrZUVsZW1lbnQucHJvcCgnY2xhc3NOYW1lJywgY2xlYW5lZENsYXNzTGlzdCk7XG5cdFx0XHRpZiAoY3VycmVudEV4dGVuc2lvbikge1xuXHRcdFx0XHR0aGlzLmZha2VFbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5leHRlbnNpb25QcmVmaXhDbGFzcyArIGN1cnJlbnRFeHRlbnNpb24pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0cmVmcmVzaDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZWN0ZWRGaWxlTmFtZSA9IHRoaXMuZ2V0RmlsZU5hbWUoKSB8fCB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXJUZXh0O1xuXHRcdFx0dGhpcy5mYWtlRWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLm9wdGlvbnMuZGlzYWJsZWRDbGFzcywgdGhpcy5yZWFsRWxlbWVudC5pcygnOmRpc2FibGVkJykpO1xuXHRcdFx0dGhpcy5maWxlTmFtZUJsb2NrLnRleHQoc2VsZWN0ZWRGaWxlTmFtZSk7XG5cdFx0XHR0aGlzLnVwZGF0ZUV4dGVuc2lvbkNsYXNzKCk7XG5cdFx0fSxcblx0XHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIHJlc2V0IHN0eWxlcyBhbmQgcmVzdG9yZSBlbGVtZW50IHBvc2l0aW9uXG5cdFx0XHR0aGlzLnJlYWxFbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLmZha2VFbGVtZW50KS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMucmVhbEVsZW1lbnRDbGFzcykuY3NzKHtcblx0XHRcdFx0cG9zaXRpb246ICcnLFxuXHRcdFx0XHRvcGFjaXR5OiAnJ1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmZha2VFbGVtZW50LnJlbW92ZSgpO1xuXG5cdFx0XHQvLyByZW1vdmUgZXZlbnQgaGFuZGxlcnNcblx0XHRcdHRoaXMucmVhbEVsZW1lbnQub2ZmKHtcblx0XHRcdFx0J2pjZi1wb2ludGVyZG93bic6IHRoaXMub25QcmVzcyxcblx0XHRcdFx0Y2hhbmdlOiB0aGlzLm9uQ2hhbmdlLFxuXHRcdFx0XHRmb2N1czogdGhpcy5vbkZvY3VzLFxuXHRcdFx0XHRibHVyOiB0aGlzLm9uQmx1clxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmRvYy5vZmYoJ2pjZi1wb2ludGVydXAnLCB0aGlzLm9uUmVsZWFzZSk7XG5cdFx0fVxuXHR9KTtcblxufShqUXVlcnkpKTtcbiIsIi8qIVxuICogSmF2YVNjcmlwdCBDdXN0b20gRm9ybXNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1IFBTRDJIVE1MIC0gaHR0cDovL3BzZDJodG1sLmNvbS9qY2ZcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSAoTElDRU5TRS50eHQpXG4gKlxuICogVmVyc2lvbjogMS4xLjJcbiAqL1xuOyhmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdCd1c2Ugc3RyaWN0Jztcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXHRcdGRlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTtcblx0fSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnanF1ZXJ5JykpO1xuXHR9IGVsc2Uge1xuXHRcdHJvb3QuamNmID0gZmFjdG9yeShqUXVlcnkpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uKCQpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdC8vIGRlZmluZSB2ZXJzaW9uXG5cdHZhciB2ZXJzaW9uID0gJzEuMS4yJztcblxuXHQvLyBwcml2YXRlIHZhcmlhYmxlc1xuXHR2YXIgY3VzdG9tSW5zdGFuY2VzID0gW107XG5cblx0Ly8gZGVmYXVsdCBnbG9iYWwgb3B0aW9uc1xuXHR2YXIgY29tbW9uT3B0aW9ucyA9IHtcblx0XHRvcHRpb25zS2V5OiAnamNmJyxcblx0XHRkYXRhS2V5OiAnamNmLWluc3RhbmNlJyxcblx0XHRydGxDbGFzczogJ2pjZi1ydGwnLFxuXHRcdGZvY3VzQ2xhc3M6ICdqY2YtZm9jdXMnLFxuXHRcdHByZXNzZWRDbGFzczogJ2pjZi1wcmVzc2VkJyxcblx0XHRkaXNhYmxlZENsYXNzOiAnamNmLWRpc2FibGVkJyxcblx0XHRoaWRkZW5DbGFzczogJ2pjZi1oaWRkZW4nLFxuXHRcdHJlc2V0QXBwZWFyYW5jZUNsYXNzOiAnamNmLXJlc2V0LWFwcGVhcmFuY2UnLFxuXHRcdHVuc2VsZWN0YWJsZUNsYXNzOiAnamNmLXVuc2VsZWN0YWJsZSdcblx0fTtcblxuXHQvLyBkZXRlY3QgZGV2aWNlIHR5cGVcblx0dmFyIGlzVG91Y2hEZXZpY2UgPSAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB8fCB3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoLFxuXHRcdGlzV2luUGhvbmVEZXZpY2UgPSAvV2luZG93cyBQaG9uZS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblx0Y29tbW9uT3B0aW9ucy5pc01vYmlsZURldmljZSA9ICEhKGlzVG91Y2hEZXZpY2UgfHwgaXNXaW5QaG9uZURldmljZSk7XG5cblx0Ly8gY3JlYXRlIGdsb2JhbCBzdHlsZXNoZWV0IGlmIGN1c3RvbSBmb3JtcyBhcmUgdXNlZFxuXHR2YXIgY3JlYXRlU3R5bGVTaGVldCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzdHlsZVRhZyA9ICQoJzxzdHlsZT4nKS5hcHBlbmRUbygnaGVhZCcpLFxuXHRcdFx0c3R5bGVTaGVldCA9IHN0eWxlVGFnLnByb3AoJ3NoZWV0JykgfHwgc3R5bGVUYWcucHJvcCgnc3R5bGVTaGVldCcpO1xuXG5cdFx0Ly8gY3Jvc3Nicm93c2VyIHN0eWxlIGhhbmRsaW5nXG5cdFx0dmFyIGFkZENTU1J1bGUgPSBmdW5jdGlvbihzZWxlY3RvciwgcnVsZXMsIGluZGV4KSB7XG5cdFx0XHRpZiAoc3R5bGVTaGVldC5pbnNlcnRSdWxlKSB7XG5cdFx0XHRcdHN0eWxlU2hlZXQuaW5zZXJ0UnVsZShzZWxlY3RvciArICd7JyArIHJ1bGVzICsgJ30nLCBpbmRleCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdHlsZVNoZWV0LmFkZFJ1bGUoc2VsZWN0b3IsIHJ1bGVzLCBpbmRleCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIGFkZCBzcGVjaWFsIHJ1bGVzXG5cdFx0YWRkQ1NTUnVsZSgnLicgKyBjb21tb25PcHRpb25zLmhpZGRlbkNsYXNzLCAncG9zaXRpb246YWJzb2x1dGUgIWltcG9ydGFudDtsZWZ0Oi05OTk5cHggIWltcG9ydGFudDtoZWlnaHQ6MXB4ICFpbXBvcnRhbnQ7d2lkdGg6MXB4ICFpbXBvcnRhbnQ7bWFyZ2luOjAgIWltcG9ydGFudDtib3JkZXItd2lkdGg6MCAhaW1wb3J0YW50Oy13ZWJraXQtYXBwZWFyYW5jZTpub25lOy1tb3otYXBwZWFyYW5jZTpub25lO2FwcGVhcmFuY2U6bm9uZScpO1xuXHRcdGFkZENTU1J1bGUoJy4nICsgY29tbW9uT3B0aW9ucy5ydGxDbGFzcyArICcgLicgKyBjb21tb25PcHRpb25zLmhpZGRlbkNsYXNzLCAncmlnaHQ6LTk5OTlweCAhaW1wb3J0YW50OyBsZWZ0OiBhdXRvICFpbXBvcnRhbnQnKTtcblx0XHRhZGRDU1NSdWxlKCcuJyArIGNvbW1vbk9wdGlvbnMudW5zZWxlY3RhYmxlQ2xhc3MsICctd2Via2l0LXVzZXItc2VsZWN0OiBub25lOyAtbW96LXVzZXItc2VsZWN0OiBub25lOyAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7IHVzZXItc2VsZWN0OiBub25lOyAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoMCwwLDAsMCk7Jyk7XG5cdFx0YWRkQ1NTUnVsZSgnLicgKyBjb21tb25PcHRpb25zLnJlc2V0QXBwZWFyYW5jZUNsYXNzLCAnYmFja2dyb3VuZDogbm9uZTsgYm9yZGVyOiBub25lOyAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7IGFwcGVhcmFuY2U6IG5vbmU7IG9wYWNpdHk6IDA7IGZpbHRlcjogYWxwaGEob3BhY2l0eT0wKTsnKTtcblxuXHRcdC8vIGRldGVjdCBydGwgcGFnZXNcblx0XHR2YXIgaHRtbCA9ICQoJ2h0bWwnKSwgYm9keSA9ICQoJ2JvZHknKTtcblx0XHRpZiAoaHRtbC5jc3MoJ2RpcmVjdGlvbicpID09PSAncnRsJyB8fCBib2R5LmNzcygnZGlyZWN0aW9uJykgPT09ICdydGwnKSB7XG5cdFx0XHRodG1sLmFkZENsYXNzKGNvbW1vbk9wdGlvbnMucnRsQ2xhc3MpO1xuXHRcdH1cblxuXHRcdC8vIGhhbmRsZSBmb3JtIHJlc2V0IGV2ZW50XG5cdFx0aHRtbC5vbigncmVzZXQnLCBmdW5jdGlvbigpIHtcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGFwaS5yZWZyZXNoQWxsKCk7XG5cdFx0XHR9LCAwKTtcblx0XHR9KTtcblxuXHRcdC8vIG1hcmsgc3R5bGVzaGVldCBhcyBjcmVhdGVkXG5cdFx0Y29tbW9uT3B0aW9ucy5zdHlsZVNoZWV0Q3JlYXRlZCA9IHRydWU7XG5cdH07XG5cblx0Ly8gc2ltcGxpZmllZCBwb2ludGVyIGV2ZW50cyBoYW5kbGVyXG5cdChmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnRlckV2ZW50c1N1cHBvcnRlZCA9IG5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCB8fCBuYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCxcblx0XHRcdHRvdWNoRXZlbnRzU3VwcG9ydGVkID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgfHwgd2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaCxcblx0XHRcdGV2ZW50TGlzdCwgZXZlbnRNYXAgPSB7fSwgZXZlbnRQcmVmaXggPSAnamNmLSc7XG5cblx0XHQvLyBkZXRlY3QgZXZlbnRzIHRvIGF0dGFjaFxuXHRcdGlmIChwb2ludGVyRXZlbnRzU3VwcG9ydGVkKSB7XG5cdFx0XHRldmVudExpc3QgPSB7XG5cdFx0XHRcdHBvaW50ZXJvdmVyOiBuYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgPyAncG9pbnRlcm92ZXInIDogJ01TUG9pbnRlck92ZXInLFxuXHRcdFx0XHRwb2ludGVyZG93bjogbmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkID8gJ3BvaW50ZXJkb3duJyA6ICdNU1BvaW50ZXJEb3duJyxcblx0XHRcdFx0cG9pbnRlcm1vdmU6IG5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCA/ICdwb2ludGVybW92ZScgOiAnTVNQb2ludGVyTW92ZScsXG5cdFx0XHRcdHBvaW50ZXJ1cDogbmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkID8gJ3BvaW50ZXJ1cCcgOiAnTVNQb2ludGVyVXAnXG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRldmVudExpc3QgPSB7XG5cdFx0XHRcdHBvaW50ZXJvdmVyOiAnbW91c2VvdmVyJyxcblx0XHRcdFx0cG9pbnRlcmRvd246ICdtb3VzZWRvd24nICsgKHRvdWNoRXZlbnRzU3VwcG9ydGVkID8gJyB0b3VjaHN0YXJ0JyA6ICcnKSxcblx0XHRcdFx0cG9pbnRlcm1vdmU6ICdtb3VzZW1vdmUnICsgKHRvdWNoRXZlbnRzU3VwcG9ydGVkID8gJyB0b3VjaG1vdmUnIDogJycpLFxuXHRcdFx0XHRwb2ludGVydXA6ICdtb3VzZXVwJyArICh0b3VjaEV2ZW50c1N1cHBvcnRlZCA/ICcgdG91Y2hlbmQnIDogJycpXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIGNyZWF0ZSBldmVudCBtYXBcblx0XHQkLmVhY2goZXZlbnRMaXN0LCBmdW5jdGlvbih0YXJnZXRFdmVudE5hbWUsIGZha2VFdmVudExpc3QpIHtcblx0XHRcdCQuZWFjaChmYWtlRXZlbnRMaXN0LnNwbGl0KCcgJyksIGZ1bmN0aW9uKGluZGV4LCBmYWtlRXZlbnROYW1lKSB7XG5cdFx0XHRcdGV2ZW50TWFwW2Zha2VFdmVudE5hbWVdID0gdGFyZ2V0RXZlbnROYW1lO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHQvLyBqUXVlcnkgZXZlbnQgaG9va3Ncblx0XHQkLmVhY2goZXZlbnRMaXN0LCBmdW5jdGlvbihldmVudE5hbWUsIGV2ZW50SGFuZGxlcnMpIHtcblx0XHRcdGV2ZW50SGFuZGxlcnMgPSBldmVudEhhbmRsZXJzLnNwbGl0KCcgJyk7XG5cdFx0XHQkLmV2ZW50LnNwZWNpYWxbZXZlbnRQcmVmaXggKyBldmVudE5hbWVdID0ge1xuXHRcdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0XHRcdCQuZWFjaChldmVudEhhbmRsZXJzLCBmdW5jdGlvbihpbmRleCwgZmFsbGJhY2tFdmVudCkge1xuXHRcdFx0XHRcdFx0aWYgKHNlbGYuYWRkRXZlbnRMaXN0ZW5lcikgc2VsZi5hZGRFdmVudExpc3RlbmVyKGZhbGxiYWNrRXZlbnQsIGZpeEV2ZW50LCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRlbHNlIHNlbGZbJ29uJyArIGZhbGxiYWNrRXZlbnRdID0gZml4RXZlbnQ7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRcdFx0JC5lYWNoKGV2ZW50SGFuZGxlcnMsIGZ1bmN0aW9uKGluZGV4LCBmYWxsYmFja0V2ZW50KSB7XG5cdFx0XHRcdFx0XHRpZiAoc2VsZi5hZGRFdmVudExpc3RlbmVyKSBzZWxmLnJlbW92ZUV2ZW50TGlzdGVuZXIoZmFsbGJhY2tFdmVudCwgZml4RXZlbnQsIGZhbHNlKTtcblx0XHRcdFx0XHRcdGVsc2Ugc2VsZlsnb24nICsgZmFsbGJhY2tFdmVudF0gPSBudWxsO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0pO1xuXG5cdFx0Ly8gY2hlY2sgdGhhdCBtb3VzZSBldmVudCBhcmUgbm90IHNpbXVsYXRlZCBieSBtb2JpbGUgYnJvd3NlcnNcblx0XHR2YXIgbGFzdFRvdWNoID0gbnVsbDtcblx0XHR2YXIgbW91c2VFdmVudFNpbXVsYXRlZCA9IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBkeCA9IE1hdGguYWJzKGUucGFnZVggLSBsYXN0VG91Y2gueCksXG5cdFx0XHRcdGR5ID0gTWF0aC5hYnMoZS5wYWdlWSAtIGxhc3RUb3VjaC55KSxcblx0XHRcdFx0cmFuZ2VEaXN0YW5jZSA9IDI1O1xuXG5cdFx0XHRpZiAoZHggPD0gcmFuZ2VEaXN0YW5jZSAmJiBkeSA8PSByYW5nZURpc3RhbmNlKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBub3JtYWxpemUgZXZlbnRcblx0XHR2YXIgZml4RXZlbnQgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgb3JpZ0V2ZW50ID0gZSB8fCB3aW5kb3cuZXZlbnQsXG5cdFx0XHRcdHRvdWNoRXZlbnREYXRhID0gbnVsbCxcblx0XHRcdFx0dGFyZ2V0RXZlbnROYW1lID0gZXZlbnRNYXBbb3JpZ0V2ZW50LnR5cGVdO1xuXG5cdFx0XHRlID0gJC5ldmVudC5maXgob3JpZ0V2ZW50KTtcblx0XHRcdGUudHlwZSA9IGV2ZW50UHJlZml4ICsgdGFyZ2V0RXZlbnROYW1lO1xuXG5cdFx0XHRpZiAob3JpZ0V2ZW50LnBvaW50ZXJUeXBlKSB7XG5cdFx0XHRcdHN3aXRjaCAob3JpZ0V2ZW50LnBvaW50ZXJUeXBlKSB7XG5cdFx0XHRcdFx0Y2FzZSAyOiBlLnBvaW50ZXJUeXBlID0gJ3RvdWNoJzsgYnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAzOiBlLnBvaW50ZXJUeXBlID0gJ3Blbic7IGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgNDogZS5wb2ludGVyVHlwZSA9ICdtb3VzZSc7IGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6IGUucG9pbnRlclR5cGUgPSBvcmlnRXZlbnQucG9pbnRlclR5cGU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGUucG9pbnRlclR5cGUgPSBvcmlnRXZlbnQudHlwZS5zdWJzdHIoMCwgNSk7IC8vIFwibW91c2VcIiBvciBcInRvdWNoXCIgd29yZCBsZW5ndGhcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFlLnBhZ2VYICYmICFlLnBhZ2VZKSB7XG5cdFx0XHRcdHRvdWNoRXZlbnREYXRhID0gb3JpZ0V2ZW50LmNoYW5nZWRUb3VjaGVzID8gb3JpZ0V2ZW50LmNoYW5nZWRUb3VjaGVzWzBdIDogb3JpZ0V2ZW50O1xuXHRcdFx0XHRlLnBhZ2VYID0gdG91Y2hFdmVudERhdGEucGFnZVg7XG5cdFx0XHRcdGUucGFnZVkgPSB0b3VjaEV2ZW50RGF0YS5wYWdlWTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9yaWdFdmVudC50eXBlID09PSAndG91Y2hlbmQnKSB7XG5cdFx0XHRcdGxhc3RUb3VjaCA9IHsgeDogZS5wYWdlWCwgeTogZS5wYWdlWSB9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScgJiYgbGFzdFRvdWNoICYmIG1vdXNlRXZlbnRTaW11bGF0ZWQoZSkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuICgkLmV2ZW50LmRpc3BhdGNoIHx8ICQuZXZlbnQuaGFuZGxlKS5jYWxsKHRoaXMsIGUpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oKSk7XG5cblx0Ly8gY3VzdG9tIG1vdXNld2hlZWwvdHJhY2twYWQgaGFuZGxlclxuXHQoZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHdoZWVsRXZlbnRzID0gKCdvbndoZWVsJyBpbiBkb2N1bWVudCB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPj0gOSA/ICd3aGVlbCcgOiAnbW91c2V3aGVlbCBET01Nb3VzZVNjcm9sbCcpLnNwbGl0KCcgJyksXG5cdFx0XHRzaGltRXZlbnROYW1lID0gJ2pjZi1tb3VzZXdoZWVsJztcblxuXHRcdCQuZXZlbnQuc3BlY2lhbFtzaGltRXZlbnROYW1lXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0XHQkLmVhY2god2hlZWxFdmVudHMsIGZ1bmN0aW9uKGluZGV4LCBmYWxsYmFja0V2ZW50KSB7XG5cdFx0XHRcdFx0aWYgKHNlbGYuYWRkRXZlbnRMaXN0ZW5lcikgc2VsZi5hZGRFdmVudExpc3RlbmVyKGZhbGxiYWNrRXZlbnQsIGZpeEV2ZW50LCBmYWxzZSk7XG5cdFx0XHRcdFx0ZWxzZSBzZWxmWydvbicgKyBmYWxsYmFja0V2ZW50XSA9IGZpeEV2ZW50O1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdFx0JC5lYWNoKHdoZWVsRXZlbnRzLCBmdW5jdGlvbihpbmRleCwgZmFsbGJhY2tFdmVudCkge1xuXHRcdFx0XHRcdGlmIChzZWxmLmFkZEV2ZW50TGlzdGVuZXIpIHNlbGYucmVtb3ZlRXZlbnRMaXN0ZW5lcihmYWxsYmFja0V2ZW50LCBmaXhFdmVudCwgZmFsc2UpO1xuXHRcdFx0XHRcdGVsc2Ugc2VsZlsnb24nICsgZmFsbGJhY2tFdmVudF0gPSBudWxsO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIGZpeEV2ZW50ID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIG9yaWdFdmVudCA9IGUgfHwgd2luZG93LmV2ZW50O1xuXHRcdFx0ZSA9ICQuZXZlbnQuZml4KG9yaWdFdmVudCk7XG5cdFx0XHRlLnR5cGUgPSBzaGltRXZlbnROYW1lO1xuXG5cdFx0XHQvLyBvbGQgd2hlZWwgZXZlbnRzIGhhbmRsZXJcblx0XHRcdGlmICgnZGV0YWlsJyAgICAgIGluIG9yaWdFdmVudCkgeyBlLmRlbHRhWSA9IC1vcmlnRXZlbnQuZGV0YWlsOyAgICAgIH1cblx0XHRcdGlmICgnd2hlZWxEZWx0YScgIGluIG9yaWdFdmVudCkgeyBlLmRlbHRhWSA9IC1vcmlnRXZlbnQud2hlZWxEZWx0YTsgIH1cblx0XHRcdGlmICgnd2hlZWxEZWx0YVknIGluIG9yaWdFdmVudCkgeyBlLmRlbHRhWSA9IC1vcmlnRXZlbnQud2hlZWxEZWx0YVk7IH1cblx0XHRcdGlmICgnd2hlZWxEZWx0YVgnIGluIG9yaWdFdmVudCkgeyBlLmRlbHRhWCA9IC1vcmlnRXZlbnQud2hlZWxEZWx0YVg7IH1cblxuXHRcdFx0Ly8gbW9kZXJuIHdoZWVsIGV2ZW50IGhhbmRsZXJcblx0XHRcdGlmICgnZGVsdGFZJyBpbiBvcmlnRXZlbnQpIHtcblx0XHRcdFx0ZS5kZWx0YVkgPSBvcmlnRXZlbnQuZGVsdGFZO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCdkZWx0YVgnIGluIG9yaWdFdmVudCkge1xuXHRcdFx0XHRlLmRlbHRhWCA9IG9yaWdFdmVudC5kZWx0YVg7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGhhbmRsZSBkZWx0YU1vZGUgZm9yIG1vdXNlIHdoZWVsXG5cdFx0XHRlLmRlbHRhID0gZS5kZWx0YVkgfHwgZS5kZWx0YVg7XG5cdFx0XHRpZiAob3JpZ0V2ZW50LmRlbHRhTW9kZSA9PT0gMSkge1xuXHRcdFx0XHR2YXIgbGluZUhlaWdodCA9IDE2O1xuXHRcdFx0XHRlLmRlbHRhICo9IGxpbmVIZWlnaHQ7XG5cdFx0XHRcdGUuZGVsdGFZICo9IGxpbmVIZWlnaHQ7XG5cdFx0XHRcdGUuZGVsdGFYICo9IGxpbmVIZWlnaHQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoJC5ldmVudC5kaXNwYXRjaCB8fCAkLmV2ZW50LmhhbmRsZSkuY2FsbCh0aGlzLCBlKTtcblx0XHR9O1xuXHR9KCkpO1xuXG5cdC8vIGV4dHJhIG1vZHVsZSBtZXRob2RzXG5cdHZhciBtb2R1bGVNaXhpbiA9IHtcblx0XHQvLyBwcm92aWRlIGZ1bmN0aW9uIGZvciBmaXJpbmcgbmF0aXZlIGV2ZW50c1xuXHRcdGZpcmVOYXRpdmVFdmVudDogZnVuY3Rpb24oZWxlbWVudHMsIGV2ZW50TmFtZSkge1xuXHRcdFx0JChlbGVtZW50cykuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW1lbnQgPSB0aGlzLCBldmVudE9iamVjdDtcblx0XHRcdFx0aWYgKGVsZW1lbnQuZGlzcGF0Y2hFdmVudCkge1xuXHRcdFx0XHRcdGV2ZW50T2JqZWN0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcblx0XHRcdFx0XHRldmVudE9iamVjdC5pbml0RXZlbnQoZXZlbnROYW1lLCB0cnVlLCB0cnVlKTtcblx0XHRcdFx0XHRlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnRPYmplY3QpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KSB7XG5cdFx0XHRcdFx0ZXZlbnRPYmplY3QgPSBkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCgpO1xuXHRcdFx0XHRcdGV2ZW50T2JqZWN0LnRhcmdldCA9IGVsZW1lbnQ7XG5cdFx0XHRcdFx0ZWxlbWVudC5maXJlRXZlbnQoJ29uJyArIGV2ZW50TmFtZSwgZXZlbnRPYmplY3QpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdC8vIGJpbmQgZXZlbnQgaGFuZGxlcnMgZm9yIG1vZHVsZSBpbnN0YW5jZSAoZnVuY3Rpb25zIGJlZ2dpbmluZyB3aXRoIFwib25cIilcblx0XHRiaW5kSGFuZGxlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0JC5lYWNoKHNlbGYsIGZ1bmN0aW9uKHByb3BOYW1lLCBwcm9wVmFsdWUpIHtcblx0XHRcdFx0aWYgKHByb3BOYW1lLmluZGV4T2YoJ29uJykgPT09IDAgJiYgJC5pc0Z1bmN0aW9uKHByb3BWYWx1ZSkpIHtcblx0XHRcdFx0XHQvLyBkb250IHVzZSAkLnByb3h5IGhlcmUgYmVjYXVzZSBpdCBkb2Vzbid0IGNyZWF0ZSB1bmlxdWUgaGFuZGxlclxuXHRcdFx0XHRcdHNlbGZbcHJvcE5hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcHJvcFZhbHVlLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIHB1YmxpYyBBUElcblx0dmFyIGFwaSA9IHtcblx0XHR2ZXJzaW9uOiB2ZXJzaW9uLFxuXHRcdG1vZHVsZXM6IHt9LFxuXHRcdGdldE9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICQuZXh0ZW5kKHt9LCBjb21tb25PcHRpb25zKTtcblx0XHR9LFxuXHRcdHNldE9wdGlvbnM6IGZ1bmN0aW9uKG1vZHVsZU5hbWUsIG1vZHVsZU9wdGlvbnMpIHtcblx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHQvLyBzZXQgbW9kdWxlIG9wdGlvbnNcblx0XHRcdFx0aWYgKHRoaXMubW9kdWxlc1ttb2R1bGVOYW1lXSkge1xuXHRcdFx0XHRcdCQuZXh0ZW5kKHRoaXMubW9kdWxlc1ttb2R1bGVOYW1lXS5wcm90b3R5cGUub3B0aW9ucywgbW9kdWxlT3B0aW9ucyk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHNldCBjb21tb24gb3B0aW9uc1xuXHRcdFx0XHQkLmV4dGVuZChjb21tb25PcHRpb25zLCBtb2R1bGVOYW1lKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGFkZE1vZHVsZTogZnVuY3Rpb24ocHJvdG8pIHtcblx0XHRcdC8vIGFkZCBtb2R1bGUgdG8gbGlzdFxuXHRcdFx0dmFyIE1vZHVsZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRcdFx0Ly8gc2F2ZSBpbnN0YW5jZSB0byBjb2xsZWN0aW9uXG5cdFx0XHRcdGlmICghb3B0aW9ucy5lbGVtZW50LmRhdGEoY29tbW9uT3B0aW9ucy5kYXRhS2V5KSkge1xuXHRcdFx0XHRcdG9wdGlvbnMuZWxlbWVudC5kYXRhKGNvbW1vbk9wdGlvbnMuZGF0YUtleSwgdGhpcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3VzdG9tSW5zdGFuY2VzLnB1c2godGhpcyk7XG5cblx0XHRcdFx0Ly8gc2F2ZSBvcHRpb25zXG5cdFx0XHRcdHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBjb21tb25PcHRpb25zLCB0aGlzLm9wdGlvbnMsIGdldElubGluZU9wdGlvbnMob3B0aW9ucy5lbGVtZW50KSwgb3B0aW9ucyk7XG5cblx0XHRcdFx0Ly8gYmluZCBldmVudCBoYW5kbGVycyB0byBpbnN0YW5jZVxuXHRcdFx0XHR0aGlzLmJpbmRIYW5kbGVycygpO1xuXG5cdFx0XHRcdC8vIGNhbGwgY29uc3RydWN0b3Jcblx0XHRcdFx0dGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBwYXJzZSBvcHRpb25zIGZyb20gSFRNTCBhdHRyaWJ1dGVcblx0XHRcdHZhciBnZXRJbmxpbmVPcHRpb25zID0gZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0XHR2YXIgZGF0YU9wdGlvbnMgPSBlbGVtZW50LmRhdGEoY29tbW9uT3B0aW9ucy5vcHRpb25zS2V5KSxcblx0XHRcdFx0XHRhdHRyT3B0aW9ucyA9IGVsZW1lbnQuYXR0cihjb21tb25PcHRpb25zLm9wdGlvbnNLZXkpO1xuXG5cdFx0XHRcdGlmIChkYXRhT3B0aW9ucykge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhT3B0aW9ucztcblx0XHRcdFx0fSBlbHNlIGlmIChhdHRyT3B0aW9ucykge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJC5wYXJzZUpTT04oYXR0ck9wdGlvbnMpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdC8vIGlnbm9yZSBpbnZhbGlkIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdC8vIHNldCBwcm90byBhcyBwcm90b3R5cGUgZm9yIG5ldyBtb2R1bGVcblx0XHRcdE1vZHVsZS5wcm90b3R5cGUgPSBwcm90bztcblxuXHRcdFx0Ly8gYWRkIG1peGluIG1ldGhvZHMgdG8gbW9kdWxlIHByb3RvXG5cdFx0XHQkLmV4dGVuZChwcm90bywgbW9kdWxlTWl4aW4pO1xuXHRcdFx0aWYgKHByb3RvLnBsdWdpbnMpIHtcblx0XHRcdFx0JC5lYWNoKHByb3RvLnBsdWdpbnMsIGZ1bmN0aW9uKHBsdWdpbk5hbWUsIHBsdWdpbikge1xuXHRcdFx0XHRcdCQuZXh0ZW5kKHBsdWdpbi5wcm90b3R5cGUsIG1vZHVsZU1peGluKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIG92ZXJyaWRlIGRlc3Ryb3kgbWV0aG9kXG5cdFx0XHR2YXIgb3JpZ2luYWxEZXN0cm95ID0gTW9kdWxlLnByb3RvdHlwZS5kZXN0cm95O1xuXHRcdFx0TW9kdWxlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5lbGVtZW50LnJlbW92ZURhdGEodGhpcy5vcHRpb25zLmRhdGFLZXkpO1xuXG5cdFx0XHRcdGZvciAodmFyIGkgPSBjdXN0b21JbnN0YW5jZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRpZiAoY3VzdG9tSW5zdGFuY2VzW2ldID09PSB0aGlzKSB7XG5cdFx0XHRcdFx0XHRjdXN0b21JbnN0YW5jZXMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG9yaWdpbmFsRGVzdHJveSkge1xuXHRcdFx0XHRcdG9yaWdpbmFsRGVzdHJveS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBzYXZlIG1vZHVsZSB0byBsaXN0XG5cdFx0XHR0aGlzLm1vZHVsZXNbcHJvdG8ubmFtZV0gPSBNb2R1bGU7XG5cdFx0fSxcblx0XHRnZXRJbnN0YW5jZTogZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0cmV0dXJuICQoZWxlbWVudCkuZGF0YShjb21tb25PcHRpb25zLmRhdGFLZXkpO1xuXHRcdH0sXG5cdFx0cmVwbGFjZTogZnVuY3Rpb24oZWxlbWVudHMsIG1vZHVsZU5hbWUsIGN1c3RvbU9wdGlvbnMpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdFx0aW5zdGFuY2U7XG5cblx0XHRcdGlmICghY29tbW9uT3B0aW9ucy5zdHlsZVNoZWV0Q3JlYXRlZCkge1xuXHRcdFx0XHRjcmVhdGVTdHlsZVNoZWV0KCk7XG5cdFx0XHR9XG5cblx0XHRcdCQoZWxlbWVudHMpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBtb2R1bGVPcHRpb25zLFxuXHRcdFx0XHRcdGVsZW1lbnQgPSAkKHRoaXMpO1xuXG5cdFx0XHRcdGluc3RhbmNlID0gZWxlbWVudC5kYXRhKGNvbW1vbk9wdGlvbnMuZGF0YUtleSk7XG5cdFx0XHRcdGlmIChpbnN0YW5jZSkge1xuXHRcdFx0XHRcdGluc3RhbmNlLnJlZnJlc2goKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoIW1vZHVsZU5hbWUpIHtcblx0XHRcdFx0XHRcdCQuZWFjaChzZWxmLm1vZHVsZXMsIGZ1bmN0aW9uKGN1cnJlbnRNb2R1bGVOYW1lLCBtb2R1bGUpIHtcblx0XHRcdFx0XHRcdFx0aWYgKG1vZHVsZS5wcm90b3R5cGUubWF0Y2hFbGVtZW50LmNhbGwobW9kdWxlLnByb3RvdHlwZSwgZWxlbWVudCkpIHtcblx0XHRcdFx0XHRcdFx0XHRtb2R1bGVOYW1lID0gY3VycmVudE1vZHVsZU5hbWU7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG1vZHVsZU5hbWUpIHtcblx0XHRcdFx0XHRcdG1vZHVsZU9wdGlvbnMgPSAkLmV4dGVuZCh7IGVsZW1lbnQ6IGVsZW1lbnQgfSwgY3VzdG9tT3B0aW9ucyk7XG5cdFx0XHRcdFx0XHRpbnN0YW5jZSA9IG5ldyBzZWxmLm1vZHVsZXNbbW9kdWxlTmFtZV0obW9kdWxlT3B0aW9ucyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBpbnN0YW5jZTtcblx0XHR9LFxuXHRcdHJlZnJlc2g6IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG5cdFx0XHQkKGVsZW1lbnRzKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaW5zdGFuY2UgPSAkKHRoaXMpLmRhdGEoY29tbW9uT3B0aW9ucy5kYXRhS2V5KTtcblx0XHRcdFx0aWYgKGluc3RhbmNlKSB7XG5cdFx0XHRcdFx0aW5zdGFuY2UucmVmcmVzaCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG5cdFx0XHQkKGVsZW1lbnRzKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaW5zdGFuY2UgPSAkKHRoaXMpLmRhdGEoY29tbW9uT3B0aW9ucy5kYXRhS2V5KTtcblx0XHRcdFx0aWYgKGluc3RhbmNlKSB7XG5cdFx0XHRcdFx0aW5zdGFuY2UuZGVzdHJveSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdHJlcGxhY2VBbGw6IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdCQuZWFjaCh0aGlzLm1vZHVsZXMsIGZ1bmN0aW9uKG1vZHVsZU5hbWUsIG1vZHVsZSkge1xuXHRcdFx0XHQkKG1vZHVsZS5wcm90b3R5cGUuc2VsZWN0b3IsIGNvbnRleHQpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuY2xhc3NOYW1lLmluZGV4T2YoJ2pjZi1pZ25vcmUnKSA8IDApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVwbGFjZSh0aGlzLCBtb2R1bGVOYW1lKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRyZWZyZXNoQWxsOiBmdW5jdGlvbihjb250ZXh0KSB7XG5cdFx0XHRpZiAoY29udGV4dCkge1xuXHRcdFx0XHQkLmVhY2godGhpcy5tb2R1bGVzLCBmdW5jdGlvbihtb2R1bGVOYW1lLCBtb2R1bGUpIHtcblx0XHRcdFx0XHQkKG1vZHVsZS5wcm90b3R5cGUuc2VsZWN0b3IsIGNvbnRleHQpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR2YXIgaW5zdGFuY2UgPSAkKHRoaXMpLmRhdGEoY29tbW9uT3B0aW9ucy5kYXRhS2V5KTtcblx0XHRcdFx0XHRcdGlmIChpbnN0YW5jZSkge1xuXHRcdFx0XHRcdFx0XHRpbnN0YW5jZS5yZWZyZXNoKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IGN1c3RvbUluc3RhbmNlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdGN1c3RvbUluc3RhbmNlc1tpXS5yZWZyZXNoKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGRlc3Ryb3lBbGw6IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHRcdGlmIChjb250ZXh0KSB7XG5cdFx0XHRcdCQuZWFjaCh0aGlzLm1vZHVsZXMsIGZ1bmN0aW9uKG1vZHVsZU5hbWUsIG1vZHVsZSkge1xuXHRcdFx0XHRcdCQobW9kdWxlLnByb3RvdHlwZS5zZWxlY3RvciwgY29udGV4dCkuZWFjaChmdW5jdGlvbihpbmRleCwgZWxlbWVudCkge1xuXHRcdFx0XHRcdFx0dmFyIGluc3RhbmNlID0gJChlbGVtZW50KS5kYXRhKGNvbW1vbk9wdGlvbnMuZGF0YUtleSk7XG5cdFx0XHRcdFx0XHRpZiAoaW5zdGFuY2UpIHtcblx0XHRcdFx0XHRcdFx0aW5zdGFuY2UuZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlIChjdXN0b21JbnN0YW5jZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Y3VzdG9tSW5zdGFuY2VzWzBdLmRlc3Ryb3koKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvLyBhbHdheXMgZXhwb3J0IEFQSSB0byB0aGUgZ2xvYmFsIHdpbmRvdyBvYmplY3Rcblx0d2luZG93LmpjZiA9IGFwaTtcblxuXHRyZXR1cm4gYXBpO1xufSkpO1xuIiwiLyohXG4gKiBKYXZhU2NyaXB0IEN1c3RvbSBGb3JtcyA6IFJhZGlvIE1vZHVsZVxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUgUFNEMkhUTUwgLSBodHRwOi8vcHNkMmh0bWwuY29tL2pjZlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIChMSUNFTlNFLnR4dClcbiAqXG4gKiBWZXJzaW9uOiAxLjEuMlxuICovXG47KGZ1bmN0aW9uKCQpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGpjZi5hZGRNb2R1bGUoe1xuXHRcdG5hbWU6ICdSYWRpbycsXG5cdFx0c2VsZWN0b3I6ICdpbnB1dFt0eXBlPVwicmFkaW9cIl0nLFxuXHRcdG9wdGlvbnM6IHtcblx0XHRcdHdyYXBOYXRpdmU6IHRydWUsXG5cdFx0XHRjaGVja2VkQ2xhc3M6ICdqY2YtY2hlY2tlZCcsXG5cdFx0XHR1bmNoZWNrZWRDbGFzczogJ2pjZi11bmNoZWNrZWQnLFxuXHRcdFx0bGFiZWxBY3RpdmVDbGFzczogJ2pjZi1sYWJlbC1hY3RpdmUnLFxuXHRcdFx0ZmFrZVN0cnVjdHVyZTogJzxzcGFuIGNsYXNzPVwiamNmLXJhZGlvXCI+PHNwYW4+PC9zcGFuPjwvc3Bhbj4nXG5cdFx0fSxcblx0XHRtYXRjaEVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdHJldHVybiBlbGVtZW50LmlzKCc6cmFkaW8nKTtcblx0XHR9LFxuXHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5pbml0U3RydWN0dXJlKCk7XG5cdFx0XHR0aGlzLmF0dGFjaEV2ZW50cygpO1xuXHRcdFx0dGhpcy5yZWZyZXNoKCk7XG5cdFx0fSxcblx0XHRpbml0U3RydWN0dXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIHByZXBhcmUgc3RydWN0dXJlXG5cdFx0XHR0aGlzLmRvYyA9ICQoZG9jdW1lbnQpO1xuXHRcdFx0dGhpcy5yZWFsRWxlbWVudCA9ICQodGhpcy5vcHRpb25zLmVsZW1lbnQpO1xuXHRcdFx0dGhpcy5mYWtlRWxlbWVudCA9ICQodGhpcy5vcHRpb25zLmZha2VTdHJ1Y3R1cmUpLmluc2VydEFmdGVyKHRoaXMucmVhbEVsZW1lbnQpO1xuXHRcdFx0dGhpcy5sYWJlbEVsZW1lbnQgPSB0aGlzLmdldExhYmVsRm9yKCk7XG5cblx0XHRcdGlmICh0aGlzLm9wdGlvbnMud3JhcE5hdGl2ZSkge1xuXHRcdFx0XHQvLyB3cmFwIG5hdGl2ZSByYWRpbyBpbnNpZGUgZmFrZSBibG9ja1xuXHRcdFx0XHR0aGlzLnJlYWxFbGVtZW50LnByZXBlbmRUbyh0aGlzLmZha2VFbGVtZW50KS5jc3Moe1xuXHRcdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0XHRcdG9wYWNpdHk6IDBcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBqdXN0IGhpZGUgbmF0aXZlIHJhZGlvXG5cdFx0XHRcdHRoaXMucmVhbEVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmhpZGRlbkNsYXNzKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGF0dGFjaEV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBhZGQgZXZlbnQgaGFuZGxlcnNcblx0XHRcdHRoaXMucmVhbEVsZW1lbnQub24oe1xuXHRcdFx0XHRmb2N1czogdGhpcy5vbkZvY3VzLFxuXHRcdFx0XHRjbGljazogdGhpcy5vblJlYWxDbGlja1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmZha2VFbGVtZW50Lm9uKCdjbGljaycsIHRoaXMub25GYWtlQ2xpY2spO1xuXHRcdFx0dGhpcy5mYWtlRWxlbWVudC5vbignamNmLXBvaW50ZXJkb3duJywgdGhpcy5vblByZXNzKTtcblx0XHR9LFxuXHRcdG9uUmVhbENsaWNrOiBmdW5jdGlvbihlKSB7XG5cdFx0XHQvLyByZWRyYXcgY3VycmVudCByYWRpbyBhbmQgaXRzIGdyb3VwIChzZXRUaW1lb3V0IGhhbmRsZXMgY2xpY2sgdGhhdCBtaWdodCBiZSBwcmV2ZW50ZWQpXG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHR0aGlzLnNhdmVkRXZlbnRPYmplY3QgPSBlO1xuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5yZWZyZXNoUmFkaW9Hcm91cCgpO1xuXHRcdFx0fSwgMCk7XG5cdFx0fSxcblx0XHRvbkZha2VDbGljazogZnVuY3Rpb24oZSkge1xuXHRcdFx0Ly8gc2tpcCBldmVudCBpZiBjbGlja2VkIG9uIHJlYWwgZWxlbWVudCBpbnNpZGUgd3JhcHBlclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy53cmFwTmF0aXZlICYmIHRoaXMucmVhbEVsZW1lbnQuaXMoZS50YXJnZXQpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdG9nZ2xlIGNoZWNrZWQgY2xhc3Ncblx0XHRcdGlmICghdGhpcy5yZWFsRWxlbWVudC5pcygnOmRpc2FibGVkJykpIHtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuc2F2ZWRFdmVudE9iamVjdDtcblx0XHRcdFx0dGhpcy5jdXJyZW50QWN0aXZlUmFkaW8gPSB0aGlzLmdldEN1cnJlbnRBY3RpdmVSYWRpbygpO1xuXHRcdFx0XHR0aGlzLnN0YXRlQ2hlY2tlZCA9IHRoaXMucmVhbEVsZW1lbnQucHJvcCgnY2hlY2tlZCcpO1xuXHRcdFx0XHR0aGlzLnJlYWxFbGVtZW50LnByb3AoJ2NoZWNrZWQnLCB0cnVlKTtcblx0XHRcdFx0dGhpcy5maXJlTmF0aXZlRXZlbnQodGhpcy5yZWFsRWxlbWVudCwgJ2NsaWNrJyk7XG5cdFx0XHRcdGlmICh0aGlzLnNhdmVkRXZlbnRPYmplY3QgJiYgdGhpcy5zYXZlZEV2ZW50T2JqZWN0LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG5cdFx0XHRcdFx0dGhpcy5yZWFsRWxlbWVudC5wcm9wKCdjaGVja2VkJywgdGhpcy5zdGF0ZUNoZWNrZWQpO1xuXHRcdFx0XHRcdHRoaXMuY3VycmVudEFjdGl2ZVJhZGlvLnByb3AoJ2NoZWNrZWQnLCB0cnVlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmZpcmVOYXRpdmVFdmVudCh0aGlzLnJlYWxFbGVtZW50LCAnY2hhbmdlJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVsZXRlIHRoaXMuc2F2ZWRFdmVudE9iamVjdDtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9uRm9jdXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCF0aGlzLnByZXNzZWRGbGFnIHx8ICF0aGlzLmZvY3VzZWRGbGFnKSB7XG5cdFx0XHRcdHRoaXMuZm9jdXNlZEZsYWcgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLmZha2VFbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5mb2N1c0NsYXNzKTtcblx0XHRcdFx0dGhpcy5yZWFsRWxlbWVudC5vbignYmx1cicsIHRoaXMub25CbHVyKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9uQmx1cjogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIXRoaXMucHJlc3NlZEZsYWcpIHtcblx0XHRcdFx0dGhpcy5mb2N1c2VkRmxhZyA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLmZha2VFbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5mb2N1c0NsYXNzKTtcblx0XHRcdFx0dGhpcy5yZWFsRWxlbWVudC5vZmYoJ2JsdXInLCB0aGlzLm9uQmx1cik7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvblByZXNzOiBmdW5jdGlvbihlKSB7XG5cdFx0XHRpZiAoIXRoaXMuZm9jdXNlZEZsYWcgJiYgZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykge1xuXHRcdFx0XHR0aGlzLnJlYWxFbGVtZW50LmZvY3VzKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnByZXNzZWRGbGFnID0gdHJ1ZTtcblx0XHRcdHRoaXMuZmFrZUVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnByZXNzZWRDbGFzcyk7XG5cdFx0XHR0aGlzLmRvYy5vbignamNmLXBvaW50ZXJ1cCcsIHRoaXMub25SZWxlYXNlKTtcblx0XHR9LFxuXHRcdG9uUmVsZWFzZTogZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYgKHRoaXMuZm9jdXNlZEZsYWcgJiYgZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykge1xuXHRcdFx0XHR0aGlzLnJlYWxFbGVtZW50LmZvY3VzKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnByZXNzZWRGbGFnID0gZmFsc2U7XG5cdFx0XHR0aGlzLmZha2VFbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5wcmVzc2VkQ2xhc3MpO1xuXHRcdFx0dGhpcy5kb2Mub2ZmKCdqY2YtcG9pbnRlcnVwJywgdGhpcy5vblJlbGVhc2UpO1xuXHRcdH0sXG5cdFx0Z2V0Q3VycmVudEFjdGl2ZVJhZGlvOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFJhZGlvR3JvdXAodGhpcy5yZWFsRWxlbWVudCkuZmlsdGVyKCc6Y2hlY2tlZCcpO1xuXHRcdH0sXG5cdFx0Z2V0UmFkaW9Hcm91cDogZnVuY3Rpb24ocmFkaW8pIHtcblx0XHRcdC8vIGZpbmQgcmFkaW8gZ3JvdXAgZm9yIHNwZWNpZmllZCByYWRpbyBidXR0b25cblx0XHRcdHZhciBuYW1lID0gcmFkaW8uYXR0cignbmFtZScpLFxuXHRcdFx0XHRwYXJlbnRGb3JtID0gcmFkaW8ucGFyZW50cygnZm9ybScpO1xuXG5cdFx0XHRpZiAobmFtZSkge1xuXHRcdFx0XHRpZiAocGFyZW50Rm9ybS5sZW5ndGgpIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyZW50Rm9ybS5maW5kKCdpbnB1dFtuYW1lPVwiJyArIG5hbWUgKyAnXCJdJyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuICQoJ2lucHV0W25hbWU9XCInICsgbmFtZSArICdcIl06bm90KGZvcm0gaW5wdXQpJyk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiByYWRpbztcblx0XHRcdH1cblx0XHR9LFxuXHRcdGdldExhYmVsRm9yOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwYXJlbnRMYWJlbCA9IHRoaXMucmVhbEVsZW1lbnQuY2xvc2VzdCgnbGFiZWwnKSxcblx0XHRcdFx0ZWxlbWVudElkID0gdGhpcy5yZWFsRWxlbWVudC5wcm9wKCdpZCcpO1xuXG5cdFx0XHRpZiAoIXBhcmVudExhYmVsLmxlbmd0aCAmJiBlbGVtZW50SWQpIHtcblx0XHRcdFx0cGFyZW50TGFiZWwgPSAkKCdsYWJlbFtmb3I9XCInICsgZWxlbWVudElkICsgJ1wiXScpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBhcmVudExhYmVsLmxlbmd0aCA/IHBhcmVudExhYmVsIDogbnVsbDtcblx0XHR9LFxuXHRcdHJlZnJlc2hSYWRpb0dyb3VwOiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIHJlZHJhdyBjdXJyZW50IHJhZGlvIGFuZCBpdHMgZ3JvdXBcblx0XHRcdHRoaXMuZ2V0UmFkaW9Hcm91cCh0aGlzLnJlYWxFbGVtZW50KS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqY2YucmVmcmVzaCh0aGlzKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0cmVmcmVzaDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyByZWRyYXcgY3VycmVudCByYWRpbyBidXR0b25cblx0XHRcdHZhciBpc0NoZWNrZWQgPSB0aGlzLnJlYWxFbGVtZW50LmlzKCc6Y2hlY2tlZCcpLFxuXHRcdFx0XHRpc0Rpc2FibGVkID0gdGhpcy5yZWFsRWxlbWVudC5pcygnOmRpc2FibGVkJyk7XG5cblx0XHRcdHRoaXMuZmFrZUVsZW1lbnQudG9nZ2xlQ2xhc3ModGhpcy5vcHRpb25zLmNoZWNrZWRDbGFzcywgaXNDaGVja2VkKVxuXHRcdFx0XHRcdFx0XHQudG9nZ2xlQ2xhc3ModGhpcy5vcHRpb25zLnVuY2hlY2tlZENsYXNzLCAhaXNDaGVja2VkKVxuXHRcdFx0XHRcdFx0XHQudG9nZ2xlQ2xhc3ModGhpcy5vcHRpb25zLmRpc2FibGVkQ2xhc3MsIGlzRGlzYWJsZWQpO1xuXG5cdFx0XHRpZiAodGhpcy5sYWJlbEVsZW1lbnQpIHtcblx0XHRcdFx0dGhpcy5sYWJlbEVsZW1lbnQudG9nZ2xlQ2xhc3ModGhpcy5vcHRpb25zLmxhYmVsQWN0aXZlQ2xhc3MsIGlzQ2hlY2tlZCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIHJlc3RvcmUgc3RydWN0dXJlXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLndyYXBOYXRpdmUpIHtcblx0XHRcdFx0dGhpcy5yZWFsRWxlbWVudC5pbnNlcnRCZWZvcmUodGhpcy5mYWtlRWxlbWVudCkuY3NzKHtcblx0XHRcdFx0XHRwb3NpdGlvbjogJycsXG5cdFx0XHRcdFx0d2lkdGg6ICcnLFxuXHRcdFx0XHRcdGhlaWdodDogJycsXG5cdFx0XHRcdFx0b3BhY2l0eTogJycsXG5cdFx0XHRcdFx0bWFyZ2luOiAnJ1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMucmVhbEVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmhpZGRlbkNsYXNzKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVtb3ZpbmcgZWxlbWVudCB3aWxsIGFsc28gcmVtb3ZlIGl0cyBldmVudCBoYW5kbGVyc1xuXHRcdFx0dGhpcy5mYWtlRWxlbWVudC5vZmYoJ2pjZi1wb2ludGVyZG93bicsIHRoaXMub25QcmVzcyk7XG5cdFx0XHR0aGlzLmZha2VFbGVtZW50LnJlbW92ZSgpO1xuXG5cdFx0XHQvLyByZW1vdmUgb3RoZXIgZXZlbnQgaGFuZGxlcnNcblx0XHRcdHRoaXMuZG9jLm9mZignamNmLXBvaW50ZXJ1cCcsIHRoaXMub25SZWxlYXNlKTtcblx0XHRcdHRoaXMucmVhbEVsZW1lbnQub2ZmKHtcblx0XHRcdFx0Ymx1cjogdGhpcy5vbkJsdXIsXG5cdFx0XHRcdGZvY3VzOiB0aGlzLm9uRm9jdXMsXG5cdFx0XHRcdGNsaWNrOiB0aGlzLm9uUmVhbENsaWNrXG5cdFx0XHR9KTtcblx0XHR9XG5cdH0pO1xuXG59KGpRdWVyeSkpO1xuIiwiLyohXG4gKiBKYXZhU2NyaXB0IEN1c3RvbSBGb3JtcyA6IFNjcm9sbGJhciBNb2R1bGVcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1IFBTRDJIVE1MIC0gaHR0cDovL3BzZDJodG1sLmNvbS9qY2ZcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSAoTElDRU5TRS50eHQpXG4gKlxuICogVmVyc2lvbjogMS4xLjJcbiAqL1xuOyhmdW5jdGlvbigkLCB3aW5kb3cpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGpjZi5hZGRNb2R1bGUoe1xuXHRcdG5hbWU6ICdTY3JvbGxhYmxlJyxcblx0XHRzZWxlY3RvcjogJy5qY2Ytc2Nyb2xsYWJsZScsXG5cdFx0cGx1Z2luczoge1xuXHRcdFx0U2Nyb2xsQmFyOiBTY3JvbGxCYXJcblx0XHR9LFxuXHRcdG9wdGlvbnM6IHtcblx0XHRcdG1vdXNlV2hlZWxTdGVwOiAxNTAsXG5cdFx0XHRoYW5kbGVSZXNpemU6IHRydWUsXG5cdFx0XHRhbHdheXNTaG93U2Nyb2xsYmFyczogZmFsc2UsXG5cdFx0XHRhbHdheXNQcmV2ZW50TW91c2VXaGVlbDogZmFsc2UsXG5cdFx0XHRzY3JvbGxBcmVhU3RydWN0dXJlOiAnPGRpdiBjbGFzcz1cImpjZi1zY3JvbGxhYmxlLXdyYXBwZXJcIj48L2Rpdj4nXG5cdFx0fSxcblx0XHRtYXRjaEVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdHJldHVybiBlbGVtZW50LmlzKCcuamNmLXNjcm9sbGFibGUnKTtcblx0XHR9LFxuXHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5pbml0U3RydWN0dXJlKCk7XG5cdFx0XHR0aGlzLmF0dGFjaEV2ZW50cygpO1xuXHRcdFx0dGhpcy5yZWJ1aWxkU2Nyb2xsYmFycygpO1xuXHRcdH0sXG5cdFx0aW5pdFN0cnVjdHVyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBwcmVwYXJlIHN0cnVjdHVyZVxuXHRcdFx0dGhpcy5kb2MgPSAkKGRvY3VtZW50KTtcblx0XHRcdHRoaXMud2luID0gJCh3aW5kb3cpO1xuXHRcdFx0dGhpcy5yZWFsRWxlbWVudCA9ICQodGhpcy5vcHRpb25zLmVsZW1lbnQpO1xuXHRcdFx0dGhpcy5zY3JvbGxXcmFwcGVyID0gJCh0aGlzLm9wdGlvbnMuc2Nyb2xsQXJlYVN0cnVjdHVyZSkuaW5zZXJ0QWZ0ZXIodGhpcy5yZWFsRWxlbWVudCk7XG5cblx0XHRcdC8vIHNldCBpbml0aWFsIHN0eWxlc1xuXHRcdFx0dGhpcy5zY3JvbGxXcmFwcGVyLmNzcygncG9zaXRpb24nLCAncmVsYXRpdmUnKTtcblx0XHRcdHRoaXMucmVhbEVsZW1lbnQuY3NzKCdvdmVyZmxvdycsICdoaWRkZW4nKTtcblx0XHRcdHRoaXMudkJhckVkZ2UgPSAwO1xuXHRcdH0sXG5cdFx0YXR0YWNoRXZlbnRzOiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIGNyZWF0ZSBzY3JvbGxiYXJzXG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHR0aGlzLnZCYXIgPSBuZXcgU2Nyb2xsQmFyKHtcblx0XHRcdFx0aG9sZGVyOiB0aGlzLnNjcm9sbFdyYXBwZXIsXG5cdFx0XHRcdHZlcnRpY2FsOiB0cnVlLFxuXHRcdFx0XHRvblNjcm9sbDogZnVuY3Rpb24oc2Nyb2xsVG9wKSB7XG5cdFx0XHRcdFx0c2VsZi5yZWFsRWxlbWVudC5zY3JvbGxUb3Aoc2Nyb2xsVG9wKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmhCYXIgPSBuZXcgU2Nyb2xsQmFyKHtcblx0XHRcdFx0aG9sZGVyOiB0aGlzLnNjcm9sbFdyYXBwZXIsXG5cdFx0XHRcdHZlcnRpY2FsOiBmYWxzZSxcblx0XHRcdFx0b25TY3JvbGw6IGZ1bmN0aW9uKHNjcm9sbExlZnQpIHtcblx0XHRcdFx0XHRzZWxmLnJlYWxFbGVtZW50LnNjcm9sbExlZnQoc2Nyb2xsTGVmdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBhZGQgZXZlbnQgaGFuZGxlcnNcblx0XHRcdHRoaXMucmVhbEVsZW1lbnQub24oJ3Njcm9sbCcsIHRoaXMub25TY3JvbGwpO1xuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5oYW5kbGVSZXNpemUpIHtcblx0XHRcdFx0dGhpcy53aW4ub24oJ3Jlc2l6ZSBvcmllbnRhdGlvbmNoYW5nZSBsb2FkJywgdGhpcy5vblJlc2l6ZSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGFkZCBwb2ludGVyL3doZWVsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHR0aGlzLnJlYWxFbGVtZW50Lm9uKCdqY2YtbW91c2V3aGVlbCcsIHRoaXMub25Nb3VzZVdoZWVsKTtcblx0XHRcdHRoaXMucmVhbEVsZW1lbnQub24oJ2pjZi1wb2ludGVyZG93bicsIHRoaXMub25Ub3VjaEJvZHkpO1xuXHRcdH0sXG5cdFx0b25TY3JvbGw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5yZWRyYXdTY3JvbGxiYXJzKCk7XG5cdFx0fSxcblx0XHRvblJlc2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBkbyBub3QgcmVidWlsZCBzY3JvbGxiYXJzIGlmIGZvcm0gZmllbGQgaXMgaW4gZm9jdXNcblx0XHRcdGlmICghJChkb2N1bWVudC5hY3RpdmVFbGVtZW50KS5pcygnOmlucHV0JykpIHtcblx0XHRcdFx0dGhpcy5yZWJ1aWxkU2Nyb2xsYmFycygpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0b25Ub3VjaEJvZHk6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdGlmIChlLnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XG5cdFx0XHRcdHRoaXMudG91Y2hEYXRhID0ge1xuXHRcdFx0XHRcdHNjcm9sbFRvcDogdGhpcy5yZWFsRWxlbWVudC5zY3JvbGxUb3AoKSxcblx0XHRcdFx0XHRzY3JvbGxMZWZ0OiB0aGlzLnJlYWxFbGVtZW50LnNjcm9sbExlZnQoKSxcblx0XHRcdFx0XHRsZWZ0OiBlLnBhZ2VYLFxuXHRcdFx0XHRcdHRvcDogZS5wYWdlWVxuXHRcdFx0XHR9O1xuXHRcdFx0XHR0aGlzLmRvYy5vbih7XG5cdFx0XHRcdFx0J2pjZi1wb2ludGVybW92ZSc6IHRoaXMub25Nb3ZlQm9keSxcblx0XHRcdFx0XHQnamNmLXBvaW50ZXJ1cCc6IHRoaXMub25SZWxlYXNlQm9keVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9uTW92ZUJvZHk6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciB0YXJnZXRTY3JvbGxUb3AsXG5cdFx0XHRcdHRhcmdldFNjcm9sbExlZnQsXG5cdFx0XHRcdHZlcnRpY2FsU2Nyb2xsQWxsb3dlZCA9IHRoaXMudmVydGljYWxTY3JvbGxBY3RpdmUsXG5cdFx0XHRcdGhvcml6b250YWxTY3JvbGxBbGxvd2VkID0gdGhpcy5ob3Jpem9udGFsU2Nyb2xsQWN0aXZlO1xuXG5cdFx0XHRpZiAoZS5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xuXHRcdFx0XHR0YXJnZXRTY3JvbGxUb3AgPSB0aGlzLnRvdWNoRGF0YS5zY3JvbGxUb3AgLSBlLnBhZ2VZICsgdGhpcy50b3VjaERhdGEudG9wO1xuXHRcdFx0XHR0YXJnZXRTY3JvbGxMZWZ0ID0gdGhpcy50b3VjaERhdGEuc2Nyb2xsTGVmdCAtIGUucGFnZVggKyB0aGlzLnRvdWNoRGF0YS5sZWZ0O1xuXG5cdFx0XHRcdC8vIGNoZWNrIHRoYXQgc2Nyb2xsaW5nIGlzIGVuZGVkIGFuZCByZWxlYXNlIG91dGVyIHNjcm9sbGluZ1xuXHRcdFx0XHRpZiAodGhpcy52ZXJ0aWNhbFNjcm9sbEFjdGl2ZSAmJiAodGFyZ2V0U2Nyb2xsVG9wIDwgMCB8fCB0YXJnZXRTY3JvbGxUb3AgPiB0aGlzLnZCYXIubWF4VmFsdWUpKSB7XG5cdFx0XHRcdFx0dmVydGljYWxTY3JvbGxBbGxvd2VkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuaG9yaXpvbnRhbFNjcm9sbEFjdGl2ZSAmJiAodGFyZ2V0U2Nyb2xsTGVmdCA8IDAgfHwgdGFyZ2V0U2Nyb2xsTGVmdCA+IHRoaXMuaEJhci5tYXhWYWx1ZSkpIHtcblx0XHRcdFx0XHRob3Jpem9udGFsU2Nyb2xsQWxsb3dlZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5yZWFsRWxlbWVudC5zY3JvbGxUb3AodGFyZ2V0U2Nyb2xsVG9wKTtcblx0XHRcdFx0dGhpcy5yZWFsRWxlbWVudC5zY3JvbGxMZWZ0KHRhcmdldFNjcm9sbExlZnQpO1xuXG5cdFx0XHRcdGlmICh2ZXJ0aWNhbFNjcm9sbEFsbG93ZWQgfHwgaG9yaXpvbnRhbFNjcm9sbEFsbG93ZWQpIHtcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5vblJlbGVhc2VCb2R5KGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvblJlbGVhc2VCb2R5OiBmdW5jdGlvbihlKSB7XG5cdFx0XHRpZiAoZS5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xuXHRcdFx0XHRkZWxldGUgdGhpcy50b3VjaERhdGE7XG5cdFx0XHRcdHRoaXMuZG9jLm9mZih7XG5cdFx0XHRcdFx0J2pjZi1wb2ludGVybW92ZSc6IHRoaXMub25Nb3ZlQm9keSxcblx0XHRcdFx0XHQnamNmLXBvaW50ZXJ1cCc6IHRoaXMub25SZWxlYXNlQm9keVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9uTW91c2VXaGVlbDogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIGN1cnJlbnRTY3JvbGxUb3AgPSB0aGlzLnJlYWxFbGVtZW50LnNjcm9sbFRvcCgpLFxuXHRcdFx0XHRjdXJyZW50U2Nyb2xsTGVmdCA9IHRoaXMucmVhbEVsZW1lbnQuc2Nyb2xsTGVmdCgpLFxuXHRcdFx0XHRtYXhTY3JvbGxUb3AgPSB0aGlzLnJlYWxFbGVtZW50LnByb3AoJ3Njcm9sbEhlaWdodCcpIC0gdGhpcy5lbWJlZGRlZERpbWVuc2lvbnMuaW5uZXJIZWlnaHQsXG5cdFx0XHRcdG1heFNjcm9sbExlZnQgPSB0aGlzLnJlYWxFbGVtZW50LnByb3AoJ3Njcm9sbFdpZHRoJykgLSB0aGlzLmVtYmVkZGVkRGltZW5zaW9ucy5pbm5lcldpZHRoLFxuXHRcdFx0XHRleHRyYUxlZnQsIGV4dHJhVG9wLCBwcmV2ZW50RmxhZztcblxuXHRcdFx0Ly8gY2hlY2sgZWRnZSBjYXNlc1xuXHRcdFx0aWYgKCF0aGlzLm9wdGlvbnMuYWx3YXlzUHJldmVudE1vdXNlV2hlZWwpIHtcblx0XHRcdFx0aWYgKHRoaXMudmVydGljYWxTY3JvbGxBY3RpdmUgJiYgZS5kZWx0YVkpIHtcblx0XHRcdFx0XHRpZiAoIShjdXJyZW50U2Nyb2xsVG9wIDw9IDAgJiYgZS5kZWx0YVkgPCAwKSAmJiAhKGN1cnJlbnRTY3JvbGxUb3AgPj0gbWF4U2Nyb2xsVG9wICYmIGUuZGVsdGFZID4gMCkpIHtcblx0XHRcdFx0XHRcdHByZXZlbnRGbGFnID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuaG9yaXpvbnRhbFNjcm9sbEFjdGl2ZSAmJiBlLmRlbHRhWCkge1xuXHRcdFx0XHRcdGlmICghKGN1cnJlbnRTY3JvbGxMZWZ0IDw9IDAgJiYgZS5kZWx0YVggPCAwKSAmJiAhKGN1cnJlbnRTY3JvbGxMZWZ0ID49IG1heFNjcm9sbExlZnQgJiYgZS5kZWx0YVggPiAwKSkge1xuXHRcdFx0XHRcdFx0cHJldmVudEZsYWcgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXRoaXMudmVydGljYWxTY3JvbGxBY3RpdmUgJiYgIXRoaXMuaG9yaXpvbnRhbFNjcm9sbEFjdGl2ZSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcmV2ZW50IGRlZmF1bHQgYWN0aW9uIGFuZCBzY3JvbGwgaXRlbVxuXHRcdFx0aWYgKHByZXZlbnRGbGFnIHx8IHRoaXMub3B0aW9ucy5hbHdheXNQcmV2ZW50TW91c2VXaGVlbCkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGV4dHJhTGVmdCA9IGUuZGVsdGFYIC8gMTAwICogdGhpcy5vcHRpb25zLm1vdXNlV2hlZWxTdGVwO1xuXHRcdFx0ZXh0cmFUb3AgPSBlLmRlbHRhWSAvIDEwMCAqIHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsU3RlcDtcblxuXHRcdFx0dGhpcy5yZWFsRWxlbWVudC5zY3JvbGxUb3AoY3VycmVudFNjcm9sbFRvcCArIGV4dHJhVG9wKTtcblx0XHRcdHRoaXMucmVhbEVsZW1lbnQuc2Nyb2xsTGVmdChjdXJyZW50U2Nyb2xsTGVmdCArIGV4dHJhTGVmdCk7XG5cdFx0fSxcblx0XHRzZXRTY3JvbGxCYXJFZGdlOiBmdW5jdGlvbihlZGdlU2l6ZSkge1xuXHRcdFx0dGhpcy52QmFyRWRnZSA9IGVkZ2VTaXplIHx8IDA7XG5cdFx0XHR0aGlzLnJlZHJhd1Njcm9sbGJhcnMoKTtcblx0XHR9LFxuXHRcdHNhdmVFbGVtZW50RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnNhdmVkRGltZW5zaW9ucyA9IHtcblx0XHRcdFx0dG9wOiB0aGlzLnJlYWxFbGVtZW50LndpZHRoKCksXG5cdFx0XHRcdGxlZnQ6IHRoaXMucmVhbEVsZW1lbnQuaGVpZ2h0KClcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXHRcdHJlc3RvcmVFbGVtZW50RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAodGhpcy5zYXZlZERpbWVuc2lvbnMpIHtcblx0XHRcdFx0dGhpcy5yZWFsRWxlbWVudC5jc3Moe1xuXHRcdFx0XHRcdHdpZHRoOiB0aGlzLnNhdmVkRGltZW5zaW9ucy53aWR0aCxcblx0XHRcdFx0XHRoZWlnaHQ6IHRoaXMuc2F2ZWREaW1lbnNpb25zLmhlaWdodFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cdFx0c2F2ZVNjcm9sbE9mZnNldHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5zYXZlZE9mZnNldHMgPSB7XG5cdFx0XHRcdHRvcDogdGhpcy5yZWFsRWxlbWVudC5zY3JvbGxUb3AoKSxcblx0XHRcdFx0bGVmdDogdGhpcy5yZWFsRWxlbWVudC5zY3JvbGxMZWZ0KClcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXHRcdHJlc3RvcmVTY3JvbGxPZmZzZXRzOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh0aGlzLnNhdmVkT2Zmc2V0cykge1xuXHRcdFx0XHR0aGlzLnJlYWxFbGVtZW50LnNjcm9sbFRvcCh0aGlzLnNhdmVkT2Zmc2V0cy50b3ApO1xuXHRcdFx0XHR0aGlzLnJlYWxFbGVtZW50LnNjcm9sbExlZnQodGhpcy5zYXZlZE9mZnNldHMubGVmdCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXHRcdGdldENvbnRhaW5lckRpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gc2F2ZSBjdXJyZW50IHN0eWxlc1xuXHRcdFx0dmFyIGRlc2lyZWREaW1lbnNpb25zLFxuXHRcdFx0XHRjdXJyZW50U3R5bGVzLFxuXHRcdFx0XHRjdXJyZW50SGVpZ2h0LFxuXHRcdFx0XHRjdXJyZW50V2lkdGg7XG5cblx0XHRcdGlmICh0aGlzLmlzTW9kaWZpZWRTdHlsZXMpIHtcblx0XHRcdFx0ZGVzaXJlZERpbWVuc2lvbnMgPSB7XG5cdFx0XHRcdFx0d2lkdGg6IHRoaXMucmVhbEVsZW1lbnQuaW5uZXJXaWR0aCgpICsgdGhpcy52QmFyLmdldFRoaWNrbmVzcygpLFxuXHRcdFx0XHRcdGhlaWdodDogdGhpcy5yZWFsRWxlbWVudC5pbm5lckhlaWdodCgpICsgdGhpcy5oQmFyLmdldFRoaWNrbmVzcygpXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyB1bndyYXAgcmVhbCBlbGVtZW50IGFuZCBtZWFzdXJlIGl0IGFjY29yZGluZyB0byBDU1Ncblx0XHRcdFx0dGhpcy5zYXZlRWxlbWVudERpbWVuc2lvbnMoKS5zYXZlU2Nyb2xsT2Zmc2V0cygpO1xuXHRcdFx0XHR0aGlzLnJlYWxFbGVtZW50Lmluc2VydEFmdGVyKHRoaXMuc2Nyb2xsV3JhcHBlcik7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsV3JhcHBlci5kZXRhY2goKTtcblxuXHRcdFx0XHQvLyBtZWFzdXJlIGVsZW1lbnRcblx0XHRcdFx0Y3VycmVudFN0eWxlcyA9IHRoaXMucmVhbEVsZW1lbnQucHJvcCgnc3R5bGUnKTtcblx0XHRcdFx0Y3VycmVudFdpZHRoID0gcGFyc2VGbG9hdChjdXJyZW50U3R5bGVzLndpZHRoKTtcblx0XHRcdFx0Y3VycmVudEhlaWdodCA9IHBhcnNlRmxvYXQoY3VycmVudFN0eWxlcy5oZWlnaHQpO1xuXG5cdFx0XHRcdC8vIHJlc2V0IHN0eWxlcyBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKHRoaXMuZW1iZWRkZWREaW1lbnNpb25zICYmIGN1cnJlbnRXaWR0aCAmJiBjdXJyZW50SGVpZ2h0KSB7XG5cdFx0XHRcdFx0dGhpcy5pc01vZGlmaWVkU3R5bGVzIHw9IChjdXJyZW50V2lkdGggIT09IHRoaXMuZW1iZWRkZWREaW1lbnNpb25zLndpZHRoIHx8IGN1cnJlbnRIZWlnaHQgIT09IHRoaXMuZW1iZWRkZWREaW1lbnNpb25zLmhlaWdodCk7XG5cdFx0XHRcdFx0dGhpcy5yZWFsRWxlbWVudC5jc3Moe1xuXHRcdFx0XHRcdFx0b3ZlcmZsb3c6ICcnLFxuXHRcdFx0XHRcdFx0d2lkdGg6ICcnLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiAnJ1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY2FsY3VsYXRlIGRlc2lyZWQgZGltZW5zaW9ucyBmb3IgcmVhbCBlbGVtZW50XG5cdFx0XHRcdGRlc2lyZWREaW1lbnNpb25zID0ge1xuXHRcdFx0XHRcdHdpZHRoOiB0aGlzLnJlYWxFbGVtZW50Lm91dGVyV2lkdGgoKSxcblx0XHRcdFx0XHRoZWlnaHQ6IHRoaXMucmVhbEVsZW1lbnQub3V0ZXJIZWlnaHQoKVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIHJlc3RvcmUgc3RydWN0dXJlIGFuZCBvcmlnaW5hbCBzY3JvbGwgb2Zmc2V0c1xuXHRcdFx0XHR0aGlzLnNjcm9sbFdyYXBwZXIuaW5zZXJ0QWZ0ZXIodGhpcy5yZWFsRWxlbWVudCk7XG5cdFx0XHRcdHRoaXMucmVhbEVsZW1lbnQuY3NzKCdvdmVyZmxvdycsICdoaWRkZW4nKS5wcmVwZW5kVG8odGhpcy5zY3JvbGxXcmFwcGVyKTtcblx0XHRcdFx0dGhpcy5yZXN0b3JlRWxlbWVudERpbWVuc2lvbnMoKS5yZXN0b3JlU2Nyb2xsT2Zmc2V0cygpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGVzaXJlZERpbWVuc2lvbnM7XG5cdFx0fSxcblx0XHRnZXRFbWJlZGRlZERpbWVuc2lvbnM6IGZ1bmN0aW9uKGRpbWVuc2lvbnMpIHtcblx0XHRcdC8vIGhhbmRsZSBzY3JvbGxiYXJzIGNyb3BwaW5nXG5cdFx0XHR2YXIgZmFrZUJhcldpZHRoID0gdGhpcy52QmFyLmdldFRoaWNrbmVzcygpLFxuXHRcdFx0XHRmYWtlQmFySGVpZ2h0ID0gdGhpcy5oQmFyLmdldFRoaWNrbmVzcygpLFxuXHRcdFx0XHRwYWRkaW5nV2lkdGggPSB0aGlzLnJlYWxFbGVtZW50Lm91dGVyV2lkdGgoKSAtIHRoaXMucmVhbEVsZW1lbnQud2lkdGgoKSxcblx0XHRcdFx0cGFkZGluZ0hlaWdodCA9IHRoaXMucmVhbEVsZW1lbnQub3V0ZXJIZWlnaHQoKSAtIHRoaXMucmVhbEVsZW1lbnQuaGVpZ2h0KCksXG5cdFx0XHRcdHJlc3VsdERpbWVuc2lvbnM7XG5cblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuYWx3YXlzU2hvd1Njcm9sbGJhcnMpIHtcblx0XHRcdFx0Ly8gc2ltcGx5IHJldHVybiBkaW1lbnNpb25zIHdpdGhvdXQgY3VzdG9tIHNjcm9sbGJhcnNcblx0XHRcdFx0dGhpcy52ZXJ0aWNhbFNjcm9sbEFjdGl2ZSA9IHRydWU7XG5cdFx0XHRcdHRoaXMuaG9yaXpvbnRhbFNjcm9sbEFjdGl2ZSA9IHRydWU7XG5cdFx0XHRcdHJlc3VsdERpbWVuc2lvbnMgPSB7XG5cdFx0XHRcdFx0aW5uZXJXaWR0aDogZGltZW5zaW9ucy53aWR0aCAtIGZha2VCYXJXaWR0aCxcblx0XHRcdFx0XHRpbm5lckhlaWdodDogZGltZW5zaW9ucy5oZWlnaHQgLSBmYWtlQmFySGVpZ2h0XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBkZXRlY3Qgd2hlbiB0byBkaXNwbGF5IGVhY2ggc2Nyb2xsYmFyXG5cdFx0XHRcdHRoaXMuc2F2ZUVsZW1lbnREaW1lbnNpb25zKCk7XG5cdFx0XHRcdHRoaXMudmVydGljYWxTY3JvbGxBY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5ob3Jpem9udGFsU2Nyb2xsQWN0aXZlID0gZmFsc2U7XG5cblx0XHRcdFx0Ly8gZmlsbCBjb250YWluZXIgd2l0aCBmdWxsIHNpemVcblx0XHRcdFx0dGhpcy5yZWFsRWxlbWVudC5jc3Moe1xuXHRcdFx0XHRcdHdpZHRoOiBkaW1lbnNpb25zLndpZHRoIC0gcGFkZGluZ1dpZHRoLFxuXHRcdFx0XHRcdGhlaWdodDogZGltZW5zaW9ucy5oZWlnaHQgLSBwYWRkaW5nSGVpZ2h0XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHRoaXMuaG9yaXpvbnRhbFNjcm9sbEFjdGl2ZSA9IHRoaXMucmVhbEVsZW1lbnQucHJvcCgnc2Nyb2xsV2lkdGgnKSA+IHRoaXMuY29udGFpbmVyRGltZW5zaW9ucy53aWR0aDtcblx0XHRcdFx0dGhpcy52ZXJ0aWNhbFNjcm9sbEFjdGl2ZSA9IHRoaXMucmVhbEVsZW1lbnQucHJvcCgnc2Nyb2xsSGVpZ2h0JykgPiB0aGlzLmNvbnRhaW5lckRpbWVuc2lvbnMuaGVpZ2h0O1xuXG5cdFx0XHRcdHRoaXMucmVzdG9yZUVsZW1lbnREaW1lbnNpb25zKCk7XG5cdFx0XHRcdHJlc3VsdERpbWVuc2lvbnMgPSB7XG5cdFx0XHRcdFx0aW5uZXJXaWR0aDogZGltZW5zaW9ucy53aWR0aCAtICh0aGlzLnZlcnRpY2FsU2Nyb2xsQWN0aXZlID8gZmFrZUJhcldpZHRoIDogMCksXG5cdFx0XHRcdFx0aW5uZXJIZWlnaHQ6IGRpbWVuc2lvbnMuaGVpZ2h0IC0gKHRoaXMuaG9yaXpvbnRhbFNjcm9sbEFjdGl2ZSA/IGZha2VCYXJIZWlnaHQgOiAwKVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0JC5leHRlbmQocmVzdWx0RGltZW5zaW9ucywge1xuXHRcdFx0XHR3aWR0aDogcmVzdWx0RGltZW5zaW9ucy5pbm5lcldpZHRoIC0gcGFkZGluZ1dpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IHJlc3VsdERpbWVuc2lvbnMuaW5uZXJIZWlnaHQgLSBwYWRkaW5nSGVpZ2h0XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiByZXN1bHREaW1lbnNpb25zO1xuXHRcdH0sXG5cdFx0cmVidWlsZFNjcm9sbGJhcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gcmVzaXplIHdyYXBwZXIgYWNjb3JkaW5nIHRvIHJlYWwgZWxlbWVudCBzdHlsZXNcblx0XHRcdHRoaXMuY29udGFpbmVyRGltZW5zaW9ucyA9IHRoaXMuZ2V0Q29udGFpbmVyRGltZW5zaW9ucygpO1xuXHRcdFx0dGhpcy5lbWJlZGRlZERpbWVuc2lvbnMgPSB0aGlzLmdldEVtYmVkZGVkRGltZW5zaW9ucyh0aGlzLmNvbnRhaW5lckRpbWVuc2lvbnMpO1xuXG5cdFx0XHQvLyByZXNpemUgd3JhcHBlciB0byBkZXNpcmVkIGRpbWVuc2lvbnNcblx0XHRcdHRoaXMuc2Nyb2xsV3JhcHBlci5jc3Moe1xuXHRcdFx0XHR3aWR0aDogdGhpcy5jb250YWluZXJEaW1lbnNpb25zLndpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IHRoaXMuY29udGFpbmVyRGltZW5zaW9ucy5oZWlnaHRcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyByZXNpemUgZWxlbWVudCBpbnNpZGUgd3JhcHBlciBleGNsdWRpbmcgc2Nyb2xsYmFyIHNpemVcblx0XHRcdHRoaXMucmVhbEVsZW1lbnQuY3NzKHtcblx0XHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nLFxuXHRcdFx0XHR3aWR0aDogdGhpcy5lbWJlZGRlZERpbWVuc2lvbnMud2lkdGgsXG5cdFx0XHRcdGhlaWdodDogdGhpcy5lbWJlZGRlZERpbWVuc2lvbnMuaGVpZ2h0XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gcmVkcmF3IHNjcm9sbGJhciBvZmZzZXRcblx0XHRcdHRoaXMucmVkcmF3U2Nyb2xsYmFycygpO1xuXHRcdH0sXG5cdFx0cmVkcmF3U2Nyb2xsYmFyczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdmlld1NpemUsIG1heFNjcm9sbFZhbHVlO1xuXG5cdFx0XHQvLyByZWRyYXcgdmVydGljYWwgc2Nyb2xsYmFyXG5cdFx0XHRpZiAodGhpcy52ZXJ0aWNhbFNjcm9sbEFjdGl2ZSkge1xuXHRcdFx0XHR2aWV3U2l6ZSA9IHRoaXMudkJhckVkZ2UgPyB0aGlzLmNvbnRhaW5lckRpbWVuc2lvbnMuaGVpZ2h0IC0gdGhpcy52QmFyRWRnZSA6IHRoaXMuZW1iZWRkZWREaW1lbnNpb25zLmlubmVySGVpZ2h0O1xuXHRcdFx0XHRtYXhTY3JvbGxWYWx1ZSA9IHRoaXMucmVhbEVsZW1lbnQucHJvcCgnc2Nyb2xsSGVpZ2h0JykgLSB0aGlzLnZCYXJFZGdlO1xuXG5cdFx0XHRcdHRoaXMudkJhci5zaG93KCkuc2V0TWF4VmFsdWUobWF4U2Nyb2xsVmFsdWUgLSB2aWV3U2l6ZSkuc2V0UmF0aW8odmlld1NpemUgLyBtYXhTY3JvbGxWYWx1ZSkuc2V0U2l6ZSh2aWV3U2l6ZSk7XG5cdFx0XHRcdHRoaXMudkJhci5zZXRWYWx1ZSh0aGlzLnJlYWxFbGVtZW50LnNjcm9sbFRvcCgpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMudkJhci5oaWRlKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlZHJhdyBob3Jpem9udGFsIHNjcm9sbGJhclxuXHRcdFx0aWYgKHRoaXMuaG9yaXpvbnRhbFNjcm9sbEFjdGl2ZSkge1xuXHRcdFx0XHR2aWV3U2l6ZSA9IHRoaXMuZW1iZWRkZWREaW1lbnNpb25zLmlubmVyV2lkdGg7XG5cdFx0XHRcdG1heFNjcm9sbFZhbHVlID0gdGhpcy5yZWFsRWxlbWVudC5wcm9wKCdzY3JvbGxXaWR0aCcpO1xuXG5cdFx0XHRcdGlmIChtYXhTY3JvbGxWYWx1ZSA9PT0gdmlld1NpemUpIHtcblx0XHRcdFx0XHR0aGlzLmhvcml6b250YWxTY3JvbGxBY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmhCYXIuc2hvdygpLnNldE1heFZhbHVlKG1heFNjcm9sbFZhbHVlIC0gdmlld1NpemUpLnNldFJhdGlvKHZpZXdTaXplIC8gbWF4U2Nyb2xsVmFsdWUpLnNldFNpemUodmlld1NpemUpO1xuXHRcdFx0XHR0aGlzLmhCYXIuc2V0VmFsdWUodGhpcy5yZWFsRWxlbWVudC5zY3JvbGxMZWZ0KCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5oQmFyLmhpZGUoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gc2V0IFwidG91Y2gtYWN0aW9uXCIgc3R5bGUgcnVsZVxuXHRcdFx0dmFyIHRvdWNoQWN0aW9uID0gJyc7XG5cdFx0XHRpZiAodGhpcy52ZXJ0aWNhbFNjcm9sbEFjdGl2ZSAmJiB0aGlzLmhvcml6b250YWxTY3JvbGxBY3RpdmUpIHtcblx0XHRcdFx0dG91Y2hBY3Rpb24gPSAnbm9uZSc7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMudmVydGljYWxTY3JvbGxBY3RpdmUpIHtcblx0XHRcdFx0dG91Y2hBY3Rpb24gPSAncGFuLXgnO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLmhvcml6b250YWxTY3JvbGxBY3RpdmUpIHtcblx0XHRcdFx0dG91Y2hBY3Rpb24gPSAncGFuLXknO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5yZWFsRWxlbWVudC5jc3MoJ3RvdWNoQWN0aW9uJywgdG91Y2hBY3Rpb24pO1xuXHRcdH0sXG5cdFx0cmVmcmVzaDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnJlYnVpbGRTY3JvbGxiYXJzKCk7XG5cdFx0fSxcblx0XHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIHJlbW92ZSBldmVudCBsaXN0ZW5lcnNcblx0XHRcdHRoaXMud2luLm9mZigncmVzaXplIG9yaWVudGF0aW9uY2hhbmdlIGxvYWQnLCB0aGlzLm9uUmVzaXplKTtcblx0XHRcdHRoaXMucmVhbEVsZW1lbnQub2ZmKHtcblx0XHRcdFx0J2pjZi1tb3VzZXdoZWVsJzogdGhpcy5vbk1vdXNlV2hlZWwsXG5cdFx0XHRcdCdqY2YtcG9pbnRlcmRvd24nOiB0aGlzLm9uVG91Y2hCb2R5XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuZG9jLm9mZih7XG5cdFx0XHRcdCdqY2YtcG9pbnRlcm1vdmUnOiB0aGlzLm9uTW92ZUJvZHksXG5cdFx0XHRcdCdqY2YtcG9pbnRlcnVwJzogdGhpcy5vblJlbGVhc2VCb2R5XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gcmVzdG9yZSBzdHJ1Y3R1cmVcblx0XHRcdHRoaXMuc2F2ZVNjcm9sbE9mZnNldHMoKTtcblx0XHRcdHRoaXMudkJhci5kZXN0cm95KCk7XG5cdFx0XHR0aGlzLmhCYXIuZGVzdHJveSgpO1xuXHRcdFx0dGhpcy5yZWFsRWxlbWVudC5pbnNlcnRBZnRlcih0aGlzLnNjcm9sbFdyYXBwZXIpLmNzcyh7XG5cdFx0XHRcdHRvdWNoQWN0aW9uOiAnJyxcblx0XHRcdFx0b3ZlcmZsb3c6ICcnLFxuXHRcdFx0XHR3aWR0aDogJycsXG5cdFx0XHRcdGhlaWdodDogJydcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5zY3JvbGxXcmFwcGVyLnJlbW92ZSgpO1xuXHRcdFx0dGhpcy5yZXN0b3JlU2Nyb2xsT2Zmc2V0cygpO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gY3VzdG9tIHNjcm9sbGJhclxuXHRmdW5jdGlvbiBTY3JvbGxCYXIob3B0aW9ucykge1xuXHRcdHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHtcblx0XHRcdGhvbGRlcjogbnVsbCxcblx0XHRcdHZlcnRpY2FsOiB0cnVlLFxuXHRcdFx0aW5hY3RpdmVDbGFzczogJ2pjZi1pbmFjdGl2ZScsXG5cdFx0XHR2ZXJ0aWNhbENsYXNzOiAnamNmLXNjcm9sbGJhci12ZXJ0aWNhbCcsXG5cdFx0XHRob3Jpem9udGFsQ2xhc3M6ICdqY2Ytc2Nyb2xsYmFyLWhvcml6b250YWwnLFxuXHRcdFx0c2Nyb2xsYmFyU3RydWN0dXJlOiAnPGRpdiBjbGFzcz1cImpjZi1zY3JvbGxiYXJcIj48ZGl2IGNsYXNzPVwiamNmLXNjcm9sbGJhci1kZWNcIj48L2Rpdj48ZGl2IGNsYXNzPVwiamNmLXNjcm9sbGJhci1zbGlkZXJcIj48ZGl2IGNsYXNzPVwiamNmLXNjcm9sbGJhci1oYW5kbGVcIj48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVwiamNmLXNjcm9sbGJhci1pbmNcIj48L2Rpdj48L2Rpdj4nLFxuXHRcdFx0YnRuRGVjU2VsZWN0b3I6ICcuamNmLXNjcm9sbGJhci1kZWMnLFxuXHRcdFx0YnRuSW5jU2VsZWN0b3I6ICcuamNmLXNjcm9sbGJhci1pbmMnLFxuXHRcdFx0c2xpZGVyU2VsZWN0b3I6ICcuamNmLXNjcm9sbGJhci1zbGlkZXInLFxuXHRcdFx0aGFuZGxlU2VsZWN0b3I6ICcuamNmLXNjcm9sbGJhci1oYW5kbGUnLFxuXHRcdFx0c2Nyb2xsSW50ZXJ2YWw6IDMwMCxcblx0XHRcdHNjcm9sbFN0ZXA6IDQwMCAvLyBweC9zZWNcblx0XHR9LCBvcHRpb25zKTtcblx0XHR0aGlzLmluaXQoKTtcblx0fVxuXHQkLmV4dGVuZChTY3JvbGxCYXIucHJvdG90eXBlLCB7XG5cdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmluaXRTdHJ1Y3R1cmUoKTtcblx0XHRcdHRoaXMuYXR0YWNoRXZlbnRzKCk7XG5cdFx0fSxcblx0XHRpbml0U3RydWN0dXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIGRlZmluZSBwcm9wb3J0aWVzXG5cdFx0XHR0aGlzLmRvYyA9ICQoZG9jdW1lbnQpO1xuXHRcdFx0dGhpcy5pc1ZlcnRpY2FsID0gISF0aGlzLm9wdGlvbnMudmVydGljYWw7XG5cdFx0XHR0aGlzLnNpemVQcm9wZXJ0eSA9IHRoaXMuaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblx0XHRcdHRoaXMuZnVsbFNpemVQcm9wZXJ0eSA9IHRoaXMuaXNWZXJ0aWNhbCA/ICdvdXRlckhlaWdodCcgOiAnb3V0ZXJXaWR0aCc7XG5cdFx0XHR0aGlzLmludmVydGVkU2l6ZVByb3BlcnR5ID0gdGhpcy5pc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXHRcdFx0dGhpcy50aGlja25lc3NNZWFzdXJlTWV0aG9kID0gJ291dGVyJyArIHRoaXMuaW52ZXJ0ZWRTaXplUHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0aGlzLmludmVydGVkU2l6ZVByb3BlcnR5LnN1YnN0cigxKTtcblx0XHRcdHRoaXMub2Zmc2V0UHJvcGVydHkgPSB0aGlzLmlzVmVydGljYWwgPyAndG9wJyA6ICdsZWZ0Jztcblx0XHRcdHRoaXMub2Zmc2V0RXZlbnRQcm9wZXJ0eSA9IHRoaXMuaXNWZXJ0aWNhbCA/ICdwYWdlWScgOiAncGFnZVgnO1xuXG5cdFx0XHQvLyBpbml0aWFsaXplIHZhcmlhYmxlc1xuXHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMub3B0aW9ucy52YWx1ZSB8fCAwO1xuXHRcdFx0dGhpcy5tYXhWYWx1ZSA9IHRoaXMub3B0aW9ucy5tYXhWYWx1ZSB8fCAwO1xuXHRcdFx0dGhpcy5jdXJyZW50U2xpZGVyU2l6ZSA9IDA7XG5cdFx0XHR0aGlzLmhhbmRsZVNpemUgPSAwO1xuXG5cdFx0XHQvLyBmaW5kIGVsZW1lbnRzXG5cdFx0XHR0aGlzLmhvbGRlciA9ICQodGhpcy5vcHRpb25zLmhvbGRlcik7XG5cdFx0XHR0aGlzLnNjcm9sbGJhciA9ICQodGhpcy5vcHRpb25zLnNjcm9sbGJhclN0cnVjdHVyZSkuYXBwZW5kVG8odGhpcy5ob2xkZXIpO1xuXHRcdFx0dGhpcy5idG5EZWMgPSB0aGlzLnNjcm9sbGJhci5maW5kKHRoaXMub3B0aW9ucy5idG5EZWNTZWxlY3Rvcik7XG5cdFx0XHR0aGlzLmJ0bkluYyA9IHRoaXMuc2Nyb2xsYmFyLmZpbmQodGhpcy5vcHRpb25zLmJ0bkluY1NlbGVjdG9yKTtcblx0XHRcdHRoaXMuc2xpZGVyID0gdGhpcy5zY3JvbGxiYXIuZmluZCh0aGlzLm9wdGlvbnMuc2xpZGVyU2VsZWN0b3IpO1xuXHRcdFx0dGhpcy5oYW5kbGUgPSB0aGlzLnNsaWRlci5maW5kKHRoaXMub3B0aW9ucy5oYW5kbGVTZWxlY3Rvcik7XG5cblx0XHRcdC8vIHNldCBpbml0aWFsIHN0eWxlc1xuXHRcdFx0dGhpcy5zY3JvbGxiYXIuYWRkQ2xhc3ModGhpcy5pc1ZlcnRpY2FsID8gdGhpcy5vcHRpb25zLnZlcnRpY2FsQ2xhc3MgOiB0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbENsYXNzKS5jc3Moe1xuXHRcdFx0XHR0b3VjaEFjdGlvbjogdGhpcy5pc1ZlcnRpY2FsID8gJ3Bhbi14JyA6ICdwYW4teScsXG5cdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnXG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuc2xpZGVyLmNzcyh7XG5cdFx0XHRcdHBvc2l0aW9uOiAncmVsYXRpdmUnXG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuaGFuZGxlLmNzcyh7XG5cdFx0XHRcdHRvdWNoQWN0aW9uOiAnbm9uZScsXG5cdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnXG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdGF0dGFjaEV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmJpbmRIYW5kbGVycygpO1xuXHRcdFx0dGhpcy5oYW5kbGUub24oJ2pjZi1wb2ludGVyZG93bicsIHRoaXMub25IYW5kbGVQcmVzcyk7XG5cdFx0XHR0aGlzLnNsaWRlci5hZGQodGhpcy5idG5EZWMpLmFkZCh0aGlzLmJ0bkluYykub24oJ2pjZi1wb2ludGVyZG93bicsIHRoaXMub25CdXR0b25QcmVzcyk7XG5cdFx0fSxcblx0XHRvbkhhbmRsZVByZXNzOiBmdW5jdGlvbihlKSB7XG5cdFx0XHRpZiAoZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyAmJiBlLmJ1dHRvbiA+IDEpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR0aGlzLmhhbmRsZURyYWdBY3RpdmUgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLnNsaWRlck9mZnNldCA9IHRoaXMuc2xpZGVyLm9mZnNldCgpW3RoaXMub2Zmc2V0UHJvcGVydHldO1xuXHRcdFx0XHR0aGlzLmlubmVySGFuZGxlT2Zmc2V0ID0gZVt0aGlzLm9mZnNldEV2ZW50UHJvcGVydHldIC0gdGhpcy5oYW5kbGUub2Zmc2V0KClbdGhpcy5vZmZzZXRQcm9wZXJ0eV07XG5cblx0XHRcdFx0dGhpcy5kb2Mub24oJ2pjZi1wb2ludGVybW92ZScsIHRoaXMub25IYW5kbGVEcmFnKTtcblx0XHRcdFx0dGhpcy5kb2Mub24oJ2pjZi1wb2ludGVydXAnLCB0aGlzLm9uSGFuZGxlUmVsZWFzZSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvbkhhbmRsZURyYWc6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHRoaXMuY2FsY09mZnNldCA9IGVbdGhpcy5vZmZzZXRFdmVudFByb3BlcnR5XSAtIHRoaXMuc2xpZGVyT2Zmc2V0IC0gdGhpcy5pbm5lckhhbmRsZU9mZnNldDtcblx0XHRcdHRoaXMuc2V0VmFsdWUodGhpcy5jYWxjT2Zmc2V0IC8gKHRoaXMuY3VycmVudFNsaWRlclNpemUgLSB0aGlzLmhhbmRsZVNpemUpICogdGhpcy5tYXhWYWx1ZSk7XG5cdFx0XHR0aGlzLnRyaWdnZXJTY3JvbGxFdmVudCh0aGlzLnZhbHVlKTtcblx0XHR9LFxuXHRcdG9uSGFuZGxlUmVsZWFzZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmhhbmRsZURyYWdBY3RpdmUgPSBmYWxzZTtcblx0XHRcdHRoaXMuZG9jLm9mZignamNmLXBvaW50ZXJtb3ZlJywgdGhpcy5vbkhhbmRsZURyYWcpO1xuXHRcdFx0dGhpcy5kb2Mub2ZmKCdqY2YtcG9pbnRlcnVwJywgdGhpcy5vbkhhbmRsZVJlbGVhc2UpO1xuXHRcdH0sXG5cdFx0b25CdXR0b25QcmVzczogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIGRpcmVjdGlvbiwgY2xpY2tPZmZzZXQ7XG5cdFx0XHRpZiAoZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyAmJiBlLmJ1dHRvbiA+IDEpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRpZiAoIXRoaXMuaGFuZGxlRHJhZ0FjdGl2ZSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLnNsaWRlci5pcyhlLmN1cnJlbnRUYXJnZXQpKSB7XG5cdFx0XHRcdFx0XHQvLyBzbGlkZXIgcHJlc3NlZFxuXHRcdFx0XHRcdFx0ZGlyZWN0aW9uID0gdGhpcy5oYW5kbGUub2Zmc2V0KClbdGhpcy5vZmZzZXRQcm9wZXJ0eV0gPiBlW3RoaXMub2Zmc2V0RXZlbnRQcm9wZXJ0eV0gPyAtMSA6IDE7XG5cdFx0XHRcdFx0XHRjbGlja09mZnNldCA9IGVbdGhpcy5vZmZzZXRFdmVudFByb3BlcnR5XSAtIHRoaXMuc2xpZGVyLm9mZnNldCgpW3RoaXMub2Zmc2V0UHJvcGVydHldO1xuXHRcdFx0XHRcdFx0dGhpcy5zdGFydFBhZ2VTY3JvbGxpbmcoZGlyZWN0aW9uLCBjbGlja09mZnNldCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIHNjcm9sbGJhciBidXR0b25zIHByZXNzZWRcblx0XHRcdFx0XHRcdGRpcmVjdGlvbiA9IHRoaXMuYnRuRGVjLmlzKGUuY3VycmVudFRhcmdldCkgPyAtMSA6IDE7XG5cdFx0XHRcdFx0XHR0aGlzLnN0YXJ0U21vb3RoU2Nyb2xsaW5nKGRpcmVjdGlvbik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuZG9jLm9uKCdqY2YtcG9pbnRlcnVwJywgdGhpcy5vbkJ1dHRvblJlbGVhc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvbkJ1dHRvblJlbGVhc2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5zdG9wUGFnZVNjcm9sbGluZygpO1xuXHRcdFx0dGhpcy5zdG9wU21vb3RoU2Nyb2xsaW5nKCk7XG5cdFx0XHR0aGlzLmRvYy5vZmYoJ2pjZi1wb2ludGVydXAnLCB0aGlzLm9uQnV0dG9uUmVsZWFzZSk7XG5cdFx0fSxcblx0XHRzdGFydFBhZ2VTY3JvbGxpbmc6IGZ1bmN0aW9uKGRpcmVjdGlvbiwgY2xpY2tPZmZzZXQpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdFx0c3RlcFZhbHVlID0gZGlyZWN0aW9uICogc2VsZi5jdXJyZW50U2l6ZTtcblxuXHRcdFx0Ly8gbGltaXQgY2hlY2tlclxuXHRcdFx0dmFyIGlzRmluaXNoZWRTY3JvbGxpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGhhbmRsZVRvcCA9IChzZWxmLnZhbHVlIC8gc2VsZi5tYXhWYWx1ZSkgKiAoc2VsZi5jdXJyZW50U2xpZGVyU2l6ZSAtIHNlbGYuaGFuZGxlU2l6ZSk7XG5cblx0XHRcdFx0aWYgKGRpcmVjdGlvbiA+IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gaGFuZGxlVG9wICsgc2VsZi5oYW5kbGVTaXplID49IGNsaWNrT2Zmc2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBoYW5kbGVUb3AgPD0gY2xpY2tPZmZzZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdC8vIHNjcm9sbCBieSBwYWdlIHdoZW4gdHJhY2sgaXMgcHJlc3NlZFxuXHRcdFx0dmFyIGRvUGFnZVNjcm9sbCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLnZhbHVlICs9IHN0ZXBWYWx1ZTtcblx0XHRcdFx0c2VsZi5zZXRWYWx1ZShzZWxmLnZhbHVlKTtcblx0XHRcdFx0c2VsZi50cmlnZ2VyU2Nyb2xsRXZlbnQoc2VsZi52YWx1ZSk7XG5cblx0XHRcdFx0aWYgKGlzRmluaXNoZWRTY3JvbGxpbmcoKSkge1xuXHRcdFx0XHRcdGNsZWFySW50ZXJ2YWwoc2VsZi5wYWdlU2Nyb2xsVGltZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBzdGFydCBzY3JvbGxpbmdcblx0XHRcdHRoaXMucGFnZVNjcm9sbFRpbWVyID0gc2V0SW50ZXJ2YWwoZG9QYWdlU2Nyb2xsLCB0aGlzLm9wdGlvbnMuc2Nyb2xsSW50ZXJ2YWwpO1xuXHRcdFx0ZG9QYWdlU2Nyb2xsKCk7XG5cdFx0fSxcblx0XHRzdG9wUGFnZVNjcm9sbGluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHRjbGVhckludGVydmFsKHRoaXMucGFnZVNjcm9sbFRpbWVyKTtcblx0XHR9LFxuXHRcdHN0YXJ0U21vb3RoU2Nyb2xsaW5nOiBmdW5jdGlvbihkaXJlY3Rpb24pIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcywgZHQ7XG5cdFx0XHR0aGlzLnN0b3BTbW9vdGhTY3JvbGxpbmcoKTtcblxuXHRcdFx0Ly8gc2ltcGxlIGFuaW1hdGlvbiBmdW5jdGlvbnNcblx0XHRcdHZhciByYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGZ1bmN0aW9uKGZ1bmMpIHtcblx0XHRcdFx0c2V0VGltZW91dChmdW5jLCAxNik7XG5cdFx0XHR9O1xuXHRcdFx0dmFyIGdldFRpbWVzdGFtcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBzZXQgYW5pbWF0aW9uIGxpbWl0XG5cdFx0XHR2YXIgaXNGaW5pc2hlZFNjcm9sbGluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoZGlyZWN0aW9uID4gMCkge1xuXHRcdFx0XHRcdHJldHVybiBzZWxmLnZhbHVlID49IHNlbGYubWF4VmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNlbGYudmFsdWUgPD0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gYW5pbWF0aW9uIHN0ZXBcblx0XHRcdHZhciBkb1Njcm9sbEFuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgc3RlcFZhbHVlID0gKGdldFRpbWVzdGFtcCgpIC0gZHQpIC8gMTAwMCAqIHNlbGYub3B0aW9ucy5zY3JvbGxTdGVwO1xuXG5cdFx0XHRcdGlmIChzZWxmLnNtb290aFNjcm9sbEFjdGl2ZSkge1xuXHRcdFx0XHRcdHNlbGYudmFsdWUgKz0gc3RlcFZhbHVlICogZGlyZWN0aW9uO1xuXHRcdFx0XHRcdHNlbGYuc2V0VmFsdWUoc2VsZi52YWx1ZSk7XG5cdFx0XHRcdFx0c2VsZi50cmlnZ2VyU2Nyb2xsRXZlbnQoc2VsZi52YWx1ZSk7XG5cblx0XHRcdFx0XHRpZiAoIWlzRmluaXNoZWRTY3JvbGxpbmcoKSkge1xuXHRcdFx0XHRcdFx0ZHQgPSBnZXRUaW1lc3RhbXAoKTtcblx0XHRcdFx0XHRcdHJhZihkb1Njcm9sbEFuaW1hdGlvbik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBzdGFydCBhbmltYXRpb25cblx0XHRcdHNlbGYuc21vb3RoU2Nyb2xsQWN0aXZlID0gdHJ1ZTtcblx0XHRcdGR0ID0gZ2V0VGltZXN0YW1wKCk7XG5cdFx0XHRyYWYoZG9TY3JvbGxBbmltYXRpb24pO1xuXHRcdH0sXG5cdFx0c3RvcFNtb290aFNjcm9sbGluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnNtb290aFNjcm9sbEFjdGl2ZSA9IGZhbHNlO1xuXHRcdH0sXG5cdFx0dHJpZ2dlclNjcm9sbEV2ZW50OiBmdW5jdGlvbihzY3JvbGxWYWx1ZSkge1xuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vblNjcm9sbCkge1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMub25TY3JvbGwoc2Nyb2xsVmFsdWUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Z2V0VGhpY2tuZXNzOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnNjcm9sbGJhclt0aGlzLnRoaWNrbmVzc01lYXN1cmVNZXRob2RdKCk7XG5cdFx0fSxcblx0XHRzZXRTaXplOiBmdW5jdGlvbihzaXplKSB7XG5cdFx0XHQvLyByZXNpemUgc2Nyb2xsYmFyXG5cdFx0XHR2YXIgYnRuRGVjU2l6ZSA9IHRoaXMuYnRuRGVjW3RoaXMuZnVsbFNpemVQcm9wZXJ0eV0oKSxcblx0XHRcdFx0YnRuSW5jU2l6ZSA9IHRoaXMuYnRuSW5jW3RoaXMuZnVsbFNpemVQcm9wZXJ0eV0oKTtcblxuXHRcdFx0Ly8gcmVzaXplIHNsaWRlclxuXHRcdFx0dGhpcy5jdXJyZW50U2l6ZSA9IHNpemU7XG5cdFx0XHR0aGlzLmN1cnJlbnRTbGlkZXJTaXplID0gc2l6ZSAtIGJ0bkRlY1NpemUgLSBidG5JbmNTaXplO1xuXHRcdFx0dGhpcy5zY3JvbGxiYXIuY3NzKHRoaXMuc2l6ZVByb3BlcnR5LCBzaXplKTtcblx0XHRcdHRoaXMuc2xpZGVyLmNzcyh0aGlzLnNpemVQcm9wZXJ0eSwgdGhpcy5jdXJyZW50U2xpZGVyU2l6ZSk7XG5cdFx0XHR0aGlzLmN1cnJlbnRTbGlkZXJTaXplID0gdGhpcy5zbGlkZXJbdGhpcy5zaXplUHJvcGVydHldKCk7XG5cblx0XHRcdC8vIHJlc2l6ZSBoYW5kbGVcblx0XHRcdHRoaXMuaGFuZGxlU2l6ZSA9IE1hdGgucm91bmQodGhpcy5jdXJyZW50U2xpZGVyU2l6ZSAqIHRoaXMucmF0aW8pO1xuXHRcdFx0dGhpcy5oYW5kbGUuY3NzKHRoaXMuc2l6ZVByb3BlcnR5LCB0aGlzLmhhbmRsZVNpemUpO1xuXHRcdFx0dGhpcy5oYW5kbGVTaXplID0gdGhpcy5oYW5kbGVbdGhpcy5mdWxsU2l6ZVByb3BlcnR5XSgpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXHRcdHNldFJhdGlvOiBmdW5jdGlvbihyYXRpbykge1xuXHRcdFx0dGhpcy5yYXRpbyA9IHJhdGlvO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblx0XHRzZXRNYXhWYWx1ZTogZnVuY3Rpb24obWF4VmFsdWUpIHtcblx0XHRcdHRoaXMubWF4VmFsdWUgPSBtYXhWYWx1ZTtcblx0XHRcdHRoaXMuc2V0VmFsdWUoTWF0aC5taW4odGhpcy52YWx1ZSwgdGhpcy5tYXhWYWx1ZSkpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblx0XHRzZXRWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdGlmICh0aGlzLnZhbHVlIDwgMCkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gMDtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy52YWx1ZSA+IHRoaXMubWF4VmFsdWUpIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMubWF4VmFsdWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnJlZnJlc2goKTtcblx0XHR9LFxuXHRcdHNldFBvc2l0aW9uOiBmdW5jdGlvbihzdHlsZXMpIHtcblx0XHRcdHRoaXMuc2Nyb2xsYmFyLmNzcyhzdHlsZXMpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblx0XHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuc2Nyb2xsYmFyLmRldGFjaCgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblx0XHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuc2Nyb2xsYmFyLmFwcGVuZFRvKHRoaXMuaG9sZGVyKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cdFx0cmVmcmVzaDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyByZWNhbGN1bGF0ZSBoYW5kbGUgcG9zaXRpb25cblx0XHRcdGlmICh0aGlzLnZhbHVlID09PSAwIHx8IHRoaXMubWF4VmFsdWUgPT09IDApIHtcblx0XHRcdFx0dGhpcy5jYWxjT2Zmc2V0ID0gMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuY2FsY09mZnNldCA9ICh0aGlzLnZhbHVlIC8gdGhpcy5tYXhWYWx1ZSkgKiAodGhpcy5jdXJyZW50U2xpZGVyU2l6ZSAtIHRoaXMuaGFuZGxlU2l6ZSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmhhbmRsZS5jc3ModGhpcy5vZmZzZXRQcm9wZXJ0eSwgdGhpcy5jYWxjT2Zmc2V0KTtcblxuXHRcdFx0Ly8gdG9nZ2xlIGluYWN0aXZlIGNsYXNzZXNcblx0XHRcdHRoaXMuYnRuRGVjLnRvZ2dsZUNsYXNzKHRoaXMub3B0aW9ucy5pbmFjdGl2ZUNsYXNzLCB0aGlzLnZhbHVlID09PSAwKTtcblx0XHRcdHRoaXMuYnRuSW5jLnRvZ2dsZUNsYXNzKHRoaXMub3B0aW9ucy5pbmFjdGl2ZUNsYXNzLCB0aGlzLnZhbHVlID09PSB0aGlzLm1heFZhbHVlKTtcblx0XHRcdHRoaXMuc2Nyb2xsYmFyLnRvZ2dsZUNsYXNzKHRoaXMub3B0aW9ucy5pbmFjdGl2ZUNsYXNzLCB0aGlzLm1heFZhbHVlID09PSAwKTtcblx0XHR9LFxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gcmVtb3ZlIGV2ZW50IGhhbmRsZXJzIGFuZCBzY3JvbGxiYXIgYmxvY2sgaXRzZWxmXG5cdFx0XHR0aGlzLmJ0bkRlYy5hZGQodGhpcy5idG5JbmMpLm9mZignamNmLXBvaW50ZXJkb3duJywgdGhpcy5vbkJ1dHRvblByZXNzKTtcblx0XHRcdHRoaXMuaGFuZGxlLm9mZignamNmLXBvaW50ZXJkb3duJywgdGhpcy5vbkhhbmRsZVByZXNzKTtcblx0XHRcdHRoaXMuZG9jLm9mZignamNmLXBvaW50ZXJtb3ZlJywgdGhpcy5vbkhhbmRsZURyYWcpO1xuXHRcdFx0dGhpcy5kb2Mub2ZmKCdqY2YtcG9pbnRlcnVwJywgdGhpcy5vbkhhbmRsZVJlbGVhc2UpO1xuXHRcdFx0dGhpcy5kb2Mub2ZmKCdqY2YtcG9pbnRlcnVwJywgdGhpcy5vbkJ1dHRvblJlbGVhc2UpO1xuXHRcdFx0dGhpcy5zdG9wU21vb3RoU2Nyb2xsaW5nKCk7XG5cdFx0XHR0aGlzLnN0b3BQYWdlU2Nyb2xsaW5nKCk7XG5cdFx0XHR0aGlzLnNjcm9sbGJhci5yZW1vdmUoKTtcblx0XHR9XG5cdH0pO1xuXG59KGpRdWVyeSwgdGhpcykpO1xuIiwiLyohXG4gKiBKYXZhU2NyaXB0IEN1c3RvbSBGb3JtcyA6IFNlbGVjdCBNb2R1bGVcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1IFBTRDJIVE1MIC0gaHR0cDovL3BzZDJodG1sLmNvbS9qY2ZcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSAoTElDRU5TRS50eHQpXG4gKlxuICogVmVyc2lvbjogMS4xLjJcbiAqL1xuOyhmdW5jdGlvbigkKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRqY2YuYWRkTW9kdWxlKHtcblx0XHRuYW1lOiAnU2VsZWN0Jyxcblx0XHRzZWxlY3RvcjogJ3NlbGVjdCcsXG5cdFx0b3B0aW9uczoge1xuXHRcdFx0ZWxlbWVudDogbnVsbCxcblx0XHRcdG11bHRpcGxlQ29tcGFjdFN0eWxlOiBmYWxzZVxuXHRcdH0sXG5cdFx0cGx1Z2luczoge1xuXHRcdFx0TGlzdEJveDogTGlzdEJveCxcblx0XHRcdENvbWJvQm94OiBDb21ib0JveCxcblx0XHRcdFNlbGVjdExpc3Q6IFNlbGVjdExpc3Rcblx0XHR9LFxuXHRcdG1hdGNoRWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIGVsZW1lbnQuaXMoJ3NlbGVjdCcpO1xuXHRcdH0sXG5cdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQgPSAkKHRoaXMub3B0aW9ucy5lbGVtZW50KTtcblx0XHRcdHRoaXMuY3JlYXRlSW5zdGFuY2UoKTtcblx0XHR9LFxuXHRcdGlzTGlzdEJveDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50LmlzKCdbc2l6ZV06bm90KFtqY2Ytc2l6ZV0pLCBbbXVsdGlwbGVdJyk7XG5cdFx0fSxcblx0XHRjcmVhdGVJbnN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAodGhpcy5pbnN0YW5jZSkge1xuXHRcdFx0XHR0aGlzLmluc3RhbmNlLmRlc3Ryb3koKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLmlzTGlzdEJveCgpICYmICF0aGlzLm9wdGlvbnMubXVsdGlwbGVDb21wYWN0U3R5bGUpIHtcblx0XHRcdFx0dGhpcy5pbnN0YW5jZSA9IG5ldyBMaXN0Qm94KHRoaXMub3B0aW9ucyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmluc3RhbmNlID0gbmV3IENvbWJvQm94KHRoaXMub3B0aW9ucyk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlTWlzbWF0Y2ggPSAodGhpcy5pc0xpc3RCb3goKSAmJiB0aGlzLmluc3RhbmNlIGluc3RhbmNlb2YgQ29tYm9Cb3gpIHx8XG5cdFx0XHRcdFx0XHRcdFx0KCF0aGlzLmlzTGlzdEJveCgpICYmIHRoaXMuaW5zdGFuY2UgaW5zdGFuY2VvZiBMaXN0Qm94KTtcblxuXHRcdFx0aWYgKHR5cGVNaXNtYXRjaCkge1xuXHRcdFx0XHR0aGlzLmNyZWF0ZUluc3RhbmNlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmluc3RhbmNlLnJlZnJlc2goKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5pbnN0YW5jZS5kZXN0cm95KCk7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBjb21ib2JveCBtb2R1bGVcblx0ZnVuY3Rpb24gQ29tYm9Cb3gob3B0aW9ucykge1xuXHRcdHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHtcblx0XHRcdHdyYXBOYXRpdmU6IHRydWUsXG5cdFx0XHR3cmFwTmF0aXZlT25Nb2JpbGU6IHRydWUsXG5cdFx0XHRmYWtlRHJvcEluQm9keTogdHJ1ZSxcblx0XHRcdHVzZUN1c3RvbVNjcm9sbDogdHJ1ZSxcblx0XHRcdGZsaXBEcm9wVG9GaXQ6IHRydWUsXG5cdFx0XHRtYXhWaXNpYmxlSXRlbXM6IDEwLFxuXHRcdFx0ZmFrZUFyZWFTdHJ1Y3R1cmU6ICc8c3BhbiBjbGFzcz1cImpjZi1zZWxlY3RcIj48c3BhbiBjbGFzcz1cImpjZi1zZWxlY3QtdGV4dFwiPjwvc3Bhbj48c3BhbiBjbGFzcz1cImpjZi1zZWxlY3Qtb3BlbmVyXCI+PC9zcGFuPjwvc3Bhbj4nLFxuXHRcdFx0ZmFrZURyb3BTdHJ1Y3R1cmU6ICc8ZGl2IGNsYXNzPVwiamNmLXNlbGVjdC1kcm9wXCI+PGRpdiBjbGFzcz1cImpjZi1zZWxlY3QtZHJvcC1jb250ZW50XCI+PC9kaXY+PC9kaXY+Jyxcblx0XHRcdG9wdGlvbkNsYXNzUHJlZml4OiAnamNmLW9wdGlvbi0nLFxuXHRcdFx0c2VsZWN0Q2xhc3NQcmVmaXg6ICdqY2Ytc2VsZWN0LScsXG5cdFx0XHRkcm9wQ29udGVudFNlbGVjdG9yOiAnLmpjZi1zZWxlY3QtZHJvcC1jb250ZW50Jyxcblx0XHRcdHNlbGVjdFRleHRTZWxlY3RvcjogJy5qY2Ytc2VsZWN0LXRleHQnLFxuXHRcdFx0ZHJvcEFjdGl2ZUNsYXNzOiAnamNmLWRyb3AtYWN0aXZlJyxcblx0XHRcdGZsaXBEcm9wQ2xhc3M6ICdqY2YtZHJvcC1mbGlwcGVkJ1xuXHRcdH0sIG9wdGlvbnMpO1xuXHRcdHRoaXMuaW5pdCgpO1xuXHR9XG5cdCQuZXh0ZW5kKENvbWJvQm94LnByb3RvdHlwZSwge1xuXHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5pbml0U3RydWN0dXJlKCk7XG5cdFx0XHR0aGlzLmJpbmRIYW5kbGVycygpO1xuXHRcdFx0dGhpcy5hdHRhY2hFdmVudHMoKTtcblx0XHRcdHRoaXMucmVmcmVzaCgpO1xuXHRcdH0sXG5cdFx0aW5pdFN0cnVjdHVyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBwcmVwYXJlIHN0cnVjdHVyZVxuXHRcdFx0dGhpcy53aW4gPSAkKHdpbmRvdyk7XG5cdFx0XHR0aGlzLmRvYyA9ICQoZG9jdW1lbnQpO1xuXHRcdFx0dGhpcy5yZWFsRWxlbWVudCA9ICQodGhpcy5vcHRpb25zLmVsZW1lbnQpO1xuXHRcdFx0dGhpcy5mYWtlRWxlbWVudCA9ICQodGhpcy5vcHRpb25zLmZha2VBcmVhU3RydWN0dXJlKS5pbnNlcnRBZnRlcih0aGlzLnJlYWxFbGVtZW50KTtcblx0XHRcdHRoaXMuc2VsZWN0VGV4dENvbnRhaW5lciA9IHRoaXMuZmFrZUVsZW1lbnQuZmluZCh0aGlzLm9wdGlvbnMuc2VsZWN0VGV4dFNlbGVjdG9yKTtcblx0XHRcdHRoaXMuc2VsZWN0VGV4dCA9ICQoJzxzcGFuPjwvc3Bhbj4nKS5hcHBlbmRUbyh0aGlzLnNlbGVjdFRleHRDb250YWluZXIpO1xuXHRcdFx0bWFrZVVuc2VsZWN0YWJsZSh0aGlzLmZha2VFbGVtZW50KTtcblxuXHRcdFx0Ly8gY29weSBjbGFzc2VzIGZyb20gb3JpZ2luYWwgc2VsZWN0XG5cdFx0XHR0aGlzLmZha2VFbGVtZW50LmFkZENsYXNzKGdldFByZWZpeGVkQ2xhc3Nlcyh0aGlzLnJlYWxFbGVtZW50LnByb3AoJ2NsYXNzTmFtZScpLCB0aGlzLm9wdGlvbnMuc2VsZWN0Q2xhc3NQcmVmaXgpKTtcblxuXHRcdFx0Ly8gaGFuZGxlIGNvbXBhY3QgbXVsdGlwbGUgc3R5bGVcblx0XHRcdGlmICh0aGlzLnJlYWxFbGVtZW50LnByb3AoJ211bHRpcGxlJykpIHtcblx0XHRcdFx0dGhpcy5mYWtlRWxlbWVudC5hZGRDbGFzcygnamNmLWNvbXBhY3QtbXVsdGlwbGUnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZGV0ZWN0IGRldmljZSB0eXBlIGFuZCBkcm9wZG93biBiZWhhdmlvclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5pc01vYmlsZURldmljZSAmJiB0aGlzLm9wdGlvbnMud3JhcE5hdGl2ZU9uTW9iaWxlICYmICF0aGlzLm9wdGlvbnMud3JhcE5hdGl2ZSkge1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMud3JhcE5hdGl2ZSA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLm9wdGlvbnMud3JhcE5hdGl2ZSkge1xuXHRcdFx0XHQvLyB3cmFwIG5hdGl2ZSBzZWxlY3QgaW5zaWRlIGZha2UgYmxvY2tcblx0XHRcdFx0dGhpcy5yZWFsRWxlbWVudC5wcmVwZW5kVG8odGhpcy5mYWtlRWxlbWVudCkuY3NzKHtcblx0XHRcdFx0XHRwb3NpdGlvbjogJ2Fic29sdXRlJyxcblx0XHRcdFx0XHRoZWlnaHQ6ICcxMDAlJyxcblx0XHRcdFx0XHR3aWR0aDogJzEwMCUnXG5cdFx0XHRcdH0pLmFkZENsYXNzKHRoaXMub3B0aW9ucy5yZXNldEFwcGVhcmFuY2VDbGFzcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBqdXN0IGhpZGUgbmF0aXZlIHNlbGVjdFxuXHRcdFx0XHR0aGlzLnJlYWxFbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5oaWRkZW5DbGFzcyk7XG5cdFx0XHRcdHRoaXMuZmFrZUVsZW1lbnQuYXR0cigndGl0bGUnLCB0aGlzLnJlYWxFbGVtZW50LmF0dHIoJ3RpdGxlJykpO1xuXHRcdFx0XHR0aGlzLmZha2VEcm9wVGFyZ2V0ID0gdGhpcy5vcHRpb25zLmZha2VEcm9wSW5Cb2R5ID8gJCgnYm9keScpIDogdGhpcy5mYWtlRWxlbWVudDtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGF0dGFjaEV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBkZWxheWVkIHJlZnJlc2ggaGFuZGxlclxuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dGhpcy5kZWxheWVkUmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHNlbGYucmVmcmVzaCgpO1xuXHRcdFx0XHRcdGlmIChzZWxmLmxpc3QpIHtcblx0XHRcdFx0XHRcdHNlbGYubGlzdC5yZWZyZXNoKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCAxKTtcblx0XHRcdH07XG5cblx0XHRcdC8vIG5hdGl2ZSBkcm9wZG93biBldmVudCBoYW5kbGVyc1xuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy53cmFwTmF0aXZlKSB7XG5cdFx0XHRcdHRoaXMucmVhbEVsZW1lbnQub24oe1xuXHRcdFx0XHRcdGZvY3VzOiB0aGlzLm9uRm9jdXMsXG5cdFx0XHRcdFx0Y2hhbmdlOiB0aGlzLm9uQ2hhbmdlLFxuXHRcdFx0XHRcdGNsaWNrOiB0aGlzLm9uQ2hhbmdlLFxuXHRcdFx0XHRcdGtleWRvd246IHRoaXMub25DaGFuZ2Vcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBjdXN0b20gZHJvcGRvd24gZXZlbnQgaGFuZGxlcnNcblx0XHRcdFx0dGhpcy5yZWFsRWxlbWVudC5vbih7XG5cdFx0XHRcdFx0Zm9jdXM6IHRoaXMub25Gb2N1cyxcblx0XHRcdFx0XHRjaGFuZ2U6IHRoaXMub25DaGFuZ2UsXG5cdFx0XHRcdFx0a2V5ZG93bjogdGhpcy5vbktleURvd25cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRoaXMuZmFrZUVsZW1lbnQub24oe1xuXHRcdFx0XHRcdCdqY2YtcG9pbnRlcmRvd24nOiB0aGlzLm9uU2VsZWN0QXJlYVByZXNzXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0b25LZXlEb3duOiBmdW5jdGlvbihlKSB7XG5cdFx0XHRpZiAoZS53aGljaCA9PT0gMTMpIHtcblx0XHRcdFx0dGhpcy50b2dnbGVEcm9wZG93bigpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLmRyb3BBY3RpdmUpIHtcblx0XHRcdFx0dGhpcy5kZWxheWVkUmVmcmVzaCgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0b25DaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5yZWZyZXNoKCk7XG5cdFx0fSxcblx0XHRvbkZvY3VzOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICghdGhpcy5wcmVzc2VkRmxhZyB8fCAhdGhpcy5mb2N1c2VkRmxhZykge1xuXHRcdFx0XHR0aGlzLmZha2VFbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5mb2N1c0NsYXNzKTtcblx0XHRcdFx0dGhpcy5yZWFsRWxlbWVudC5vbignYmx1cicsIHRoaXMub25CbHVyKTtcblx0XHRcdFx0dGhpcy50b2dnbGVMaXN0TW9kZSh0cnVlKTtcblx0XHRcdFx0dGhpcy5mb2N1c2VkRmxhZyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvbkJsdXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCF0aGlzLnByZXNzZWRGbGFnKSB7XG5cdFx0XHRcdHRoaXMuZmFrZUVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmZvY3VzQ2xhc3MpO1xuXHRcdFx0XHR0aGlzLnJlYWxFbGVtZW50Lm9mZignYmx1cicsIHRoaXMub25CbHVyKTtcblx0XHRcdFx0dGhpcy50b2dnbGVMaXN0TW9kZShmYWxzZSk7XG5cdFx0XHRcdHRoaXMuZm9jdXNlZEZsYWcgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9uUmVzaXplOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh0aGlzLmRyb3BBY3RpdmUpIHtcblx0XHRcdFx0dGhpcy5oaWRlRHJvcGRvd24oKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9uU2VsZWN0RHJvcFByZXNzOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMucHJlc3NlZEZsYWcgPSB0cnVlO1xuXHRcdH0sXG5cdFx0b25TZWxlY3REcm9wUmVsZWFzZTogZnVuY3Rpb24oZSwgcG9pbnRlckV2ZW50KSB7XG5cdFx0XHR0aGlzLnByZXNzZWRGbGFnID0gZmFsc2U7XG5cdFx0XHRpZiAocG9pbnRlckV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7XG5cdFx0XHRcdHRoaXMucmVhbEVsZW1lbnQuZm9jdXMoKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9uU2VsZWN0QXJlYVByZXNzOiBmdW5jdGlvbihlKSB7XG5cdFx0XHQvLyBza2lwIGNsaWNrIGlmIGRyb3AgaW5zaWRlIGZha2UgZWxlbWVudCBvciByZWFsIHNlbGVjdCBpcyBkaXNhYmxlZFxuXHRcdFx0dmFyIGRyb3BDbGlja2VkSW5zaWRlRmFrZUVsZW1lbnQgPSAhdGhpcy5vcHRpb25zLmZha2VEcm9wSW5Cb2R5ICYmICQoZS50YXJnZXQpLmNsb3Nlc3QodGhpcy5kcm9wZG93bikubGVuZ3RoO1xuXHRcdFx0aWYgKGRyb3BDbGlja2VkSW5zaWRlRmFrZUVsZW1lbnQgfHwgZS5idXR0b24gPiAxIHx8IHRoaXMucmVhbEVsZW1lbnQuaXMoJzpkaXNhYmxlZCcpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdG9nZ2xlIGRyb3Bkb3duIHZpc2liaWxpdHlcblx0XHRcdHRoaXMuc2VsZWN0T3BlbmVkQnlFdmVudCA9IGUucG9pbnRlclR5cGU7XG5cdFx0XHR0aGlzLnRvZ2dsZURyb3Bkb3duKCk7XG5cblx0XHRcdC8vIG1pc2MgaGFuZGxlcnNcblx0XHRcdGlmICghdGhpcy5mb2N1c2VkRmxhZykge1xuXHRcdFx0XHRpZiAoZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykge1xuXHRcdFx0XHRcdHRoaXMucmVhbEVsZW1lbnQuZm9jdXMoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLm9uRm9jdXMoZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMucHJlc3NlZEZsYWcgPSB0cnVlO1xuXHRcdFx0dGhpcy5mYWtlRWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMucHJlc3NlZENsYXNzKTtcblx0XHRcdHRoaXMuZG9jLm9uKCdqY2YtcG9pbnRlcnVwJywgdGhpcy5vblNlbGVjdEFyZWFSZWxlYXNlKTtcblx0XHR9LFxuXHRcdG9uU2VsZWN0QXJlYVJlbGVhc2U6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdGlmICh0aGlzLmZvY3VzZWRGbGFnICYmIGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHtcblx0XHRcdFx0dGhpcy5yZWFsRWxlbWVudC5mb2N1cygpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5wcmVzc2VkRmxhZyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5mYWtlRWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMucHJlc3NlZENsYXNzKTtcblx0XHRcdHRoaXMuZG9jLm9mZignamNmLXBvaW50ZXJ1cCcsIHRoaXMub25TZWxlY3RBcmVhUmVsZWFzZSk7XG5cdFx0fSxcblx0XHRvbk91dHNpZGVDbGljazogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIHRhcmdldCA9ICQoZS50YXJnZXQpLFxuXHRcdFx0XHRjbGlja2VkSW5zaWRlU2VsZWN0ID0gdGFyZ2V0LmNsb3Nlc3QodGhpcy5mYWtlRWxlbWVudCkubGVuZ3RoIHx8IHRhcmdldC5jbG9zZXN0KHRoaXMuZHJvcGRvd24pLmxlbmd0aDtcblxuXHRcdFx0aWYgKCFjbGlja2VkSW5zaWRlU2VsZWN0KSB7XG5cdFx0XHRcdHRoaXMuaGlkZURyb3Bkb3duKCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvblNlbGVjdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnJlZnJlc2goKTtcblxuXHRcdFx0aWYgKHRoaXMucmVhbEVsZW1lbnQucHJvcCgnbXVsdGlwbGUnKSkge1xuXHRcdFx0XHR0aGlzLnJlcG9zaXRpb25Ecm9wZG93bigpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5oaWRlRHJvcGRvd24oKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5maXJlTmF0aXZlRXZlbnQodGhpcy5yZWFsRWxlbWVudCwgJ2NoYW5nZScpO1xuXHRcdH0sXG5cdFx0dG9nZ2xlTGlzdE1vZGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG5cdFx0XHRpZiAoIXRoaXMub3B0aW9ucy53cmFwTmF0aXZlKSB7XG5cdFx0XHRcdGlmIChzdGF0ZSkge1xuXHRcdFx0XHRcdC8vIHRlbXBvcmFyeSBjaGFuZ2Ugc2VsZWN0IHRvIGxpc3QgdG8gYXZvaWQgYXBwZWFyaW5nIG9mIG5hdGl2ZSBkcm9wZG93blxuXHRcdFx0XHRcdHRoaXMucmVhbEVsZW1lbnQuYXR0cih7XG5cdFx0XHRcdFx0XHRzaXplOiA0LFxuXHRcdFx0XHRcdFx0J2pjZi1zaXplJzogJydcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyByZXN0b3JlIHNlbGVjdCBmcm9tIGxpc3QgbW9kZSB0byBkcm9wZG93biBzZWxlY3Rcblx0XHRcdFx0XHRpZiAoIXRoaXMub3B0aW9ucy53cmFwTmF0aXZlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJlYWxFbGVtZW50LnJlbW92ZUF0dHIoJ3NpemUgamNmLXNpemUnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGNyZWF0ZURyb3Bkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIGRlc3Ryb3kgcHJldmlvdXMgZHJvcGRvd24gaWYgbmVlZGVkXG5cdFx0XHRpZiAodGhpcy5kcm9wZG93bikge1xuXHRcdFx0XHR0aGlzLmxpc3QuZGVzdHJveSgpO1xuXHRcdFx0XHR0aGlzLmRyb3Bkb3duLnJlbW92ZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjcmVhdGUgbmV3IGRyb3AgY29udGFpbmVyXG5cdFx0XHR0aGlzLmRyb3Bkb3duID0gJCh0aGlzLm9wdGlvbnMuZmFrZURyb3BTdHJ1Y3R1cmUpLmFwcGVuZFRvKHRoaXMuZmFrZURyb3BUYXJnZXQpO1xuXHRcdFx0dGhpcy5kcm9wZG93bi5hZGRDbGFzcyhnZXRQcmVmaXhlZENsYXNzZXModGhpcy5yZWFsRWxlbWVudC5wcm9wKCdjbGFzc05hbWUnKSwgdGhpcy5vcHRpb25zLnNlbGVjdENsYXNzUHJlZml4KSk7XG5cdFx0XHRtYWtlVW5zZWxlY3RhYmxlKHRoaXMuZHJvcGRvd24pO1xuXG5cdFx0XHQvLyBoYW5kbGUgY29tcGFjdCBtdWx0aXBsZSBzdHlsZVxuXHRcdFx0aWYgKHRoaXMucmVhbEVsZW1lbnQucHJvcCgnbXVsdGlwbGUnKSkge1xuXHRcdFx0XHR0aGlzLmRyb3Bkb3duLmFkZENsYXNzKCdqY2YtY29tcGFjdC1tdWx0aXBsZScpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBzZXQgaW5pdGlhbCBzdHlsZXMgZm9yIGRyb3Bkb3duIGluIGJvZHlcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuZmFrZURyb3BJbkJvZHkpIHtcblx0XHRcdFx0dGhpcy5kcm9wZG93bi5jc3Moe1xuXHRcdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0XHRcdHRvcDogLTk5OTlcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNyZWF0ZSBuZXcgc2VsZWN0IGxpc3QgaW5zdGFuY2Vcblx0XHRcdHRoaXMubGlzdCA9IG5ldyBTZWxlY3RMaXN0KHtcblx0XHRcdFx0dXNlSG92ZXJDbGFzczogdHJ1ZSxcblx0XHRcdFx0aGFuZGxlUmVzaXplOiBmYWxzZSxcblx0XHRcdFx0YWx3YXlzUHJldmVudE1vdXNlV2hlZWw6IHRydWUsXG5cdFx0XHRcdG1heFZpc2libGVJdGVtczogdGhpcy5vcHRpb25zLm1heFZpc2libGVJdGVtcyxcblx0XHRcdFx0dXNlQ3VzdG9tU2Nyb2xsOiB0aGlzLm9wdGlvbnMudXNlQ3VzdG9tU2Nyb2xsLFxuXHRcdFx0XHRob2xkZXI6IHRoaXMuZHJvcGRvd24uZmluZCh0aGlzLm9wdGlvbnMuZHJvcENvbnRlbnRTZWxlY3RvciksXG5cdFx0XHRcdG11bHRpcGxlU2VsZWN0V2l0aG91dEtleTogdGhpcy5yZWFsRWxlbWVudC5wcm9wKCdtdWx0aXBsZScpLFxuXHRcdFx0XHRlbGVtZW50OiB0aGlzLnJlYWxFbGVtZW50XG5cdFx0XHR9KTtcblx0XHRcdCQodGhpcy5saXN0KS5vbih7XG5cdFx0XHRcdHNlbGVjdDogdGhpcy5vblNlbGVjdCxcblx0XHRcdFx0cHJlc3M6IHRoaXMub25TZWxlY3REcm9wUHJlc3MsXG5cdFx0XHRcdHJlbGVhc2U6IHRoaXMub25TZWxlY3REcm9wUmVsZWFzZVxuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRyZXBvc2l0aW9uRHJvcGRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGVjdE9mZnNldCA9IHRoaXMuZmFrZUVsZW1lbnQub2Zmc2V0KCksXG5cdFx0XHRcdHNlbGVjdFdpZHRoID0gdGhpcy5mYWtlRWxlbWVudC5vdXRlcldpZHRoKCksXG5cdFx0XHRcdHNlbGVjdEhlaWdodCA9IHRoaXMuZmFrZUVsZW1lbnQub3V0ZXJIZWlnaHQoKSxcblx0XHRcdFx0ZHJvcEhlaWdodCA9IHRoaXMuZHJvcGRvd24uY3NzKCd3aWR0aCcsIHNlbGVjdFdpZHRoKS5vdXRlckhlaWdodCgpLFxuXHRcdFx0XHR3aW5TY3JvbGxUb3AgPSB0aGlzLndpbi5zY3JvbGxUb3AoKSxcblx0XHRcdFx0d2luSGVpZ2h0ID0gdGhpcy53aW4uaGVpZ2h0KCksXG5cdFx0XHRcdGNhbGNUb3AsIGNhbGNMZWZ0LCBib2R5T2Zmc2V0LCBuZWVkRmxpcERyb3AgPSBmYWxzZTtcblxuXHRcdFx0Ly8gY2hlY2sgZmxpcCBkcm9wIHBvc2l0aW9uXG5cdFx0XHRpZiAoc2VsZWN0T2Zmc2V0LnRvcCArIHNlbGVjdEhlaWdodCArIGRyb3BIZWlnaHQgPiB3aW5TY3JvbGxUb3AgKyB3aW5IZWlnaHQgJiYgc2VsZWN0T2Zmc2V0LnRvcCAtIGRyb3BIZWlnaHQgPiB3aW5TY3JvbGxUb3ApIHtcblx0XHRcdFx0bmVlZEZsaXBEcm9wID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5mYWtlRHJvcEluQm9keSkge1xuXHRcdFx0XHRib2R5T2Zmc2V0ID0gdGhpcy5mYWtlRHJvcFRhcmdldC5jc3MoJ3Bvc2l0aW9uJykgIT09ICdzdGF0aWMnID8gdGhpcy5mYWtlRHJvcFRhcmdldC5vZmZzZXQoKS50b3AgOiAwO1xuXHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLmZsaXBEcm9wVG9GaXQgJiYgbmVlZEZsaXBEcm9wKSB7XG5cdFx0XHRcdFx0Ly8gY2FsY3VsYXRlIGZsaXBwZWQgZHJvcGRvd24gcG9zaXRpb25cblx0XHRcdFx0XHRjYWxjTGVmdCA9IHNlbGVjdE9mZnNldC5sZWZ0O1xuXHRcdFx0XHRcdGNhbGNUb3AgPSBzZWxlY3RPZmZzZXQudG9wIC0gZHJvcEhlaWdodCAtIGJvZHlPZmZzZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gY2FsY3VsYXRlIGRlZmF1bHQgZHJvcCBwb3NpdGlvblxuXHRcdFx0XHRcdGNhbGNMZWZ0ID0gc2VsZWN0T2Zmc2V0LmxlZnQ7XG5cdFx0XHRcdFx0Y2FsY1RvcCA9IHNlbGVjdE9mZnNldC50b3AgKyBzZWxlY3RIZWlnaHQgLSBib2R5T2Zmc2V0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdXBkYXRlIGRyb3Agc3R5bGVzXG5cdFx0XHRcdHRoaXMuZHJvcGRvd24uY3NzKHtcblx0XHRcdFx0XHR3aWR0aDogc2VsZWN0V2lkdGgsXG5cdFx0XHRcdFx0bGVmdDogY2FsY0xlZnQsXG5cdFx0XHRcdFx0dG9wOiBjYWxjVG9wXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyByZWZyZXNoIGZsaXBwZWQgY2xhc3Ncblx0XHRcdHRoaXMuZHJvcGRvd24uYWRkKHRoaXMuZmFrZUVsZW1lbnQpLnRvZ2dsZUNsYXNzKHRoaXMub3B0aW9ucy5mbGlwRHJvcENsYXNzLCB0aGlzLm9wdGlvbnMuZmxpcERyb3BUb0ZpdCAmJiBuZWVkRmxpcERyb3ApO1xuXHRcdH0sXG5cdFx0c2hvd0Ryb3Bkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIGRvIG5vdCBzaG93IGVtcHR5IGN1c3RvbSBkcm9wZG93blxuXHRcdFx0aWYgKCF0aGlzLnJlYWxFbGVtZW50LnByb3AoJ29wdGlvbnMnKS5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjcmVhdGUgb3B0aW9ucyBsaXN0IGlmIG5vdCBjcmVhdGVkXG5cdFx0XHRpZiAoIXRoaXMuZHJvcGRvd24pIHtcblx0XHRcdFx0dGhpcy5jcmVhdGVEcm9wZG93bigpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBzaG93IGRyb3Bkb3duXG5cdFx0XHR0aGlzLmRyb3BBY3RpdmUgPSB0cnVlO1xuXHRcdFx0dGhpcy5kcm9wZG93bi5hcHBlbmRUbyh0aGlzLmZha2VEcm9wVGFyZ2V0KTtcblx0XHRcdHRoaXMuZmFrZUVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmRyb3BBY3RpdmVDbGFzcyk7XG5cdFx0XHR0aGlzLnJlZnJlc2hTZWxlY3RlZFRleHQoKTtcblx0XHRcdHRoaXMucmVwb3NpdGlvbkRyb3Bkb3duKCk7XG5cdFx0XHR0aGlzLmxpc3Quc2V0U2Nyb2xsVG9wKHRoaXMuc2F2ZWRTY3JvbGxUb3ApO1xuXHRcdFx0dGhpcy5saXN0LnJlZnJlc2goKTtcblxuXHRcdFx0Ly8gYWRkIHRlbXBvcmFyeSBldmVudCBoYW5kbGVyc1xuXHRcdFx0dGhpcy53aW4ub24oJ3Jlc2l6ZScsIHRoaXMub25SZXNpemUpO1xuXHRcdFx0dGhpcy5kb2Mub24oJ2pjZi1wb2ludGVyZG93bicsIHRoaXMub25PdXRzaWRlQ2xpY2spO1xuXHRcdH0sXG5cdFx0aGlkZURyb3Bkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh0aGlzLmRyb3Bkb3duKSB7XG5cdFx0XHRcdHRoaXMuc2F2ZWRTY3JvbGxUb3AgPSB0aGlzLmxpc3QuZ2V0U2Nyb2xsVG9wKCk7XG5cdFx0XHRcdHRoaXMuZmFrZUVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmRyb3BBY3RpdmVDbGFzcyArICcgJyArIHRoaXMub3B0aW9ucy5mbGlwRHJvcENsYXNzKTtcblx0XHRcdFx0dGhpcy5kcm9wZG93bi5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZmxpcERyb3BDbGFzcykuZGV0YWNoKCk7XG5cdFx0XHRcdHRoaXMuZG9jLm9mZignamNmLXBvaW50ZXJkb3duJywgdGhpcy5vbk91dHNpZGVDbGljayk7XG5cdFx0XHRcdHRoaXMud2luLm9mZigncmVzaXplJywgdGhpcy5vblJlc2l6ZSk7XG5cdFx0XHRcdHRoaXMuZHJvcEFjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHRpZiAodGhpcy5zZWxlY3RPcGVuZWRCeUV2ZW50ID09PSAndG91Y2gnKSB7XG5cdFx0XHRcdFx0dGhpcy5vbkJsdXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dG9nZ2xlRHJvcGRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHRoaXMuZHJvcEFjdGl2ZSkge1xuXHRcdFx0XHR0aGlzLmhpZGVEcm9wZG93bigpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zaG93RHJvcGRvd24oKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlZnJlc2hTZWxlY3RlZFRleHQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gcmVkcmF3IHNlbGVjdGVkIGFyZWFcblx0XHRcdHZhciBzZWxlY3RlZEluZGV4ID0gdGhpcy5yZWFsRWxlbWVudC5wcm9wKCdzZWxlY3RlZEluZGV4JyksXG5cdFx0XHRcdHNlbGVjdGVkT3B0aW9uID0gdGhpcy5yZWFsRWxlbWVudC5wcm9wKCdvcHRpb25zJylbc2VsZWN0ZWRJbmRleF0sXG5cdFx0XHRcdHNlbGVjdGVkT3B0aW9uSW1hZ2UgPSBzZWxlY3RlZE9wdGlvbiA/IHNlbGVjdGVkT3B0aW9uLmdldEF0dHJpYnV0ZSgnZGF0YS1pbWFnZScpIDogbnVsbCxcblx0XHRcdFx0c2VsZWN0ZWRPcHRpb25UZXh0ID0gJycsXG5cdFx0XHRcdHNlbGVjdGVkT3B0aW9uQ2xhc3NlcztcblxuXHRcdFx0aWYgKHRoaXMucmVhbEVsZW1lbnQucHJvcCgnbXVsdGlwbGUnKSkge1xuXHRcdFx0XHQkLmVhY2godGhpcy5yZWFsRWxlbWVudC5wcm9wKCdvcHRpb25zJyksIGZ1bmN0aW9uKGluZGV4LCBvcHRpb24pIHtcblx0XHRcdFx0XHRpZiAob3B0aW9uLnNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0XHRzZWxlY3RlZE9wdGlvblRleHQgKz0gKHNlbGVjdGVkT3B0aW9uVGV4dCA/ICcsICcgOiAnJykgKyBvcHRpb24uaW5uZXJIVE1MO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRoaXMuc2VsZWN0VGV4dC5yZW1vdmVBdHRyKCdjbGFzcycpLmh0bWwoc2VsZWN0ZWRPcHRpb25UZXh0KTtcblx0XHRcdH0gZWxzZSBpZiAoIXNlbGVjdGVkT3B0aW9uKSB7XG5cdFx0XHRcdGlmICh0aGlzLnNlbGVjdEltYWdlKSB7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3RJbWFnZS5oaWRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5zZWxlY3RUZXh0LnJlbW92ZUF0dHIoJ2NsYXNzJykuZW1wdHkoKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5jdXJyZW50U2VsZWN0ZWRUZXh0ICE9PSBzZWxlY3RlZE9wdGlvbi5pbm5lckhUTUwgfHwgdGhpcy5jdXJyZW50U2VsZWN0ZWRJbWFnZSAhPT0gc2VsZWN0ZWRPcHRpb25JbWFnZSkge1xuXHRcdFx0XHRzZWxlY3RlZE9wdGlvbkNsYXNzZXMgPSBnZXRQcmVmaXhlZENsYXNzZXMoc2VsZWN0ZWRPcHRpb24uY2xhc3NOYW1lLCB0aGlzLm9wdGlvbnMub3B0aW9uQ2xhc3NQcmVmaXgpO1xuXHRcdFx0XHR0aGlzLnNlbGVjdFRleHQuYXR0cignY2xhc3MnLCBzZWxlY3RlZE9wdGlvbkNsYXNzZXMpLmh0bWwoc2VsZWN0ZWRPcHRpb24uaW5uZXJIVE1MKTtcblxuXHRcdFx0XHRpZiAoc2VsZWN0ZWRPcHRpb25JbWFnZSkge1xuXHRcdFx0XHRcdGlmICghdGhpcy5zZWxlY3RJbWFnZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5zZWxlY3RJbWFnZSA9ICQoJzxpbWc+JykucHJlcGVuZFRvKHRoaXMuc2VsZWN0VGV4dENvbnRhaW5lcikuaGlkZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLnNlbGVjdEltYWdlLmF0dHIoJ3NyYycsIHNlbGVjdGVkT3B0aW9uSW1hZ2UpLnNob3coKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLnNlbGVjdEltYWdlKSB7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3RJbWFnZS5oaWRlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmN1cnJlbnRTZWxlY3RlZFRleHQgPSBzZWxlY3RlZE9wdGlvbi5pbm5lckhUTUw7XG5cdFx0XHRcdHRoaXMuY3VycmVudFNlbGVjdGVkSW1hZ2UgPSBzZWxlY3RlZE9wdGlvbkltYWdlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0cmVmcmVzaDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyByZWZyZXNoIGZha2Ugc2VsZWN0IHZpc2liaWxpdHlcblx0XHRcdGlmICh0aGlzLnJlYWxFbGVtZW50LnByb3AoJ3N0eWxlJykuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG5cdFx0XHRcdHRoaXMuZmFrZUVsZW1lbnQuaGlkZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5mYWtlRWxlbWVudC5zaG93KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlZnJlc2ggc2VsZWN0ZWQgdGV4dFxuXHRcdFx0dGhpcy5yZWZyZXNoU2VsZWN0ZWRUZXh0KCk7XG5cblx0XHRcdC8vIGhhbmRsZSBkaXNhYmxlZCBzdGF0ZVxuXHRcdFx0dGhpcy5mYWtlRWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLm9wdGlvbnMuZGlzYWJsZWRDbGFzcywgdGhpcy5yZWFsRWxlbWVudC5pcygnOmRpc2FibGVkJykpO1xuXHRcdH0sXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyByZXN0b3JlIHN0cnVjdHVyZVxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy53cmFwTmF0aXZlKSB7XG5cdFx0XHRcdHRoaXMucmVhbEVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRoaXMuZmFrZUVsZW1lbnQpLmNzcyh7XG5cdFx0XHRcdFx0cG9zaXRpb246ICcnLFxuXHRcdFx0XHRcdGhlaWdodDogJycsXG5cdFx0XHRcdFx0d2lkdGg6ICcnXG5cdFx0XHRcdH0pLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5yZXNldEFwcGVhcmFuY2VDbGFzcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnJlYWxFbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5oaWRkZW5DbGFzcyk7XG5cdFx0XHRcdGlmICh0aGlzLnJlYWxFbGVtZW50LmlzKCdbamNmLXNpemVdJykpIHtcblx0XHRcdFx0XHR0aGlzLnJlYWxFbGVtZW50LnJlbW92ZUF0dHIoJ3NpemUgamNmLXNpemUnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZW1vdmluZyBlbGVtZW50IHdpbGwgYWxzbyByZW1vdmUgaXRzIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHR0aGlzLmZha2VFbGVtZW50LnJlbW92ZSgpO1xuXG5cdFx0XHQvLyByZW1vdmUgb3RoZXIgZXZlbnQgaGFuZGxlcnNcblx0XHRcdHRoaXMuZG9jLm9mZignamNmLXBvaW50ZXJ1cCcsIHRoaXMub25TZWxlY3RBcmVhUmVsZWFzZSk7XG5cdFx0XHR0aGlzLnJlYWxFbGVtZW50Lm9mZih7XG5cdFx0XHRcdGZvY3VzOiB0aGlzLm9uRm9jdXNcblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gbGlzdGJveCBtb2R1bGVcblx0ZnVuY3Rpb24gTGlzdEJveChvcHRpb25zKSB7XG5cdFx0dGhpcy5vcHRpb25zID0gJC5leHRlbmQoe1xuXHRcdFx0d3JhcE5hdGl2ZTogdHJ1ZSxcblx0XHRcdHVzZUN1c3RvbVNjcm9sbDogdHJ1ZSxcblx0XHRcdGZha2VTdHJ1Y3R1cmU6ICc8c3BhbiBjbGFzcz1cImpjZi1saXN0LWJveFwiPjxzcGFuIGNsYXNzPVwiamNmLWxpc3Qtd3JhcHBlclwiPjwvc3Bhbj48L3NwYW4+Jyxcblx0XHRcdHNlbGVjdENsYXNzUHJlZml4OiAnamNmLXNlbGVjdC0nLFxuXHRcdFx0bGlzdEhvbGRlcjogJy5qY2YtbGlzdC13cmFwcGVyJ1xuXHRcdH0sIG9wdGlvbnMpO1xuXHRcdHRoaXMuaW5pdCgpO1xuXHR9XG5cdCQuZXh0ZW5kKExpc3RCb3gucHJvdG90eXBlLCB7XG5cdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmJpbmRIYW5kbGVycygpO1xuXHRcdFx0dGhpcy5pbml0U3RydWN0dXJlKCk7XG5cdFx0XHR0aGlzLmF0dGFjaEV2ZW50cygpO1xuXHRcdH0sXG5cdFx0aW5pdFN0cnVjdHVyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnJlYWxFbGVtZW50ID0gJCh0aGlzLm9wdGlvbnMuZWxlbWVudCk7XG5cdFx0XHR0aGlzLmZha2VFbGVtZW50ID0gJCh0aGlzLm9wdGlvbnMuZmFrZVN0cnVjdHVyZSkuaW5zZXJ0QWZ0ZXIodGhpcy5yZWFsRWxlbWVudCk7XG5cdFx0XHR0aGlzLmxpc3RIb2xkZXIgPSB0aGlzLmZha2VFbGVtZW50LmZpbmQodGhpcy5vcHRpb25zLmxpc3RIb2xkZXIpO1xuXHRcdFx0bWFrZVVuc2VsZWN0YWJsZSh0aGlzLmZha2VFbGVtZW50KTtcblxuXHRcdFx0Ly8gY29weSBjbGFzc2VzIGZyb20gb3JpZ2luYWwgc2VsZWN0XG5cdFx0XHR0aGlzLmZha2VFbGVtZW50LmFkZENsYXNzKGdldFByZWZpeGVkQ2xhc3Nlcyh0aGlzLnJlYWxFbGVtZW50LnByb3AoJ2NsYXNzTmFtZScpLCB0aGlzLm9wdGlvbnMuc2VsZWN0Q2xhc3NQcmVmaXgpKTtcblx0XHRcdHRoaXMucmVhbEVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmhpZGRlbkNsYXNzKTtcblxuXHRcdFx0dGhpcy5saXN0ID0gbmV3IFNlbGVjdExpc3Qoe1xuXHRcdFx0XHR1c2VDdXN0b21TY3JvbGw6IHRoaXMub3B0aW9ucy51c2VDdXN0b21TY3JvbGwsXG5cdFx0XHRcdGhvbGRlcjogdGhpcy5saXN0SG9sZGVyLFxuXHRcdFx0XHRzZWxlY3RPbkNsaWNrOiBmYWxzZSxcblx0XHRcdFx0ZWxlbWVudDogdGhpcy5yZWFsRWxlbWVudFxuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRhdHRhY2hFdmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gZGVsYXllZCByZWZyZXNoIGhhbmRsZXJcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHRoaXMuZGVsYXllZFJlZnJlc2ggPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdGlmIChlICYmIGUud2hpY2ggPT09IDE2KSB7XG5cdFx0XHRcdFx0Ly8gaWdub3JlIFNISUZUIGtleVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQoc2VsZi5yZWZyZXNoVGltZXIpO1xuXHRcdFx0XHRcdHNlbGYucmVmcmVzaFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHNlbGYucmVmcmVzaCgpO1xuXHRcdFx0XHRcdH0sIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBvdGhlciBldmVudCBoYW5kbGVyc1xuXHRcdFx0dGhpcy5yZWFsRWxlbWVudC5vbih7XG5cdFx0XHRcdGZvY3VzOiB0aGlzLm9uRm9jdXMsXG5cdFx0XHRcdGNsaWNrOiB0aGlzLmRlbGF5ZWRSZWZyZXNoLFxuXHRcdFx0XHRrZXlkb3duOiB0aGlzLmRlbGF5ZWRSZWZyZXNoXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gc2VsZWN0IGxpc3QgZXZlbnQgaGFuZGxlcnNcblx0XHRcdCQodGhpcy5saXN0KS5vbih7XG5cdFx0XHRcdHNlbGVjdDogdGhpcy5vblNlbGVjdCxcblx0XHRcdFx0cHJlc3M6IHRoaXMub25GYWtlT3B0aW9uc1ByZXNzLFxuXHRcdFx0XHRyZWxlYXNlOiB0aGlzLm9uRmFrZU9wdGlvbnNSZWxlYXNlXG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdG9uRmFrZU9wdGlvbnNQcmVzczogZnVuY3Rpb24oZSwgcG9pbnRlckV2ZW50KSB7XG5cdFx0XHR0aGlzLnByZXNzZWRGbGFnID0gdHJ1ZTtcblx0XHRcdGlmIChwb2ludGVyRXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHtcblx0XHRcdFx0dGhpcy5yZWFsRWxlbWVudC5mb2N1cygpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0b25GYWtlT3B0aW9uc1JlbGVhc2U6IGZ1bmN0aW9uKGUsIHBvaW50ZXJFdmVudCkge1xuXHRcdFx0dGhpcy5wcmVzc2VkRmxhZyA9IGZhbHNlO1xuXHRcdFx0aWYgKHBvaW50ZXJFdmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykge1xuXHRcdFx0XHR0aGlzLnJlYWxFbGVtZW50LmZvY3VzKCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvblNlbGVjdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmZpcmVOYXRpdmVFdmVudCh0aGlzLnJlYWxFbGVtZW50LCAnY2hhbmdlJyk7XG5cdFx0XHR0aGlzLmZpcmVOYXRpdmVFdmVudCh0aGlzLnJlYWxFbGVtZW50LCAnY2xpY2snKTtcblx0XHR9LFxuXHRcdG9uRm9jdXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCF0aGlzLnByZXNzZWRGbGFnIHx8ICF0aGlzLmZvY3VzZWRGbGFnKSB7XG5cdFx0XHRcdHRoaXMuZmFrZUVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmZvY3VzQ2xhc3MpO1xuXHRcdFx0XHR0aGlzLnJlYWxFbGVtZW50Lm9uKCdibHVyJywgdGhpcy5vbkJsdXIpO1xuXHRcdFx0XHR0aGlzLmZvY3VzZWRGbGFnID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9uQmx1cjogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIXRoaXMucHJlc3NlZEZsYWcpIHtcblx0XHRcdFx0dGhpcy5mYWtlRWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZm9jdXNDbGFzcyk7XG5cdFx0XHRcdHRoaXMucmVhbEVsZW1lbnQub2ZmKCdibHVyJywgdGhpcy5vbkJsdXIpO1xuXHRcdFx0XHR0aGlzLmZvY3VzZWRGbGFnID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuZmFrZUVsZW1lbnQudG9nZ2xlQ2xhc3ModGhpcy5vcHRpb25zLmRpc2FibGVkQ2xhc3MsIHRoaXMucmVhbEVsZW1lbnQuaXMoJzpkaXNhYmxlZCcpKTtcblx0XHRcdHRoaXMubGlzdC5yZWZyZXNoKCk7XG5cdFx0fSxcblx0XHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMubGlzdC5kZXN0cm95KCk7XG5cdFx0XHR0aGlzLnJlYWxFbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLmZha2VFbGVtZW50KS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuaGlkZGVuQ2xhc3MpO1xuXHRcdFx0dGhpcy5mYWtlRWxlbWVudC5yZW1vdmUoKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIG9wdGlvbnMgbGlzdCBtb2R1bGVcblx0ZnVuY3Rpb24gU2VsZWN0TGlzdChvcHRpb25zKSB7XG5cdFx0dGhpcy5vcHRpb25zID0gJC5leHRlbmQoe1xuXHRcdFx0aG9sZGVyOiBudWxsLFxuXHRcdFx0bWF4VmlzaWJsZUl0ZW1zOiAxMCxcblx0XHRcdHNlbGVjdE9uQ2xpY2s6IHRydWUsXG5cdFx0XHR1c2VIb3ZlckNsYXNzOiBmYWxzZSxcblx0XHRcdHVzZUN1c3RvbVNjcm9sbDogZmFsc2UsXG5cdFx0XHRoYW5kbGVSZXNpemU6IHRydWUsXG5cdFx0XHRtdWx0aXBsZVNlbGVjdFdpdGhvdXRLZXk6IGZhbHNlLFxuXHRcdFx0YWx3YXlzUHJldmVudE1vdXNlV2hlZWw6IGZhbHNlLFxuXHRcdFx0aW5kZXhBdHRyaWJ1dGU6ICdkYXRhLWluZGV4Jyxcblx0XHRcdGNsb25lQ2xhc3NQcmVmaXg6ICdqY2Ytb3B0aW9uLScsXG5cdFx0XHRjb250YWluZXJTdHJ1Y3R1cmU6ICc8c3BhbiBjbGFzcz1cImpjZi1saXN0XCI+PHNwYW4gY2xhc3M9XCJqY2YtbGlzdC1jb250ZW50XCI+PC9zcGFuPjwvc3Bhbj4nLFxuXHRcdFx0Y29udGFpbmVyU2VsZWN0b3I6ICcuamNmLWxpc3QtY29udGVudCcsXG5cdFx0XHRjYXB0aW9uQ2xhc3M6ICdqY2Ytb3B0Z3JvdXAtY2FwdGlvbicsXG5cdFx0XHRkaXNhYmxlZENsYXNzOiAnamNmLWRpc2FibGVkJyxcblx0XHRcdG9wdGlvbkNsYXNzOiAnamNmLW9wdGlvbicsXG5cdFx0XHRncm91cENsYXNzOiAnamNmLW9wdGdyb3VwJyxcblx0XHRcdGhvdmVyQ2xhc3M6ICdqY2YtaG92ZXInLFxuXHRcdFx0c2VsZWN0ZWRDbGFzczogJ2pjZi1zZWxlY3RlZCcsXG5cdFx0XHRzY3JvbGxDbGFzczogJ2pjZi1zY3JvbGwtYWN0aXZlJ1xuXHRcdH0sIG9wdGlvbnMpO1xuXHRcdHRoaXMuaW5pdCgpO1xuXHR9XG5cdCQuZXh0ZW5kKFNlbGVjdExpc3QucHJvdG90eXBlLCB7XG5cdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmluaXRTdHJ1Y3R1cmUoKTtcblx0XHRcdHRoaXMucmVmcmVzaFNlbGVjdGVkQ2xhc3MoKTtcblx0XHRcdHRoaXMuYXR0YWNoRXZlbnRzKCk7XG5cdFx0fSxcblx0XHRpbml0U3RydWN0dXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuZWxlbWVudCA9ICQodGhpcy5vcHRpb25zLmVsZW1lbnQpO1xuXHRcdFx0dGhpcy5pbmRleFNlbGVjdG9yID0gJ1snICsgdGhpcy5vcHRpb25zLmluZGV4QXR0cmlidXRlICsgJ10nO1xuXHRcdFx0dGhpcy5jb250YWluZXIgPSAkKHRoaXMub3B0aW9ucy5jb250YWluZXJTdHJ1Y3R1cmUpLmFwcGVuZFRvKHRoaXMub3B0aW9ucy5ob2xkZXIpO1xuXHRcdFx0dGhpcy5saXN0SG9sZGVyID0gdGhpcy5jb250YWluZXIuZmluZCh0aGlzLm9wdGlvbnMuY29udGFpbmVyU2VsZWN0b3IpO1xuXHRcdFx0dGhpcy5sYXN0Q2xpY2tlZEluZGV4ID0gdGhpcy5lbGVtZW50LnByb3AoJ3NlbGVjdGVkSW5kZXgnKTtcblx0XHRcdHRoaXMucmVidWlsZExpc3QoKTtcblx0XHR9LFxuXHRcdGF0dGFjaEV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmJpbmRIYW5kbGVycygpO1xuXHRcdFx0dGhpcy5saXN0SG9sZGVyLm9uKCdqY2YtcG9pbnRlcmRvd24nLCB0aGlzLmluZGV4U2VsZWN0b3IsIHRoaXMub25JdGVtUHJlc3MpO1xuXHRcdFx0dGhpcy5saXN0SG9sZGVyLm9uKCdqY2YtcG9pbnRlcmRvd24nLCB0aGlzLm9uUHJlc3MpO1xuXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnVzZUhvdmVyQ2xhc3MpIHtcblx0XHRcdFx0dGhpcy5saXN0SG9sZGVyLm9uKCdqY2YtcG9pbnRlcm92ZXInLCB0aGlzLmluZGV4U2VsZWN0b3IsIHRoaXMub25Ib3Zlckl0ZW0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0b25QcmVzczogZnVuY3Rpb24oZSkge1xuXHRcdFx0JCh0aGlzKS50cmlnZ2VyKCdwcmVzcycsIGUpO1xuXHRcdFx0dGhpcy5saXN0SG9sZGVyLm9uKCdqY2YtcG9pbnRlcnVwJywgdGhpcy5vblJlbGVhc2UpO1xuXHRcdH0sXG5cdFx0b25SZWxlYXNlOiBmdW5jdGlvbihlKSB7XG5cdFx0XHQkKHRoaXMpLnRyaWdnZXIoJ3JlbGVhc2UnLCBlKTtcblx0XHRcdHRoaXMubGlzdEhvbGRlci5vZmYoJ2pjZi1wb2ludGVydXAnLCB0aGlzLm9uUmVsZWFzZSk7XG5cdFx0fSxcblx0XHRvbkhvdmVySXRlbTogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIGhvdmVySW5kZXggPSBwYXJzZUZsb2F0KGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUodGhpcy5vcHRpb25zLmluZGV4QXR0cmlidXRlKSk7XG5cdFx0XHR0aGlzLmZha2VPcHRpb25zLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5ob3ZlckNsYXNzKS5lcShob3ZlckluZGV4KS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuaG92ZXJDbGFzcyk7XG5cdFx0fSxcblx0XHRvbkl0ZW1QcmVzczogZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYgKGUucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgfHwgdGhpcy5vcHRpb25zLnNlbGVjdE9uQ2xpY2spIHtcblx0XHRcdFx0Ly8gc2VsZWN0IG9wdGlvbiBhZnRlciBcImNsaWNrXCJcblx0XHRcdFx0dGhpcy50bXBMaXN0T2Zmc2V0VG9wID0gdGhpcy5saXN0Lm9mZnNldCgpLnRvcDtcblx0XHRcdFx0dGhpcy5saXN0SG9sZGVyLm9uKCdqY2YtcG9pbnRlcnVwJywgdGhpcy5pbmRleFNlbGVjdG9yLCB0aGlzLm9uSXRlbVJlbGVhc2UpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gc2VsZWN0IG9wdGlvbiBpbW1lZGlhdGVseVxuXHRcdFx0XHR0aGlzLm9uU2VsZWN0SXRlbShlKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9uSXRlbVJlbGVhc2U6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdC8vIHJlbW92ZSBldmVudCBoYW5kbGVycyBhbmQgdGVtcG9yYXJ5IGRhdGFcblx0XHRcdHRoaXMubGlzdEhvbGRlci5vZmYoJ2pjZi1wb2ludGVydXAnLCB0aGlzLmluZGV4U2VsZWN0b3IsIHRoaXMub25JdGVtUmVsZWFzZSk7XG5cblx0XHRcdC8vIHNpbXVsYXRlIGl0ZW0gc2VsZWN0aW9uXG5cdFx0XHRpZiAodGhpcy50bXBMaXN0T2Zmc2V0VG9wID09PSB0aGlzLmxpc3Qub2Zmc2V0KCkudG9wKSB7XG5cdFx0XHRcdHRoaXMubGlzdEhvbGRlci5vbignY2xpY2snLCB0aGlzLmluZGV4U2VsZWN0b3IsIHsgc2F2ZWRQb2ludGVyVHlwZTogZS5wb2ludGVyVHlwZSB9LCB0aGlzLm9uU2VsZWN0SXRlbSk7XG5cdFx0XHR9XG5cdFx0XHRkZWxldGUgdGhpcy50bXBMaXN0T2Zmc2V0VG9wO1xuXHRcdH0sXG5cdFx0b25TZWxlY3RJdGVtOiBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgY2xpY2tlZEluZGV4ID0gcGFyc2VGbG9hdChlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKHRoaXMub3B0aW9ucy5pbmRleEF0dHJpYnV0ZSkpLFxuXHRcdFx0XHRwb2ludGVyVHlwZSA9IGUuZGF0YSAmJiBlLmRhdGEuc2F2ZWRQb2ludGVyVHlwZSB8fCBlLnBvaW50ZXJUeXBlIHx8ICdtb3VzZScsXG5cdFx0XHRcdHJhbmdlO1xuXG5cdFx0XHQvLyByZW1vdmUgY2xpY2sgZXZlbnQgaGFuZGxlclxuXHRcdFx0dGhpcy5saXN0SG9sZGVyLm9mZignY2xpY2snLCB0aGlzLmluZGV4U2VsZWN0b3IsIHRoaXMub25TZWxlY3RJdGVtKTtcblxuXHRcdFx0Ly8gaWdub3JlIGNsaWNrcyBvbiBkaXNhYmxlZCBvcHRpb25zXG5cdFx0XHRpZiAoZS5idXR0b24gPiAxIHx8IHRoaXMucmVhbE9wdGlvbnNbY2xpY2tlZEluZGV4XS5kaXNhYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmVsZW1lbnQucHJvcCgnbXVsdGlwbGUnKSkge1xuXHRcdFx0XHRpZiAoZS5tZXRhS2V5IHx8IGUuY3RybEtleSB8fCBwb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyB8fCB0aGlzLm9wdGlvbnMubXVsdGlwbGVTZWxlY3RXaXRob3V0S2V5KSB7XG5cdFx0XHRcdFx0Ly8gaWYgQ1RSTC9DTUQgcHJlc3NlZCBvciB0b3VjaCBkZXZpY2VzIC0gdG9nZ2xlIHNlbGVjdGVkIG9wdGlvblxuXHRcdFx0XHRcdHRoaXMucmVhbE9wdGlvbnNbY2xpY2tlZEluZGV4XS5zZWxlY3RlZCA9ICF0aGlzLnJlYWxPcHRpb25zW2NsaWNrZWRJbmRleF0uc2VsZWN0ZWQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZS5zaGlmdEtleSkge1xuXHRcdFx0XHRcdC8vIGlmIFNISUZUIHByZXNzZWQgLSB1cGRhdGUgc2VsZWN0aW9uXG5cdFx0XHRcdFx0cmFuZ2UgPSBbdGhpcy5sYXN0Q2xpY2tlZEluZGV4LCBjbGlja2VkSW5kZXhdLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGEgLSBiO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHRoaXMucmVhbE9wdGlvbnMuZWFjaChmdW5jdGlvbihpbmRleCwgb3B0aW9uKSB7XG5cdFx0XHRcdFx0XHRvcHRpb24uc2VsZWN0ZWQgPSAoaW5kZXggPj0gcmFuZ2VbMF0gJiYgaW5kZXggPD0gcmFuZ2VbMV0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHNldCBzaW5nbGUgc2VsZWN0ZWQgaW5kZXhcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnQucHJvcCgnc2VsZWN0ZWRJbmRleCcsIGNsaWNrZWRJbmRleCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5wcm9wKCdzZWxlY3RlZEluZGV4JywgY2xpY2tlZEluZGV4KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gc2F2ZSBsYXN0IGNsaWNrZWQgb3B0aW9uXG5cdFx0XHRpZiAoIWUuc2hpZnRLZXkpIHtcblx0XHRcdFx0dGhpcy5sYXN0Q2xpY2tlZEluZGV4ID0gY2xpY2tlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyByZWZyZXNoIGNsYXNzZXNcblx0XHRcdHRoaXMucmVmcmVzaFNlbGVjdGVkQ2xhc3MoKTtcblxuXHRcdFx0Ly8gc2Nyb2xsIHRvIGFjdGl2ZSBpdGVtIGluIGRlc2t0b3AgYnJvd3NlcnNcblx0XHRcdGlmIChwb2ludGVyVHlwZSA9PT0gJ21vdXNlJykge1xuXHRcdFx0XHR0aGlzLnNjcm9sbFRvQWN0aXZlT3B0aW9uKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIG1ha2UgY2FsbGJhY2sgd2hlbiBpdGVtIHNlbGVjdGVkXG5cdFx0XHQkKHRoaXMpLnRyaWdnZXIoJ3NlbGVjdCcpO1xuXHRcdH0sXG5cdFx0cmVidWlsZExpc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gcmVidWlsZCBvcHRpb25zXG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRcdHJvb3RFbGVtZW50ID0gdGhpcy5lbGVtZW50WzBdO1xuXG5cdFx0XHQvLyByZWN1cnNpdmVseSBjcmVhdGUgZmFrZSBvcHRpb25zXG5cdFx0XHR0aGlzLnN0b3JlZFNlbGVjdEhUTUwgPSByb290RWxlbWVudC5pbm5lckhUTUw7XG5cdFx0XHR0aGlzLm9wdGlvbkluZGV4ID0gMDtcblx0XHRcdHRoaXMubGlzdCA9ICQodGhpcy5jcmVhdGVPcHRpb25zTGlzdChyb290RWxlbWVudCkpO1xuXHRcdFx0dGhpcy5saXN0SG9sZGVyLmVtcHR5KCkuYXBwZW5kKHRoaXMubGlzdCk7XG5cdFx0XHR0aGlzLnJlYWxPcHRpb25zID0gdGhpcy5lbGVtZW50LmZpbmQoJ29wdGlvbicpO1xuXHRcdFx0dGhpcy5mYWtlT3B0aW9ucyA9IHRoaXMubGlzdC5maW5kKHRoaXMuaW5kZXhTZWxlY3Rvcik7XG5cdFx0XHR0aGlzLmZha2VMaXN0SXRlbXMgPSB0aGlzLmxpc3QuZmluZCgnLicgKyB0aGlzLm9wdGlvbnMuY2FwdGlvbkNsYXNzICsgJywnICsgdGhpcy5pbmRleFNlbGVjdG9yKTtcblx0XHRcdGRlbGV0ZSB0aGlzLm9wdGlvbkluZGV4O1xuXG5cdFx0XHQvLyBkZXRlY3QgbWF4IHZpc2libGUgaXRlbXNcblx0XHRcdHZhciBtYXhDb3VudCA9IHRoaXMub3B0aW9ucy5tYXhWaXNpYmxlSXRlbXMsXG5cdFx0XHRcdHNpemVWYWx1ZSA9IHRoaXMuZWxlbWVudC5wcm9wKCdzaXplJyk7XG5cdFx0XHRpZiAoc2l6ZVZhbHVlID4gMSAmJiAhdGhpcy5lbGVtZW50LmlzKCdbamNmLXNpemVdJykpIHtcblx0XHRcdFx0bWF4Q291bnQgPSBzaXplVmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGhhbmRsZSBzY3JvbGxiYXJcblx0XHRcdHZhciBuZWVkU2Nyb2xsQmFyID0gdGhpcy5mYWtlT3B0aW9ucy5sZW5ndGggPiBtYXhDb3VudDtcblx0XHRcdHRoaXMuY29udGFpbmVyLnRvZ2dsZUNsYXNzKHRoaXMub3B0aW9ucy5zY3JvbGxDbGFzcywgbmVlZFNjcm9sbEJhcik7XG5cdFx0XHRpZiAobmVlZFNjcm9sbEJhcikge1xuXHRcdFx0XHQvLyBjaGFuZ2UgbWF4LWhlaWdodFxuXHRcdFx0XHR0aGlzLmxpc3RIb2xkZXIuY3NzKHtcblx0XHRcdFx0XHRtYXhIZWlnaHQ6IHRoaXMuZ2V0T3ZlcmZsb3dIZWlnaHQobWF4Q291bnQpLFxuXHRcdFx0XHRcdG92ZXJmbG93OiAnYXV0bydcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy51c2VDdXN0b21TY3JvbGwgJiYgamNmLm1vZHVsZXMuU2Nyb2xsYWJsZSkge1xuXHRcdFx0XHRcdC8vIGFkZCBjdXN0b20gc2Nyb2xsYmFyIGlmIHNwZWNpZmllZCBpbiBvcHRpb25zXG5cdFx0XHRcdFx0amNmLnJlcGxhY2UodGhpcy5saXN0SG9sZGVyLCAnU2Nyb2xsYWJsZScsIHtcblx0XHRcdFx0XHRcdGhhbmRsZVJlc2l6ZTogdGhpcy5vcHRpb25zLmhhbmRsZVJlc2l6ZSxcblx0XHRcdFx0XHRcdGFsd2F5c1ByZXZlbnRNb3VzZVdoZWVsOiB0aGlzLm9wdGlvbnMuYWx3YXlzUHJldmVudE1vdXNlV2hlZWxcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gZGlzYWJsZSBlZGdlIHdoZWVsIHNjcm9sbGluZ1xuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5hbHdheXNQcmV2ZW50TW91c2VXaGVlbCkge1xuXHRcdFx0XHR0aGlzLnByZXZlbnRXaGVlbEhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0dmFyIGN1cnJlbnRTY3JvbGxUb3AgPSBzZWxmLmxpc3RIb2xkZXIuc2Nyb2xsVG9wKCksXG5cdFx0XHRcdFx0XHRtYXhTY3JvbGxUb3AgPSBzZWxmLmxpc3RIb2xkZXIucHJvcCgnc2Nyb2xsSGVpZ2h0JykgLSBzZWxmLmxpc3RIb2xkZXIuaW5uZXJIZWlnaHQoKTtcblxuXHRcdFx0XHRcdC8vIGNoZWNrIGVkZ2UgY2FzZXNcblx0XHRcdFx0XHRpZiAoKGN1cnJlbnRTY3JvbGxUb3AgPD0gMCAmJiBlLmRlbHRhWSA8IDApIHx8IChjdXJyZW50U2Nyb2xsVG9wID49IG1heFNjcm9sbFRvcCAmJiBlLmRlbHRhWSA+IDApKSB7XG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0XHR0aGlzLmxpc3RIb2xkZXIub24oJ2pjZi1tb3VzZXdoZWVsJywgdGhpcy5wcmV2ZW50V2hlZWxIYW5kbGVyKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlZnJlc2hTZWxlY3RlZENsYXNzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdFx0c2VsZWN0ZWRJdGVtLFxuXHRcdFx0XHRpc011bHRpcGxlID0gdGhpcy5lbGVtZW50LnByb3AoJ211bHRpcGxlJyksXG5cdFx0XHRcdHNlbGVjdGVkSW5kZXggPSB0aGlzLmVsZW1lbnQucHJvcCgnc2VsZWN0ZWRJbmRleCcpO1xuXG5cdFx0XHRpZiAoaXNNdWx0aXBsZSkge1xuXHRcdFx0XHR0aGlzLnJlYWxPcHRpb25zLmVhY2goZnVuY3Rpb24oaW5kZXgsIG9wdGlvbikge1xuXHRcdFx0XHRcdHNlbGYuZmFrZU9wdGlvbnMuZXEoaW5kZXgpLnRvZ2dsZUNsYXNzKHNlbGYub3B0aW9ucy5zZWxlY3RlZENsYXNzLCAhIW9wdGlvbi5zZWxlY3RlZCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5mYWtlT3B0aW9ucy5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcyArICcgJyArIHRoaXMub3B0aW9ucy5ob3ZlckNsYXNzKTtcblx0XHRcdFx0c2VsZWN0ZWRJdGVtID0gdGhpcy5mYWtlT3B0aW9ucy5lcShzZWxlY3RlZEluZGV4KS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcyk7XG5cdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMudXNlSG92ZXJDbGFzcykge1xuXHRcdFx0XHRcdHNlbGVjdGVkSXRlbS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuaG92ZXJDbGFzcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHNjcm9sbFRvQWN0aXZlT3B0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIHNjcm9sbCB0byB0YXJnZXQgb3B0aW9uXG5cdFx0XHR2YXIgdGFyZ2V0T2Zmc2V0ID0gdGhpcy5nZXRBY3RpdmVPcHRpb25PZmZzZXQoKTtcblx0XHRcdHRoaXMubGlzdEhvbGRlci5wcm9wKCdzY3JvbGxUb3AnLCB0YXJnZXRPZmZzZXQpO1xuXHRcdH0sXG5cdFx0Z2V0U2VsZWN0ZWRJbmRleFJhbmdlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBmaXJzdFNlbGVjdGVkID0gLTEsIGxhc3RTZWxlY3RlZCA9IC0xO1xuXHRcdFx0dGhpcy5yZWFsT3B0aW9ucy5lYWNoKGZ1bmN0aW9uKGluZGV4LCBvcHRpb24pIHtcblx0XHRcdFx0aWYgKG9wdGlvbi5zZWxlY3RlZCkge1xuXHRcdFx0XHRcdGlmIChmaXJzdFNlbGVjdGVkIDwgMCkge1xuXHRcdFx0XHRcdFx0Zmlyc3RTZWxlY3RlZCA9IGluZGV4O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsYXN0U2VsZWN0ZWQgPSBpbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gW2ZpcnN0U2VsZWN0ZWQsIGxhc3RTZWxlY3RlZF07XG5cdFx0fSxcblx0XHRnZXRDaGFuZ2VkU2VsZWN0ZWRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZWN0ZWRJbmRleCA9IHRoaXMuZWxlbWVudC5wcm9wKCdzZWxlY3RlZEluZGV4JyksXG5cdFx0XHRcdHRhcmdldEluZGV4O1xuXG5cdFx0XHRpZiAodGhpcy5lbGVtZW50LnByb3AoJ211bHRpcGxlJykpIHtcblx0XHRcdFx0Ly8gbXVsdGlwbGUgc2VsZWN0cyBoYW5kbGluZ1xuXHRcdFx0XHRpZiAoIXRoaXMucHJldmlvdXNSYW5nZSkge1xuXHRcdFx0XHRcdHRoaXMucHJldmlvdXNSYW5nZSA9IFtzZWxlY3RlZEluZGV4LCBzZWxlY3RlZEluZGV4XTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmN1cnJlbnRSYW5nZSA9IHRoaXMuZ2V0U2VsZWN0ZWRJbmRleFJhbmdlKCk7XG5cdFx0XHRcdHRhcmdldEluZGV4ID0gdGhpcy5jdXJyZW50UmFuZ2VbdGhpcy5jdXJyZW50UmFuZ2VbMF0gIT09IHRoaXMucHJldmlvdXNSYW5nZVswXSA/IDAgOiAxXTtcblx0XHRcdFx0dGhpcy5wcmV2aW91c1JhbmdlID0gdGhpcy5jdXJyZW50UmFuZ2U7XG5cdFx0XHRcdHJldHVybiB0YXJnZXRJbmRleDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHNpbmdsZSBjaG9pY2Ugc2VsZWN0cyBoYW5kbGluZ1xuXHRcdFx0XHRyZXR1cm4gc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGdldEFjdGl2ZU9wdGlvbk9mZnNldDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBjYWxjIHZhbHVlc1xuXHRcdFx0dmFyIGRyb3BIZWlnaHQgPSB0aGlzLmxpc3RIb2xkZXIuaGVpZ2h0KCksXG5cdFx0XHRcdGRyb3BTY3JvbGxUb3AgPSB0aGlzLmxpc3RIb2xkZXIucHJvcCgnc2Nyb2xsVG9wJyksXG5cdFx0XHRcdGN1cnJlbnRJbmRleCA9IHRoaXMuZ2V0Q2hhbmdlZFNlbGVjdGVkSW5kZXgoKSxcblx0XHRcdFx0ZmFrZU9wdGlvbiA9IHRoaXMuZmFrZU9wdGlvbnMuZXEoY3VycmVudEluZGV4KSxcblx0XHRcdFx0ZmFrZU9wdGlvbk9mZnNldCA9IGZha2VPcHRpb24ub2Zmc2V0KCkudG9wIC0gdGhpcy5saXN0Lm9mZnNldCgpLnRvcCxcblx0XHRcdFx0ZmFrZU9wdGlvbkhlaWdodCA9IGZha2VPcHRpb24uaW5uZXJIZWlnaHQoKTtcblxuXHRcdFx0Ly8gc2Nyb2xsIGxpc3Rcblx0XHRcdGlmIChmYWtlT3B0aW9uT2Zmc2V0ICsgZmFrZU9wdGlvbkhlaWdodCA+PSBkcm9wU2Nyb2xsVG9wICsgZHJvcEhlaWdodCkge1xuXHRcdFx0XHQvLyBzY3JvbGwgZG93biAoYWx3YXlzIHNjcm9sbCB0byBvcHRpb24pXG5cdFx0XHRcdHJldHVybiBmYWtlT3B0aW9uT2Zmc2V0IC0gZHJvcEhlaWdodCArIGZha2VPcHRpb25IZWlnaHQ7XG5cdFx0XHR9IGVsc2UgaWYgKGZha2VPcHRpb25PZmZzZXQgPCBkcm9wU2Nyb2xsVG9wKSB7XG5cdFx0XHRcdC8vIHNjcm9sbCB1cCB0byBvcHRpb25cblx0XHRcdFx0cmV0dXJuIGZha2VPcHRpb25PZmZzZXQ7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRnZXRPdmVyZmxvd0hlaWdodDogZnVuY3Rpb24oc2l6ZVZhbHVlKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHRoaXMuZmFrZUxpc3RJdGVtcy5lcShzaXplVmFsdWUgLSAxKSxcblx0XHRcdFx0bGlzdE9mZnNldCA9IHRoaXMubGlzdC5vZmZzZXQoKS50b3AsXG5cdFx0XHRcdGl0ZW1PZmZzZXQgPSBpdGVtLm9mZnNldCgpLnRvcCxcblx0XHRcdFx0aXRlbUhlaWdodCA9IGl0ZW0uaW5uZXJIZWlnaHQoKTtcblxuXHRcdFx0cmV0dXJuIGl0ZW1PZmZzZXQgKyBpdGVtSGVpZ2h0IC0gbGlzdE9mZnNldDtcblx0XHR9LFxuXHRcdGdldFNjcm9sbFRvcDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5saXN0SG9sZGVyLnNjcm9sbFRvcCgpO1xuXHRcdH0sXG5cdFx0c2V0U2Nyb2xsVG9wOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dGhpcy5saXN0SG9sZGVyLnNjcm9sbFRvcCh2YWx1ZSk7XG5cdFx0fSxcblx0XHRjcmVhdGVPcHRpb246IGZ1bmN0aW9uKG9wdGlvbikge1xuXHRcdFx0dmFyIG5ld09wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcblx0XHRcdG5ld09wdGlvbi5jbGFzc05hbWUgPSB0aGlzLm9wdGlvbnMub3B0aW9uQ2xhc3M7XG5cdFx0XHRuZXdPcHRpb24uaW5uZXJIVE1MID0gb3B0aW9uLmlubmVySFRNTDtcblx0XHRcdG5ld09wdGlvbi5zZXRBdHRyaWJ1dGUodGhpcy5vcHRpb25zLmluZGV4QXR0cmlidXRlLCB0aGlzLm9wdGlvbkluZGV4KyspO1xuXG5cdFx0XHR2YXIgb3B0aW9uSW1hZ2UsIG9wdGlvbkltYWdlU3JjID0gb3B0aW9uLmdldEF0dHJpYnV0ZSgnZGF0YS1pbWFnZScpO1xuXHRcdFx0aWYgKG9wdGlvbkltYWdlU3JjKSB7XG5cdFx0XHRcdG9wdGlvbkltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG5cdFx0XHRcdG9wdGlvbkltYWdlLnNyYyA9IG9wdGlvbkltYWdlU3JjO1xuXHRcdFx0XHRuZXdPcHRpb24uaW5zZXJ0QmVmb3JlKG9wdGlvbkltYWdlLCBuZXdPcHRpb24uY2hpbGROb2Rlc1swXSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAob3B0aW9uLmRpc2FibGVkKSB7XG5cdFx0XHRcdG5ld09wdGlvbi5jbGFzc05hbWUgKz0gJyAnICsgdGhpcy5vcHRpb25zLmRpc2FibGVkQ2xhc3M7XG5cdFx0XHR9XG5cdFx0XHRpZiAob3B0aW9uLmNsYXNzTmFtZSkge1xuXHRcdFx0XHRuZXdPcHRpb24uY2xhc3NOYW1lICs9ICcgJyArIGdldFByZWZpeGVkQ2xhc3NlcyhvcHRpb24uY2xhc3NOYW1lLCB0aGlzLm9wdGlvbnMuY2xvbmVDbGFzc1ByZWZpeCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3T3B0aW9uO1xuXHRcdH0sXG5cdFx0Y3JlYXRlT3B0R3JvdXA6IGZ1bmN0aW9uKG9wdGdyb3VwKSB7XG5cdFx0XHR2YXIgb3B0R3JvdXBDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyksXG5cdFx0XHRcdG9wdEdyb3VwTmFtZSA9IG9wdGdyb3VwLmdldEF0dHJpYnV0ZSgnbGFiZWwnKSxcblx0XHRcdFx0b3B0R3JvdXBDYXB0aW9uLCBvcHRHcm91cExpc3Q7XG5cblx0XHRcdC8vIGNyZWF0ZSBjYXB0aW9uXG5cdFx0XHRvcHRHcm91cENhcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cdFx0XHRvcHRHcm91cENhcHRpb24uY2xhc3NOYW1lID0gdGhpcy5vcHRpb25zLmNhcHRpb25DbGFzcztcblx0XHRcdG9wdEdyb3VwQ2FwdGlvbi5pbm5lckhUTUwgPSBvcHRHcm91cE5hbWU7XG5cdFx0XHRvcHRHcm91cENvbnRhaW5lci5hcHBlbmRDaGlsZChvcHRHcm91cENhcHRpb24pO1xuXG5cdFx0XHQvLyBjcmVhdGUgbGlzdCBvZiBvcHRpb25zXG5cdFx0XHRpZiAob3B0Z3JvdXAuY2hpbGRyZW4ubGVuZ3RoKSB7XG5cdFx0XHRcdG9wdEdyb3VwTGlzdCA9IHRoaXMuY3JlYXRlT3B0aW9uc0xpc3Qob3B0Z3JvdXApO1xuXHRcdFx0XHRvcHRHcm91cENvbnRhaW5lci5hcHBlbmRDaGlsZChvcHRHcm91cExpc3QpO1xuXHRcdFx0fVxuXG5cdFx0XHRvcHRHcm91cENvbnRhaW5lci5jbGFzc05hbWUgPSB0aGlzLm9wdGlvbnMuZ3JvdXBDbGFzcztcblx0XHRcdHJldHVybiBvcHRHcm91cENvbnRhaW5lcjtcblx0XHR9LFxuXHRcdGNyZWF0ZU9wdGlvbkNvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb3B0aW9uQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcblx0XHRcdHJldHVybiBvcHRpb25Db250YWluZXI7XG5cdFx0fSxcblx0XHRjcmVhdGVPcHRpb25zTGlzdDogZnVuY3Rpb24oY29udGFpbmVyKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRcdGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuXG5cdFx0XHQkLmVhY2goY29udGFpbmVyLmNoaWxkcmVuLCBmdW5jdGlvbihpbmRleCwgY3VycmVudE5vZGUpIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSBzZWxmLmNyZWF0ZU9wdGlvbkNvbnRhaW5lcihjdXJyZW50Tm9kZSksXG5cdFx0XHRcdFx0bmV3Tm9kZTtcblxuXHRcdFx0XHRzd2l0Y2ggKGN1cnJlbnROb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkge1xuXHRcdFx0XHRcdGNhc2UgJ29wdGlvbic6IG5ld05vZGUgPSBzZWxmLmNyZWF0ZU9wdGlvbihjdXJyZW50Tm9kZSk7IGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ29wdGdyb3VwJzogbmV3Tm9kZSA9IHNlbGYuY3JlYXRlT3B0R3JvdXAoY3VycmVudE5vZGUpOyBicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LmFwcGVuZENoaWxkKGl0ZW0pLmFwcGVuZENoaWxkKG5ld05vZGUpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gbGlzdDtcblx0XHR9LFxuXHRcdHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gY2hlY2sgZm9yIHNlbGVjdCBpbm5lckhUTUwgY2hhbmdlc1xuXHRcdFx0aWYgKHRoaXMuc3RvcmVkU2VsZWN0SFRNTCAhPT0gdGhpcy5lbGVtZW50LnByb3AoJ2lubmVySFRNTCcpKSB7XG5cdFx0XHRcdHRoaXMucmVidWlsZExpc3QoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVmcmVzaCBjdXN0b20gc2Nyb2xsYmFyXG5cdFx0XHR2YXIgc2Nyb2xsSW5zdGFuY2UgPSBqY2YuZ2V0SW5zdGFuY2UodGhpcy5saXN0SG9sZGVyKTtcblx0XHRcdGlmIChzY3JvbGxJbnN0YW5jZSkge1xuXHRcdFx0XHRzY3JvbGxJbnN0YW5jZS5yZWZyZXNoKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlZnJlc2ggc2VsZWN0ZXMgY2xhc3Nlc1xuXHRcdFx0dGhpcy5yZWZyZXNoU2VsZWN0ZWRDbGFzcygpO1xuXHRcdH0sXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmxpc3RIb2xkZXIub2ZmKCdqY2YtbW91c2V3aGVlbCcsIHRoaXMucHJldmVudFdoZWVsSGFuZGxlcik7XG5cdFx0XHR0aGlzLmxpc3RIb2xkZXIub2ZmKCdqY2YtcG9pbnRlcmRvd24nLCB0aGlzLmluZGV4U2VsZWN0b3IsIHRoaXMub25TZWxlY3RJdGVtKTtcblx0XHRcdHRoaXMubGlzdEhvbGRlci5vZmYoJ2pjZi1wb2ludGVyb3ZlcicsIHRoaXMuaW5kZXhTZWxlY3RvciwgdGhpcy5vbkhvdmVySXRlbSk7XG5cdFx0XHR0aGlzLmxpc3RIb2xkZXIub2ZmKCdqY2YtcG9pbnRlcmRvd24nLCB0aGlzLm9uUHJlc3MpO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gaGVscGVyIGZ1bmN0aW9uc1xuXHR2YXIgZ2V0UHJlZml4ZWRDbGFzc2VzID0gZnVuY3Rpb24oY2xhc3NOYW1lLCBwcmVmaXhUb0FkZCkge1xuXHRcdHJldHVybiBjbGFzc05hbWUgPyBjbGFzc05hbWUucmVwbGFjZSgvW1xcc10qKFtcXFNdKykrW1xcc10qL2dpLCBwcmVmaXhUb0FkZCArICckMSAnKSA6ICcnO1xuXHR9O1xuXHR2YXIgbWFrZVVuc2VsZWN0YWJsZSA9IChmdW5jdGlvbigpIHtcblx0XHR2YXIgdW5zZWxlY3RhYmxlQ2xhc3MgPSBqY2YuZ2V0T3B0aW9ucygpLnVuc2VsZWN0YWJsZUNsYXNzO1xuXHRcdGZ1bmN0aW9uIHByZXZlbnRIYW5kbGVyKGUpIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdG5vZGUuYWRkQ2xhc3ModW5zZWxlY3RhYmxlQ2xhc3MpLm9uKCdzZWxlY3RzdGFydCcsIHByZXZlbnRIYW5kbGVyKTtcblx0XHR9O1xuXHR9KCkpO1xuXG59KGpRdWVyeSwgdGhpcykpO1xuIiwiLyohXG4gKiBKYXZhU2NyaXB0IEN1c3RvbSBGb3JtcyA6IFRleHRhcmVhIE1vZHVsZVxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUgUFNEMkhUTUwgLSBodHRwOi8vcHNkMmh0bWwuY29tL2pjZlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIChMSUNFTlNFLnR4dClcbiAqXG4gKiBWZXJzaW9uOiAxLjEuMlxuICovXG47KGZ1bmN0aW9uKCQpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGpjZi5hZGRNb2R1bGUoe1xuXHRcdG5hbWU6ICdUZXh0YXJlYScsXG5cdFx0c2VsZWN0b3I6ICd0ZXh0YXJlYScsXG5cdFx0b3B0aW9uczoge1xuXHRcdFx0cmVzaXplOiB0cnVlLFxuXHRcdFx0cmVzaXplclN0cnVjdHVyZTogJzxzcGFuIGNsYXNzPVwiamNmLXJlc2l6ZVwiPjwvc3Bhbj4nLFxuXHRcdFx0ZmFrZVN0cnVjdHVyZTogJzxzcGFuIGNsYXNzPVwiamNmLXRleHRhcmVhXCI+PC9zcGFuPidcblx0XHR9LFxuXHRcdG1hdGNoRWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIGVsZW1lbnQuaXMoJ3RleHRhcmVhJyk7XG5cdFx0fSxcblx0XHRpbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuaW5pdFN0cnVjdHVyZSgpO1xuXHRcdFx0dGhpcy5hdHRhY2hFdmVudHMoKTtcblx0XHRcdHRoaXMucmVmcmVzaCgpO1xuXHRcdH0sXG5cdFx0aW5pdFN0cnVjdHVyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBwcmVwYXJlIHN0cnVjdHVyZVxuXHRcdFx0dGhpcy5kb2MgPSAkKGRvY3VtZW50KTtcblx0XHRcdHRoaXMucmVhbEVsZW1lbnQgPSAkKHRoaXMub3B0aW9ucy5lbGVtZW50KTtcblx0XHRcdHRoaXMuZmFrZUVsZW1lbnQgPSAkKHRoaXMub3B0aW9ucy5mYWtlU3RydWN0dXJlKS5pbnNlcnRBZnRlcih0aGlzLnJlYWxFbGVtZW50KTtcblx0XHRcdHRoaXMucmVzaXplciA9ICQodGhpcy5vcHRpb25zLnJlc2l6ZXJTdHJ1Y3R1cmUpLmFwcGVuZFRvKHRoaXMuZmFrZUVsZW1lbnQpO1xuXG5cdFx0XHQvLyBhZGQgY3VzdG9tIHNjcm9sbGJhclxuXHRcdFx0aWYgKGpjZi5tb2R1bGVzLlNjcm9sbGFibGUpIHtcblx0XHRcdFx0dGhpcy5yZWFsRWxlbWVudC5wcmVwZW5kVG8odGhpcy5mYWtlRWxlbWVudCkuYWRkQ2xhc3MoKS5jc3Moe1xuXHRcdFx0XHRcdG92ZXJmbG93OiAnaGlkZGVuJyxcblx0XHRcdFx0XHRyZXNpemU6ICdub25lJ1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR0aGlzLnNjcm9sbGFibGUgPSBuZXcgamNmLm1vZHVsZXMuU2Nyb2xsYWJsZSh7XG5cdFx0XHRcdFx0ZWxlbWVudDogdGhpcy5yZWFsRWxlbWVudCxcblx0XHRcdFx0XHRhbHdheXNTaG93U2Nyb2xsYmFyczogdHJ1ZVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0dGhpcy5zY3JvbGxhYmxlLnNldFNjcm9sbEJhckVkZ2UodGhpcy5yZXNpemVyLm91dGVySGVpZ2h0KCkpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YXR0YWNoRXZlbnRzOiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIGFkZCBldmVudCBoYW5kbGVyc1xuXHRcdFx0dGhpcy5yZWFsRWxlbWVudC5vbih7XG5cdFx0XHRcdGZvY3VzOiB0aGlzLm9uRm9jdXMsXG5cdFx0XHRcdGtleXVwOiB0aGlzLm9uQ2hhbmdlLFxuXHRcdFx0XHRjaGFuZ2U6IHRoaXMub25DaGFuZ2Vcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLnJlc2l6ZXIub24oJ2pjZi1wb2ludGVyZG93bicsIHRoaXMub25SZXNpemVQcmVzcyk7XG5cdFx0fSxcblx0XHRvblJlc2l6ZVByZXNzOiBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgcmVzaXplck9mZnNldCA9IHRoaXMucmVzaXplci5vZmZzZXQoKSxcblx0XHRcdFx0YXJlYU9mZnNldCA9IHRoaXMuZmFrZUVsZW1lbnQub2Zmc2V0KCk7XG5cblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHRoaXMuZHJhZ0RhdGEgPSB7XG5cdFx0XHRcdGFyZWFPZmZzZXQ6IGFyZWFPZmZzZXQsXG5cdFx0XHRcdGlubmVyT2Zmc2V0TGVmdDogZS5wYWdlWCAtIHJlc2l6ZXJPZmZzZXQubGVmdCxcblx0XHRcdFx0aW5uZXJPZmZzZXRUb3A6IGUucGFnZVkgLSByZXNpemVyT2Zmc2V0LnRvcFxuXHRcdFx0fTtcblx0XHRcdHRoaXMuZG9jLm9uKHtcblx0XHRcdFx0J2pjZi1wb2ludGVybW92ZSc6IHRoaXMub25SZXNpemVNb3ZlLFxuXHRcdFx0XHQnamNmLXBvaW50ZXJ1cCc6IHRoaXMub25SZXNpemVSZWxlYXNlXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gcmVzdG9yZSBmb2N1c1xuXHRcdFx0aWYgKHRoaXMuaXNGb2N1c2VkKSB7XG5cdFx0XHRcdHRoaXMuZm9jdXNlZERyYWcgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLnJlYWxFbGVtZW50LmZvY3VzKCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvblJlc2l6ZU1vdmU6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBuZXdXaWR0aCA9IGUucGFnZVggKyB0aGlzLmRyYWdEYXRhLmlubmVyT2Zmc2V0TGVmdCAtIHRoaXMuZHJhZ0RhdGEuYXJlYU9mZnNldC5sZWZ0LFxuXHRcdFx0XHRuZXdIZWlnaHQgPSBlLnBhZ2VZICsgdGhpcy5kcmFnRGF0YS5pbm5lck9mZnNldFRvcCAtIHRoaXMuZHJhZ0RhdGEuYXJlYU9mZnNldC50b3AsXG5cdFx0XHRcdHdpZHRoRGlmZiA9IHRoaXMuZmFrZUVsZW1lbnQuaW5uZXJXaWR0aCgpIC0gdGhpcy5yZWFsRWxlbWVudC5pbm5lcldpZHRoKCk7XG5cblx0XHRcdC8vIHByZXZlbnQgdGV4dCBzZWxlY3Rpb24gb3IgcGFnZSBzY3JvbGwgb24gdG91Y2ggZGV2aWNlc1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHQvLyByZXNpemUgdGV4dGFyZWEgYW5kIHJlZnJlc2ggc2Nyb2xsYmFyc1xuXHRcdFx0dGhpcy5yZWFsRWxlbWVudC5pbm5lcldpZHRoKG5ld1dpZHRoIC0gd2lkdGhEaWZmKS5pbm5lckhlaWdodChuZXdIZWlnaHQpO1xuXHRcdFx0dGhpcy5zY3JvbGxhYmxlLnJlYnVpbGRTY3JvbGxiYXJzKCk7XG5cblx0XHRcdC8vIHJlc3RvcmUgZm9jdXNcblx0XHRcdGlmICh0aGlzLmZvY3VzZWREcmFnKSB7XG5cdFx0XHRcdHRoaXMucmVhbEVsZW1lbnQuZm9jdXMoKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9uUmVzaXplUmVsZWFzZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmRvYy5vZmYoe1xuXHRcdFx0XHQnamNmLXBvaW50ZXJtb3ZlJzogdGhpcy5vblJlc2l6ZU1vdmUsXG5cdFx0XHRcdCdqY2YtcG9pbnRlcnVwJzogdGhpcy5vblJlc2l6ZVJlbGVhc2Vcblx0XHRcdH0pO1xuXG5cdFx0XHRkZWxldGUgdGhpcy5mb2N1c2VkRHJhZztcblx0XHR9LFxuXHRcdG9uRm9jdXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5pc0ZvY3VzZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy5mYWtlRWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZm9jdXNDbGFzcyk7XG5cdFx0XHR0aGlzLnJlYWxFbGVtZW50Lm9uKCdibHVyJywgdGhpcy5vbkJsdXIpO1xuXHRcdH0sXG5cdFx0b25CbHVyOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuaXNGb2N1c2VkID0gZmFsc2U7XG5cdFx0XHR0aGlzLmZha2VFbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5mb2N1c0NsYXNzKTtcblx0XHRcdHRoaXMucmVhbEVsZW1lbnQub2ZmKCdibHVyJywgdGhpcy5vbkJsdXIpO1xuXHRcdH0sXG5cdFx0b25DaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5yZWZyZXNoQ3VzdG9tU2Nyb2xsYmFycygpO1xuXHRcdH0sXG5cdFx0cmVmcmVzaEN1c3RvbVNjcm9sbGJhcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHRoaXMuaXNGb2N1c2VkKSB7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsYWJsZS5yZWRyYXdTY3JvbGxiYXJzKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNjcm9sbGFibGUucmVidWlsZFNjcm9sbGJhcnMoKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gcmVmcmVzaCBjdXN0b20gc2Nyb2xsIHBvc2l0aW9uXG5cdFx0XHR2YXIgaXNEaXNhYmxlZCA9IHRoaXMucmVhbEVsZW1lbnQuaXMoJzpkaXNhYmxlZCcpO1xuXHRcdFx0dGhpcy5mYWtlRWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLm9wdGlvbnMuZGlzYWJsZWRDbGFzcywgaXNEaXNhYmxlZCk7XG5cdFx0XHR0aGlzLnJlZnJlc2hDdXN0b21TY3JvbGxiYXJzKCk7XG5cdFx0fSxcblx0XHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIGRlc3Ryb3kgY3VzdG9tIHNjcm9sbGJhclxuXHRcdFx0dGhpcy5zY3JvbGxhYmxlLmRlc3Ryb3koKTtcblxuXHRcdFx0Ly8gcmVzdG9yZSBzdHlsZXMgYW5kIHJlbW92ZSBldmVudCBsaXN0ZW5lcnNcblx0XHRcdHRoaXMucmVhbEVsZW1lbnQuY3NzKHtcblx0XHRcdFx0b3ZlcmZsb3c6ICcnLFxuXHRcdFx0XHRyZXNpemU6ICcnXG5cdFx0XHR9KS5pbnNlcnRCZWZvcmUodGhpcy5mYWtlRWxlbWVudCkub2ZmKHtcblx0XHRcdFx0Zm9jdXM6IHRoaXMub25Gb2N1cyxcblx0XHRcdFx0Ymx1cjogdGhpcy5vbkJsdXJcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyByZW1vdmUgc2Nyb2xsYmFyIGFuZCBmYWtlIHdyYXBwZXJcblx0XHRcdHRoaXMuZmFrZUVsZW1lbnQucmVtb3ZlKCk7XG5cdFx0fVxuXHR9KTtcblxufShqUXVlcnkpKTtcbiIsImZ1bmN0aW9uIFB1YmxpY2F0aW9uU2Nyb2xsKGNvbnRhaW5lcikge1xuICAgIHRoaXMuc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5ib2R5ID0galF1ZXJ5KCdib2R5Jyk7XG4gICAgdGhpcy53aW5kb3cgPSBqUXVlcnkod2luZG93KTtcbiAgICB0aGlzLnRvZ2dsZWRDb250ZW50ID0gdGhpcy5jb250YWluZXIuc2libGluZ3MoJy50b2dnbGVkLWNvbnRlbnQnKTtcbiAgICB0aGlzLmNvbnRhaW5lckluaXRpYWxPZmZzZXQgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXQoKS50b3A7XG5cbiAgICB0aGlzLndpbmRvdy5vbignc2Nyb2xsJywgdGhpcy5zY3JvbGxJbmZvLmJpbmQodGhpcykpO1xufVxuXG5QdWJsaWNhdGlvblNjcm9sbC5wcm90b3R5cGUuc2Nyb2xsSW5mbyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB3aW5kb3dXaWR0aCA9IGpRdWVyeSh3aW5kb3cpLndpZHRoKCk7XG4gICAgdmFyIGJvZHlDbGFzc2VzID0gZG9jdW1lbnQuYm9keS5jbGFzc0xpc3Q7XG4gICAgdmFyIGFycmF5Qm9keUNsYXNzZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChib2R5Q2xhc3Nlcyk7XG5cbiAgICBpZiAod2luZG93V2lkdGggPj0gOTYwKSB7XG4gICAgICAgIGlmIChhcnJheUJvZHlDbGFzc2VzLmluZGV4T2YoJ2lwYWQnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnN0aWNrX2luX3BhcmVudCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGFycmF5Qm9keUNsYXNzZXMuaW5kZXhPZignaXBhZCcpICE9PSAtMSAmJiBhcnJheUJvZHlDbGFzc2VzLmluZGV4T2YoJ3ZpZXdwb3J0LWxhbmRzY2FwZScpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuc3RpY2tfaW5fcGFyZW50KClcbiAgICAgICAgfVxuICAgIH1cbn1cblxualF1ZXJ5LmZuLnB1YmxpY2F0aW9uU2Nyb2xsID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGpRdWVyeSh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICBuZXcgUHVibGljYXRpb25TY3JvbGwoalF1ZXJ5KHRoaXMpKTtcbiAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFB1YmxpY2F0aW9uU2Nyb2xsOiBQdWJsaWNhdGlvblNjcm9sbFxufTsiLCJmdW5jdGlvbiBSZWxhdGVkQm94KGVsZW1lbnQpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMucXVlcnkgPSB0aGlzLmVsZW1lbnQuZGF0YSgncXVlcnknKTtcbiAgICB0aGlzLnNlYXJjaGJveCA9IGpRdWVyeSgnLnNlYXJjaGJveCAuc2VhcmNoJyk7XG5cbiAgICB0aGlzLmVsZW1lbnQub24oJ2NsaWNrJywgdGhpcy5vbkNsaWNrLmJpbmQodGhpcykpO1xufVxuXG5SZWxhdGVkQm94LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuc2VhcmNoYm94LnZhbCh0aGlzLnF1ZXJ5KS50cmlnZ2VyKCdrZXl1cCcpO1xufTtcblxualF1ZXJ5LmZuLnJlbGF0ZWRTZWFyY2hCb3ggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4galF1ZXJ5KHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIG5ldyBSZWxhdGVkQm94KGpRdWVyeSh0aGlzKSk7XG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbGF0ZWRCb3g7XG4iLCJ2YXIgdmlld3BvcnQgPSByZXF1aXJlKCcuLi91dGlscy92aWV3cG9ydCcpO1xuXG5mdW5jdGlvbiBTZWFyY2hGaWx0ZXJzKGZpbHRlcikge1xuICAgIHRoaXMuZmlsdGVyID0gZmlsdGVyO1xuICAgIHRoaXMuZmlsdGVycyA9IHRoaXMuZmlsdGVyLmZpbmQoJ2lucHV0LHNlbGVjdCcpO1xuICAgIHRoaXMuZmlsdGVyTGlzdCA9IHRoaXMuZmlsdGVyLmZpbmQoJ3VsJyk7XG4gICAgdGhpcy5zZWFyY2hGb3JtID0gdGhpcy5maWx0ZXIuY2xvc2VzdCgnZm9ybS5hamF4Jyk7XG4gICAgdGhpcy5zaG93RmlsdGVyID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5maWx0ZXIuaGFzQ2xhc3MoJ2hpZGRlbi1hdC1zdGFydCcpID09IHRydWUpIHtcbiAgICAgICAgdGhpcy5maWx0ZXIuaGlkZSgpO1xuICAgICAgICB0aGlzLnNob3dGaWx0ZXIgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmZpbHRlcnMub24oJ2NoYW5nZScsIHRoaXMuc2VuZFNlYXJjaEZvcm0uYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLm9uU3BlY2lhbEtleXdvcmRVc2VkID0gdGhpcy5vblNwZWNpYWxLZXl3b3JkVXNlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25TcGVjaWFsS2V5d29yZFJlbW92ZWQgPSB0aGlzLm9uU3BlY2lhbEtleXdvcmRSZW1vdmVkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblNlbmRTZWFyY2hGb3JtUmVzZXQgPSB0aGlzLm9uU2VuZFNlYXJjaEZvcm1SZXNldC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc2VhcmNoRm9ybS5vbignc3BlY2lhbC1rZXl3b3JkLXVzZWQnLCB0aGlzLm9uU3BlY2lhbEtleXdvcmRVc2VkKTtcbiAgICB0aGlzLnNlYXJjaEZvcm0ub24oJ3NwZWNpYWwta2V5d29yZC1yZW1vdmVkJywgdGhpcy5vblNwZWNpYWxLZXl3b3JkUmVtb3ZlZCk7XG4gICAgdGhpcy5zZWFyY2hGb3JtLm9uKCdzZW5kLXNlYXJjaC1mb3JtLXJlc2V0JywgdGhpcy5vblNlbmRTZWFyY2hGb3JtUmVzZXQpO1xuXG4gICAgdGhpcy5nZW5lcmF0ZU1vYmlsZVZpZXcoKTtcbn1cblxuU2VhcmNoRmlsdGVycy5wcm90b3R5cGUuc2VuZFNlYXJjaEZvcm0gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNlYXJjaEZvcm0udHJpZ2dlcignZmlsdGVyLXNlbmQnKTtcblxuICAgIHZhciBzZWFyY2hSZXN1bHQgPSB0aGlzLnNlYXJjaEZvcm0uc2libGluZ3MoJy5zZWFyY2gtcmVzdWx0LXNlY3Rpb24nKS5maXJzdCgpO1xuICAgIGlmIChzZWFyY2hSZXN1bHQuZmluZCgnLmxvYWRpbmctaW5kaWNhdG9yJykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNlYXJjaFJlc3VsdC5hcHBlbmQoJzxkaXYgY2xhc3M9XCJsb2FkaW5nLWluZGljYXRvclwiLz4nKTtcbiAgICB9XG4gICAgdGhpcy5zZWFyY2hGb3JtLnN1Ym1pdCgpO1xufTtcblxuU2VhcmNoRmlsdGVycy5wcm90b3R5cGUub25TcGVjaWFsS2V5d29yZFVzZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmhpZGVGaWx0ZXJzKCk7XG59O1xuXG5TZWFyY2hGaWx0ZXJzLnByb3RvdHlwZS5vblNwZWNpYWxLZXl3b3JkUmVtb3ZlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2hvd0ZpbHRlcnMoKTtcbn07XG5cblNlYXJjaEZpbHRlcnMucHJvdG90eXBlLm9uU2VuZFNlYXJjaEZvcm1SZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVzZXRGaWx0ZXJzKCk7XG4gICAgdGhpcy5zZW5kU2VhcmNoRm9ybSgpO1xufTtcblxuXG5TZWFyY2hGaWx0ZXJzLnByb3RvdHlwZS5oaWRlRmlsdGVycyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnNob3dGaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5maWx0ZXIuYW5pbWF0ZSh7XG4gICAgICAgICAgICAnb3BhY2l0eSc6IDBcbiAgICAgICAgfSwgMjUwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGpRdWVyeSh0aGlzKS5zbGlkZVVwKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeSh0aGlzKS5hZGRDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2hvd0ZpbHRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlc2V0RmlsdGVycygpO1xuICAgIH1cbn07XG5cblNlYXJjaEZpbHRlcnMucHJvdG90eXBlLnNob3dGaWx0ZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnNob3dGaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5maWx0ZXIucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpLnNsaWRlRG93bihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGpRdWVyeSh0aGlzKS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICAnb3BhY2l0eSc6IDFcbiAgICAgICAgICAgIH0sIDI1MCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNob3dGaWx0ZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLmZpbHRlci5yZW1vdmVDbGFzcygnaGlkZGVuLWF0LXN0YXJ0Jyk7XG4gICAgfVxufTtcblxuU2VhcmNoRmlsdGVycy5wcm90b3R5cGUucmVzZXRGaWx0ZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5maWx0ZXJMaXN0LmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIGpRdWVyeSh0aGlzKS5maW5kKCdpbnB1dCcpLmVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLnByb3AoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBqUXVlcnkodGhpcy5maWx0ZXIpLmZpbmQoJ3NlbGVjdCcpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIGpRdWVyeSh0aGlzKS5maW5kKCdvcHRpb24nKS5maXJzdCgpLnByb3AoJ3NlbGVjdGVkJywgJ3NlbGVjdGVkJyk7XG4gICAgICAgIGpjZi5yZWZyZXNoKGpRdWVyeSh0aGlzKSk7XG4gICAgfSk7XG59O1xuXG5TZWFyY2hGaWx0ZXJzLnByb3RvdHlwZS5nZW5lcmF0ZU1vYmlsZVZpZXcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmZpbHRlckxpc3QuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBqUXVlcnkodGhpcyk7XG4gICAgICAgIHZhciBkZXNjcmlwdGlvbiA9IGxpc3QuZmluZCgnaW5wdXQ6Y2hlY2tlZCArIGxhYmVsJykuaHRtbCgpO1xuXG4gICAgICAgIGxpc3QuYmVmb3JlKCc8YSBocmVmPVwiI1wiIGNsYXNzPVwidG9nZ2xlLWZpbHRlciBqY2Ytc2VsZWN0IGpjZi1zZWxlY3Qtc2Vjb25kYXJ5XCI+PHNwYW4gY2xhc3M9XCJqY2Ytc2VsZWN0LXRleHRcIj48c3Bhbj4nICsgZGVzY3JpcHRpb24gKyAnPC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cImpjZi1zZWxlY3Qtb3BlbmVyXCIgLz48L2E+Jyk7XG5cbiAgICAgICAgbGlzdC5zaWJsaW5ncygnYS50b2dnbGUtZmlsdGVyJykuY2xpY2soZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBqUXVlcnkodGhpcykudG9nZ2xlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgbGlzdC5zbGlkZVRvZ2dsZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgalF1ZXJ5KCdib2R5JykuY2xpY2soZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICh2aWV3cG9ydCA8PSAxMDI0KSB7XG4gICAgICAgICAgICAgICAgaWYoIWpRdWVyeS5jb250YWlucyhsaXN0LnNpYmxpbmdzKCdhLnRvZ2dsZS1maWx0ZXInKVswXSwgZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0LnNsaWRlVXAoKS5zaWJsaW5ncygnYS50b2dnbGUtZmlsdGVyJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxpc3QuZmluZCgnaW5wdXQnKS5jbGljayhmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgaWYgKHZpZXdwb3J0LndpZHRoKCkgPD0gMTAyNCkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0galF1ZXJ5KHRoaXMpO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50TGlzdCA9IGVsZW1lbnQuY2xvc2VzdCgndWwnKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5hdHRyKCd2YWx1ZScpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5zaWJsaW5ncygnYS50b2dnbGUtZmlsdGVyJykuZmluZCgnLmpjZi1zZWxlY3QtdGV4dCcpLmh0bWwoZWxlbWVudC5zaWJsaW5ncygnbGFiZWwnKS5odG1sKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50TGlzdC5zbGlkZVVwKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudExpc3Quc2libGluZ3MoJ2EudG9nZ2xlLWZpbHRlcicpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5qUXVlcnkuZm4uc2VhcmNoRmlsdGVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBqUXVlcnkodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgbmV3IFNlYXJjaEZpbHRlcnMoalF1ZXJ5KHRoaXMpKTtcbiAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VhcmNoRmlsdGVycztcbiIsImZ1bmN0aW9uIFNlYXJjaGJveChzZWFyY2gpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5zZWFyY2ggPSBzZWFyY2g7XG4gICAgdGhpcy5zZWFyY2hib3ggPSB0aGlzLnNlYXJjaC5wYXJlbnQoKTtcbiAgICB0aGlzLnNlYXJjaEZvcm0gPSB0aGlzLnNlYXJjaC5jbG9zZXN0KCdmb3JtLmFqYXgnKTtcblxuICAgIHRoaXMuZGVsYXkgPSA1MDA7XG4gICAgdGhpcy5rZXlUb1NlbmQgPSAwO1xuICAgIGlmICh0eXBlb2YgdGhpcy5zZWFyY2guYXR0cignZGF0YS1kZWxheScpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmRlbGF5ID0gdGhpcy5zZWFyY2guZGF0YSgnZGVsYXknKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLnNlYXJjaC5hdHRyKCdkYXRhLW1heC1jaGFycycpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmtleVRvU2VuZCA9IHRoaXMuc2VhcmNoLmRhdGEoJ21heC1jaGFycycpO1xuICAgIH1cblxuICAgIHRoaXMubm93ID0gbmV3IERhdGUoKTtcbiAgICB0aGlzLnNlbmQgPSBmYWxzZTtcbiAgICB0aGlzLmxhc3RFeGVjdXRpb24gPSB0aGlzLm5vdy5nZXRUaW1lKCk7XG4gICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgdGhpcy5rZXlFbnRlcmVkID0gMDtcbiAgICB0aGlzLmhpbnRzID0gbnVsbDtcbiAgICB0aGlzLnNob3dIaW50cyA9IHRydWU7XG4gICAgdGhpcy5zcGVjaWFsS2V5d29yZCA9IGZhbHNlO1xuICAgIHRoaXMuc3BlY2lhbEtleXdvcmRzID0gW107XG5cbiAgICB0aGlzLmdldFNwZWNpYWxLZXl3b3JkcygpO1xuICAgIHRoaXMuZ2VuZXJhdGVIaW50SFRNTCgpO1xuICAgIHRoaXMuZ2V0SGludHMoKTtcblxuICAgIHRoaXMub25TZWFyY2hLZXlVcCA9IHRoaXMub25TZWFyY2hLZXlVcC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25TZWFyY2hLZXlEb3duID0gdGhpcy5vblNlYXJjaEtleURvd24uYmluZCh0aGlzKTtcblxuICAgIHRoaXMuc2VhcmNoLm9uKCdrZXl1cCcsIHRoaXMub25TZWFyY2hLZXlVcCk7XG4gICAgdGhpcy5zZWFyY2gub24oJ2JsdXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5hZGRNYWluS2V5d29yZCgpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5oaWRlS2V5d29yZHMoKTtcbiAgICAgICAgfSwgMTUwKTtcbiAgICAgICAgc2VsZi5hY3RpdmVCdXR0b24oKTtcbiAgICB9KTtcbiAgICB0aGlzLnNlYXJjaC5vbignZm9jdXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5yZW1vdmVNYWluS2V5d29yZCgpO1xuICAgICAgICBzZWxmLnNob3dLZXl3b3JkcygpO1xuICAgICAgICBzZWxmLmFjdGl2ZUJ1dHRvbih0cnVlKTtcbiAgICB9KTtcblxuICAgIHRoaXMuc2VhcmNoRm9ybS5vbignZmlsdGVyLXNlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5zaG93SGludHMgPSBmYWxzZTtcbiAgICB9KTtcbn1cblxuU2VhcmNoYm94LnByb3RvdHlwZS5hY3RpdmVCdXR0b24gPSBmdW5jdGlvbihhY3RpdmUpIHtcbiAgICB2YXIgc2VhcmNoQnV0dG9uID0galF1ZXJ5KCcuc2VhcmNoLmJ1dHRvbicpO1xuXG4gICAgaWYgKHRoaXMuc2VhcmNoLnZhbCgpIHx8IGFjdGl2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICBzZWFyY2hCdXR0b24uYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNlYXJjaEJ1dHRvbi5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgfVxufTtcblxuU2VhcmNoYm94LnByb3RvdHlwZS5nZXRTcGVjaWFsS2V5d29yZHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIga2V5d29yZHMgPSB0aGlzLnNlYXJjaC5kYXRhKCdzcGVjaWFsLWtleXdvcmRzJyk7XG5cbiAgICB0aGlzLnNwZWNpYWxLZXl3b3JkcyA9IGtleXdvcmRzLnNwbGl0KCcgJyk7XG59O1xuXG5TZWFyY2hib3gucHJvdG90eXBlLmdlbmVyYXRlSGludEhUTUwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGludElucHV0ID0galF1ZXJ5KCc8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cInNlYXJjaC1oaW50XCIgcmVhZG9ubHk+Jyk7XG4gICAgdGhpcy5zZWFyY2hib3guYXBwZW5kKGhpbnRJbnB1dCk7XG5cbiAgICB0aGlzLnNlYXJjaEhpbnQgPSBoaW50SW5wdXQ7XG59O1xuXG5TZWFyY2hib3gucHJvdG90eXBlLm9uU2VhcmNoS2V5VXAgPSBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICh0aGlzLmtleVRvU2VuZCA+IDApIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgIH1cblxuICAgIHRoaXMuc3BlY2lhbEtleXdvcmQgPSBmYWxzZTtcbiAgICB2YXIgc2VhcmNoVmFsdWUgPSB0aGlzLnNlYXJjaC52YWwoKTtcbiAgICB2YXIgc2VhcmNoVmFsdWVBcnJheSA9IFtdO1xuXG4gICAgLy8gQ2hlY2sgaWYgc3BlY2lhbCBrZXl3b3JkIHVzZWRcbiAgICBzZWFyY2hWYWx1ZUFycmF5ID0gc2VhcmNoVmFsdWUuc3BsaXQoJyAnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3BlY2lhbEtleXdvcmRzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgLypcbiAgICAgICAgLy8gQ09NTUVOVEVEIE9VVCAtIFNLUlxuICAgICAgICAvLyBUaGlzIGNoZWNrcyBmb3IgdGhlIHNwZWNpYWxLZXl3b3JkIGF0IHRoZSBiZWdpbm5pbmcgb25seVxuICAgICAgICBpZiAoc2VhcmNoVmFsdWVBcnJheVswXS50b0xvd2VyQ2FzZSgpID09PSB0aGlzLnNwZWNpYWxLZXl3b3Jkc1tpXS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnNwZWNpYWxLZXl3b3JkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaGlkZUtleXdvcmRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgICAgICAvLyBmaW5kIHNwZWNpYWxLZXl3b3JkIGFueXdoZXJlIGluIHN0cmluZ1xuICAgICAgICBpZiAoc2VhcmNoVmFsdWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKHRoaXMuc3BlY2lhbEtleXdvcmRzW2ldLnRvTG93ZXJDYXNlKCkpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuc3BlY2lhbEtleXdvcmQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5oaWRlS2V5d29yZHMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByZXZlbnQgc2VuZCB3aGVuIHVzZWQgYXJyb3cga2V5cywgdGFiIGFuZCBzcGVjaWFsIGtleXdvcmRzXG4gICAgaWYgKGV2ZW50LndoaWNoICE9PSAzNyAmJiBldmVudC53aGljaCAhPT0gMzggJiYgZXZlbnQud2hpY2ggIT09IDM5ICYmIGV2ZW50LndoaWNoICE9PSA0MCAmJiBldmVudC53aGljaCAhPT0gMTMgJiYgZXZlbnQud2hpY2ggIT09IDkgJiYgIXRoaXMuc3BlY2lhbEtleXdvcmQpIHtcblxuICAgICAgICAvKlxuICAgICAgICAvLyBDT01NRU5URUQgT1VUIC0gU0tSXG4gICAgICAgIGlmICh0aGlzLmhpbnRzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrU2VuZFNlYXJjaEZvcm0oZXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrS2V5d29yZE1hdGNoKHRoaXMuaGludHMua2V5d29yZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrU2VuZFNlYXJjaEZvcm0oZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2hlY2tTZW5kU2VhcmNoRm9ybShldmVudCk7XG4gICAgfVxuXG4gICAgLy8gRmlyZSBzZWFyY2ggd2hlbiBlbnRlcmVkIHN0cmluZy1sZW5ndGggaXMgPCAxXG4gICAgaWYgKHRoaXMuc2VhcmNoLnZhbCgpLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgdGhpcy5zZW5kU2VhcmNoRm9ybSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNwZWNpYWxLZXl3b3JkKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoRm9ybS50cmlnZ2VyKCdzcGVjaWFsLWtleXdvcmQtdXNlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VhcmNoRm9ybS50cmlnZ2VyKCdzcGVjaWFsLWtleXdvcmQtcmVtb3ZlZCcpO1xuICAgIH1cblxuICAgIC8vIFNlbmQgb24gZW50ZXJcbiAgICAvL2lmIChldmVudC53aGljaCA9PT0gMTMgJiYgdGhpcy5zcGVjaWFsS2V5d29yZCkge1xuICAgIGlmIChldmVudC53aGljaCA9PT0gMTMpIHtcbiAgICAgICAgdGhpcy5zZWFyY2guYmx1cigpO1xuICAgICAgICB0aGlzLnNlbmRTZWFyY2hGb3JtKCk7XG4gICAgfVxufTtcblxuU2VhcmNoYm94LnByb3RvdHlwZS5vblNlYXJjaEtleURvd24gPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAzOCB8fCBldmVudC53aGljaCA9PT0gNDAgfHwgZXZlbnQud2hpY2ggPT09IDEzIHx8IGV2ZW50LndoaWNoID09PSA5KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgdmFyIGhpZ2h0bGlndGggPSB0aGlzLmtleXdvcmRzSFRNTExpc3QuZmluZCgnbGkuaGlnaGxpZ2h0Jyk7XG5cbiAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSA0MCkgeyAvLyBhcnJvdyBkb3duXG4gICAgICAgICAgICBpZiAoaGlnaHRsaWd0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhpZ2h0bGlndGguaW5kZXgoKSA9PT0gdGhpcy5rZXl3b3Jkc0hUTUxMaXN0LmZpbmQoJ2xpJykubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBoaWdodGxpZ3RoLnJlbW92ZUNsYXNzKCdoaWdobGlnaHQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5rZXl3b3Jkc0hUTUxMaXN0LmZpbmQoJ2xpOmZpcnN0LWNoaWxkJykuYWRkQ2xhc3MoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhpZ2h0bGlndGgucmVtb3ZlQ2xhc3MoJ2hpZ2hsaWdodCcpLm5leHQoKS5hZGRDbGFzcygnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtleXdvcmRzSFRNTExpc3QuZmluZCgnbGk6Zmlyc3QtY2hpbGQnKS5hZGRDbGFzcygnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQud2hpY2ggPT09IDM4KSB7IC8vIGFycm93IHVwXG4gICAgICAgICAgICBpZiAoaGlnaHRsaWd0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhpZ2h0bGlndGguaW5kZXgoKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBoaWdodGxpZ3RoLnJlbW92ZUNsYXNzKCdoaWdobGlnaHQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5rZXl3b3Jkc0hUTUxMaXN0LmZpbmQoJ2xpOmxhc3QtY2hpbGQnKS5hZGRDbGFzcygnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGlnaHRsaWd0aC5yZW1vdmVDbGFzcygnaGlnaGxpZ2h0JykucHJldigpLmFkZENsYXNzKCdoaWdobGlnaHQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMua2V5d29yZHNIVE1MTGlzdC5maW5kKCdsaTpsYXN0LWNoaWxkJykuYWRkQ2xhc3MoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LndoaWNoID09PSAxMykgeyAvLyBlbnRlclxuXG4gICAgICAgICAgICB0aGlzLnNlYXJjaC5ibHVyKCk7XG4gICAgICAgICAgICB0aGlzLnNlbmRTZWFyY2hGb3JtKCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChldmVudC53aGljaCA9PT0gOSkgeyAvLyB0YWIga2V5XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUhpbnQodGhpcy5rZXl3b3Jkc0hUTUxMaXN0LmZpbmQoJ2xpOmZpcnN0LWNoaWxkIGEnKSk7XG4gICAgICAgICAgICB0aGlzLnNlYXJjaC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuU2VhcmNoYm94LnByb3RvdHlwZS5jaGVja1NlbmRTZWFyY2hGb3JtID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB0aGlzLmtleUVudGVyZWQgKz0gMTtcblxuICAgIGlmICh0aGlzLmtleVRvU2VuZCA+IDApIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdEV4ZWN1dGlvbiAmJiB0aGlzLm5vdy5nZXRUaW1lKCkgPCB0aGlzLmxhc3RFeGVjdXRpb24gKyB0aGlzLmRlbGF5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5rZXlFbnRlcmVkID09PSB0aGlzLmtleVRvU2VuZCB8fCBldmVudC53aGljaCA9PT0gMzIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRTZWFyY2hGb3JtKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuc2VuZFNlYXJjaEZvcm0uYmluZCh0aGlzKSwgdGhpcy5kZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuc2VuZCkge1xuICAgICAgICAgICAgdGhpcy5zZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuc2VuZFNlYXJjaEZvcm0uYmluZCh0aGlzKSwgdGhpcy5kZWxheSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5TZWFyY2hib3gucHJvdG90eXBlLnNlbmRTZWFyY2hGb3JtID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMua2V5VG9TZW5kID09PSAwKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgdGhpcy5zZW5kID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMubGFzdEV4ZWN1dGlvbiA9IHRoaXMubm93LmdldFRpbWUoKTtcbiAgICB0aGlzLmtleUVudGVyZWQgPSAwO1xuXG4gICAgdmFyIHNlYXJjaFJlc3VsdCA9IHRoaXMuc2VhcmNoRm9ybS5zaWJsaW5ncygnLnNlYXJjaC1yZXN1bHQtc2VjdGlvbicpLmZpcnN0KCk7XG4gICAgdmFyIHNlYXJjaEF1dG9jb21wbGV0ZSA9IGpRdWVyeSgnI3NlYXJjaC1hdXRvY29tcGxldGUnKTtcblxuICAgIGlmIChzZWFyY2hSZXN1bHQuZmluZCgnLmxvYWRpbmctaW5kaWNhdG9yJykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNlYXJjaFJlc3VsdC5hcHBlbmQoJzxkaXYgY2xhc3M9XCJsb2FkaW5nLWluZGljYXRvclwiLz4nKTtcbiAgICB9XG4gICAgaWYgKHNlYXJjaEF1dG9jb21wbGV0ZS5maW5kKCcubG9hZGluZy1pbmRpY2F0b3InKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2VhcmNoQXV0b2NvbXBsZXRlLmFwcGVuZCgnPGRpdiBjbGFzcz1cImxvYWRpbmctaW5kaWNhdG9yXCIvPicpO1xuICAgIH1cblxuICAgIHRoaXMuc2VhcmNoRm9ybS5zdWJtaXQoKTtcbn07XG5cblNlYXJjaGJveC5wcm90b3R5cGUuZ2V0SGludHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLnNlYXJjaEZvcm0ub24oJ2FqYXgtZGF0YS1vYmplY3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5oaW50cyA9IChqUXVlcnkuZGF0YShqUXVlcnkodGhpcylbMF0sICdkYXRhT2JqZWN0JykpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIHNvbWUgZGF0YVxuICAgICAgICBpZiAoISBzZWxmLmhpbnRzLmtleXdvcmQpIHtcbiAgICAgICAgICAgIHNlbGYuaGludHMgPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5rZXl3b3Jkc0hUTUxMaXN0ID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYuaGlkZUtleXdvcmRzKCk7XG4gICAgICAgICAgICBzZWxmLnJlbW92ZU1haW5LZXl3b3JkKCk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgc2VsZi5nZW5lcmF0ZUtleXdvcmRzSFRNTCgpO1xuICAgICAgICAgICAgaWYgKHNlbGYuc2hvd0hpbnRzKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5oaWRlS2V5d29yZHMoKTtcblxuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNlYXJjaC5pcygnOmZvY3VzJykpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zaG93S2V5d29yZHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnNob3dIaW50cyA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICghIHNlbGYuc2VhcmNoLmlzKCc6Zm9jdXMnKSlcbiAgICAgICAgICAgICAgICBzZWxmLmFkZE1haW5LZXl3b3JkKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cblNlYXJjaGJveC5wcm90b3R5cGUuY2hlY2tNYWluS2V5d29yZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChcbiAgICAgICAgKHRoaXMuaGludHMgIT09IG51bGwpXG4gICAgICAgICYmICh0aGlzLmhpbnRzLmtleXdvcmQgIT09IG51bGwpXG4gICAgKSB7XG4gICAgICAgIHZhciBtYWluS2V5d29yZCA9IHRoaXMuaGludHMua2V5d29yZDtcbiAgICAgICAgdmFyIGtleXdvcmRMZW5ndGggPSBtYWluS2V5d29yZC5sZW5ndGg7XG4gICAgICAgIHZhciBzZWFyY2hWYWx1ZSA9IHRoaXMuc2VhcmNoLnZhbCgpO1xuICAgICAgICB2YXIgc2VhcmNoTGVuZ3RoID0gc2VhcmNoVmFsdWUubGVuZ3RoO1xuXG4gICAgICAgIGlmICgoc2VhcmNoVmFsdWUubGVuZ3RoID4gMCkgJiYgdGhpcy5jaGVja0tleXdvcmRNYXRjaChtYWluS2V5d29yZCkpIHtcbiAgICAgICAgICAgIHRoaXMua2V5d29yZCA9IHNlYXJjaFZhbHVlICsgbWFpbktleXdvcmQuc3Vic3RyKHNlYXJjaExlbmd0aCwga2V5d29yZExlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5TZWFyY2hib3gucHJvdG90eXBlLmFkZE1haW5LZXl3b3JkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY2hlY2tNYWluS2V5d29yZCgpKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoSGludC52YWwodGhpcy5rZXl3b3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZU1haW5LZXl3b3JkKCk7XG4gICAgfVxufTtcblxuU2VhcmNoYm94LnByb3RvdHlwZS5yZW1vdmVNYWluS2V5d29yZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2VhcmNoSGludC52YWwoJycpO1xufTtcblxuU2VhcmNoYm94LnByb3RvdHlwZS5nZW5lcmF0ZUtleXdvcmRzSFRNTCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBrZXl3b3JkQWx0ZXJuYXRpdmVzID0gJ2tleXdvcmQtYWx0ZXJuYXRpdmVzJztcblxuICAgIGlmICh0aGlzLmhpbnRzW2tleXdvcmRBbHRlcm5hdGl2ZXNdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGh0bWwgPSAnPGRpdiBpZD1cInNlYXJjaC1hdXRvY29tcGxldGVcIj48dWw+JztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmhpbnRzW2tleXdvcmRBbHRlcm5hdGl2ZXNdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBodG1sICs9ICc8bGk+PGEgaHJlZj1cIiNcIj4nICsgdGhpcy5oaW50c1trZXl3b3JkQWx0ZXJuYXRpdmVzXVtpXSArICc8L2E+JztcbiAgICAgICAgfVxuICAgICAgICBodG1sICs9ICc8L3VsPjwvZGl2Pic7XG5cbiAgICAgICAgdGhpcy5rZXl3b3Jkc0hUTUxMaXN0ID0galF1ZXJ5KGh0bWwpO1xuICAgIH1cbn07XG5cblNlYXJjaGJveC5wcm90b3R5cGUuc2hvd0tleXdvcmRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICghdGhpcy5zcGVjaWFsS2V5d29yZCkge1xuICAgICAgICBpZiAodGhpcy5rZXl3b3Jkc0hUTUxMaXN0ICYmIHRoaXMuc2VhcmNoLnZhbCgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0galF1ZXJ5KCdib2R5Jyk7XG4gICAgICAgICAgICBib2R5LmZpbmQoJyNzZWFyY2gtYXV0b2NvbXBsZXRlJykucmVtb3ZlKCk7XG4gICAgICAgICAgICBib2R5LmFwcGVuZCh0aGlzLmtleXdvcmRzSFRNTExpc3QpO1xuXG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMuc2VhcmNoLm9mZnNldCgpLnRvcCArIHRoaXMuc2VhcmNoLm91dGVySGVpZ2h0KCk7XG4gICAgICAgICAgICB2YXIgeSA9IHRoaXMuc2VhcmNoLm9mZnNldCgpLmxlZnQ7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLnNlYXJjaC5vdXRlcldpZHRoKCk7XG5cbiAgICAgICAgICAgIHRoaXMua2V5d29yZHNIVE1MTGlzdC5jc3Moe1xuICAgICAgICAgICAgICAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgJ3RvcCc6IHgsXG4gICAgICAgICAgICAgICAgJ2xlZnQnOiB5LFxuICAgICAgICAgICAgICAgICd3aWR0aCc6IHdpZHRoXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5rZXl3b3Jkc0hUTUxMaXN0LmZpbmQoJ2EnKS5jbGljayhmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgc2VsZi5hY3RpdmVIaW50KGpRdWVyeSh0aGlzKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5zZWFyY2gub24oJ2tleWRvd24nLCB0aGlzLm9uU2VhcmNoS2V5RG93bik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5TZWFyY2hib3gucHJvdG90eXBlLmhpZGVLZXl3b3JkcyA9IGZ1bmN0aW9uKCkge1xuICAgIGpRdWVyeSgnYm9keScpLmZpbmQoJyNzZWFyY2gtYXV0b2NvbXBsZXRlJykucmVtb3ZlKCk7XG4gICAgdGhpcy5zZWFyY2gub2ZmKCdrZXlkb3duJywgdGhpcy5vblNlYXJjaEtleURvd24pO1xufTtcblxuU2VhcmNoYm94LnByb3RvdHlwZS5hY3RpdmVIaW50ID0gZnVuY3Rpb24obGluaykge1xuICAgIHZhciBrZXl3b3JkID0gbGluay50ZXh0KCk7XG5cbiAgICB0aGlzLnNob3dIaW50cyA9IGZhbHNlO1xuICAgIHRoaXMuc2VhcmNoLnZhbChrZXl3b3JkKTtcbiAgICB0aGlzLnNlbmRTZWFyY2hGb3JtKCk7XG4gICAgdGhpcy5hZGRNYWluS2V5d29yZCgpO1xufTtcblxuU2VhcmNoYm94LnByb3RvdHlwZS5jaGVja0tleXdvcmRNYXRjaCA9IGZ1bmN0aW9uKGtleXdvcmQpIHtcbiAgICB2YXIgc2VhcmNoVmFsdWUgPSB0aGlzLnNlYXJjaC52YWwoKTtcbiAgICB2YXIgc2VhcmNoTGVuZ3RoID0gc2VhcmNoVmFsdWUubGVuZ3RoO1xuICAgIHZhciBrZXl3b3JkU3RhcnRTdHJpbmcgPSBrZXl3b3JkLnN1YnN0cigwLCBzZWFyY2hMZW5ndGgpO1xuXG4gICAgaWYgKHNlYXJjaFZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IGtleXdvcmRTdGFydFN0cmluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5qUXVlcnkuZm4uc2VhcmNoYm94ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGpRdWVyeSh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICBuZXcgU2VhcmNoYm94KGpRdWVyeSh0aGlzKSk7XG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlYXJjaGJveDtcbiIsInZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcbnZhciBudW1iZXJzID0gcmVxdWlyZSgnLi4vdXRpbHMvbnVtYmVycycpO1xudmFyIHNldHRpbmdzID0gcmVxdWlyZSgnLi4vdXRpbHMvc2V0dGluZ3MnKTtcbnZhciBnZXN0dXJlcyA9IHJlcXVpcmUoJy4uL3V0aWxzL2dlc3R1cmVzJyk7XG52YXIgU2lnbmFsID0gcmVxdWlyZSgnLi4vdXRpbHMvc2lnbmFsJyk7XG5nZXN0dXJlcy5lbmFibGUoKTtcblxuLy8gQ2hlY2sgZm9yIHRyYW5zZm9ybSBzdXBwb3J0O1xudmFyIGNzc1RyYW5zZm9ybTtcbnZhciBwcmVmaXhlcyA9IFsndHJhbnNmb3JtJywgJy13ZWJraXQtdHJhbnNmb3JtJywgJy1tcy10cmFuc2Zvcm0nXTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKylcbiAgaWYgKHR5cGVvZiBkb2N1bWVudC5ib2R5LnN0eWxlW3ByZWZpeGVzW2ldXSAhPSAndW5kZWZpbmVkJylcbiAgICAgIGNzc1RyYW5zZm9ybSA9IHByZWZpeGVzW2ldO1xuXG5cbmZ1bmN0aW9uIFNsaWRlcihlbGVtZW50LCBvcHRpb25zKSB7XG4gIGpRdWVyeS5leHRlbmQodHJ1ZSwgdGhpcywgU2xpZGVyLkRFRkFVTFRfU0VUVElOR1MsIG9wdGlvbnMpO1xuXG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMuaXRlbXMgPSB0aGlzLmVsZW1lbnQuZmluZCgnPi5zbGlkZScpOyAvLyBJdGVtcyBpbiB0aGUgc2xpZGVyLlxuICB0aGlzLmNvdW50ID0gdGhpcy5pdGVtcy5sZW5ndGg7IC8vIENvdW50IG9mIGl0ZW1zIGluIHRoZSBzbGlkZXIuXG4gIHRoaXMuZGVzdGluYXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICB0aGlzLnRlbXBBdXRvID0gdGhpcy5hdXRvO1xuXG4gIHRoaXMuaXRlbVN0YXRlID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb3VudDsgaSsrKVxuICAgICAgdGhpcy5pdGVtU3RhdGUucHVzaChpKTtcblxuICB0aGlzLmFuaW1hdGVkID0gZmFsc2U7XG5cbiAgdGhpcy5pdGVtcy53cmFwQWxsKCc8ZGl2IGNsYXNzPVwic2xpZGVyLWNvbnRhaW5lclwiPjwvZGl2PicpO1xuICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuZWxlbWVudC5jaGlsZHJlbignLnNsaWRlci1jb250YWluZXInKTtcblxuICBpZiAodGhpcy5hdXRvKVxuICAgICAgdGhpcy5lbmFibGVBdXRvKCk7XG5cbiAgdGhpcy5zbGlkZXJUb3VjaCgpO1xuXG4gIGlmICh0aGlzLmFycm93cylcbiAgICAgIHRoaXMuY3JlYXRlQXJyb3dzKCk7XG5cbiAgaWYgKHRoaXMuZG90cylcbiAgICAgIHRoaXMuY3JlYXRlRG90cygpO1xuXG4gIHRoaXMub25DaGFuZ2VTbGlkZSA9IG5ldyBTaWduYWwoKTtcblxufVxuXG5TbGlkZXIuTU9ERV9ERUZBVUxUID0gJ2RlZmF1bHQnO1xuU2xpZGVyLk1PREVfQ0FST1VTRUwgPSAnY2Fyb3VzZWwnO1xuXG5TbGlkZXIuREVGQVVMVF9TRVRUSU5HUyA9IHtcbiAgJ2l0ZW1JbmRleCc6IDAsXG4gICdpdGVtU2l6ZSc6IDEwMCwgIC8vIFVzdWFsbHkgd2lkdGggb2Ygb25lIHNsaWRlIChvciBoZWlnaHQgaW4gY2FzZSBvZiB2ZXJ0aWNhbCBzbGlkZXIpLlxuICAncGVyUGFnZSc6IDEsIC8vIE51bWJlciBvZiBzbGlkZXMgcGVyIHBhZ2UuIENhbiBiZSAxIHRvIE4sIHdoZXJlIE4gPD0gdGhpcy5jb3VudC5cbiAgJ3N0ZXAnOiAxLFxuICAnZWFzZSc6IDAuMiwgLy8gU3BlZWQgb2YgYW5pbWF0aW9uLCBzbWFsbGVyIHZhbHVlIGlzIGZhc3Rlci5cbiAgJ3VuaXQnOiAnJScsIC8vICdweCdcbiAgJ2Fycm93cyc6IHRydWUsXG4gICdkb3RzJzogdHJ1ZSxcbiAgJ2F1dG8nOiB0cnVlLFxuICAnYXV0b0ludGVydmFsJzogODAwMCxcbiAgJ2FuaW1hdGVkUHJvcGVydHknOiAnbGVmdCcsXG4gICdtaW5Db3VudCc6IDEsXG4gICdtb2RlJzogU2xpZGVyLk1PREVfREVGQVVMVCxcbiAgJ3Bvc2l0aW9uJzogMCxcbiAgJ3Rha2VTaG9ydGN1dHMnOiB0cnVlLFxuICAndG91Y2hFbmFibGVkJzogdHJ1ZVxufTtcblxuU2xpZGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7XG4gIHZhciBjc3MgPSB7fTtcbiAgdmFyIGxpc3QgPSB0aGlzLmNvbnRhaW5lcjtcblxuICBpZiAodGhpcy5hbmltYXRlZFByb3BlcnR5ID09ICdsZWZ0JyB8fCB0aGlzLmFuaW1hdGVkUHJvcGVydHkgPT0gJ3RvcCcpIHtcbiAgICAgIGlmICh0aGlzLmFuaW1hdGVkUHJvcGVydHkgPT0gJ2xlZnQnKVxuICAgICAgICAgIHggPSB0aGlzLnBvc2l0aW9uO1xuXG4gICAgICBpZiAodGhpcy5hbmltYXRlZFByb3BlcnR5ID09ICd0b3AnKVxuICAgICAgICAgIHkgPSB0aGlzLnBvc2l0aW9uO1xuXG4gICAgICBjc3NbY3NzVHJhbnNmb3JtXSA9ICd0cmFuc2xhdGUoJyArIHggKyB0aGlzLnVuaXQgKyAnLCAnICsgeSArIHRoaXMudW5pdCArICcpJztcbiAgfSBlbHNlXG4gICAgICBjc3NbdGhpcy5hbmltYXRlZFByb3BlcnR5XSA9IE1hdGgucm91bmQodGhpcy5wb3NpdGlvbikgKyB0aGlzLnVuaXQ7XG5cbiAgbGlzdC5jc3MoY3NzKTtcbn07XG5cblNsaWRlci5wcm90b3R5cGUuYW5pbWF0ZSA9IGZ1bmN0aW9uKGluc3RhbnQpIHtcbiAgdmFyIG5ld0l0ZW1JbmRleDtcblxuICB0aGlzLmFuaW1hdGVkID0gdHJ1ZTtcblxuICBpZiAodGhpcy5wb3NpdGlvbiA9PSB0aGlzLmRlc3RpbmF0aW9uKSB7XG4gICAgICB0aGlzLmFuaW1hdGVkID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5zdGFudClcbiAgICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuXG4gIHZhciBkaXN0YW5jZSA9IHRoaXMuZGVzdGluYXRpb24gLSB0aGlzLnBvc2l0aW9uO1xuXG4gIGlmIChNYXRoLmFicyhkaXN0YW5jZSkgPCAodGhpcy51bml0ID09ICclJyA/IDAuMSA6IDEpKSB7XG4gICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgfSBlbHNlIHtcbiAgICAgIHRoaXMucG9zaXRpb24gKz0gTWF0aC5hYnMoZGlzdGFuY2UpICogdGhpcy5lYXNlICogTWF0aC5zaWduKGRpc3RhbmNlKTtcbiAgICAvL2FsZXJ0KHRoaXMucG9zaXRpb24gKyAnICcgKyB0aGlzLmRlc3RpbmF0aW9uKVxuICB9XG5cbiAgLy9DYXJvdXNlbCBtb2RlIHJlcXVpcmVkIG1vdmluZyBzbGlkZXIgZWxlbWVudHMgZnJvbSBiZWdpbm5pbmcgdG8gdGhlIGVuZCBhbmQgdmljZSB2ZXJzYS5cbiAgaWYgKHRoaXMubW9kZSA9PSBTbGlkZXIuTU9ERV9DQVJPVVNFTCkge1xuICAgICAgaWYgKGRpc3RhbmNlIDwgMCAmJiB0aGlzLnBvc2l0aW9uIDw9IC10aGlzLml0ZW1TaXplKVxuICAgICAgICAgIHRoaXMuYXBwZW5kKCk7XG5cbiAgICAgIGlmIChkaXN0YW5jZSA+IDAgJiYgdGhpcy5wb3NpdGlvbiA+IDApXG4gICAgICAgICAgdGhpcy5wcmVwZW5kKCk7XG5cbiAgICAgIG5ld0l0ZW1JbmRleCA9IG51bWJlcnMubW9kKHRoaXMuaXRlbVN0YXRlWzBdICsgTWF0aC5yb3VuZCgtdGhpcy5wb3NpdGlvbiAvIHRoaXMuaXRlbVNpemUpLCB0aGlzLmNvdW50KTtcbiAgfSBlbHNlXG4gICAgICBuZXdJdGVtSW5kZXggPSBNYXRoLnJvdW5kKC10aGlzLnBvc2l0aW9uIC8gdGhpcy5pdGVtU2l6ZSk7XG5cbiAgaWYgKHR5cGVvZiBuZXdJdGVtSW5kZXggIT0gJ3VuZGVmaW5lZCcgJiYgbmV3SXRlbUluZGV4ICE9IHRoaXMuaXRlbUluZGV4KSB7XG4gICAgICB0aGlzLml0ZW1JbmRleCA9IG5ld0l0ZW1JbmRleDtcbiAgICAgIHRoaXMub25DaGFuZ2VTbGlkZS5zZW5kKHRoaXMuaXRlbUluZGV4KTtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICAvLyBBY3R1YWxseSBtb3ZlIHRoZSBzbGlkZXIgZWxlbWVudHMuXG4gIHRoaXMucmVuZGVyKCk7XG5cbiAgaWYgKHRoaXMuX3RpbWVyKVxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuYW5pbWF0ZS5iaW5kKHRoaXMpLCAzMyk7XG5cblxufTtcblxuU2xpZGVyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wb3NpdGlvbiArPSB0aGlzLml0ZW1TaXplO1xuICB0aGlzLmRlc3RpbmF0aW9uICs9IHRoaXMuaXRlbVNpemU7XG5cbiAgdGhpcy5pdGVtU3RhdGUucHVzaCh0aGlzLml0ZW1TdGF0ZS5zaGlmdCgpKTtcblxuICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnQuZmluZCgnLnNsaWRlJyk7XG4gIGVsZW1lbnRzLmZpcnN0KCkuaW5zZXJ0QWZ0ZXIoZWxlbWVudHMubGFzdCgpKTtcbn07XG5cblNsaWRlci5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnBvc2l0aW9uIC09IHRoaXMuaXRlbVNpemU7XG4gIHRoaXMuZGVzdGluYXRpb24gLT0gdGhpcy5pdGVtU2l6ZTtcblxuICB0aGlzLml0ZW1TdGF0ZS51bnNoaWZ0KHRoaXMuaXRlbVN0YXRlLnBvcCgpKTtcblxuICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnQuZmluZCgnLnNsaWRlJyk7XG4gIGVsZW1lbnRzLmxhc3QoKS5pbnNlcnRCZWZvcmUoZWxlbWVudHMuZmlyc3QoKSk7XG59O1xuXG5TbGlkZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5ld0l0ZW1JbmRleCwgcG9zaXRpb247XG5cbiAgaWYgKHRoaXMubW9kZSA9PSBTbGlkZXIuTU9ERV9ERUZBVUxUKSB7XG4gICAgICBuZXdJdGVtSW5kZXggPSBNYXRoLm1pbih0aGlzLml0ZW1JbmRleCArIHRoaXMuc3RlcCwgdGhpcy5jb3VudCk7XG5cbiAgICAgIGlmICgobmV3SXRlbUluZGV4ID09IHRoaXMuaXRlbUluZGV4KSB8fCAobmV3SXRlbUluZGV4ID09IHRoaXMuY291bnQpKVxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgcG9zaXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uIC0gKG5ld0l0ZW1JbmRleCAtIHRoaXMuaXRlbUluZGV4KSAqIHRoaXMuaXRlbVNpemU7XG4gIH0gZWxzZVxuICAgICAgcG9zaXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uICsgdGhpcy5zdGVwICogdGhpcy5pdGVtU2l6ZTtcblxuICB0aGlzLnNsaWRlVG8ocG9zaXRpb24pO1xufTtcblxuU2xpZGVyLnByb3RvdHlwZS5wcmV2aW91cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbmV3SXRlbUluZGV4LCBwb3NpdGlvbjtcblxuICBpZiAodGhpcy5tb2RlID09IFNsaWRlci5NT0RFX0RFRkFVTFQpIHtcbiAgICAgIG5ld0l0ZW1JbmRleCA9IE1hdGgubWF4KDAsIHRoaXMuaXRlbUluZGV4IC0gdGhpcy5zdGVwKTtcblxuICAgICAgaWYgKG5ld0l0ZW1JbmRleCA9PSB0aGlzLml0ZW1JbmRleClcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgIHBvc2l0aW9uID0gdGhpcy5kZXN0aW5hdGlvbiArICh0aGlzLml0ZW1JbmRleCAtIG5ld0l0ZW1JbmRleCkgKiB0aGlzLml0ZW1TaXplO1xuICB9IGVsc2VcbiAgICAgIHBvc2l0aW9uID0gdGhpcy5kZXN0aW5hdGlvbiAtIHRoaXMuc3RlcCAqIHRoaXMuaXRlbVNpemU7XG5cbiAgdGhpcy5zbGlkZVRvKHBvc2l0aW9uKTtcbn07XG5cblNsaWRlci5wcm90b3R5cGUuc2xpZGVUbyA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gIGlmICh0aGlzLnRlbXBBdXRvICYmIHRoaXMuYXV0bylcbiAgICAgIHRoaXMuZGlzYWJsZUF1dG8oKTtcblxuICB0aGlzLmRlc3RpbmF0aW9uID0gcG9zaXRpb247XG4gIHRoaXMuYW5pbWF0ZSgpO1xuXG4gIGlmICghKHRoaXMudGVtcEF1dG8pICYmIHRoaXMuYXV0bylcbiAgICAgIHRoaXMuZW5hYmxlQXV0bygpO1xuXG59O1xuXG5TbGlkZXIucHJvdG90eXBlLnNsaWRlVG9JbmRleCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHZhciBwb3NpdGlvbjtcbiAgdmFyIGhhbGYgPSB0aGlzLml0ZW1TdGF0ZS5sZW5ndGggLyAyO1xuXG4gIGlmICh0aGlzLm1vZGUgPT0gU2xpZGVyLk1PREVfREVGQVVMVClcbiAgICAgIHBvc2l0aW9uID0gLWluZGV4ICogdGhpcy5pdGVtU2l6ZTtcbiAgZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbVN0YXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMuaXRlbVN0YXRlW2ldKSB7XG4gICAgICAgICAgICAgIGlmICgodGhpcy50YWtlU2hvcnRjdXRzICYmIGkgPCBoYWxmKSB8fCBpbmRleCA+IHRoaXMuaXRlbUluZGV4KVxuICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSAtaSAqIHRoaXMuaXRlbVNpemU7XG4gICAgICAgICAgICAgIGVsc2UgaWYgKCh0aGlzLnRha2VTaG9ydGN1dHMgJiYgaSA+IGhhbGYpIHx8IGluZGV4IDw9IHRoaXMuaXRlbUluZGV4KVxuICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSAodGhpcy5pdGVtU3RhdGUubGVuZ3RoLWkpICogdGhpcy5pdGVtU2l6ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9XG5cbiAgdGhpcy5zbGlkZVRvKHBvc2l0aW9uKTtcbn07XG5cblNsaWRlci5wcm90b3R5cGUuY3JlYXRlQXJyb3dzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICh0aGlzLml0ZW1TdGF0ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBuYXZpZ2F0aW9uID0gJzxidXR0b24gaHJlZj1cIiNcIiBjbGFzcz1cImljb24tYXJyb3ctbGVmdCBzbGlkZXItbmF2aWdhdGlvbiBwcmV2aW91c1wiPjwvYnV0dG9uPjxidXR0b24gaHJlZj1cIiNcIiBjbGFzcz1cImljb24tYXJyb3ctcmlnaHQgc2xpZGVyLW5hdmlnYXRpb24gbmV4dFwiPjwvYnV0dG9uPic7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmQobmF2aWdhdGlvbik7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRDbGFzcygnbmF2aWdhdGlvbnMnKTtcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQuZmluZCgnLnNsaWRlci1uYXZpZ2F0aW9uJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgalF1ZXJ5KHRoaXMpLmNsaWNrKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgdmFyIG5hdmlnYXRpb25MaW5rID0galF1ZXJ5KHRoaXMpO1xuICAgICAgICAgICAgaWYgKG5hdmlnYXRpb25MaW5rLmhhc0NsYXNzKCdwcmV2aW91cycpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubW9kZSA9PT0gU2xpZGVyLk1PREVfREVGQVVMVCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnByZXZpb3VzKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChuYXZpZ2F0aW9uTGluay5oYXNDbGFzcygnbmV4dCcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubW9kZSA9PT0gU2xpZGVyLk1PREVfREVGQVVMVCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnByZXZpb3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cblNsaWRlci5wcm90b3R5cGUuY3JlYXRlRG90cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLml0ZW1TdGF0ZS5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgbmF2aWdhdGlvbiA9ICc8dWwgY2xhc3M9XCJuYXZpZ2F0aW9uLWxpc3RcIiByb2xlPVwibGlzdGJveFwiPic7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbVN0YXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgPT0gMClcbiAgICAgICAgICAgICAgbmF2aWdhdGlvbiArPSAnPGxpIGNsYXNzPVwiYWN0aXZlXCIgcm9sZT1cIm9wdGlvblwiIGFyaWEtc2VsZWN0ZWQ9XCJmYWxzZVwiPjxhIGhyZWY9XCIjXCIgZGF0YS1zbGlkZT1cIicraSsnXCIgdGFiaW5kZXg9XCIxXCIgYXJpYS1zZWxlY3RlZD1cIjFcIiB0aXRsZT1cIlplaWdlIEJlaXRyYWcgJysoaSsxKSsnXCIvPjwvbGk+JztcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG5hdmlnYXRpb24gKz0gJzxsaSByb2xlPVwib3B0aW9uXCIgYXJpYS1zZWxlY3RlZD1cImZhbHNlXCI+PGEgaHJlZj1cIiNcIiBkYXRhLXNsaWRlPVwiJytpKydcIiB0YWJpbmRleD1cIi0xXCIgdGl0bGU9XCJaZWlnZSBCZWl0cmFnICcrKGkrMSkrJ1wiIC8+PC9saT4nO1xuICAgICAgfVxuICAgICAgbmF2aWdhdGlvbiArPSAnPC91bD4nO1xuICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZChuYXZpZ2F0aW9uKTtcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRDbGFzcygnbmF2aWdhdGlvbnMnKTtcblxuICAgICAgdGhpcy5lbGVtZW50LmZpbmQoJy5uYXZpZ2F0aW9uLWxpc3QgYScpLmNsaWNrKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IGpRdWVyeSh0aGlzKTtcbiAgICAgICAgICB2YXIgc2xpZGVJbmRleCA9IGVsZW1lbnQuZGF0YSgnc2xpZGUnKTtcblxuICAgICAgICAgIHNlbGYuc2xpZGVUb0luZGV4KHNsaWRlSW5kZXgpO1xuICAgICAgfSk7XG4gIH1cbn07XG5cblNsaWRlci5wcm90b3R5cGUuZW5hYmxlQXV0byA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnRlbXBBdXRvID0gdHJ1ZTtcblxuICBpZiAodGhpcy5jb3VudCA8PSB0aGlzLnBlclBhZ2UpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHRoaXMuX2F1dG9UaW1lcilcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fYXV0b1RpbWVyKTtcblxuICB0aGlzLl9hdXRvVGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLnByZXZpb3VzLmJpbmQodGhpcyksIHRoaXMuYXV0b0ludGVydmFsKTtcbn07XG5cblNsaWRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMuZG90cykge1xuICAgICAgdmFyIGRvdHMgPSB0aGlzLmVsZW1lbnQuZmluZCgnLm5hdmlnYXRpb24tbGlzdCBsaScpO1xuICAgICAgZG90cy5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICBkb3RzLmZpbmQoJ2EnKS5yZW1vdmVBdHRyKCdhcmlhLXNlbGVjdGVkJyk7XG4gICAgICBkb3RzLmZpbmQoJ2EnKS5hdHRyKCd0YWJpbmRleCcsIC0xKTtcbiAgICAgIGRvdHMuZXEoc2VsZi5pdGVtSW5kZXgpLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICAgIGRvdHMuZXEoc2VsZi5pdGVtSW5kZXgpLmZpbmQoJ2EnKS5hdHRyKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSk7XG4gICAgICBkb3RzLmVxKHNlbGYuaXRlbUluZGV4KS5maW5kKCdhJykuYXR0cigndGFiaW5kZXgnLCAxKTtcbiAgfVxufTtcblxuU2xpZGVyLnByb3RvdHlwZS5kaXNhYmxlQXV0byA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnRlbXBBdXRvID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuX2F1dG9UaW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9hdXRvVGltZXIpO1xuICAgICAgZGVsZXRlIHRoaXMuX2F1dG9UaW1lcjtcbiAgfVxufTtcblxuU2xpZGVyLnByb3RvdHlwZS5zbGlkZXJUb3VjaCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLnRvdWNoRW5hYmxlZCkge1xuICAgICAgICBnZXN0dXJlcy5vblRvdWNoTW92ZShmdW5jdGlvbih0YXJnZXQsIHRvdWNoLCBldmVudCkge1xuICAgICAgICAgICAgdmFyIHNsaWRlckNoaWxkID0galF1ZXJ5LmNvbnRhaW5zKHNlbGYuZWxlbWVudFswXSwgdGFyZ2V0KTtcblxuICAgICAgICAgICAgaWYgKHNsaWRlckNoaWxkKVxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh0b3VjaC5keCkgPiBNYXRoLmFicyh0b3VjaC5keSkpXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGdlc3R1cmVzLm9uVG91Y2hFbmQoZnVuY3Rpb24odGFyZ2V0LCB0b3VjaCwgZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBzbGlkZXJDaGlsZCA9IGpRdWVyeS5jb250YWlucyhzZWxmLmVsZW1lbnRbMF0sIHRhcmdldCk7XG5cbiAgICAgICAgICAgIGlmIChzbGlkZXJDaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmICh0b3VjaC5keCA+IDAgJiYgdG91Y2guZHggPiAxMDApXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubmV4dCgpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRvdWNoLmR4IDwgMCAmJiB0b3VjaC5keCA8IC0xMDApXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucHJldmlvdXMoKTtcblxuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5qUXVlcnkuZm4uc2xpZGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbmV3IFNsaWRlcihqUXVlcnkodGhpcyksIG9wdGlvbnMpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2xpZGVyO1xuIiwidmFyIGpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xyXG5mdW5jdGlvbiB0aHJvdHRsZSAoc2NvcGUsIGRlbGF5LCBjYWxsYmFjaykge1xyXG4gICAgdmFyIGRlbGF5ID0gZGVsYXkgfHwgMjUwO1xyXG4gICAgdmFyIGxhc3RFeGVjdXRpb24sIHRpbWVyO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuXHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSBzY29wZSB8fCB0aGlzO1xyXG5cclxuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUsXHJcbiAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XHJcblxyXG4gICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbGFzdEV4ZWN1dGlvbiA9IG5vdy5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChsYXN0RXhlY3V0aW9uICYmIG5vdy5nZXRUaW1lKCkgPCBsYXN0RXhlY3V0aW9uICsgZGVsYXkpXHJcbiAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmbiwgZGVsYXkpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgZm4oKTtcclxuICAgIH07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gdGhyb3R0bGU7XHJcbiIsInZhciBEZWJvdW5jZSA9IHJlcXVpcmUoJy4uL3V0aWxzL2RlYm91bmNlLmpzJyk7XG52YXIgVGhyb3R0bGUgPSByZXF1aXJlKCcuLi91dGlscy90aHJvdHRsZS5qcycpXG5cbmZ1bmN0aW9uIFRvcE1lbnUodG9wTWVudSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLnRvcE1lbnUgPSB0b3BNZW51O1xuXG4gICAgdGhpcy5ib2R5ID0galF1ZXJ5KCdib2R5Jyk7XG4gICAgdGhpcy53aW5kb3cgPSBqUXVlcnkod2luZG93KTtcbiAgICB0aGlzLnBhZ2VXcmFwcGVyID0gdGhpcy5ib2R5LmZpbmQoJy5wYWdlLXdyYXAnKTtcbiAgICB0aGlzLnBhZ2VDb250YWluZXIgPSB0aGlzLnBhZ2VXcmFwcGVyLmZpbmQoJy5jb250YWluZXInKTtcblxuICAgIHRoaXMubGlzdEl0ZW0gPSB0aGlzLnRvcE1lbnUuZmluZCgnLnRvcC1tZW51X19saXN0LWl0ZW0nKTtcbiAgICB0aGlzLmxpc3RJdGVtRGlzcGxheWVkID0gdGhpcy50b3BNZW51LmZpbmQoJy50b3AtbWVudV9fbGlzdC1pdGVtLS1kaXNwbGF5ZWQnKTtcbiAgICB0aGlzLmxpc3RMaW5rID0gdGhpcy5saXN0SXRlbURpc3BsYXllZC5maW5kKCcudG9wLW1lbnVfX2xpc3QtbGluaycpO1xuICAgIHRoaXMuc2Vjb25kTGV2ZWxNZW51ID0gdGhpcy50b3BNZW51LmZpbmQoJy50b3AtbWVudV9fbGV2ZWwyJyk7XG4gICAgdGhpcy50aGlyZExldmVsTWVudSA9IHRoaXMubGlzdEl0ZW1EaXNwbGF5ZWQuZmluZCgnLnRvcC1tZW51X19sZXZlbDMnKTtcbiAgICB0aGlzLnRoaXJkTGV2ZWxJdGVtcyA9IHRoaXMubGlzdEl0ZW1EaXNwbGF5ZWQuZmluZCgnLnRvcC1tZW51X19sZXZlbDMtaXRlbScpO1xuICAgIHRoaXMuc2Vjb25kTGV2ZWxMaW5rID0gdGhpcy5saXN0SXRlbURpc3BsYXllZC5maW5kKCcudG9wLW1lbnVfX2xldmVsMi1saW5rJyk7XG4gICAgdGhpcy50aGlyZExldmVsTGluayA9IHRoaXMubGlzdEl0ZW1EaXNwbGF5ZWQuZmluZCgnLnRvcC1tZW51X19saXN0LWxpbmsnKTtcbiAgICB0aGlzLm9mZnNldE1lbnUgPSB0aGlzLmxpc3RJdGVtRGlzcGxheWVkLmZpbmQoJy50b3AtbWVudV9fb2Zmc2V0LW1lbnUnKTtcbiAgICB0aGlzLmZvdXJ0aExldmVsTWVudSA9IHRoaXMub2Zmc2V0TWVudS5maW5kKCcudG9wLW1lbnVfX2xldmVsNCcpO1xuICAgIHRoaXMuZXhwYW5kZWRTdWJtZW51ID0gdGhpcy50b3BNZW51LmZpbmQoJy50b3AtbWVudV9fc3VibWVudScpO1xuICAgIHRoaXMuY2xvc2VTdWJtZW51QnV0dG9uID0gdGhpcy50b3BNZW51LmZpbmQoJy50b3AtbWVudV9fY2xvc2UtaWNvbicpO1xuICAgIHRoaXMubGV2ZWxTdWJtZW51ID0gdGhpcy5vZmZzZXRNZW51LmZpbmQoJy50b3AtbWVudV9fc3VibGlzdCcpO1xuICAgIHRoaXMuZGVlcGVyTGV2ZWxNZW51ID0gdGhpcy5vZmZzZXRNZW51LmZpbmQoJy50b3AtbWVudV9fZGVlcGVyLWxldmVsJyk7XG4gICAgdGhpcy5kZWVwZXJMZXZlbEl0ZW0gPSB0aGlzLm9mZnNldE1lbnUuZmluZCgnLnRvcC1tZW51X19zdWJsaXN0LWl0ZW0nKTtcbiAgICB0aGlzLmRlZXBlckxldmVsTGluayA9IHRoaXMub2Zmc2V0TWVudS5maW5kKCcudG9wLW1lbnVfX3N1Ymxpc3QtbGluaycpO1xuICAgIHRoaXMubWVudUJ1dHRvbiA9IHRoaXMub2Zmc2V0TWVudS5maW5kKCcudG9wLW1lbnVfX2J1dHRvbicpO1xuICAgIHRoaXMubGVmdE1lbnVCdXR0b24gPSB0aGlzLm9mZnNldE1lbnUuZmluZCgnLnRvcC1tZW51X19idXR0b24tLWxlZnQnKTtcbiAgICB0aGlzLnJpZ2h0TWVudUJ1dHRvbiA9IHRoaXMub2Zmc2V0TWVudS5maW5kKCcudG9wLW1lbnVfX2J1dHRvbi0tcmlnaHQnKTtcbiAgICB0aGlzLmxpc3RMZW5ndGggPSB0aGlzLnRoaXJkTGV2ZWxJdGVtcy5zaXplKCk7XG4gICAgdGhpcy5sYXN0SXRlbSA9ICQodGhpcy50aGlyZExldmVsSXRlbXNbdGhpcy5saXN0TGVuZ3RoLTFdKTtcbiAgICB0aGlzLmxhc3RJdGVtV2lkdGggPSB0aGlzLmxhc3RJdGVtLndpZHRoKCk7XG4gICAgdGhpcy5maXJzdEl0ZW0gPSAkKHRoaXMudGhpcmRMZXZlbEl0ZW1zWzBdKTtcbiAgICB0aGlzLmZpcnN0V2lkdGggPSB0aGlzLmZpcnN0SXRlbS53aWR0aCgpO1xuICAgIHRoaXMuY3VycmVudFBhZ2UgPSB0aGlzLmRlZXBlckxldmVsTGluay5maWx0ZXIoJy50b3AtbWVudV9fc3VibGlzdC1saW5rLS1jdXJyZW50LXBhZ2UnKTtcblxuXG4gICAgaWYgKHRoaXMub2Zmc2V0TWVudS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgdGhpcy5kZWVwZXJMZXZlbE1lbnUuY3NzKCdsZWZ0JywgdGhpcy5wYWdlQ29udGFpbmVyLndpZHRoKCkvMik7XG5cbiAgICAgICAgdGhpcy5zZXRTdWJtZW51U2l6ZSgpO1xuICAgICAgICB0aGlzLnNob3dDdXJyZW50SXRlbSgpO1xuICAgICAgICB0aGlzLnNldE9mZnNldFBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuY2hlY2tGb3VydGhMZXZlbFN1Ym1lbnVFeGlzdGFuY2UoKTtcbiAgICAgICAgdGhpcy5jaGVja0RlZXBlckxldmVsU3VibWVudUV4aXN0YW5jZSgpO1xuXG4gICAgICAgIHRoaXMud2luZG93Lm9uKCdyZXNpemUnLCB0aGlzLnVwZGF0ZU9uUmVzaXplLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLndpbmRvdy5vbignZm9udC1yZWxvYWQnLCB0aGlzLnVwZGF0ZU9uUmVzaXplLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmRlZXBlckxldmVsTGluay5vbignY2xpY2snLCB0aGlzLnNob3dEZWVwZXJNZW51TGV2ZWwuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuY2xvc2VTdWJtZW51QnV0dG9uLm9uKCdjbGljaycsIHRoaXMuY2xvc2VNZW51LmJpbmQodGhpcykpO1xuICAgICAgICAkKGRvY3VtZW50KS5vbignbW91c2V1cCcsIHRoaXMuY2xvc2VNZW51V2l0aFJhbmRvbUNsaWNrLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnJpZ2h0TWVudUJ1dHRvbi5vbignY2xpY2snLCB0aGlzLnByZXZlbnREZWZhdWx0QmVoYXZpb3IuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMubGVmdE1lbnVCdXR0b24ub24oJ2NsaWNrJywgdGhpcy5wcmV2ZW50RGVmYXVsdEJlaGF2aW9yLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnJpZ2h0TWVudUJ1dHRvbi5vbmUoJ2NsaWNrJywgdGhpcy5zbGlkZVJpZ2h0LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmxlZnRNZW51QnV0dG9uLm9uZSgnY2xpY2snLCB0aGlzLnNsaWRlTGVmdC5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLnRoaXJkTGV2ZWxMaW5rLm9uKCdjbGljaycsIGpRdWVyeS5kZWJvdW5jZSg1MDAsIHRydWUsIHRoaXMuc2hvd01lbnUuYmluZCh0aGlzKSkpO1xuICAgIH1cbn1cblxuVG9wTWVudS5wcm90b3R5cGUucHJldmVudERlZmF1bHRCZWhhdmlvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG59XG5cblRvcE1lbnUucHJvdG90eXBlLnNldE9mZnNldFBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlZnRQb3NpdGlvbiA9IHRoaXMuc2Vjb25kTGV2ZWxNZW51Lm9mZnNldCgpLmxlZnQ7XG4gICAgdGhpcy5vZmZzZXRNZW51Lm9mZnNldCh7bGVmdDogbGVmdFBvc2l0aW9ufSk7XG59XG5cblRvcE1lbnUucHJvdG90eXBlLnNob3dDdXJyZW50SXRlbSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY3VycmVudFBhZ2UucGFyZW50cygnLnRvcC1tZW51X19sZXZlbDMtaXRlbScpLmFkZENsYXNzKCd0b3AtbWVudV9fbGlzdC1pdGVtLS1kaXNwbGF5ZWQnKTtcblxuICAgIHZhciBjdXJyZW50UGFnZUl0ZW0gPSB0aGlzLnRoaXJkTGV2ZWxJdGVtcy5maWx0ZXIoJy50b3AtbWVudV9fbGlzdC1pdGVtLS1kaXNwbGF5ZWQnKTtcbiAgICB2YXIgaXRlbVBvc2l0aW9uID0gY3VycmVudFBhZ2VJdGVtLm9mZnNldCgpLmxlZnQ7XG4gICAgdmFyIG1lbnVXaWR0aCA9IHRoaXMudGhpcmRMZXZlbE1lbnUud2lkdGgoKTtcbiAgICB2YXIgbmV3UG9zaXRpb24gPSBpdGVtUG9zaXRpb24gLSBtZW51V2lkdGgvMjtcblxuICAgIGlmIChpdGVtUG9zaXRpb24gPiBtZW51V2lkdGggJiYgbWVudVdpZHRoID4gdGhpcy5ib2R5LndpZHRoKCkpIHtcbiAgICAgICAgdGhpcy50aGlyZExldmVsSXRlbXMuYW5pbWF0ZSh7bGVmdDogJy09JyArIG5ld1Bvc2l0aW9ufSwgNTAwKTtcbiAgICAgICAgY3VycmVudFBhZ2VJdGVtLmNoaWxkcmVuKCcudG9wLW1lbnVfX2xpc3QtbGluaycpLmFkZENsYXNzKCd0b3AtbWVudV9fbGlzdC1saW5rLS1hY3RpdmUnKTtcbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KHRoaXMuY2hlY2tNZW51TGVuZ3RoLmJpbmQodGhpcyksIDEwMDApO1xufVxuXG5Ub3BNZW51LnByb3RvdHlwZS51cGRhdGVPblJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0T2Zmc2V0UG9zaXRpb24oKTtcbiAgICB0aGlzLnNldFN1Ym1lbnVTaXplKCk7XG4gICAgdGhpcy5jaGVja01lbnVMZW5ndGgoKTtcbiAgICB0aGlzLmNoZWNrRm91cnRoTGV2ZWxTdWJtZW51RXhpc3RhbmNlKCk7XG4gICAgdGhpcy5jaGVja0RlZXBlckxldmVsU3VibWVudUV4aXN0YW5jZSgpO1xuICAgIHRoaXMuc2hvd0N1cnJlbnRJdGVtKCk7XG59XG5cblRvcE1lbnUucHJvdG90eXBlLnNldFN1Ym1lbnVTaXplID0gZnVuY3Rpb24oY3VycmVudEhlaWdodCkge1xuICAgIHZhciBjdXJyZW50V2lkdGggPSB0aGlzLnBhZ2VDb250YWluZXIud2lkdGgoKTtcblxuICAgIGlmICghY3VycmVudEhlaWdodCkge1xuICAgICAgICB2YXIgY3VycmVudEhlaWdodCA9IHRoaXMubGV2ZWxTdWJtZW51LmhlaWdodCgpO1xuICAgIH0gICAgXG5cbiAgICB0aGlzLmV4cGFuZGVkU3VibWVudS5jc3Moe1xuICAgICAgICB3aWR0aDogY3VycmVudFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGN1cnJlbnRIZWlnaHQgKyA0MFxuICAgIH0pO1xuXG4gICAgdGhpcy5vZmZzZXRNZW51LmNzcyh7XG4gICAgICAgIHdpZHRoOiBjdXJyZW50V2lkdGggLSAxNixcbiAgICAgICAgaGVpZ2h0OiBjdXJyZW50SGVpZ2h0ICsgODBcbiAgICB9KTtcblxuICAgIHRoaXMuZXhwYW5kZWRTdWJtZW51LmhlaWdodChjdXJyZW50SGVpZ2h0ICsgNDApO1xufVxuXG5Ub3BNZW51LnByb3RvdHlwZS5jaGVja0ZvdXJ0aExldmVsU3VibWVudUV4aXN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGhpcmRMZXZlbEl0ZW1zLmVhY2goZnVuY3Rpb24oaSwgZSl7XG4gICAgICAgIGlmKCQoZSkuaGFzKCcudG9wLW1lbnVfX2xldmVsNCcpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgJChlKS5maW5kKCcudG9wLW1lbnVfX2xpc3QtbGluaycpLmFkZENsYXNzKCdpY29uLWFycm93LWRvd24nKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5Ub3BNZW51LnByb3RvdHlwZS5jaGVja0RlZXBlckxldmVsU3VibWVudUV4aXN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGVlcGVyTGV2ZWxJdGVtLmVhY2goZnVuY3Rpb24oaSwgZSl7XG4gICAgICAgIGlmKCQoZSkuaGFzKCcudG9wLW1lbnVfX3N1Ymxpc3QnKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICQoZSkuY2hpbGRyZW4oJy50b3AtbWVudV9fc3VibGlzdC1saW5rJykuYWRkQ2xhc3MoJ3RvcC1tZW51X19zdWJsaXN0LWxpbmstLWFycm93LXJpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuVG9wTWVudS5wcm90b3R5cGUuc2hvd0RlZXBlck1lbnVMZXZlbCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgdmFyIGNsaWNrZWRMaW5rID0gJChlbC50YXJnZXQpO1xuICAgIHZhciBzdWJsaXN0ID0gY2xpY2tlZExpbmsuc2libGluZ3MoJy50b3AtbWVudV9fZGVlcGVyLWxldmVsJyk7XG4gICAgdmFyIGNsaWNrZWRMaW5rUGFyZW50ID0gY2xpY2tlZExpbmsucGFyZW50KCk7XG4gICAgdmFyIGNsaWNrZWRMaW5rUGFyZW50U2libGluZ3MgPSBjbGlja2VkTGlua1BhcmVudC5zaWJsaW5ncygpO1xuICAgIHZhciBjdXJyZW50SGVpZ2h0ID0gMDtcblxuICAgIGlmICgoY2xpY2tlZExpbmsuc2libGluZ3MoJy50b3AtbWVudV9fZGVlcGVyLWxldmVsJykubGVuZ3RoICE9PSAwKSAmJiAhKGNsaWNrZWRMaW5rLmhhc0NsYXNzKCd0b3AtbWVudV9fc3VibGlzdC1saW5rLS1iYWNrJykpKSB7XG4gICAgICAgIGVsLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgY2xpY2tlZExpbmsuaGlkZSgpO1xuXG4gICAgICAgIGNsaWNrZWRMaW5rUGFyZW50U2libGluZ3MuYWRkQ2xhc3MoJ3RvcC1tZW51X19zdWJsaXN0LWl0ZW0tLWhpZGRlbicpO1xuICAgICAgICBzdWJsaXN0LmFkZENsYXNzKCd0b3AtbWVudV9fZGVlcGVyLWxldmVsLS12aXNpYmxlJykuY3NzKCdsZWZ0JywgMCk7XG5cbiAgICAgICAgY3VycmVudEhlaWdodCA9IGNsaWNrZWRMaW5rLnNpYmxpbmdzKCcudG9wLW1lbnVfX3N1Ymxpc3QnKS5oZWlnaHQoKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuc2V0U3VibWVudVNpemUoY3VycmVudEhlaWdodCk7XG4gICAgfSBlbHNlIGlmIChjbGlja2VkTGluay5oYXNDbGFzcygndG9wLW1lbnVfX3N1Ymxpc3QtbGluay0tYmFjaycpKXtcbiAgICAgICAgZWwucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIHN1Ymxpc3RQYXJlbnQgPSBjbGlja2VkTGluay5jbG9zZXN0KCcudG9wLW1lbnVfX3N1Ymxpc3QnKTsgXG5cbiAgICAgICAgc3VibGlzdFBhcmVudC5yZW1vdmVDbGFzcygndG9wLW1lbnVfX2RlZXBlci1sZXZlbC0tdmlzaWJsZScpLmNzcygnbGVmdCcsIHRoaXMucGFnZUNvbnRhaW5lci53aWR0aCgpLzIpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzdWJsaXN0UGFyZW50LnNpYmxpbmdzKCcudG9wLW1lbnVfX3N1Ymxpc3QtbGluaycpLnNob3coKTtcbiAgICAgICAgICAgIHN1Ymxpc3RQYXJlbnQuY2xvc2VzdCgnLnRvcC1tZW51X19zdWJsaXN0LWl0ZW0nKS5zaWJsaW5ncygpLnJlbW92ZUNsYXNzKCd0b3AtbWVudV9fc3VibGlzdC1pdGVtLS1oaWRkZW4nKTtcbiAgICAgICAgICAgIGN1cnJlbnRIZWlnaHQgPSBzdWJsaXN0UGFyZW50LmNsb3Nlc3QoJy50b3AtbWVudV9fc3VibGlzdC1pdGVtJykucGFyZW50KCkuaGVpZ2h0KCk7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0U3VibWVudVNpemUoY3VycmVudEhlaWdodCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSwgMjAwKTsgICAgIFxuICAgIH1cblxufVxuXG5Ub3BNZW51LnByb3RvdHlwZS5zaG93TWVudSA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgdmFyIGNsaWNrZWRUb3BMaW5rID0gJChlbC50YXJnZXQpO1xuICAgIHZhciBzdWJtZW51V2lkdGggPSBjbGlja2VkVG9wTGluay5zaWJsaW5ncygnLnRvcC1tZW51X19sZXZlbDQnKS53aWR0aCgpO1xuICAgIHZhciBjbGlja2VkTGlua1NpYmxpbmdzID0gY2xpY2tlZFRvcExpbmsuc2libGluZ3ModGhpcy5sZXZlbFN1Ym1lbnUpO1xuICAgIHZhciBkZWVwZXJMaW5rcyA9IGNsaWNrZWRMaW5rU2libGluZ3MuZmluZCgnLnRvcC1tZW51X19zdWJsaXN0LWxpbmsnKTtcblxuICAgIHZhciBoZWlnaHQgPSBjbGlja2VkVG9wTGluay5zaWJsaW5ncyh0aGlzLmZvdXJ0aExldmVsTWVudSkuaGVpZ2h0KCk7XG4gICAgdGhpcy5zZXRTdWJtZW51U2l6ZShoZWlnaHQpO1xuXG4gICAgaWYgKGNsaWNrZWRUb3BMaW5rLnNpYmxpbmdzKCcudG9wLW1lbnVfX2xldmVsNCcpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBlbC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnRoaXJkTGV2ZWxNZW51LndpZHRoKCkgLSBjbGlja2VkVG9wTGluay5vZmZzZXQoKS5sZWZ0O1xuICAgICAgICBpZiAocG9zaXRpb24gPCBzdWJtZW51V2lkdGgpIHtcbiAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvbiA9IHN1Ym1lbnVXaWR0aCAtIHBvc2l0aW9uO1xuICAgICAgICAgICAgdGhpcy50aGlyZExldmVsSXRlbXMuYW5pbWF0ZSh7bGVmdDogJy09JyArIG5ld1Bvc2l0aW9ufSwgNTAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjbGlja2VkTGlua1NpYmxpbmdzLmxlbmd0aCAhPT0gMCAmJiBjbGlja2VkTGlua1NpYmxpbmdzLmNzcygnZGlzcGxheScpID09PSAnYmxvY2snKSB7XG4gICAgICAgIGNsaWNrZWRMaW5rU2libGluZ3Muc3RvcCgpLnNsaWRlVXAoKTtcbiAgICAgICAgdGhpcy5leHBhbmRlZFN1Ym1lbnUuc3RvcCgpLnNsaWRlVXAoKTtcblxuICAgICAgICB0aGlzLnNldFN1Ym1lbnVJbml0aWFsVmFsdWVzKCk7XG4gICAgfSBlbHNlIGlmIChjbGlja2VkTGlua1NpYmxpbmdzLmxlbmd0aCAhPT0gMCAmJiBjbGlja2VkTGlua1NpYmxpbmdzLmlzKCc6aGlkZGVuJykpIHtcbiAgICAgICAgdGhpcy5mb3VydGhMZXZlbE1lbnUubm90KGNsaWNrZWRMaW5rU2libGluZ3MpLnNsaWRlVXAoKTtcbiAgICAgICAgY2xpY2tlZExpbmtTaWJsaW5ncy5zdG9wKCkuc2xpZGVEb3duKCk7XG4gICAgICAgIHRoaXMuZXhwYW5kZWRTdWJtZW51LnN0b3AoKS5zbGlkZURvd24oKTtcblxuICAgICAgICBpZiAoZGVlcGVyTGlua3MuaGFzQ2xhc3MoJ3RvcC1tZW51X19zdWJsaXN0LWxpbmstLWN1cnJlbnQtcGFnZScpKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFBhZ2VMaW5rID0gZGVlcGVyTGlua3MuZmlsdGVyKCcudG9wLW1lbnVfX3N1Ymxpc3QtbGluay0tY3VycmVudC1wYWdlJyk7XG4gICAgICAgICAgICB2YXIgY2xvc2VzdFN1Ymxpc3QgPSBjdXJyZW50UGFnZUxpbmsuY2xvc2VzdCgnLnRvcC1tZW51X19zdWJsaXN0Jyk7XG4gICAgICAgICAgICB2YXIgY3VycmVudFBhZ2VQYXJlbnRTdWJsaXN0cyA9ICBjdXJyZW50UGFnZUxpbmsucGFyZW50cygnLnRvcC1tZW51X19zdWJsaXN0Jyk7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBjbG9zZXN0U3VibGlzdC5wYXJlbnRzKCcudG9wLW1lbnVfX3N1Ymxpc3QtaXRlbScpLnNpYmxpbmdzKCk7XG4gICAgICAgICAgICB2YXIgZGlzcGxheWVkSXRlbSA9IGN1cnJlbnRQYWdlTGluay5wYXJlbnRzKCcudG9wLW1lbnVfX2xpc3QtaXRlbScpLmFkZENsYXNzKCd0b3AtbWVudV9fbGlzdC1pdGVtLS1kaXNwbGF5ZWQnKTtcblxuICAgICAgICAgICAgY3VycmVudFBhZ2VMaW5rLmFkZENsYXNzKCd0b3AtbWVudV9fc3VibGlzdC1saW5rLS1jdXJyZW50Jyk7XG4gICAgICAgICAgICBjbG9zZXN0U3VibGlzdC5zaWJsaW5ncygpLnNob3coKTtcbiAgICAgICAgICAgIGN1cnJlbnRQYWdlUGFyZW50U3VibGlzdHMuc2libGluZ3MoJy50b3AtbWVudV9fc3VibGlzdC1saW5rJykuYWRkQ2xhc3MoJ3RvcC1tZW51X19zdWJsaXN0LWxpbmstLWN1cnJlbnQnKS5oaWRlKCk7XG4gICAgICAgICAgICBjdXJyZW50UGFnZVBhcmVudFN1Ymxpc3RzLmFkZENsYXNzKCd0b3AtbWVudV9fZGVlcGVyLWxldmVsLS12aXNpYmxlJykuY3NzKCdsZWZ0JywgMCk7XG4gICAgICAgICAgICBpdGVtcy5hZGRDbGFzcygndG9wLW1lbnVfX3N1Ymxpc3QtaXRlbS0taGlkZGVuJyk7XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGN1cnJlbnRQYWdlTGluay5wYXJlbnQoKS5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFnZUxpbmsucGFyZW50KCkuc2libGluZ3MoKS5lYWNoKGZ1bmN0aW9uKGksIGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCArPSAkKGVsKS5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN1Ym1lbnVTaXplKGhlaWdodCk7IFxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCA1MDApICAgICAgICAgXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMuc2Vjb25kTGV2ZWxMaW5rLnJlbW92ZUNsYXNzKCd0b3AtbWVudV9fbGlzdC1saW5rLS1hY3RpdmUnKTtcbiAgICAgICAgICAgIGNsaWNrZWRUb3BMaW5rLmFkZENsYXNzKCd0b3AtbWVudV9fbGlzdC1saW5rLS1hY3RpdmUnKTtcbiAgICAgICAgICAgIHRoaXMudGhpcmRMZXZlbExpbmsubm90KGNsaWNrZWRUb3BMaW5rKS5yZW1vdmVDbGFzcygndG9wLW1lbnVfX2xpc3QtbGluay0tYWN0aXZlJyk7XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGNsaWNrZWRUb3BMaW5rLnNpYmxpbmdzKHRoaXMuZm91cnRoTGV2ZWxNZW51KS5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN1Ym1lbnVTaXplKGhlaWdodCk7ICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgNDAwKVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2xpY2tlZFRvcExpbmsuYWRkQ2xhc3MoJ3RvcC1tZW51X19saXN0LWxpbmstLWFjdGl2ZScpO1xuICAgICAgICB0aGlzLnRoaXJkTGV2ZWxMaW5rLm5vdChjbGlja2VkVG9wTGluaykucmVtb3ZlQ2xhc3MoJ3RvcC1tZW51X19saXN0LWxpbmstLWFjdGl2ZScpO1xuICAgIH1cblxuICAgIHNldFRpbWVvdXQodGhpcy5jaGVja01lbnVMZW5ndGguYmluZCh0aGlzKSwgMjUwKTtcbiAgICBcbn1cblxuVG9wTWVudS5wcm90b3R5cGUuY2xvc2VNZW51ID0gZnVuY3Rpb24oZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAodGhpcy5sZXZlbFN1Ym1lbnUuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgdGhpcy5mb3VydGhMZXZlbE1lbnUuc2xpZGVVcCgpO1xuICAgICAgICB0aGlzLmV4cGFuZGVkU3VibWVudS5zbGlkZVVwKCk7XG4gICAgICAgIHRoaXMuY2hlY2tNZW51TGVuZ3RoKCk7XG4gICAgICAgIHRoaXMuc2V0U3VibWVudUluaXRpYWxWYWx1ZXMoKTtcbiAgICB9XG59XG5cblRvcE1lbnUucHJvdG90eXBlLnNldFN1Ym1lbnVJbml0aWFsVmFsdWVzID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciBjdXJyZW50SGVpZ2h0ID0gdGhpcy5sZXZlbFN1Ym1lbnUuaGVpZ2h0KCkgKyA3MDtcbiAgICB0aGlzLmZvdXJ0aExldmVsTWVudS5jaGlsZHJlbigpLnJlbW92ZUNsYXNzKCd0b3AtbWVudV9fc3VibGlzdC1pdGVtLS1oaWRkZW4nKTtcbiAgICB0aGlzLmRlZXBlckxldmVsSXRlbS5yZW1vdmVDbGFzcygndG9wLW1lbnVfX3N1Ymxpc3QtaXRlbS0taGlkZGVuJyk7XG4gICAgdGhpcy5kZWVwZXJMZXZlbExpbmsucmVtb3ZlQ2xhc3MoJ3RvcC1tZW51X19zdWJsaXN0LWxpbmstLWhpZGRlbicpO1xuICAgIHRoaXMuZGVlcGVyTGV2ZWxNZW51LnJlbW92ZUNsYXNzKCd0b3AtbWVudV9fZGVlcGVyLWxldmVsLS12aXNpYmxlJyk7XG4gICAgdGhpcy5kZWVwZXJMZXZlbExpbmsuc2hvdygpO1xuXG4gICAgdGhpcy5jdXJyZW50UGFnZS5wYXJlbnRzKCcudG9wLW1lbnVfX2xldmVsMy1pdGVtJykuYWRkQ2xhc3MoJ3RvcC1tZW51X19sZXZlbDMtaXRlbS0tZGlzcGxheWVkJyk7XG5cbiAgICB0aGlzLmxpc3RJdGVtLmZpbHRlcignLnRvcC1tZW51X19saXN0LWl0ZW0tLWRpc3BsYXllZCcpXG4gICAgICAgIC5jaGlsZHJlbignLnRvcC1tZW51X19saXN0LWxpbmsnKS5hZGRDbGFzcygndG9wLW1lbnVfX2xpc3QtbGluay0tYWN0aXZlJyk7XG4gICAgdGhpcy50aGlyZExldmVsSXRlbXMubm90KCcudG9wLW1lbnVfX2xpc3QtaXRlbS0tZGlzcGxheWVkJykucmVtb3ZlQ2xhc3MoJ3RvcC1tZW51X19saXN0LWxpbmstLWFjdGl2ZScpO1xuICAgIHRoaXMudGhpcmRMZXZlbEl0ZW1zLmZpbHRlcignLnRvcC1tZW51X19saXN0LWl0ZW0tLWRpc3BsYXllZCcpXG4gICAgICAgIC5jaGlsZHJlbignLnRvcC1tZW51X19saXN0LWxpbmsnKS5hZGRDbGFzcygndG9wLW1lbnVfX2xpc3QtbGluay0tYWN0aXZlJyk7XG5cbiAgICB0aGlzLmRlZXBlckxldmVsSXRlbS5maWx0ZXIoJy50b3AtbWVudV9fc3VibGlzdC1pdGVtLS1jdXJyZW50JylcbiAgICAgICAgLnJlbW92ZUNsYXNzKCd0b3AtbWVudV9fc3VibGlzdC1pdGVtLS1jdXJyZW50JylcbiAgICAgICAgLmNoaWxkcmVuKCcudG9wLW1lbnVfX3N1Ymxpc3QtbGluaycpLmFkZENsYXNzKCd0b3AtbWVudV9fc3VibGlzdC1saW5rLS1jdXJyZW50Jyk7XG5cbiAgICB0aGlzLmNoZWNrRGVlcGVyTGV2ZWxTdWJtZW51RXhpc3RhbmNlKCk7XG4gICAgdGhpcy5kZWVwZXJMZXZlbE1lbnUuY3NzKCdsZWZ0JywgdGhpcy5wYWdlQ29udGFpbmVyLndpZHRoKCkvMik7XG4gICAgdGhpcy5vZmZzZXRNZW51LmNzcygnaGVpZ2h0JywgY3VycmVudEhlaWdodCk7XG59XG5cblRvcE1lbnUucHJvdG90eXBlLmNsb3NlTWVudVdpdGhSYW5kb21DbGljayA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoIXRoaXMubGV2ZWxTdWJtZW51LmlzKGUudGFyZ2V0KSAmJiAhdGhpcy5saXN0TGluay5pcyhlLnRhcmdldCkgJiYgdGhpcy5sZXZlbFN1Ym1lbnUuaGFzKGUudGFyZ2V0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5mb3VydGhMZXZlbE1lbnUuc2xpZGVVcCgpO1xuICAgICAgICB0aGlzLmV4cGFuZGVkU3VibWVudS5zbGlkZVVwKCk7XG4gICAgICAgIHRoaXMuY2hlY2tNZW51TGVuZ3RoKCk7XG4gICAgICAgIHRoaXMuc2V0U3VibWVudUluaXRpYWxWYWx1ZXMoKTtcbiAgICB9XG59XG5cblRvcE1lbnUucHJvdG90eXBlLmNoZWNrTWVudUxlbmd0aCA9IGZ1bmN0aW9uKCkgeyBcbiAgICB2YXIgbGFzdEl0ZW1PZmZzZXRMZWZ0ID0gdGhpcy5sYXN0SXRlbS5vZmZzZXQoKS5sZWZ0O1xuICAgIHZhciBsYXN0SXRlbU9mZnNldFJpZ2h0ID0gbGFzdEl0ZW1PZmZzZXRMZWZ0ICsgdGhpcy5sYXN0SXRlbVdpZHRoO1xuICAgIHZhciBmaXJzdEl0ZW1PZmZzZXRMZWZ0ID0gdGhpcy5maXJzdEl0ZW0ub2Zmc2V0KCkubGVmdDtcbiAgICB2YXIgdGhpcmRMZXZlbE1lbnVXaWR0aCA9IHRoaXMudGhpcmRMZXZlbE1lbnUud2lkdGgoKTtcbiAgICB2YXIgbWVudVdpZHRoID0gMDtcblxuICAgIHRoaXMudGhpcmRMZXZlbEl0ZW1zLmVhY2goZnVuY3Rpb24oaSwgZWwpe1xuICAgICAgICBtZW51V2lkdGggKz0gJChlbCkub3V0ZXJXaWR0aCgpO1xuICAgIH0pO1xuXG4gICAgaWYgKCQoJ21haW4nKS53aWR0aCgpIDwgbWVudVdpZHRoICYmIHRoaXMud2luZG93LndpZHRoKCkgPiAxODI0KSB7XG4gICAgICAgIGlmIChsYXN0SXRlbU9mZnNldFJpZ2h0ID4gbWVudVdpZHRoICsgIHRoaXMuZmlyc3RJdGVtLndpZHRoKCkpIHtcbiAgICAgICAgICAgIHRoaXMucmlnaHRNZW51QnV0dG9uLmFkZENsYXNzKCd0b3AtbWVudV9fYnV0dG9uLS1hY3RpdmUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmlnaHRNZW51QnV0dG9uLnJlbW92ZUNsYXNzKCd0b3AtbWVudV9fYnV0dG9uLS1hY3RpdmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaXJzdEl0ZW1PZmZzZXRMZWZ0IDwgMTUwICkge1xuICAgICAgICAgICAgdGhpcy5sZWZ0TWVudUJ1dHRvbi5hZGRDbGFzcygndG9wLW1lbnVfX2J1dHRvbi0tYWN0aXZlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxlZnRNZW51QnV0dG9uLnJlbW92ZUNsYXNzKCd0b3AtbWVudV9fYnV0dG9uLS1hY3RpdmUnKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJCgnbWFpbicpLndpZHRoKCkgPCBtZW51V2lkdGgpIHsgICAgICAgIFxuICAgICAgICBpZiAobGFzdEl0ZW1PZmZzZXRSaWdodCA+IHRoaXJkTGV2ZWxNZW51V2lkdGggKyAxMDApIHtcbiAgICAgICAgICAgIHRoaXMucmlnaHRNZW51QnV0dG9uLmFkZENsYXNzKCd0b3AtbWVudV9fYnV0dG9uLS1hY3RpdmUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmlnaHRNZW51QnV0dG9uLnJlbW92ZUNsYXNzKCd0b3AtbWVudV9fYnV0dG9uLS1hY3RpdmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaXJzdEl0ZW1PZmZzZXRMZWZ0IDwgODAgKSB7XG4gICAgICAgICAgICB0aGlzLmxlZnRNZW51QnV0dG9uLmFkZENsYXNzKCd0b3AtbWVudV9fYnV0dG9uLS1hY3RpdmUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGVmdE1lbnVCdXR0b24ucmVtb3ZlQ2xhc3MoJ3RvcC1tZW51X19idXR0b24tLWFjdGl2ZScpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZpcnN0SXRlbU9mZnNldExlZnQgPCA4MCApIHtcbiAgICAgICAgICAgIHRoaXMubGVmdE1lbnVCdXR0b24uYWRkQ2xhc3MoJ3RvcC1tZW51X19idXR0b24tLWFjdGl2ZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sZWZ0TWVudUJ1dHRvbi5yZW1vdmVDbGFzcygndG9wLW1lbnVfX2J1dHRvbi0tYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblRvcE1lbnUucHJvdG90eXBlLnNsaWRlUmlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGFzdEl0ZW1PZmZzZXRMZWZ0ID0gdGhpcy5sYXN0SXRlbS5vZmZzZXQoKS5sZWZ0O1xuICAgIHZhciBsYXN0SXRlbU9mZnNldFJpZ2h0ID0gbGFzdEl0ZW1PZmZzZXRMZWZ0ICsgdGhpcy5sYXN0SXRlbVdpZHRoO1xuICAgIHZhciB0aGlyZExldmVsTWVudVdpZHRoID0gdGhpcy50aGlyZExldmVsTWVudS53aWR0aCgpO1xuICAgIHZhciBtZW51V2lkdGggPSAwO1xuXG4gICAgdGhpcy50aGlyZExldmVsSXRlbXMuZWFjaChmdW5jdGlvbihpLCBlbCl7XG4gICAgICAgIG1lbnVXaWR0aCArPSAkKGVsKS5vdXRlcldpZHRoKCk7XG4gICAgfSk7XG5cbiAgICB2YXIgc2xpZGVEaXN0YW5jZSA9IG1lbnVXaWR0aCAtIHRoaXJkTGV2ZWxNZW51V2lkdGg7XG5cbiAgICBpZiAodGhpcy5leHBhbmRlZFN1Ym1lbnUuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgdGhpcy5yaWdodE1lbnVCdXR0b24ub2ZmKCdjbGljaycsIHRoaXMuc2xpZGVSaWdodC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5sZWZ0TWVudUJ1dHRvbi5vZmYoJ2NsaWNrJywgdGhpcy5zbGlkZUxlZnQuYmluZCh0aGlzKSk7XG4gICAgfSBcblxuICAgIGlmIChtZW51V2lkdGgvdGhpcmRMZXZlbE1lbnVXaWR0aCA+PSAyICYmIGxhc3RJdGVtT2Zmc2V0UmlnaHQgPiBtZW51V2lkdGgpIHtcbiAgICAgICAgdGhpcy50aGlyZExldmVsSXRlbXMuYW5pbWF0ZSh7bGVmdDogJy09JyArICh0aGlyZExldmVsTWVudVdpZHRoIC0gMTAwKX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChtZW51V2lkdGgvdGhpcmRMZXZlbE1lbnVXaWR0aCA+PSAyKSB7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsID0gMioobWVudVdpZHRoIC0gdGhpcmRMZXZlbE1lbnVXaWR0aCoocGFyc2VJbnQobWVudVdpZHRoL3RoaXJkTGV2ZWxNZW51V2lkdGgpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsID0gbWVudVdpZHRoIC0gdGhpcmRMZXZlbE1lbnVXaWR0aCArIDQ1O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhpcmRMZXZlbEl0ZW1zLmFuaW1hdGUoe2xlZnQ6ICctPScgKyBzY3JvbGx9KTtcbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJpZ2h0TWVudUJ1dHRvbi5vbmUoJ2NsaWNrJywgdGhpcy5zbGlkZVJpZ2h0LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmNoZWNrTWVudUxlbmd0aCgpO1xuICAgIH0uYmluZCh0aGlzKSwgNTAwKTtcbn1cblxuVG9wTWVudS5wcm90b3R5cGUuc2xpZGVMZWZ0ID0gZnVuY3Rpb24oZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgZmlyc3RJdGVtT2Zmc2V0TGVmdCA9IHRoaXMuZmlyc3RJdGVtLm9mZnNldCgpLmxlZnQ7XG4gICAgdmFyIHRoaXJkTGV2ZWxNZW51V2lkdGggPSB0aGlzLnRoaXJkTGV2ZWxNZW51LndpZHRoKCk7XG4gICAgdmFyIG1lbnVXaWR0aCA9IDA7XG5cbiAgICB0aGlzLnRoaXJkTGV2ZWxJdGVtcy5lYWNoKGZ1bmN0aW9uKGksIGVsKXtcbiAgICAgICAgbWVudVdpZHRoICs9ICQoZWwpLm91dGVyV2lkdGgoKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmV4cGFuZGVkU3VibWVudS5pcygnOnZpc2libGUnKSkge1xuICAgICAgICB0aGlzLnJpZ2h0TWVudUJ1dHRvbi5vZmYoJ2NsaWNrJywgdGhpcy5zbGlkZVJpZ2h0LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmxlZnRNZW51QnV0dG9uLm9mZignY2xpY2snLCB0aGlzLnNsaWRlTGVmdC5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICBpZiAobWVudVdpZHRoL3RoaXJkTGV2ZWxNZW51V2lkdGggPj0gMiAmJiAtZmlyc3RJdGVtT2Zmc2V0TGVmdCA+IHRoaXJkTGV2ZWxNZW51V2lkdGgpIHtcbiAgICAgICAgdGhpcy50aGlyZExldmVsSXRlbXMuYW5pbWF0ZSh7bGVmdDogJys9JyArIHRoaXJkTGV2ZWxNZW51V2lkdGh9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRoaXJkTGV2ZWxJdGVtcy5hbmltYXRlKHtsZWZ0OiAwfSk7XG4gICAgfVxuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5sZWZ0TWVudUJ1dHRvbi5vbmUoJ2NsaWNrJywgdGhpcy5zbGlkZUxlZnQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuY2hlY2tNZW51TGVuZ3RoKCk7XG4gICAgfS5iaW5kKHRoaXMpLCA1MDApO1xuXG59XG5cbmpRdWVyeS5mbi50b3BNZW51ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGpRdWVyeSh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICBuZXcgVG9wTWVudShqUXVlcnkodGhpcykpO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgVG9wTWVudTogVG9wTWVudVxufTsiLCIvKiA9PT09PT09PT09PT09PT09PT09XG4qIFZhbGlkYXRpb24gU2NyaXB0XG4qIE1hcmNpbiBNYWpld3NraSwgTWFyY2luIFdhc2lsZXdza2kgLSBNZXJpeCBTdHVkaW9cbipcbiogQXZhaWJsZSBydWxlczogcmVxdWlyZWQsIGVtYWlsLCBwaG9uZSwgbGV0dGVycy1vbmx5LCBwb3N0Y29kZSwgZXF1YWx0bywgbnVtYmVyLCBtaW4tbGVuZ3RoXG4qL1xuXG52YXIgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG52YXIgdHJhbnNsYXRlID0gcmVxdWlyZSgnLi4vdXRpbHMvdHJhbnNsYXRlJylcbmZ1bmN0aW9uIFZhbGlkYXRlKGZvcm0pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5mb3JtID0gZm9ybTtcbiAgICB0aGlzLmZvcm1WYWxpZCA9IG5ldyBBcnJheSgpO1xuXG4gICAgdGhpcy5jaGVja0ZpZWxkcygpO1xufVxuXG5WYWxpZGF0ZS5wcm90b3R5cGUuY2hlY2tGaWVsZHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5mb3JtLmZpbmQoJ1tkYXRhLXZhbGlkYXRlXScpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IGpRdWVyeSh0aGlzKTtcbiAgICAgICAgdmFyIHZhbGlkYXRlRGF0YSA9IEpTT04ucGFyc2UoZmllbGQuZGF0YSgndmFsaWRhdGUnKS5yZXBsYWNlKC9cXCcvZywgJ1wiJykpO1xuICAgICAgICBzZWxmLmlzUmVxdWlyZWQoZmllbGQsIHZhbGlkYXRlRGF0YSk7XG4gICAgICAgIHNlbGYuaXNNYWlsKGZpZWxkLCB2YWxpZGF0ZURhdGEpO1xuICAgICAgICBzZWxmLmlzUGhvbmUoZmllbGQsIHZhbGlkYXRlRGF0YSk7XG4gICAgICAgIHNlbGYuaGFzTGV0dGVyc09ubHkoZmllbGQsIHZhbGlkYXRlRGF0YSk7XG4gICAgICAgIHNlbGYuaXNQb3N0Y29kZShmaWVsZCwgdmFsaWRhdGVEYXRhKTtcbiAgICAgICAgc2VsZi5pc0VxdWFsVG8oZmllbGQsIHZhbGlkYXRlRGF0YSk7XG4gICAgICAgIHNlbGYuaXNOdW1iZXIoZmllbGQsIHZhbGlkYXRlRGF0YSk7XG4gICAgICAgIHNlbGYuaXNNaW5MZW5ndGgoZmllbGQsIHZhbGlkYXRlRGF0YSk7XG4gICAgfSk7XG59O1xuXG5WYWxpZGF0ZS5wcm90b3R5cGUuaXNSZXF1aXJlZCA9IGZ1bmN0aW9uKGZpZWxkLCB2YWxpZGF0ZURhdGEpIHtcbiAgICBpZiAoZmllbGQucHJvcCgndGFnTmFtZScpICE9ICdTUEFOJykge1xuICAgICAgICBpZiAodmFsaWRhdGVEYXRhWydyZXF1aXJlZCddICYmIGZpZWxkLmlzKCdbdHlwZT1cImNoZWNrYm94XCJdJykpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5pcygnOmNoZWNrZWQnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRXJyb3IoZmllbGQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybVZhbGlkLnB1c2goW3RydWUsIGZpZWxkXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Vycm9yKGZpZWxkLCAncmVxdWlyZWQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1WYWxpZC5wdXNoKFtmYWxzZSwgZmllbGRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh2YWxpZGF0ZURhdGFbJ3JlcXVpcmVkJ10gJiYgZmllbGQuaXMoJ1t0eXBlPVwicmFkaW9cIl0nKSkge1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgalF1ZXJ5KCdbbmFtZT1cIicrZmllbGQuYXR0cignbmFtZScpKydcIl0nKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChqUXVlcnkodGhpcykuaXMoJzpjaGVja2VkJykpXG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUVycm9yKGZpZWxkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1WYWxpZC5wdXNoKFt0cnVlLCBmaWVsZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93RXJyb3IoZmllbGQsICdyZXF1aXJlZCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybVZhbGlkLnB1c2goW2ZhbHNlLCBmaWVsZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHZhbGlkYXRlRGF0YVsncmVxdWlyZWQnXSAmJiBmaWVsZC52YWwoKSA9PSAnJykge1xuICAgICAgICAgICAgdGhpcy5zaG93RXJyb3IoZmllbGQsICdyZXF1aXJlZCcpO1xuICAgICAgICAgICAgdGhpcy5mb3JtVmFsaWQucHVzaChbZmFsc2UsIGZpZWxkXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUVycm9yKGZpZWxkLCAncmVxdWlyZWQnKTtcbiAgICAgICAgICAgIHRoaXMuZm9ybVZhbGlkLnB1c2goW3RydWUsIGZpZWxkXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5WYWxpZGF0ZS5wcm90b3R5cGUuaXNNYWlsID0gZnVuY3Rpb24oZmllbGQsIHZhbGlkYXRlRGF0YSkge1xuICAgIGlmIChmaWVsZC5wcm9wKCd0YWdOYW1lJykgIT0gJ1NQQU4nKSB7XG4gICAgICAgIGlmICh2YWxpZGF0ZURhdGFbJ2VtYWlsJ10pIHtcbiAgICAgICAgICAgIHZhciByZWdleCA9IC9eWy0hIyQlJicqKy8wLTk9P0EtWl5fYS16e3x9fl0oXFwuP1stISMkJSYnKisvMC05PT9BLVpeX2Etent8fX5dKSpAW2EtekEtWl0oLT9bYS16QS1aMC05XSkqKFxcLlthLXpBLVpdKC0/W2EtekEtWjAtOV0pKikrJC87IC8vIHJlZ2V4ICdcbiAgICAgICAgICAgIHZhciBlbWFpbCA9IGZpZWxkLnZhbCgpO1xuICAgICAgICAgICAgaWYgKHJlZ2V4LnRlc3QoZW1haWwpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFcnJvcihmaWVsZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtVmFsaWQucHVzaChbdHJ1ZSwgZmllbGRdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93RXJyb3IoZmllbGQsICdlbWFpbCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybVZhbGlkLnB1c2goW2ZhbHNlLCBmaWVsZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuVmFsaWRhdGUucHJvdG90eXBlLmlzUGhvbmUgPSBmdW5jdGlvbihmaWVsZCwgdmFsaWRhdGVEYXRhKSB7XG4gICAgaWYgKGZpZWxkLnByb3AoJ3RhZ05hbWUnKSAhPSAnU1BBTicpIHtcbiAgICAgICAgaWYgKHZhbGlkYXRlRGF0YVsncGhvbmUnXSAmJiBmaWVsZC52YWwoKSAhPSAnJykge1xuICAgICAgICAgICAgdmFyIHJlZ2V4ID0gL1xcKD8oWzAtOS5cXCtcXC1cXHMoKV0rKS87XG4gICAgICAgICAgICB2YXIgcGhvbmUgPSBmaWVsZC52YWwoKTtcbiAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KHBob25lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRXJyb3IoZmllbGQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybVZhbGlkLnB1c2goW3RydWUsIGZpZWxkXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Vycm9yKGZpZWxkLCAncGhvbmUnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1WYWxpZC5wdXNoKFtmYWxzZSwgZmllbGRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblZhbGlkYXRlLnByb3RvdHlwZS5oYXNMZXR0ZXJzT25seSA9IGZ1bmN0aW9uKGZpZWxkLCB2YWxpZGF0ZURhdGEpIHtcbiAgICBpZiAoZmllbGQucHJvcCgndGFnTmFtZScpICE9ICdTUEFOJykge1xuICAgICAgICBpZiAodmFsaWRhdGVEYXRhWydsZXR0ZXJzLW9ubHknXSAmJiBmaWVsZC52YWwoKSAhPSAnJykge1xuICAgICAgICAgICAgdmFyIHJlZ2V4ID0gL15bXiFAI1xcJCVcXF4mXFwqXFwoXFwpXFxbXFxdOjsnXCIsXFwuXFxkKy1dKyQvO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBmaWVsZC52YWwoKTtcbiAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFcnJvcihmaWVsZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtVmFsaWQucHVzaChbdHJ1ZSwgZmllbGRdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93RXJyb3IoZmllbGQsICdsZXR0ZXJzLW9ubHknKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1WYWxpZC5wdXNoKFtmYWxzZSwgZmllbGRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblZhbGlkYXRlLnByb3RvdHlwZS5pc0VxdWFsVG8gPSBmdW5jdGlvbihmaWVsZCwgdmFsaWRhdGVEYXRhKSB7XG4gICAgaWYgKGZpZWxkLnByb3AoJ3RhZ05hbWUnKSAhPSAnU1BBTicpIHtcbiAgICAgICAgaWYgKHZhbGlkYXRlRGF0YVsnZXF1YWwtdG8nXSAmJiBmaWVsZC52YWwoKSAhPSAnJykge1xuICAgICAgICAgICAgdmFyIGVxdWFsVG8gPSB0aGlzLmZvcm0uZmluZCgnIycrIHZhbGlkYXRlRGF0YVsnZXF1YWwtdG8nXSk7XG4gICAgICAgICAgICBpZiAoZmllbGQudmFsKCkgPT09IGVxdWFsVG8udmFsKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUVycm9yKGZpZWxkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1WYWxpZC5wdXNoKFt0cnVlLCBmaWVsZF0pO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRXJyb3IoZXF1YWxUbyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Vycm9yKGZpZWxkLCAnZXF1YWwnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1WYWxpZC5wdXNoKFtmYWxzZSwgZmllbGRdKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dFcnJvcihlcXVhbFRvLCAnZXF1YWwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblZhbGlkYXRlLnByb3RvdHlwZS5pc1Bvc3Rjb2RlID0gZnVuY3Rpb24oZmllbGQsIHZhbGlkYXRlRGF0YSkge1xuICAgIGlmIChmaWVsZC5wcm9wKCd0YWdOYW1lJykgIT0gJ1NQQU4nKSB7XG4gICAgICAgIGlmICh2YWxpZGF0ZURhdGFbJ3Bvc3Rjb2RlJ10gJiYgZmllbGQudmFsKCkgIT0gJycpIHtcbiAgICAgICAgICAgIHZhciByZWdleCA9IC9eWzAtOV17Mn0tWzAtOV17M30kLztcbiAgICAgICAgICAgIHZhciBwb3N0Y29kZSA9IGZpZWxkLnZhbCgpO1xuICAgICAgICAgICAgaWYgKHJlZ2V4LnRlc3QocG9zdGNvZGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFcnJvcihmaWVsZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtVmFsaWQucHVzaChbdHJ1ZSwgZmllbGRdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93RXJyb3IoZmllbGQsICdwb3N0Y29kZScpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybVZhbGlkLnB1c2goW2ZhbHNlLCBmaWVsZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuVmFsaWRhdGUucHJvdG90eXBlLmlzTnVtYmVyID0gZnVuY3Rpb24oZmllbGQsIHZhbGlkYXRlRGF0YSkge1xuICAgIGlmIChmaWVsZC5wcm9wKCd0YWdOYW1lJykgIT0gJ1NQQU4nKSB7XG4gICAgICAgIGlmICh2YWxpZGF0ZURhdGFbJ251bWJlciddICYmIGZpZWxkLnZhbCgpICE9ICcnKSB7XG4gICAgICAgICAgICB2YXIgcmVnZXggPSAvXlswLTldKiQvO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBmaWVsZC52YWwoKTtcbiAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFcnJvcihmaWVsZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtVmFsaWQucHVzaChbdHJ1ZSwgZmllbGRdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93RXJyb3IoZmllbGQsICdudW1iZXInKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1WYWxpZC5wdXNoKFtmYWxzZSwgZmllbGRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblZhbGlkYXRlLnByb3RvdHlwZS5pc01pbkxlbmd0aCA9IGZ1bmN0aW9uKGZpZWxkLCB2YWxpZGF0ZURhdGEpIHtcbiAgICBpZiAoZmllbGQucHJvcCgndGFnTmFtZScpICE9ICdTUEFOJykge1xuICAgICAgICBpZiAodmFsaWRhdGVEYXRhWydtaW4tbGVuZ3RoJ10gJiYgZmllbGQudmFsKCkgIT0gJycpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gZmllbGQudmFsKCk7XG4gICAgICAgICAgICBpZiAobmFtZS5sZW5ndGggPj0gdmFsaWRhdGVEYXRhWydtaW4tbGVuZ3RoJ10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUVycm9yKGZpZWxkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1WYWxpZC5wdXNoKFt0cnVlLCBmaWVsZF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dFcnJvcihmaWVsZCwgJ21pbmxlbmd0aCcsIHswOiB2YWxpZGF0ZURhdGFbJ21pbi1sZW5ndGgnXX0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybVZhbGlkLnB1c2goW2ZhbHNlLCBmaWVsZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuVmFsaWRhdGUucHJvdG90eXBlLnNob3dFcnJvciA9IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUsIGVycm9yVmFyaWFibGVzKSB7XG4gICAgdmFyIG11bHRpcGxlID0gZmFsc2U7XG4gICAgdmFyIGVycm9yUGxhY2UgPSBlbGVtZW50LnBhcmVudCgpO1xuICAgIGVycm9yVmFyaWFibGVzID0gZXJyb3JWYXJpYWJsZXMgfHwgbnVsbDtcblxuICAgIGlmIChlbGVtZW50LmlzKCdbdHlwZT1cImNoZWNrYm94XCJdJykgfHwgZWxlbWVudC5pcygnW3R5cGU9XCJyYWRpb1wiXScpKSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IGpRdWVyeSgnW3R5cGU9XCJyYWRpb1wiXVtuYW1lPVwiJyArIGVsZW1lbnQuYXR0cignbmFtZScpICsgJ1wiXScpO1xuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50cy5sYXN0KCkuY2xvc2VzdCgnbGFiZWwnKS5oYXNDbGFzcygnZXJyb3InKSlcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5sYXN0KCkuY2xvc2VzdCgnbGFiZWwnKS5hZGRDbGFzcygnZXJyb3InKTtcblxuICAgICAgICAgICAgZXJyb3JQbGFjZSA9IGVsZW1lbnRzLmxhc3QoKS5jbG9zZXN0KCdsYWJlbCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5jbG9zZXN0KCdsYWJlbCcpLmFkZENsYXNzKCdlcnJvcicpO1xuICAgICAgICAgICAgZXJyb3JQbGFjZSA9IGVsZW1lbnQuY2xvc2VzdCgnbGFiZWwnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVsc2UgaWYgKGVsZW1lbnQucHJvcCgndGFnTmFtZScpID09ICdURVhUQVJFQScpIHtcbiAgICAgICAgZWxlbWVudC5jbG9zZXN0KCcudGV4dGFyZWEtd3JhcHBlcicpLmFkZENsYXNzKCdlcnJvcicpO1xuICAgICAgICBlcnJvclBsYWNlID0gZWxlbWVudC5jbG9zZXN0KCcudGV4dGFyZWEtd3JhcHBlcicpLnBhcmVudCgpO1xuICAgIH1cblxuICAgIGVsc2UgaWYgKGVsZW1lbnQucHJvcCgndGFnTmFtZScpID09ICdTRUxFQ1QnKSB7XG4gICAgICAgIGVsZW1lbnQuY2xvc2VzdCgnLmZha2Utc2VsZWN0JykuYWRkQ2xhc3MoJ2Vycm9yJyk7XG4gICAgICAgIGVycm9yUGxhY2UgPSBlbGVtZW50LmNsb3Nlc3QoJy5mYWtlLXNlbGVjdCcpLnBhcmVudCgpO1xuICAgIH1cblxuICAgIGVsc2VcbiAgICAgICAgZWxlbWVudC5wYXJlbnQoKS5hZGRDbGFzcygnZXJyb3InKTtcblxuICAgIGlmIChlbGVtZW50LnBhcmVudCgpLmNoaWxkcmVuKCcuZXJyb3ItbWVzc2FnZScpLmxlbmd0aCA9PSAwICYmIGVsZW1lbnQuY2xvc2VzdCgnLnNldCcpLmNoaWxkcmVuKCcuZXJyb3ItbWVzc2FnZScpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGlmIChtdWx0aXBsZSA9PSBmYWxzZSB8fCAobXVsdGlwbGUgPT0gdHJ1ZSAmJiBlbGVtZW50LmNsb3Nlc3QoJ2xhYmVsJykuaGFzQ2xhc3MoJ2Vycm9yJykpKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRhdGUgPSBKU09OLnBhcnNlKGVsZW1lbnQuZGF0YSgndmFsaWRhdGUnKS5yZXBsYWNlKC9cXCcvZywgJ1wiJykpO1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gKHR5cGVvZiB2YWxpZGF0ZVt0eXBlXSA9PSAnc3RyaW5nJyA/IHZhbGlkYXRlW3R5cGVdIDogdHJhbnNsYXRlKCd2YWxpZGF0aW9uXycgKyB0eXBlLCBlcnJvclZhcmlhYmxlcykpO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5wcm9wKCd0YWdOYW1lJykgPT0gJ1NFTEVDVCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5wYXJlbnQoKS5uZXh0QWxsKCcuZXJyb3ItbWVzc2FnZScpLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICBlcnJvclBsYWNlLmFwcGVuZCgnPHNwYW4gY2xhc3M9XCJlcnJvci1tZXNzYWdlXCI+JyArIGxhYmVsICsgJzwvc3Bhbj4nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5wcm9wKCd0YWdOYW1lJykgPT0gJ1RFWFRBUkVBJykge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnBhcmVudHMoJy50ZXh0YXJlYS13cmFwcGVyJykubmV4dEFsbCgnLmVycm9yLW1lc3NhZ2UnKS5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JQbGFjZS5hcHBlbmQoJzxzcGFuIGNsYXNzPVwiZXJyb3ItbWVzc2FnZVwiPicgKyBsYWJlbCArICc8L3NwYW4+Jyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuaXMoJ1t0eXBlPVwiY2hlY2tib3hcIl0nKSB8fCBlbGVtZW50LmlzKCdbdHlwZT1cInJhZGlvXCJdJykpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JQbGFjZS5maW5kKCcuZXJyb3ItbWVzc2FnZScpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yUGxhY2UuYXBwZW5kKCc8c3BhbiBjbGFzcz1cImVycm9yLW1lc3NhZ2VcIj4nICsgbGFiZWwgKyAnPC9zcGFuPicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3JQbGFjZS5hcHBlbmQoJzxzcGFuIGNsYXNzPVwiZXJyb3ItbWVzc2FnZVwiPicgKyBsYWJlbCArICc8L3NwYW4+Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5WYWxpZGF0ZS5wcm90b3R5cGUucmVtb3ZlRXJyb3IgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQuaXMoJ1t0eXBlPVwiY2hlY2tib3hcIl0nKSB8fCBlbGVtZW50LmlzKCdbdHlwZT1cInJhZGlvXCJdJykpXG4gICAgICAgIGVsZW1lbnQuY2xvc2VzdCgnbGFiZWwnKS5yZW1vdmVDbGFzcygnZXJyb3InKTtcblxuICAgIGVsc2UgaWYgKGVsZW1lbnQucHJvcCgndGFnTmFtZScpID09ICdURVhUQVJFQScpIHtcbiAgICAgICAgZWxlbWVudC5wYXJlbnRzKCcudGV4dGFyZWEtd3JhcHBlcicpLnJlbW92ZUNsYXNzKCdlcnJvcicpLm5leHRBbGwoJy5lcnJvci1tZXNzYWdlJykucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoZWxlbWVudC5oYXNDbGFzcygnc2Nyb2xsYWJsZScpKVxuICAgICAgICBlbGVtZW50LmNsb3Nlc3QoJy5zY3JvbGxiYXItd3JhcHBlcicpLnJlbW92ZUNsYXNzKCdlcnJvcicpO1xuXG4gICAgZWxzZSBpZiAoZWxlbWVudC5wcm9wKCd0YWdOYW1lJykgPT0gJ1NFTEVDVCcpIHtcbiAgICAgICAgZWxlbWVudC5jbG9zZXN0KCcuZmFrZS1zZWxlY3QnKS5yZW1vdmVDbGFzcygnZXJyb3InKTtcbiAgICAgICAgZWxlbWVudC5jbG9zZXN0KCcuZmFrZS1zZWxlY3QnKS5uZXh0QWxsKCcuZXJyb3ItbWVzc2FnZScpLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIGVsc2VcbiAgICAgICAgZWxlbWVudC5wYXJlbnQoKS5yZW1vdmVDbGFzcygnZXJyb3InKTtcblxuICAgIGlmIChlbGVtZW50LmlzKCdbdHlwZT1cImNoZWNrYm94XCJdJykgfHwgZWxlbWVudC5pcygnW3R5cGU9XCJyYWRpb1wiXScpKSB7XG4gICAgICAgIGVsZW1lbnQuY2xvc2VzdCgnbGFiZWwnKS5maW5kKCcuZXJyb3ItbWVzc2FnZScpLnJlbW92ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQubmV4dEFsbCgnLmVycm9yLW1lc3NhZ2UnKS5yZW1vdmUoKTtcbiAgICB9XG59O1xuXG5WYWxpZGF0ZS5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uKCkge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmZvcm1WYWxpZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5mb3JtVmFsaWRbaV1bMF0gPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9FcnJvcih0aGlzLmZvcm1WYWxpZFtpXVsxXSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuVmFsaWRhdGUucHJvdG90eXBlLnNjcm9sbFRvRXJyb3IgPSBmdW5jdGlvbihmaWVsZCkge1xuICAgIHZhciBzZWN0aW9uT2Zmc2V0ID0gTWF0aC5jZWlsKGZpZWxkLm9mZnNldCgpLnRvcCk7XG4gICAgdmFyIHNjcm9sbFRvID0gc2VjdGlvbk9mZnNldCAtIDUwO1xuXG4gICAgalF1ZXJ5KCdib2R5LCBodG1sJykuc3RvcCgpLmFuaW1hdGUoeydzY3JvbGxUb3AnOiBzY3JvbGxUb30sIDUwMCk7XG5cbiAgICBmaWVsZC5mb2N1cygpO1xufTtcblxualF1ZXJ5LmZuLnZhbGlkYXRlID0gZnVuY3Rpb24oKXtcbiAgICBqUXVlcnkodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZvcm0gPSBqUXVlcnkodGhpcyk7XG4gICAgICAgIHZhciBidXR0b24gPSBmb3JtLmZpbmQoJ2J1dHRvbicpO1xuICAgICAgICB2YXIgYm9keSA9IGZvcm0uY2xvc2VzdCgnLnBhZ2Utd3JhcCcpO1xuICAgICAgICBmb3JtLmF0dHIoJ25vdmFsaWRhdGUnLCAnbm92YWxpZGF0ZScpO1xuICAgICAgICBmb3JtLm9uKCdzdWJtaXQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vL0RFTEVURVxuICAgICAgICAgICAgdmFyIHZhbGlkID0gbmV3IFZhbGlkYXRlKGZvcm0pO1xuXG4gICAgICAgICAgICBpZiAodmFsaWQuaXNWYWxpZCgpICE9IHRydWUpXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmFsaWRhdGU7XG4iLCJmdW5jdGlvbiBWZXJ0aWNhbE1lbnUoY29udGFpbmVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuYm9keSA9IGpRdWVyeSgnYm9keScpO1xuICAgIHRoaXMucGFnZUhlYWRlciA9IHRoaXMuYm9keS5maW5kKCcucGFnZS1oZWFkZXInKTtcbiAgICB0aGlzLnBhZ2VXcmFwID0gdGhpcy5ib2R5LmZpbmQoJy5wYWdlLXdyYXAnKTtcbiAgICB0aGlzLm1haW5NZW51Q29udGFpbmVyID0gdGhpcy5wYWdlSGVhZGVyLmZpbmQoJy5wYWdlLWhlYWRlcl9fY29udGFpbmVyJyk7XG4gICAgdGhpcy5jbG9zZU1vYmlsZUJ1dHRvbiA9IHRoaXMucGFnZUhlYWRlci5maW5kKCcucGFnZS1oZWFkZXJfX2Nsb3NlLW1vYmlsZS1idXR0b24nKTtcbiAgICB0aGlzLm1haW5NZW51QnV0dG9uID0gdGhpcy5jb250YWluZXIuZmluZCgnLm1haW4tbWVudV9faXRlbS1saW5rJyk7XG4gICAgdGhpcy5zZWNvbmRMZXZlbExpc3QgPSB0aGlzLmNvbnRhaW5lci5maW5kKCcubWFpbi1tZW51X19zdWJsaXN0Jyk7XG4gICAgdGhpcy5wYWdlQ29udGVudCA9IHRoaXMuYm9keS5maW5kKCcucGFnZS1jb250ZW50LXdyYXBwZXInKTtcbiAgICB0aGlzLm1vYmlsZU1lbnVCdXR0b24gPSB0aGlzLnBhZ2VIZWFkZXIuZmluZCgnLnBhZ2UtaGVhZGVyX19tb2JpbGUtYnV0dG9uJyk7XG4gICAgdGhpcy5sb2dvQ29udGFpbmVyID0gdGhpcy5wYWdlSGVhZGVyLmZpbmQoJy5wYWdlLWhlYWRlcl9fbG9nby1jb250YWluZXInKTtcbiAgICB0aGlzLnBhZ2VIZWFkZXJDbG9zZUJ1dHRvbiA9IHRoaXMucGFnZUhlYWRlci5maW5kKCcucGFnZS1oZWFkZXJfX2Nsb3NlLWJ1dHRvbicpO1xuICAgIHRoaXMuc2Vjb25kTGV2ZWxJdGVtcyA9IHRoaXMucGFnZUhlYWRlci5maW5kKCcubWFpbi1tZW51X19zdWJsaXN0LWl0ZW0nKTtcbiAgICB0aGlzLnNlY29uZExldmVsTGlua3MgPSB0aGlzLnBhZ2VIZWFkZXIuZmluZCgnLm1haW4tbWVudV9fZGVlcGVyLWxpc3QtbGluaycpO1xuICAgIHRoaXMuZGVlcGVyTGV2ZWxMaXN0ID0gdGhpcy5wYWdlSGVhZGVyLmZpbmQoJy5tYWluLW1lbnVfX2RlZXBlci1sZXZlbC1saXN0Jyk7XG4gICAgdGhpcy5kZWVwZXJMZXZlbEl0ZW1zID0gdGhpcy5wYWdlSGVhZGVyLmZpbmQoJy5tYWluLW1lbnVfX2RlZXBlci1saXN0LWl0ZW0nKTtcbiAgICB0aGlzLmRlZXBlckxldmVsTGlua3MgPSB0aGlzLnBhZ2VIZWFkZXIuZmluZCgnLm1haW4tbWVudV9fZGVlcGVyLWxpc3QtbGluaycpO1xuICAgIHRoaXMubWljcm9zaXRlTmF2aWdhdGlvbiA9IHRoaXMucGFnZUhlYWRlci5maW5kKCcucGFnZS1oZWFkZXJfX21pY3Jvc2l0ZS1uYXZpZ2F0aW9uJyk7XG4gICAgdGhpcy5taWNyb3NpdGVWZXJ0aWNhbFRleHQgPSB0aGlzLnBhZ2VIZWFkZXIuZmluZCgnLnBhZ2UtaGVhZGVyX192ZXJ0aWNhbC10ZXh0Jyk7XG4gICAgdGhpcy5taWNyb3NpdGVCdXR0b24gPSB0aGlzLnBhZ2VIZWFkZXIuZmluZCgnLnBhZ2UtaGVhZGVyX19taWNyb3NpdGUtYnV0dG9uJyk7XG5cbiAgICB0aGlzLmFkZENsYXNzVG9Cb2R5KCk7XG4gICAgdGhpcy5jaGVja0RlZXBlckxldmVsU3VibWVudUV4aXN0YW5jZSgpO1xuXG4gICAgdGhpcy5tYWluTWVudUJ1dHRvbi5vbignY2xpY2snLCB0aGlzLm9wZW5NZW51LmJpbmQodGhpcykpO1xuICAgIHRoaXMubW9iaWxlTWVudUJ1dHRvbi5vbignY2xpY2snLCB0aGlzLm9wZW5NZW51T25Nb2JpbGUuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5jbG9zZU1vYmlsZUJ1dHRvbi5vbignY2xpY2snLCB0aGlzLmNsb3NlTWVudS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnBhZ2VDb250ZW50Lm9uKCdjbGljaycsIHRoaXMuY2xvc2VNZW51LmJpbmQodGhpcykpO1xuICAgIHRoaXMucGFnZUhlYWRlckNsb3NlQnV0dG9uLm9uKCdjbGljaycsIHRoaXMuY2xvc2VNZW51LmJpbmQodGhpcykpO1xuICAgIHRoaXMuZGVlcGVyTGV2ZWxMaW5rcy5vbignY2xpY2snLCB0aGlzLnNob3dEZWVwZXJNZW51TGV2ZWwuYmluZCh0aGlzKSk7XG59XG5cblZlcnRpY2FsTWVudS5wcm90b3R5cGUuYWRkQ2xhc3NUb0JvZHkgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jb250YWluZXIuaGFzQ2xhc3MoJ21haW4tbWVudS0tb3BlbmVkJykpIHtcbiAgICAgICAgdGhpcy5ib2R5LmFkZENsYXNzKCdvcGVuZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvZHkucmVtb3ZlQ2xhc3MoJ29wZW5lZCcpO1xuICAgIH1cbn07XG5cblZlcnRpY2FsTWVudS5wcm90b3R5cGUuY2xvc2VNZW51ID0gZnVuY3Rpb24oZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIHRoaXMubWFpbk1lbnVDb250YWluZXIucmVtb3ZlQ2xhc3MoJ3BhZ2UtaGVhZGVyX19jb250YWluZXItLW9wZW5lZCcpO1xuICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNsYXNzKCdtYWluLW1lbnUtLW9wZW5lZCcpO1xuICAgIHRoaXMuc2Vjb25kTGV2ZWxMaXN0LnJlbW92ZUNsYXNzKCdtYWluLW1lbnVfX3N1Ymxpc3QtLWFjdGl2ZScpO1xuICAgIHRoaXMuYm9keS5yZW1vdmVDbGFzcygnb3BlbmVkJyk7XG5cbiAgICBpZiAodGhpcy5jb250YWluZXIuaGFzQ2xhc3MoJ21haW4tbWVudS0tbWljcm9zaXRlJykpIHtcbiAgICAgICAgdGhpcy5taWNyb3NpdGVOYXZpZ2F0aW9uLnJlbW92ZUNsYXNzKCdwYWdlLWhlYWRlcl9fbWljcm9zaXRlLW5hdmlnYXRpb24tLWhpZGRlbicpO1xuICAgIH0gZWxzZSB7IFxuICAgICAgICB0aGlzLm1haW5NZW51QnV0dG9uLnJlbW92ZUNsYXNzKCdtYWluLW1lbnVfX2l0ZW0tbGluay0tYWN0aXZlJyk7XG4gICAgfVxuICAgIGlmICgkKHdpbmRvdykud2lkdGgoKSA8PSA5NTkpIHtcbiAgICAgICAgdGhpcy5tYWluTWVudUNvbnRhaW5lci5yZW1vdmVDbGFzcygncGFnZS1oZWFkZXJfX2NvbnRhaW5lci0tdmlzaWJsZScpXG4gICAgICAgIHRoaXMubW9iaWxlTWVudUJ1dHRvbi5yZW1vdmVDbGFzcygncGFnZS1oZWFkZXJfX21vYmlsZS1idXR0b24tLWhpZGRlbicpO1xuICAgIH1cblxuICAgIHRoaXMucGFnZUhlYWRlci5yZW1vdmVDbGFzcygncGFnZS1oZWFkZXItLW9wZW5lZCcpOyBcbiAgICB0aGlzLmJvZHkucmVtb3ZlQ2xhc3MoJ25vLXNjcm9sbCcpO1xuICAgIHRoaXMucGFnZVdyYXAucmVtb3ZlQ2xhc3MoJ2ZpeGVkJyk7XG5cbiAgICB0aGlzLnRvZ2dsZVBhZ2VTY3JvbGxpbmcoKTtcbiAgICB0aGlzLmFkZENsYXNzVG9Cb2R5KCk7XG4gICAgdGhpcy5zZXRTdWJtZW51SW5pdGlhbFZhbHVlcygpO1xufTtcblxuVmVydGljYWxNZW51LnByb3RvdHlwZS5vcGVuTWVudSA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgY2xpY2tlZEJ1dHRvbiA9ICQoZS5jdXJyZW50VGFyZ2V0KTtcbiAgICB2YXIgc2Vjb25kTGV2ZWxMaXN0ID0gY2xpY2tlZEJ1dHRvbi5zaWJsaW5ncygnLm1haW4tbWVudV9fc3VibGlzdCcpO1xuICAgIFxuICAgIGlmIChzZWNvbmRMZXZlbExpc3QubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY2xpY2tlZEJ1dHRvbi5hZGRDbGFzcygnbWFpbi1tZW51X19pdGVtLWxpbmstLWFjdGl2ZScpO1xuICAgICAgICBzZWNvbmRMZXZlbExpc3QuYWRkQ2xhc3MoJ21haW4tbWVudV9fc3VibGlzdC0tYWN0aXZlJyk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLm1haW5NZW51QnV0dG9uLm5vdChjbGlja2VkQnV0dG9uKS5yZW1vdmVDbGFzcygnbWFpbi1tZW51X19pdGVtLWxpbmstLWFjdGl2ZScpO1xuICAgICAgICB0aGlzLnNlY29uZExldmVsTGlzdC5ub3Qoc2Vjb25kTGV2ZWxMaXN0KS5yZW1vdmVDbGFzcygnbWFpbi1tZW51X19zdWJsaXN0LS1hY3RpdmUnKTtcblxuICAgICAgICB0aGlzLm1haW5NZW51Q29udGFpbmVyLmFkZENsYXNzKCdwYWdlLWhlYWRlcl9fY29udGFpbmVyLS1vcGVuZWQnKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3MoJ21haW4tbWVudS0tb3BlbmVkJyk7XG5cbiAgICAgICAgdGhpcy5wYWdlSGVhZGVyLmFkZENsYXNzKCdwYWdlLWhlYWRlci0tb3BlbmVkJyk7XG4gICAgICAgIHRoaXMuYm9keS5hZGRDbGFzcygnbm8tc2Nyb2xsJyk7XG4gICAgICAgIHRoaXMucGFnZVdyYXAuYWRkQ2xhc3MoJ2ZpeGVkJyk7XG5cbiAgICAgICAgdGhpcy5hZGRDbGFzc1RvQm9keSgpO1xuICAgICAgICB0aGlzLnNldFN1Ym1lbnVJbml0aWFsVmFsdWVzKCk7XG5cbiAgICB9XG59XG5cblZlcnRpY2FsTWVudS5wcm90b3R5cGUub3Blbk1lbnVPbk1vYmlsZSA9IGZ1bmN0aW9uKGUpIHtcbiAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgdGhpcy5tb2JpbGVNZW51QnV0dG9uLmFkZENsYXNzKCdwYWdlLWhlYWRlcl9fbW9iaWxlLWJ1dHRvbi0taGlkZGVuJyk7XG4gICB0aGlzLm1haW5NZW51Q29udGFpbmVyLmFkZENsYXNzKCdwYWdlLWhlYWRlcl9fY29udGFpbmVyLS12aXNpYmxlIHBhZ2UtaGVhZGVyX19jb250YWluZXItLW9wZW5lZCcpO1xuICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3MoJ21haW4tbWVudS0tb3BlbmVkJyk7XG4gICB0aGlzLnBhZ2VIZWFkZXIuYWRkQ2xhc3MoJ3BhZ2UtaGVhZGVyLS1vcGVuZWQnKTtcbiAgIHRoaXMuYm9keS5hZGRDbGFzcygnb3BlbmVkJyk7XG5cbiAgIGlmICh0aGlzLm1vYmlsZU1lbnVCdXR0b24uaGFzQ2xhc3MoJ3BhZ2UtaGVhZGVyX19tb2JpbGUtYnV0dG9uLS1taWNyb3NpdGUnKSkge1xuICAgICAgICB0aGlzLnNlY29uZExldmVsTGlzdC5hZGRDbGFzcygnbWFpbi1tZW51X19zdWJsaXN0LS1hY3RpdmUnKTtcbiAgIH1cblxuICAgIHRoaXMuYWRkQ2xhc3NUb0JvZHkoKTtcbiAgICB0aGlzLnRvZ2dsZVBhZ2VTY3JvbGxpbmcoKTtcblxuICAgIGlmICgkKHdpbmRvdykud2lkdGgoKSA8IDk2MCkge1xuICAgICAgICBpZiAodGhpcy5kZWVwZXJMZXZlbExpbmtzLmhhc0NsYXNzKCdtYWluLW1lbnVfX2RlZXBlci1saXN0LWxpbmstLWN1cnJlbnQtcGFnZScpKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFBhZ2VMaW5rID0gdGhpcy5kZWVwZXJMZXZlbExpbmtzLmZpbHRlcignLm1haW4tbWVudV9fZGVlcGVyLWxpc3QtbGluay0tY3VycmVudC1wYWdlJyk7XG4gICAgICAgICAgICB2YXIgY2xvc2VzdFN1Ymxpc3QgPSBjdXJyZW50UGFnZUxpbmsuY2xvc2VzdCgnLm1haW4tbWVudV9fZGVlcGVyLWxldmVsLWxpc3QnKTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UGFnZVBhcmVudFN1Ymxpc3RzID0gIGN1cnJlbnRQYWdlTGluay5wYXJlbnRzKCcubWFpbi1tZW51X19kZWVwZXItbGV2ZWwtbGlzdCcpO1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gY2xvc2VzdFN1Ymxpc3QucGFyZW50cygnLm1haW4tbWVudV9fZGVlcGVyLWxpc3QtaXRlbScpLnNpYmxpbmdzKCk7XG4gICAgICAgICAgICB2YXIgdG9wU3VibGlzdCA9IGN1cnJlbnRQYWdlTGluay5wYXJlbnRzKCcubWFpbi1tZW51X19zdWJsaXN0Jyk7XG4gICAgICAgICAgICB2YXIgdG9wSXRlbUxpbmsgPSB0b3BTdWJsaXN0LnNpYmxpbmdzKCcubWFpbi1tZW51X19pdGVtLWxpbmsnKTtcbiAgICAgICAgICAgIHZhciB0b3BJdGVtID0gdG9wU3VibGlzdC5wYXJlbnRzKCcubWFpbi1tZW51X19pdGVtJyk7XG5cbiAgICAgICAgICAgIHRvcFN1Ymxpc3QuYWRkQ2xhc3MoJ21haW4tbWVudV9fc3VibGlzdC0tYWN0aXZlJyk7XG4gICAgICAgICAgICB0b3BJdGVtTGluay5hZGRDbGFzcygnbWFpbi1tZW51X19pdGVtLWxpbmstLWFjdGl2ZScpO1xuICAgICAgICAgICAgdGhpcy5tYWluTWVudUJ1dHRvbi5ub3QodG9wSXRlbUxpbmspLnJlbW92ZUNsYXNzKCdtYWluLW1lbnVfX2l0ZW0tbGluay0tYWN0aXZlJyk7XG4gICAgICAgICAgICB0aGlzLnNlY29uZExldmVsTGlzdC5ub3QodG9wU3VibGlzdCkucmVtb3ZlQ2xhc3MoJ21haW4tbWVudV9fc3VibGlzdC0tYWN0aXZlJyk7XG5cbiAgICAgICAgICAgIGN1cnJlbnRQYWdlTGluay5hZGRDbGFzcygnbWFpbi1tZW51X19kZWVwZXItbGlzdC1saW5rLS1jdXJyZW50Jyk7XG4gICAgICAgICAgICBjbG9zZXN0U3VibGlzdC5hZGRDbGFzcygnbWFpbi1tZW51X19kZWVwZXItbGV2ZWwtbGlzdC0tdmlzaWJsZScpO1xuICAgICAgICAgICAgY3VycmVudFBhZ2VQYXJlbnRTdWJsaXN0cy5hZGRDbGFzcygnbWFpbi1tZW51X19kZWVwZXItbGV2ZWwtbGlzdC0tdmlzaWJsZScpO1xuICAgICAgICAgICAgY3VycmVudFBhZ2VQYXJlbnRTdWJsaXN0cy5zaWJsaW5ncygpLmFkZENsYXNzKCdtYWluLW1lbnVfX2RlZXBlci1saXN0LWxpbmstLWN1cnJlbnQnKS5oaWRlKCk7XG4gICAgICAgICAgICBpdGVtcy5hZGRDbGFzcygnbWFpbi1tZW51X19kZWVwZXItbGlzdC1pdGVtLS1oaWRkZW4nKTtcbiAgICAgICAgfSBcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ib2R5Lmhhc0NsYXNzKCdpcGFkJykpIHtcbiAgICAgICB0aGlzLnBhZ2VIZWFkZXIuYWRkQ2xhc3MoJ3BhZ2UtaGVhZGVyLS1vcGVuZWQnKTsgXG4gICAgICAgdGhpcy5ib2R5LmFkZENsYXNzKCduby1zY3JvbGwnKTtcbiAgICAgICB0aGlzLnBhZ2VXcmFwLmFkZENsYXNzKCdmaXhlZCcpO1xuICAgIH1cbn1cblxuVmVydGljYWxNZW51LnByb3RvdHlwZS5jaGVja0RlZXBlckxldmVsU3VibWVudUV4aXN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICgkKHdpbmRvdykud2lkdGgoKSA8PSA5NTkpe1xuICAgICAgICB0aGlzLmRlZXBlckxldmVsSXRlbXMuZWFjaChmdW5jdGlvbihpLCBlKXtcbiAgICAgICAgICAgIGlmKCQoZSkuaGFzKCcubWFpbi1tZW51X19kZWVwZXItbGV2ZWwtbGlzdCcpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAkKGUpLmNoaWxkcmVuKCcubWFpbi1tZW51X19kZWVwZXItbGlzdC1saW5rJykuYWRkQ2xhc3MoJ21haW4tbWVudV9fZGVlcGVyLWxpc3QtbGluay0tYXJyb3ctcmlnaHQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuVmVydGljYWxNZW51LnByb3RvdHlwZS5zaG93RGVlcGVyTWVudUxldmVsID0gZnVuY3Rpb24oZWwpIHtcbiAgICB2YXIgY2xpY2tlZExpbmsgPSAkKGVsLnRhcmdldCk7XG4gICAgdmFyIHN1Ymxpc3QgPSBjbGlja2VkTGluay5zaWJsaW5ncygnLm1haW4tbWVudV9fZGVlcGVyLWxldmVsLWxpc3QnKTtcbiAgICB2YXIgY2xpY2tlZExpbmtQYXJlbnQgPSBjbGlja2VkTGluay5wYXJlbnQoKTtcbiAgICB2YXIgY2xpY2tlZExpbmtQYXJlbnRTaWJsaW5ncyA9IGNsaWNrZWRMaW5rUGFyZW50LnNpYmxpbmdzKCk7XG4gICAgdmFyIGNsaWNrZWRMaW5rR3JhbmRmYXRoZXIgPSBjbGlja2VkTGlua1BhcmVudC5wYXJlbnQoKTtcblxuICAgIGlmICgkKHdpbmRvdykud2lkdGgoKSA8PSA5NTkpIHtcbiAgICAgICAgaWYgKChjbGlja2VkTGluay5zaWJsaW5ncygnLm1haW4tbWVudV9fZGVlcGVyLWxldmVsLWxpc3QnKS5sZW5ndGggIT09IDApICYmICEoY2xpY2tlZExpbmsuaGFzQ2xhc3MoJ21haW4tbWVudV9fZGVlcGVyLWxpc3QtbGluay0tYmFjaycpKSkge1xuICAgICAgICAgICAgZWwucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGNsaWNrZWRMaW5rLmhpZGUoKTtcblxuICAgICAgICAgICAgY2xpY2tlZExpbmtQYXJlbnRTaWJsaW5ncy5hZGRDbGFzcygnbWFpbi1tZW51X19kZWVwZXItbGlzdC1pdGVtLS1oaWRkZW4nKTtcbiAgICAgICAgICAgIHN1Ymxpc3QuYWRkQ2xhc3MoJ21haW4tbWVudV9fZGVlcGVyLWxldmVsLWxpc3QtLXZpc2libGUnKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbGlja2VkTGluay5oYXNDbGFzcygnbWFpbi1tZW51X19kZWVwZXItbGlzdC1saW5rLS1iYWNrJykpe1xuICAgICAgICAgICAgZWwucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHZhciBzdWJsaXN0UGFyZW50ID0gY2xpY2tlZExpbmsuY2xvc2VzdCgnLm1haW4tbWVudV9fZGVlcGVyLWxldmVsLWxpc3QnKTsgXG5cbiAgICAgICAgICAgIHN1Ymxpc3RQYXJlbnQucmVtb3ZlQ2xhc3MoJ21haW4tbWVudV9fZGVlcGVyLWxldmVsLWxpc3QtLXZpc2libGUnKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBzdWJsaXN0UGFyZW50LnNpYmxpbmdzKCcubWFpbi1tZW51X19kZWVwZXItbGlzdC1saW5rJykuc2hvdygpO1xuICAgICAgICAgICAgICAgIHN1Ymxpc3RQYXJlbnQuY2xvc2VzdCgnLm1haW4tbWVudV9fZGVlcGVyLWxpc3QtaXRlbScpLnNpYmxpbmdzKCkucmVtb3ZlQ2xhc3MoJ21haW4tbWVudV9fZGVlcGVyLWxpc3QtaXRlbS0taGlkZGVuJyk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIDIwMCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5WZXJ0aWNhbE1lbnUucHJvdG90eXBlLnNldFN1Ym1lbnVJbml0aWFsVmFsdWVzID0gZnVuY3Rpb24oZSkge1xuICAgIHRoaXMuc2Vjb25kTGV2ZWxMaW5rcy5zaG93KCk7XG4gICAgdGhpcy5kZWVwZXJMZXZlbExpbmtzLnNob3coKTtcbiAgICB0aGlzLmRlZXBlckxldmVsTGlzdC5jaGlsZHJlbigpLnJlbW92ZUNsYXNzKCdtYWluLW1lbnVfX2RlZXBlci1saXN0LWl0ZW0tLWhpZGRlbicpO1xuICAgIHRoaXMuZGVlcGVyTGV2ZWxJdGVtcy5yZW1vdmVDbGFzcygnbWFpbi1tZW51X19kZWVwZXItbGlzdC1pdGVtLS1oaWRkZW4nKTtcbiAgICB0aGlzLmRlZXBlckxldmVsTGlzdC5yZW1vdmVDbGFzcygnbWFpbi1tZW51X19kZWVwZXItbGV2ZWwtbGlzdC0tdmlzaWJsZScpLnJlbW92ZUF0dHIoJ3N0eWxlJyk7XG5cbiAgICB0aGlzLmRlZXBlckxldmVsSXRlbXMuZmlsdGVyKCcubWFpbi1tZW51X19kZWVwZXItbGlzdC1pdGVtLS1jdXJyZW50JylcbiAgICAgICAgLmNoaWxkcmVuKCcubWFpbi1tZW51X19kZWVwZXItbGlzdC1saW5rJykuYWRkQ2xhc3MoJ21haW4tbWVudV9fZGVlcGVyLWxpc3QtbGluay0tY3VycmVudCcpO1xuXG4gICAgdGhpcy5jaGVja0RlZXBlckxldmVsU3VibWVudUV4aXN0YW5jZSgpO1xufVxuXG5WZXJ0aWNhbE1lbnUucHJvdG90eXBlLnRvZ2dsZVBhZ2VTY3JvbGxpbmcgPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCQod2luZG93KS53aWR0aCgpIDwgMTAyNSAmJiB0aGlzLmNvbnRhaW5lci5oYXNDbGFzcygnbWFpbi1tZW51LS1vcGVuZWQnKSkge1xuICAgICAgICAkKCdodG1sLCBib2R5JykuYWRkQ2xhc3MoJ25vLXNjcm9sbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgICQoJ2h0bWwsIGJvZHknKS5yZW1vdmVDbGFzcygnbm8tc2Nyb2xsJyk7XG4gICAgfVxufVxuXG5qUXVlcnkuZm4udmVydGljYWxNZW51ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGpRdWVyeSh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICBuZXcgVmVydGljYWxNZW51KGpRdWVyeSh0aGlzKSk7XG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBWZXJ0aWNhbE1lbnU6IFZlcnRpY2FsTWVudVxufTsiXX0=
